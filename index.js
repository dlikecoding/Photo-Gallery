// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  var __rewriteRelativeImportExtension;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw2) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw2 });
      } else {
        cooked.raw = raw2;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    __rewriteRelativeImportExtension = function(path2, preserveJsx) {
      if (typeof path2 === "string" && /^\.\.?\//.test(path2)) {
        return path2.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
      }
      return path2;
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
    exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);
  });
});

// node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS((exports, module) => {
  (function(root) {
    const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
    const ipv4Regexes = {
      fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
      threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
      twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
      longValue: new RegExp(`^${ipv4Part}$`, "i")
    };
    const octalRegex = new RegExp(`^0[0-7]+$`, "i");
    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
    const zoneIndex = "%[0-9a-z]{1,}";
    const ipv6Part = "(?:[0-9a-f]+::?)+";
    const ipv6Regexes = {
      zoneIndex: new RegExp(zoneIndex, "i"),
      native: new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
      deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
      transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
    };
    function expandIPv6(string, parts) {
      if (string.indexOf("::") !== string.lastIndexOf("::")) {
        return null;
      }
      let colonCount = 0;
      let lastColon = -1;
      let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];
      let replacement, replacementCount;
      if (zoneId) {
        zoneId = zoneId.substring(1);
        string = string.replace(/%.+$/, "");
      }
      while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
        colonCount++;
      }
      if (string.substr(0, 2) === "::") {
        colonCount--;
      }
      if (string.substr(-2, 2) === "::") {
        colonCount--;
      }
      if (colonCount > parts) {
        return null;
      }
      replacementCount = parts - colonCount;
      replacement = ":";
      while (replacementCount--) {
        replacement += "0:";
      }
      string = string.replace("::", replacement);
      if (string[0] === ":") {
        string = string.slice(1);
      }
      if (string[string.length - 1] === ":") {
        string = string.slice(0, -1);
      }
      parts = function() {
        const ref = string.split(":");
        const results = [];
        for (let i = 0;i < ref.length; i++) {
          results.push(parseInt(ref[i], 16));
        }
        return results;
      }();
      return {
        parts,
        zoneId
      };
    }
    function matchCIDR(first, second, partSize, cidrBits) {
      if (first.length !== second.length) {
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      }
      let part = 0;
      let shift;
      while (cidrBits > 0) {
        shift = partSize - cidrBits;
        if (shift < 0) {
          shift = 0;
        }
        if (first[part] >> shift !== second[part] >> shift) {
          return false;
        }
        cidrBits -= partSize;
        part += 1;
      }
      return true;
    }
    function parseIntAuto(string) {
      if (hexRegex.test(string)) {
        return parseInt(string, 16);
      }
      if (string[0] === "0" && !isNaN(parseInt(string[1], 10))) {
        if (octalRegex.test(string)) {
          return parseInt(string, 8);
        }
        throw new Error(`ipaddr: cannot parse ${string} as octal`);
      }
      return parseInt(string, 10);
    }
    function padPart(part, length) {
      while (part.length < length) {
        part = `0${part}`;
      }
      return part;
    }
    const ipaddr = {};
    ipaddr.IPv4 = function() {
      function IPv4(octets) {
        if (octets.length !== 4) {
          throw new Error("ipaddr: ipv4 octet count should be 4");
        }
        let i, octet;
        for (i = 0;i < octets.length; i++) {
          octet = octets[i];
          if (!(0 <= octet && octet <= 255)) {
            throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
          }
        }
        this.octets = octets;
      }
      IPv4.prototype.SpecialRanges = {
        unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
        broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
        multicast: [[new IPv4([224, 0, 0, 0]), 4]],
        linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
        loopback: [[new IPv4([127, 0, 0, 0]), 8]],
        carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
        private: [
          [new IPv4([10, 0, 0, 0]), 8],
          [new IPv4([172, 16, 0, 0]), 12],
          [new IPv4([192, 168, 0, 0]), 16]
        ],
        reserved: [
          [new IPv4([192, 0, 0, 0]), 24],
          [new IPv4([192, 0, 2, 0]), 24],
          [new IPv4([192, 88, 99, 0]), 24],
          [new IPv4([198, 18, 0, 0]), 15],
          [new IPv4([198, 51, 100, 0]), 24],
          [new IPv4([203, 0, 113, 0]), 24],
          [new IPv4([240, 0, 0, 0]), 4]
        ],
        as112: [
          [new IPv4([192, 175, 48, 0]), 24],
          [new IPv4([192, 31, 196, 0]), 24]
        ],
        amt: [
          [new IPv4([192, 52, 193, 0]), 24]
        ]
      };
      IPv4.prototype.kind = function() {
        return "ipv4";
      };
      IPv4.prototype.match = function(other, cidrRange) {
        let ref;
        if (cidrRange === undefined) {
          ref = other;
          other = ref[0];
          cidrRange = ref[1];
        }
        if (other.kind() !== "ipv4") {
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        }
        return matchCIDR(this.octets, other.octets, 8, cidrRange);
      };
      IPv4.prototype.prefixLengthFromSubnetMask = function() {
        let cidr = 0;
        let stop = false;
        const zerotable = {
          0: 8,
          128: 7,
          192: 6,
          224: 5,
          240: 4,
          248: 3,
          252: 2,
          254: 1,
          255: 0
        };
        let i, octet, zeros;
        for (i = 3;i >= 0; i -= 1) {
          octet = this.octets[i];
          if (octet in zerotable) {
            zeros = zerotable[octet];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 8) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 32 - cidr;
      };
      IPv4.prototype.range = function() {
        return ipaddr.subnetMatch(this, this.SpecialRanges);
      };
      IPv4.prototype.toByteArray = function() {
        return this.octets.slice(0);
      };
      IPv4.prototype.toIPv4MappedAddress = function() {
        return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);
      };
      IPv4.prototype.toNormalizedString = function() {
        return this.toString();
      };
      IPv4.prototype.toString = function() {
        return this.octets.join(".");
      };
      return IPv4;
    }();
    ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
      try {
        const cidr = this.parseCIDR(string);
        const ipInterfaceOctets = cidr[0].toByteArray();
        const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        const octets = [];
        let i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
          i++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr.IPv4.isIPv4 = function(string) {
      return this.parser(string) !== null;
    };
    ipaddr.IPv4.isValid = function(string) {
      try {
        new this(this.parser(string));
        return true;
      } catch (e) {
        return false;
      }
    };
    ipaddr.IPv4.isValidCIDR = function(string) {
      try {
        this.parseCIDR(string);
        return true;
      } catch (e) {
        return false;
      }
    };
    ipaddr.IPv4.isValidFourPartDecimal = function(string) {
      if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
        return true;
      } else {
        return false;
      }
    };
    ipaddr.IPv4.networkAddressFromCIDR = function(string) {
      let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
          i++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr.IPv4.parse = function(string) {
      const parts = this.parser(string);
      if (parts === null) {
        throw new Error("ipaddr: string is not formatted like an IPv4 Address");
      }
      return new this(parts);
    };
    ipaddr.IPv4.parseCIDR = function(string) {
      let match2;
      if (match2 = string.match(/^(.+)\/(\d+)$/)) {
        const maskLength = parseInt(match2[2]);
        if (maskLength >= 0 && maskLength <= 32) {
          const parsed = [this.parse(match2[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    };
    ipaddr.IPv4.parser = function(string) {
      let match2, part, value;
      if (match2 = string.match(ipv4Regexes.fourOctet)) {
        return function() {
          const ref = match2.slice(1, 6);
          const results = [];
          for (let i = 0;i < ref.length; i++) {
            part = ref[i];
            results.push(parseIntAuto(part));
          }
          return results;
        }();
      } else if (match2 = string.match(ipv4Regexes.longValue)) {
        value = parseIntAuto(match2[1]);
        if (value > 4294967295 || value < 0) {
          throw new Error("ipaddr: address outside defined range");
        }
        return function() {
          const results = [];
          let shift;
          for (shift = 0;shift <= 24; shift += 8) {
            results.push(value >> shift & 255);
          }
          return results;
        }().reverse();
      } else if (match2 = string.match(ipv4Regexes.twoOctet)) {
        return function() {
          const ref = match2.slice(1, 4);
          const results = [];
          value = parseIntAuto(ref[1]);
          if (value > 16777215 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          results.push(parseIntAuto(ref[0]));
          results.push(value >> 16 & 255);
          results.push(value >> 8 & 255);
          results.push(value & 255);
          return results;
        }();
      } else if (match2 = string.match(ipv4Regexes.threeOctet)) {
        return function() {
          const ref = match2.slice(1, 5);
          const results = [];
          value = parseIntAuto(ref[2]);
          if (value > 65535 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          results.push(parseIntAuto(ref[0]));
          results.push(parseIntAuto(ref[1]));
          results.push(value >> 8 & 255);
          results.push(value & 255);
          return results;
        }();
      } else {
        return null;
      }
    };
    ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
      prefix = parseInt(prefix);
      if (prefix < 0 || prefix > 32) {
        throw new Error("ipaddr: invalid IPv4 prefix length");
      }
      const octets = [0, 0, 0, 0];
      let j = 0;
      const filledOctetCount = Math.floor(prefix / 8);
      while (j < filledOctetCount) {
        octets[j] = 255;
        j++;
      }
      if (filledOctetCount < 4) {
        octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
      }
      return new this(octets);
    };
    ipaddr.IPv6 = function() {
      function IPv6(parts, zoneId) {
        let i, part;
        if (parts.length === 16) {
          this.parts = [];
          for (i = 0;i <= 14; i += 2) {
            this.parts.push(parts[i] << 8 | parts[i + 1]);
          }
        } else if (parts.length === 8) {
          this.parts = parts;
        } else {
          throw new Error("ipaddr: ipv6 part count should be 8 or 16");
        }
        for (i = 0;i < this.parts.length; i++) {
          part = this.parts[i];
          if (!(0 <= part && part <= 65535)) {
            throw new Error("ipaddr: ipv6 part should fit in 16 bits");
          }
        }
        if (zoneId) {
          this.zoneId = zoneId;
        }
      }
      IPv6.prototype.SpecialRanges = {
        unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
        discard: [new IPv6([256, 0, 0, 0, 0, 0, 0, 0]), 64],
        rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
        rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
        "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
        teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
        benchmarking: [new IPv6([8193, 2, 0, 0, 0, 0, 0, 0]), 48],
        amt: [new IPv6([8193, 3, 0, 0, 0, 0, 0, 0]), 32],
        as112v6: [
          [new IPv6([8193, 4, 274, 0, 0, 0, 0, 0]), 48],
          [new IPv6([9760, 79, 32768, 0, 0, 0, 0, 0]), 48]
        ],
        deprecated: [new IPv6([8193, 16, 0, 0, 0, 0, 0, 0]), 28],
        orchid2: [new IPv6([8193, 32, 0, 0, 0, 0, 0, 0]), 28],
        droneRemoteIdProtocolEntityTags: [new IPv6([8193, 48, 0, 0, 0, 0, 0, 0]), 28],
        reserved: [
          [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 23],
          [new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]
        ]
      };
      IPv6.prototype.isIPv4MappedAddress = function() {
        return this.range() === "ipv4Mapped";
      };
      IPv6.prototype.kind = function() {
        return "ipv6";
      };
      IPv6.prototype.match = function(other, cidrRange) {
        let ref;
        if (cidrRange === undefined) {
          ref = other;
          other = ref[0];
          cidrRange = ref[1];
        }
        if (other.kind() !== "ipv6") {
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        }
        return matchCIDR(this.parts, other.parts, 16, cidrRange);
      };
      IPv6.prototype.prefixLengthFromSubnetMask = function() {
        let cidr = 0;
        let stop = false;
        const zerotable = {
          0: 16,
          32768: 15,
          49152: 14,
          57344: 13,
          61440: 12,
          63488: 11,
          64512: 10,
          65024: 9,
          65280: 8,
          65408: 7,
          65472: 6,
          65504: 5,
          65520: 4,
          65528: 3,
          65532: 2,
          65534: 1,
          65535: 0
        };
        let part, zeros;
        for (let i = 7;i >= 0; i -= 1) {
          part = this.parts[i];
          if (part in zerotable) {
            zeros = zerotable[part];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 16) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 128 - cidr;
      };
      IPv6.prototype.range = function() {
        return ipaddr.subnetMatch(this, this.SpecialRanges);
      };
      IPv6.prototype.toByteArray = function() {
        let part;
        const bytes = [];
        const ref = this.parts;
        for (let i = 0;i < ref.length; i++) {
          part = ref[i];
          bytes.push(part >> 8);
          bytes.push(part & 255);
        }
        return bytes;
      };
      IPv6.prototype.toFixedLengthString = function() {
        const addr = function() {
          const results = [];
          for (let i = 0;i < this.parts.length; i++) {
            results.push(padPart(this.parts[i].toString(16), 4));
          }
          return results;
        }.call(this).join(":");
        let suffix = "";
        if (this.zoneId) {
          suffix = `%${this.zoneId}`;
        }
        return addr + suffix;
      };
      IPv6.prototype.toIPv4Address = function() {
        if (!this.isIPv4MappedAddress()) {
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        }
        const ref = this.parts.slice(-2);
        const high = ref[0];
        const low = ref[1];
        return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
      };
      IPv6.prototype.toNormalizedString = function() {
        const addr = function() {
          const results = [];
          for (let i = 0;i < this.parts.length; i++) {
            results.push(this.parts[i].toString(16));
          }
          return results;
        }.call(this).join(":");
        let suffix = "";
        if (this.zoneId) {
          suffix = `%${this.zoneId}`;
        }
        return addr + suffix;
      };
      IPv6.prototype.toRFC5952String = function() {
        const regex = /((^|:)(0(:|$)){2,})/g;
        const string = this.toNormalizedString();
        let bestMatchIndex = 0;
        let bestMatchLength = -1;
        let match2;
        while (match2 = regex.exec(string)) {
          if (match2[0].length > bestMatchLength) {
            bestMatchIndex = match2.index;
            bestMatchLength = match2[0].length;
          }
        }
        if (bestMatchLength < 0) {
          return string;
        }
        return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;
      };
      IPv6.prototype.toString = function() {
        return this.toRFC5952String();
      };
      return IPv6;
    }();
    ipaddr.IPv6.broadcastAddressFromCIDR = function(string) {
      try {
        const cidr = this.parseCIDR(string);
        const ipInterfaceOctets = cidr[0].toByteArray();
        const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        const octets = [];
        let i = 0;
        while (i < 16) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
          i++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
      }
    };
    ipaddr.IPv6.isIPv6 = function(string) {
      return this.parser(string) !== null;
    };
    ipaddr.IPv6.isValid = function(string) {
      if (typeof string === "string" && string.indexOf(":") === -1) {
        return false;
      }
      try {
        const addr = this.parser(string);
        new this(addr.parts, addr.zoneId);
        return true;
      } catch (e) {
        return false;
      }
    };
    ipaddr.IPv6.isValidCIDR = function(string) {
      if (typeof string === "string" && string.indexOf(":") === -1) {
        return false;
      }
      try {
        this.parseCIDR(string);
        return true;
      } catch (e) {
        return false;
      }
    };
    ipaddr.IPv6.networkAddressFromCIDR = function(string) {
      let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 16) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
          i++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
      }
    };
    ipaddr.IPv6.parse = function(string) {
      const addr = this.parser(string);
      if (addr.parts === null) {
        throw new Error("ipaddr: string is not formatted like an IPv6 Address");
      }
      return new this(addr.parts, addr.zoneId);
    };
    ipaddr.IPv6.parseCIDR = function(string) {
      let maskLength, match2, parsed;
      if (match2 = string.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match2[2]);
        if (maskLength >= 0 && maskLength <= 128) {
          parsed = [this.parse(match2[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    };
    ipaddr.IPv6.parser = function(string) {
      let addr, i, match2, octet, octets, zoneId;
      if (match2 = string.match(ipv6Regexes.deprecatedTransitional)) {
        return this.parser(`::ffff:${match2[1]}`);
      }
      if (ipv6Regexes.native.test(string)) {
        return expandIPv6(string, 8);
      }
      if (match2 = string.match(ipv6Regexes.transitional)) {
        zoneId = match2[6] || "";
        addr = match2[1];
        if (!match2[1].endsWith("::")) {
          addr = addr.slice(0, -1);
        }
        addr = expandIPv6(addr + zoneId, 6);
        if (addr.parts) {
          octets = [
            parseInt(match2[2]),
            parseInt(match2[3]),
            parseInt(match2[4]),
            parseInt(match2[5])
          ];
          for (i = 0;i < octets.length; i++) {
            octet = octets[i];
            if (!(0 <= octet && octet <= 255)) {
              return null;
            }
          }
          addr.parts.push(octets[0] << 8 | octets[1]);
          addr.parts.push(octets[2] << 8 | octets[3]);
          return {
            parts: addr.parts,
            zoneId: addr.zoneId
          };
        }
      }
      return null;
    };
    ipaddr.IPv6.subnetMaskFromPrefixLength = function(prefix) {
      prefix = parseInt(prefix);
      if (prefix < 0 || prefix > 128) {
        throw new Error("ipaddr: invalid IPv6 prefix length");
      }
      const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      let j = 0;
      const filledOctetCount = Math.floor(prefix / 8);
      while (j < filledOctetCount) {
        octets[j] = 255;
        j++;
      }
      if (filledOctetCount < 16) {
        octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
      }
      return new this(octets);
    };
    ipaddr.fromByteArray = function(bytes) {
      const length = bytes.length;
      if (length === 4) {
        return new ipaddr.IPv4(bytes);
      } else if (length === 16) {
        return new ipaddr.IPv6(bytes);
      } else {
        throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
      }
    };
    ipaddr.isValid = function(string) {
      return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
    };
    ipaddr.isValidCIDR = function(string) {
      return ipaddr.IPv6.isValidCIDR(string) || ipaddr.IPv4.isValidCIDR(string);
    };
    ipaddr.parse = function(string) {
      if (ipaddr.IPv6.isValid(string)) {
        return ipaddr.IPv6.parse(string);
      } else if (ipaddr.IPv4.isValid(string)) {
        return ipaddr.IPv4.parse(string);
      } else {
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
      }
    };
    ipaddr.parseCIDR = function(string) {
      try {
        return ipaddr.IPv6.parseCIDR(string);
      } catch (e) {
        try {
          return ipaddr.IPv4.parseCIDR(string);
        } catch (e2) {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
        }
      }
    };
    ipaddr.process = function(string) {
      const addr = this.parse(string);
      if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
        return addr.toIPv4Address();
      } else {
        return addr;
      }
    };
    ipaddr.subnetMatch = function(address, rangeList, defaultName) {
      let i, rangeName, rangeSubnets, subnet;
      if (defaultName === undefined || defaultName === null) {
        defaultName = "unicast";
      }
      for (rangeName in rangeList) {
        if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
          rangeSubnets = rangeList[rangeName];
          if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
            rangeSubnets = [rangeSubnets];
          }
          for (i = 0;i < rangeSubnets.length; i++) {
            subnet = rangeSubnets[i];
            if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
              return rangeName;
            }
          }
        }
      }
      return defaultName;
    };
    if (typeof module !== "undefined" && module.exports) {
      module.exports = ipaddr;
    } else {
      root.ipaddr = ipaddr;
    }
  })(exports);
});

// node_modules/reflect-metadata/Reflect.js
var require_Reflect = __commonJS(() => {
  /*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  var Reflect2;
  (function(Reflect3) {
    (function(factory) {
      var root = typeof globalThis === "object" ? globalThis : typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
      var exporter = makeExporter(Reflect3);
      if (typeof root.Reflect !== "undefined") {
        exporter = makeExporter(root.Reflect, exporter);
      }
      factory(exporter, root);
      if (typeof root.Reflect === "undefined") {
        root.Reflect = Reflect3;
      }
      function makeExporter(target, previous) {
        return function(key, value) {
          Object.defineProperty(target, key, { configurable: true, writable: true, value });
          if (previous)
            previous(key, value);
        };
      }
      function functionThis() {
        try {
          return Function("return this;")();
        } catch (_) {}
      }
      function indirectEvalThis() {
        try {
          return (undefined, eval)("(function() { return this; })()");
        } catch (_) {}
      }
      function sloppyModeThis() {
        return functionThis() || indirectEvalThis();
      }
    })(function(exporter, root) {
      var hasOwn = Object.prototype.hasOwnProperty;
      var supportsSymbol = typeof Symbol === "function";
      var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
      var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
      var supportsCreate = typeof Object.create === "function";
      var supportsProto = { __proto__: [] } instanceof Array;
      var downLevel = !supportsCreate && !supportsProto;
      var HashMap = {
        create: supportsCreate ? function() {
          return MakeDictionary(Object.create(null));
        } : supportsProto ? function() {
          return MakeDictionary({ __proto__: null });
        } : function() {
          return MakeDictionary({});
        },
        has: downLevel ? function(map, key) {
          return hasOwn.call(map, key);
        } : function(map, key) {
          return key in map;
        },
        get: downLevel ? function(map, key) {
          return hasOwn.call(map, key) ? map[key] : undefined;
        } : function(map, key) {
          return map[key];
        }
      };
      var functionPrototype = Object.getPrototypeOf(Function);
      var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
      var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
      var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
      var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : undefined;
      var metadataRegistry = GetOrCreateMetadataRegistry();
      var metadataProvider = CreateMetadataProvider(metadataRegistry);
      function decorate(decorators, target, propertyKey, attributes) {
        if (!IsUndefined(propertyKey)) {
          if (!IsArray(decorators))
            throw new TypeError;
          if (!IsObject(target))
            throw new TypeError;
          if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
            throw new TypeError;
          if (IsNull(attributes))
            attributes = undefined;
          propertyKey = ToPropertyKey(propertyKey);
          return DecorateProperty(decorators, target, propertyKey, attributes);
        } else {
          if (!IsArray(decorators))
            throw new TypeError;
          if (!IsConstructor(target))
            throw new TypeError;
          return DecorateConstructor(decorators, target);
        }
      }
      exporter("decorate", decorate);
      function metadata(metadataKey, metadataValue) {
        function decorator(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError;
          if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
            throw new TypeError;
          OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        return decorator;
      }
      exporter("metadata", metadata);
      function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      exporter("defineMetadata", defineMetadata);
      function hasMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasMetadata(metadataKey, target, propertyKey);
      }
      exporter("hasMetadata", hasMetadata);
      function hasOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
      }
      exporter("hasOwnMetadata", hasOwnMetadata);
      function getMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetMetadata(metadataKey, target, propertyKey);
      }
      exporter("getMetadata", getMetadata);
      function getOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
      }
      exporter("getOwnMetadata", getOwnMetadata);
      function getMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryMetadataKeys(target, propertyKey);
      }
      exporter("getMetadataKeys", getMetadataKeys);
      function getOwnMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryOwnMetadataKeys(target, propertyKey);
      }
      exporter("getOwnMetadataKeys", getOwnMetadataKeys);
      function deleteMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        var provider = GetMetadataProvider(target, propertyKey, false);
        if (IsUndefined(provider))
          return false;
        return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
      }
      exporter("deleteMetadata", deleteMetadata);
      function DecorateConstructor(decorators, target) {
        for (var i = decorators.length - 1;i >= 0; --i) {
          var decorator = decorators[i];
          var decorated = decorator(target);
          if (!IsUndefined(decorated) && !IsNull(decorated)) {
            if (!IsConstructor(decorated))
              throw new TypeError;
            target = decorated;
          }
        }
        return target;
      }
      function DecorateProperty(decorators, target, propertyKey, descriptor) {
        for (var i = decorators.length - 1;i >= 0; --i) {
          var decorator = decorators[i];
          var decorated = decorator(target, propertyKey, descriptor);
          if (!IsUndefined(decorated) && !IsNull(decorated)) {
            if (!IsObject(decorated))
              throw new TypeError;
            descriptor = decorated;
          }
        }
        return descriptor;
      }
      function OrdinaryHasMetadata(MetadataKey, O, P) {
        var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn2)
          return true;
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
          return OrdinaryHasMetadata(MetadataKey, parent, P);
        return false;
      }
      function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
        var provider = GetMetadataProvider(O, P, false);
        if (IsUndefined(provider))
          return false;
        return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));
      }
      function OrdinaryGetMetadata(MetadataKey, O, P) {
        var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn2)
          return OrdinaryGetOwnMetadata(MetadataKey, O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
          return OrdinaryGetMetadata(MetadataKey, parent, P);
        return;
      }
      function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
        var provider = GetMetadataProvider(O, P, false);
        if (IsUndefined(provider))
          return;
        return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);
      }
      function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        var provider = GetMetadataProvider(O, P, true);
        provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);
      }
      function OrdinaryMetadataKeys(O, P) {
        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (parent === null)
          return ownKeys;
        var parentKeys = OrdinaryMetadataKeys(parent, P);
        if (parentKeys.length <= 0)
          return ownKeys;
        if (ownKeys.length <= 0)
          return parentKeys;
        var set = new _Set;
        var keys = [];
        for (var _i = 0, ownKeys_1 = ownKeys;_i < ownKeys_1.length; _i++) {
          var key = ownKeys_1[_i];
          var hasKey = set.has(key);
          if (!hasKey) {
            set.add(key);
            keys.push(key);
          }
        }
        for (var _a2 = 0, parentKeys_1 = parentKeys;_a2 < parentKeys_1.length; _a2++) {
          var key = parentKeys_1[_a2];
          var hasKey = set.has(key);
          if (!hasKey) {
            set.add(key);
            keys.push(key);
          }
        }
        return keys;
      }
      function OrdinaryOwnMetadataKeys(O, P) {
        var provider = GetMetadataProvider(O, P, false);
        if (!provider) {
          return [];
        }
        return provider.OrdinaryOwnMetadataKeys(O, P);
      }
      function Type(x) {
        if (x === null)
          return 1;
        switch (typeof x) {
          case "undefined":
            return 0;
          case "boolean":
            return 2;
          case "string":
            return 3;
          case "symbol":
            return 4;
          case "number":
            return 5;
          case "object":
            return x === null ? 1 : 6;
          default:
            return 6;
        }
      }
      function IsUndefined(x) {
        return x === undefined;
      }
      function IsNull(x) {
        return x === null;
      }
      function IsSymbol(x) {
        return typeof x === "symbol";
      }
      function IsObject(x) {
        return typeof x === "object" ? x !== null : typeof x === "function";
      }
      function ToPrimitive(input, PreferredType) {
        switch (Type(input)) {
          case 0:
            return input;
          case 1:
            return input;
          case 2:
            return input;
          case 3:
            return input;
          case 4:
            return input;
          case 5:
            return input;
        }
        var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
        var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
        if (exoticToPrim !== undefined) {
          var result = exoticToPrim.call(input, hint);
          if (IsObject(result))
            throw new TypeError;
          return result;
        }
        return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
      }
      function OrdinaryToPrimitive(O, hint) {
        if (hint === "string") {
          var toString_1 = O.toString;
          if (IsCallable(toString_1)) {
            var result = toString_1.call(O);
            if (!IsObject(result))
              return result;
          }
          var valueOf = O.valueOf;
          if (IsCallable(valueOf)) {
            var result = valueOf.call(O);
            if (!IsObject(result))
              return result;
          }
        } else {
          var valueOf = O.valueOf;
          if (IsCallable(valueOf)) {
            var result = valueOf.call(O);
            if (!IsObject(result))
              return result;
          }
          var toString_2 = O.toString;
          if (IsCallable(toString_2)) {
            var result = toString_2.call(O);
            if (!IsObject(result))
              return result;
          }
        }
        throw new TypeError;
      }
      function ToBoolean(argument) {
        return !!argument;
      }
      function ToString(argument) {
        return "" + argument;
      }
      function ToPropertyKey(argument) {
        var key = ToPrimitive(argument, 3);
        if (IsSymbol(key))
          return key;
        return ToString(key);
      }
      function IsArray(argument) {
        return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
      }
      function IsCallable(argument) {
        return typeof argument === "function";
      }
      function IsConstructor(argument) {
        return typeof argument === "function";
      }
      function IsPropertyKey(argument) {
        switch (Type(argument)) {
          case 3:
            return true;
          case 4:
            return true;
          default:
            return false;
        }
      }
      function SameValueZero(x, y) {
        return x === y || x !== x && y !== y;
      }
      function GetMethod(V, P) {
        var func = V[P];
        if (func === undefined || func === null)
          return;
        if (!IsCallable(func))
          throw new TypeError;
        return func;
      }
      function GetIterator(obj) {
        var method = GetMethod(obj, iteratorSymbol);
        if (!IsCallable(method))
          throw new TypeError;
        var iterator = method.call(obj);
        if (!IsObject(iterator))
          throw new TypeError;
        return iterator;
      }
      function IteratorValue(iterResult) {
        return iterResult.value;
      }
      function IteratorStep(iterator) {
        var result = iterator.next();
        return result.done ? false : result;
      }
      function IteratorClose(iterator) {
        var f = iterator["return"];
        if (f)
          f.call(iterator);
      }
      function OrdinaryGetPrototypeOf(O) {
        var proto = Object.getPrototypeOf(O);
        if (typeof O !== "function" || O === functionPrototype)
          return proto;
        if (proto !== functionPrototype)
          return proto;
        var prototype = O.prototype;
        var prototypeProto = prototype && Object.getPrototypeOf(prototype);
        if (prototypeProto == null || prototypeProto === Object.prototype)
          return proto;
        var constructor = prototypeProto.constructor;
        if (typeof constructor !== "function")
          return proto;
        if (constructor === O)
          return proto;
        return constructor;
      }
      function CreateMetadataRegistry() {
        var fallback;
        if (!IsUndefined(registrySymbol) && typeof root.Reflect !== "undefined" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === "function") {
          fallback = CreateFallbackProvider(root.Reflect);
        }
        var first;
        var second;
        var rest;
        var targetProviderMap = new _WeakMap;
        var registry = {
          registerProvider,
          getProvider,
          setProvider
        };
        return registry;
        function registerProvider(provider) {
          if (!Object.isExtensible(registry)) {
            throw new Error("Cannot add provider to a frozen registry.");
          }
          switch (true) {
            case fallback === provider:
              break;
            case IsUndefined(first):
              first = provider;
              break;
            case first === provider:
              break;
            case IsUndefined(second):
              second = provider;
              break;
            case second === provider:
              break;
            default:
              if (rest === undefined)
                rest = new _Set;
              rest.add(provider);
              break;
          }
        }
        function getProviderNoCache(O, P) {
          if (!IsUndefined(first)) {
            if (first.isProviderFor(O, P))
              return first;
            if (!IsUndefined(second)) {
              if (second.isProviderFor(O, P))
                return first;
              if (!IsUndefined(rest)) {
                var iterator = GetIterator(rest);
                while (true) {
                  var next = IteratorStep(iterator);
                  if (!next) {
                    return;
                  }
                  var provider = IteratorValue(next);
                  if (provider.isProviderFor(O, P)) {
                    IteratorClose(iterator);
                    return provider;
                  }
                }
              }
            }
          }
          if (!IsUndefined(fallback) && fallback.isProviderFor(O, P)) {
            return fallback;
          }
          return;
        }
        function getProvider(O, P) {
          var providerMap = targetProviderMap.get(O);
          var provider;
          if (!IsUndefined(providerMap)) {
            provider = providerMap.get(P);
          }
          if (!IsUndefined(provider)) {
            return provider;
          }
          provider = getProviderNoCache(O, P);
          if (!IsUndefined(provider)) {
            if (IsUndefined(providerMap)) {
              providerMap = new _Map;
              targetProviderMap.set(O, providerMap);
            }
            providerMap.set(P, provider);
          }
          return provider;
        }
        function hasProvider(provider) {
          if (IsUndefined(provider))
            throw new TypeError;
          return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
        }
        function setProvider(O, P, provider) {
          if (!hasProvider(provider)) {
            throw new Error("Metadata provider not registered.");
          }
          var existingProvider = getProvider(O, P);
          if (existingProvider !== provider) {
            if (!IsUndefined(existingProvider)) {
              return false;
            }
            var providerMap = targetProviderMap.get(O);
            if (IsUndefined(providerMap)) {
              providerMap = new _Map;
              targetProviderMap.set(O, providerMap);
            }
            providerMap.set(P, provider);
          }
          return true;
        }
      }
      function GetOrCreateMetadataRegistry() {
        var metadataRegistry2;
        if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
          metadataRegistry2 = root.Reflect[registrySymbol];
        }
        if (IsUndefined(metadataRegistry2)) {
          metadataRegistry2 = CreateMetadataRegistry();
        }
        if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
          Object.defineProperty(root.Reflect, registrySymbol, {
            enumerable: false,
            configurable: false,
            writable: false,
            value: metadataRegistry2
          });
        }
        return metadataRegistry2;
      }
      function CreateMetadataProvider(registry) {
        var metadata2 = new _WeakMap;
        var provider = {
          isProviderFor: function(O, P) {
            var targetMetadata = metadata2.get(O);
            if (IsUndefined(targetMetadata))
              return false;
            return targetMetadata.has(P);
          },
          OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
          OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
          OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
          OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
          OrdinaryDeleteMetadata
        };
        metadataRegistry.registerProvider(provider);
        return provider;
        function GetOrCreateMetadataMap(O, P, Create) {
          var targetMetadata = metadata2.get(O);
          var createdTargetMetadata = false;
          if (IsUndefined(targetMetadata)) {
            if (!Create)
              return;
            targetMetadata = new _Map;
            metadata2.set(O, targetMetadata);
            createdTargetMetadata = true;
          }
          var metadataMap = targetMetadata.get(P);
          if (IsUndefined(metadataMap)) {
            if (!Create)
              return;
            metadataMap = new _Map;
            targetMetadata.set(P, metadataMap);
            if (!registry.setProvider(O, P, provider)) {
              targetMetadata.delete(P);
              if (createdTargetMetadata) {
                metadata2.delete(O);
              }
              throw new Error("Wrong provider for target.");
            }
          }
          return metadataMap;
        }
        function OrdinaryHasOwnMetadata2(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap))
            return false;
          return ToBoolean(metadataMap.has(MetadataKey));
        }
        function OrdinaryGetOwnMetadata2(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap))
            return;
          return metadataMap.get(MetadataKey);
        }
        function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, true);
          metadataMap.set(MetadataKey, MetadataValue);
        }
        function OrdinaryOwnMetadataKeys2(O, P) {
          var keys = [];
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap))
            return keys;
          var keysObj = metadataMap.keys();
          var iterator = GetIterator(keysObj);
          var k = 0;
          while (true) {
            var next = IteratorStep(iterator);
            if (!next) {
              keys.length = k;
              return keys;
            }
            var nextValue = IteratorValue(next);
            try {
              keys[k] = nextValue;
            } catch (e) {
              try {
                IteratorClose(iterator);
              } finally {
                throw e;
              }
            }
            k++;
          }
        }
        function OrdinaryDeleteMetadata(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap))
            return false;
          if (!metadataMap.delete(MetadataKey))
            return false;
          if (metadataMap.size === 0) {
            var targetMetadata = metadata2.get(O);
            if (!IsUndefined(targetMetadata)) {
              targetMetadata.delete(P);
              if (targetMetadata.size === 0) {
                metadata2.delete(targetMetadata);
              }
            }
          }
          return true;
        }
      }
      function CreateFallbackProvider(reflect) {
        var { defineMetadata: defineMetadata2, hasOwnMetadata: hasOwnMetadata2, getOwnMetadata: getOwnMetadata2, getOwnMetadataKeys: getOwnMetadataKeys2, deleteMetadata: deleteMetadata2 } = reflect;
        var metadataOwner = new _WeakMap;
        var provider = {
          isProviderFor: function(O, P) {
            var metadataPropertySet = metadataOwner.get(O);
            if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P)) {
              return true;
            }
            if (getOwnMetadataKeys2(O, P).length) {
              if (IsUndefined(metadataPropertySet)) {
                metadataPropertySet = new _Set;
                metadataOwner.set(O, metadataPropertySet);
              }
              metadataPropertySet.add(P);
              return true;
            }
            return false;
          },
          OrdinaryDefineOwnMetadata: defineMetadata2,
          OrdinaryHasOwnMetadata: hasOwnMetadata2,
          OrdinaryGetOwnMetadata: getOwnMetadata2,
          OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
          OrdinaryDeleteMetadata: deleteMetadata2
        };
        return provider;
      }
      function GetMetadataProvider(O, P, Create) {
        var registeredProvider = metadataRegistry.getProvider(O, P);
        if (!IsUndefined(registeredProvider)) {
          return registeredProvider;
        }
        if (Create) {
          if (metadataRegistry.setProvider(O, P, metadataProvider)) {
            return metadataProvider;
          }
          throw new Error("Illegal state.");
        }
        return;
      }
      function CreateMapPolyfill() {
        var cacheSentinel = {};
        var arraySentinel = [];
        var MapIterator = function() {
          function MapIterator2(keys, values, selector) {
            this._index = 0;
            this._keys = keys;
            this._values = values;
            this._selector = selector;
          }
          MapIterator2.prototype["@@iterator"] = function() {
            return this;
          };
          MapIterator2.prototype[iteratorSymbol] = function() {
            return this;
          };
          MapIterator2.prototype.next = function() {
            var index = this._index;
            if (index >= 0 && index < this._keys.length) {
              var result = this._selector(this._keys[index], this._values[index]);
              if (index + 1 >= this._keys.length) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              } else {
                this._index++;
              }
              return { value: result, done: false };
            }
            return { value: undefined, done: true };
          };
          MapIterator2.prototype.throw = function(error) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            throw error;
          };
          MapIterator2.prototype.return = function(value) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            return { value, done: true };
          };
          return MapIterator2;
        }();
        var Map2 = function() {
          function Map3() {
            this._keys = [];
            this._values = [];
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          }
          Object.defineProperty(Map3.prototype, "size", {
            get: function() {
              return this._keys.length;
            },
            enumerable: true,
            configurable: true
          });
          Map3.prototype.has = function(key) {
            return this._find(key, false) >= 0;
          };
          Map3.prototype.get = function(key) {
            var index = this._find(key, false);
            return index >= 0 ? this._values[index] : undefined;
          };
          Map3.prototype.set = function(key, value) {
            var index = this._find(key, true);
            this._values[index] = value;
            return this;
          };
          Map3.prototype.delete = function(key) {
            var index = this._find(key, false);
            if (index >= 0) {
              var size = this._keys.length;
              for (var i = index + 1;i < size; i++) {
                this._keys[i - 1] = this._keys[i];
                this._values[i - 1] = this._values[i];
              }
              this._keys.length--;
              this._values.length--;
              if (SameValueZero(key, this._cacheKey)) {
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              return true;
            }
            return false;
          };
          Map3.prototype.clear = function() {
            this._keys.length = 0;
            this._values.length = 0;
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          };
          Map3.prototype.keys = function() {
            return new MapIterator(this._keys, this._values, getKey);
          };
          Map3.prototype.values = function() {
            return new MapIterator(this._keys, this._values, getValue);
          };
          Map3.prototype.entries = function() {
            return new MapIterator(this._keys, this._values, getEntry);
          };
          Map3.prototype["@@iterator"] = function() {
            return this.entries();
          };
          Map3.prototype[iteratorSymbol] = function() {
            return this.entries();
          };
          Map3.prototype._find = function(key, insert) {
            if (!SameValueZero(this._cacheKey, key)) {
              this._cacheIndex = -1;
              for (var i = 0;i < this._keys.length; i++) {
                if (SameValueZero(this._keys[i], key)) {
                  this._cacheIndex = i;
                  break;
                }
              }
            }
            if (this._cacheIndex < 0 && insert) {
              this._cacheIndex = this._keys.length;
              this._keys.push(key);
              this._values.push(undefined);
            }
            return this._cacheIndex;
          };
          return Map3;
        }();
        return Map2;
        function getKey(key, _) {
          return key;
        }
        function getValue(_, value) {
          return value;
        }
        function getEntry(key, value) {
          return [key, value];
        }
      }
      function CreateSetPolyfill() {
        var Set3 = function() {
          function Set4() {
            this._map = new _Map;
          }
          Object.defineProperty(Set4.prototype, "size", {
            get: function() {
              return this._map.size;
            },
            enumerable: true,
            configurable: true
          });
          Set4.prototype.has = function(value) {
            return this._map.has(value);
          };
          Set4.prototype.add = function(value) {
            return this._map.set(value, value), this;
          };
          Set4.prototype.delete = function(value) {
            return this._map.delete(value);
          };
          Set4.prototype.clear = function() {
            this._map.clear();
          };
          Set4.prototype.keys = function() {
            return this._map.keys();
          };
          Set4.prototype.values = function() {
            return this._map.keys();
          };
          Set4.prototype.entries = function() {
            return this._map.entries();
          };
          Set4.prototype["@@iterator"] = function() {
            return this.keys();
          };
          Set4.prototype[iteratorSymbol] = function() {
            return this.keys();
          };
          return Set4;
        }();
        return Set3;
      }
      function CreateWeakMapPolyfill() {
        var UUID_SIZE = 16;
        var keys = HashMap.create();
        var rootKey = CreateUniqueKey();
        return function() {
          function WeakMap2() {
            this._key = CreateUniqueKey();
          }
          WeakMap2.prototype.has = function(target) {
            var table = GetOrCreateWeakMapTable(target, false);
            return table !== undefined ? HashMap.has(table, this._key) : false;
          };
          WeakMap2.prototype.get = function(target) {
            var table = GetOrCreateWeakMapTable(target, false);
            return table !== undefined ? HashMap.get(table, this._key) : undefined;
          };
          WeakMap2.prototype.set = function(target, value) {
            var table = GetOrCreateWeakMapTable(target, true);
            table[this._key] = value;
            return this;
          };
          WeakMap2.prototype.delete = function(target) {
            var table = GetOrCreateWeakMapTable(target, false);
            return table !== undefined ? delete table[this._key] : false;
          };
          WeakMap2.prototype.clear = function() {
            this._key = CreateUniqueKey();
          };
          return WeakMap2;
        }();
        function CreateUniqueKey() {
          var key;
          do
            key = "@@WeakMap@@" + CreateUUID();
          while (HashMap.has(keys, key));
          keys[key] = true;
          return key;
        }
        function GetOrCreateWeakMapTable(target, create) {
          if (!hasOwn.call(target, rootKey)) {
            if (!create)
              return;
            Object.defineProperty(target, rootKey, { value: HashMap.create() });
          }
          return target[rootKey];
        }
        function FillRandomBytes(buffer, size) {
          for (var i = 0;i < size; ++i)
            buffer[i] = Math.random() * 255 | 0;
          return buffer;
        }
        function GenRandomBytes(size) {
          if (typeof Uint8Array === "function") {
            var array = new Uint8Array(size);
            if (typeof crypto !== "undefined") {
              crypto.getRandomValues(array);
            } else if (typeof msCrypto !== "undefined") {
              msCrypto.getRandomValues(array);
            } else {
              FillRandomBytes(array, size);
            }
            return array;
          }
          return FillRandomBytes(new Array(size), size);
        }
        function CreateUUID() {
          var data = GenRandomBytes(UUID_SIZE);
          data[6] = data[6] & 79 | 64;
          data[8] = data[8] & 191 | 128;
          var result = "";
          for (var offset = 0;offset < UUID_SIZE; ++offset) {
            var byte = data[offset];
            if (offset === 4 || offset === 6 || offset === 8)
              result += "-";
            if (byte < 16)
              result += "0";
            result += byte.toString(16).toLowerCase();
          }
          return result;
        }
      }
      function MakeDictionary(obj) {
        obj.__ = undefined;
        delete obj.__;
        return obj;
      }
    });
  })(Reflect2 || (Reflect2 = {}));
});

// node_modules/tsyringe/node_modules/tslib/tslib.js
var require_tslib2 = __commonJS((exports, module) => {
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var __extends2;
  var __assign2;
  var __rest2;
  var __decorate2;
  var __param2;
  var __metadata2;
  var __awaiter2;
  var __generator2;
  var __exportStar2;
  var __values2;
  var __read2;
  var __spread2;
  var __spreadArrays2;
  var __await2;
  var __asyncGenerator2;
  var __asyncDelegator2;
  var __asyncValues2;
  var __makeTemplateObject2;
  var __importStar2;
  var __importDefault2;
  var __classPrivateFieldGet2;
  var __classPrivateFieldSet2;
  var __createBinding2;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
    };
    __extends2 = function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign2 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest2 = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate2 = function(decorators, target2, key, desc) {
      var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target2, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
      return c > 3 && r && Object.defineProperty(target2, key, r), r;
    };
    __param2 = function(paramIndex, decorator) {
      return function(target2, key) {
        decorator(target2, key, paramIndex);
      };
    };
    __metadata2 = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator2 = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __createBinding2 = function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __exportStar2 = function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !exports2.hasOwnProperty(p))
          exports2[p] = m[p];
    };
    __values2 = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read2 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread2 = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read2(arguments[i]));
      return ar;
    };
    __spreadArrays2 = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __await2 = function(v) {
      return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
    };
    __asyncGenerator2 = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator2 = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues2 = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject2 = function(cooked, raw2) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw2 });
      } else {
        cooked.raw = raw2;
      }
      return cooked;
    };
    __importStar2 = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    __importDefault2 = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet2 = function(receiver, privateMap) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
      }
      return privateMap.get(receiver);
    };
    __classPrivateFieldSet2 = function(receiver, privateMap, value) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
      }
      privateMap.set(receiver, value);
      return value;
    };
    exporter("__extends", __extends2);
    exporter("__assign", __assign2);
    exporter("__rest", __rest2);
    exporter("__decorate", __decorate2);
    exporter("__param", __param2);
    exporter("__metadata", __metadata2);
    exporter("__awaiter", __awaiter2);
    exporter("__generator", __generator2);
    exporter("__exportStar", __exportStar2);
    exporter("__createBinding", __createBinding2);
    exporter("__values", __values2);
    exporter("__read", __read2);
    exporter("__spread", __spread2);
    exporter("__spreadArrays", __spreadArrays2);
    exporter("__await", __await2);
    exporter("__asyncGenerator", __asyncGenerator2);
    exporter("__asyncDelegator", __asyncDelegator2);
    exporter("__asyncValues", __asyncValues2);
    exporter("__makeTemplateObject", __makeTemplateObject2);
    exporter("__importStar", __importStar2);
    exporter("__importDefault", __importDefault2);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
  });
});

// server/db/main.ts
var {$: $2 } = globalThis.Bun;

// server/db/index.ts
var {SQL } = globalThis.Bun;
var sql = new SQL({
  url: Bun.env.DB_URL,
  maxLifetime: 0,
  connectionTimeout: 30,
  max: 10,
  idleTimeout: 60
});

// server/db/module/system.ts
var checkInitialized = async () => {
  try {
    const result = await sql`SELECT * FROM multi_schema."ServerSystem" LIMIT 1`;
    return result.length;
  } catch (error) {
    return false;
  }
};
var initializeSystem = async () => {
  try {
    const system = { system_id: Bun.randomUUIDv7() };
    const [result] = await sql`INSERT INTO multi_schema."ServerSystem" ${sql(system)} RETURNING system_id`;
    return result;
  } catch (error) {
    console.error("Error initializing the system:", error);
    await insertErrorLog("system.ts", "initializeSystem", error);
  }
};
var updateProcessMediaStatus = async (status = true) => {
  try {
    return await sql`UPDATE multi_schema."ServerSystem" SET process_medias = ${status}`;
  } catch (error) {
    await insertErrorLog("system.ts", "updateProcessMediaStatus", error);
    console.log("updateProcessMediaStatus", error);
  }
};
var insertErrorLog = async (fileName, funcName, errMegs) => {
  try {
    const error = { file_error: fileName, func_occur: funcName, stack_trace: errMegs };
    await sql`INSERT INTO multi_schema."ErrorLog" ${sql(error)}`;
  } catch (error) {
    console.log(error);
  }
};

// server/service/helper.ts
import * as fs from "fs/promises";
var {$ } = globalThis.Bun;
import path, { basename, dirname } from "path";
import { rename } from "fs/promises";
var isExist = async (path2) => {
  try {
    await fs.access(path2);
    return true;
  } catch {
    return false;
  }
};
var createFolder = async (dePath, isRecursive = true) => {
  try {
    if (path.extname(dePath)) {
      dePath = path.dirname(dePath);
    }
    if (await isExist(dePath))
      return;
    await fs.mkdir(dePath, { recursive: isRecursive });
  } catch (error) {
    console.log("service/helper.ts", "createFolder", error);
    await insertErrorLog("service/helper.ts", "createFolder", error);
  }
};
var deleteFile = async (filePath) => {
  const { exitCode, stderr } = await $`rm ${filePath}`.nothrow();
  if (exitCode === 0)
    return true;
  console.log("service/helper.ts", "deleteFile", stderr);
  await insertErrorLog("service/helper.ts", "deleteFile", stderr);
  return false;
};
var copyFile = async (source, destination) => {
  const { exitCode, stderr } = await $`rsync -ahv ${source} ${destination}`.quiet().nothrow();
  if (exitCode === 0)
    return true;
  console.log("service/helper.ts", "copyFile", stderr);
  await insertErrorLog("service/helper.ts", "copyFile", stderr);
  return false;
};
var moveFile = async (oldPath, newPath) => {
  const copyTatus = await copyFile(oldPath, newPath);
  if (copyTatus)
    return await deleteFile(oldPath);
  return false;
};
var sanitizeFileName = (name) => {
  return name.replace(/[^\w.-]/g, "_");
};
var renameIfInvalid = async (sourcePath) => {
  try {
    const name = basename(sourcePath);
    const dir = dirname(sourcePath);
    const cleanName = sanitizeFileName(name);
    if (cleanName === name)
      return sourcePath;
    const oldPath = path.join(dir, name);
    const newPath = path.join(dir, cleanName);
    await rename(oldPath, newPath);
    return path.join(dir, cleanName);
  } catch (error) {
    await insertErrorLog("service/helper.ts", "renameIfInvalid", error);
    console.log("renameIfInvalid", error);
    return "";
  }
};
var moveUnsupportFile = async (source) => {
  const movePath = path.join(Bun.env.UNSUPPORT_PATH, nameFolderByTime(true));
  await createFolder(movePath);
  return await moveFile(source, path.join(movePath, basename(source)));
};
var createRandomId = (length) => {
  return Math.random().toString(36).substring(2, 2 + length);
};
var formatDate = (component) => {
  return String(component).padStart(2, "0");
};
var reducePath = (absolutePath) => absolutePath.startsWith(Bun.env.MAIN_PATH) ? absolutePath.slice(Bun.env.MAIN_PATH.length) : absolutePath;
var nameFolderByTime = (isShort = false) => {
  const currentDate = new Date;
  const year = currentDate.getFullYear();
  const month = formatDate(currentDate.getMonth() + 1);
  const day = formatDate(currentDate.getDate());
  if (isShort)
    return `${year}-${month}-${day}`;
  const hour = formatDate(currentDate.getHours());
  const minute = formatDate(currentDate.getMinutes());
  const second = formatDate(currentDate.getSeconds());
  return `${year}-${month}-${day}_${hour}-${minute}-${second}`;
};
var diskCapacity = async (pathToCheck) => {
  try {
    const { stdout } = await $`df -k ${pathToCheck}`.quiet();
    const output = new TextDecoder().decode(stdout);
    const lines = output.trim().split(`
`);
    const parts = lines[1].split(/\s+/);
    const total = parseInt(parts[1]) * 1024;
    const used = parseInt(parts[2]) * 1024;
    const free = parseInt(parts[3]) * 1024;
    return { total, used, free };
  } catch (error) {
    await insertErrorLog("service/helper.ts", "diskCapacity", error);
    return null;
  }
};
var getDirName = (dirPath) => dirPath.split("/").at(-1);
var removeDirRecursive = async (targetPath) => {
  await fs.rm(targetPath, { recursive: true, force: true });
};
var isDirEmpty = async (targetPath) => {
  const files = await fs.readdir(targetPath);
  return files.length === 0;
};
var removeEmptyDirs = async (dir) => {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (!await isExist(fullPath))
      continue;
    if (entry.isDirectory()) {
      await removeEmptyDirs(fullPath);
      if (await isDirEmpty(fullPath)) {
        await removeDirRecursive(fullPath);
        console.log(`[Cleanup] Removed empty directory: ${fullPath}`);
      }
    }
  }
};
var startWithDot = (filePath) => {
  const basename2 = path.basename(filePath);
  return basename2.startsWith(".");
};

// server/db/main.ts
var createDBMS = async () => {
  try {
    const { exitCode } = await $2`PGPASSWORD=$DB_PASS psql -U $DB_USER -d postgres -h $DB_HOST -v name_db=$DB_NAME -v user_db=$DB_USER -f $DB_CREATE`;
    if (exitCode !== 0)
      return false;
    await sql.file(Bun.env.DB_MODEL);
    await sql.file(Bun.env.DB_VIEW);
    await sql.file(Bun.env.DB_TRIGGER);
    return true;
  } catch (error) {
    console.log("createDBMS", error);
    return false;
  }
};
var backupToDB = async () => {
  const { stderr, exitCode } = await $2`pg_dump $DB_URL > $DB_BACKUP`.quiet();
  exitCode !== 0 ? await insertErrorLog("db/main.ts", `backupToDB`, stderr) : console.log(`BACKUP successfully to the DB!`);
  return exitCode === 0;
};
var backupFiles = async (stream) => {
  const [isMainExist, isBackupExist] = await Promise.all([isExist(Bun.env.MAIN_PATH), isExist(Bun.env.BACKUP_DATA)]);
  if (!isMainExist || !isBackupExist) {
    await stream.writeln(`\u274C Failed! ${!isMainExist ? "Source" : "Backup"} directory path is not exist`);
    return false;
  }
  const [mainDisk, backupDisk] = await Promise.all([diskCapacity(Bun.env.MAIN_PATH), diskCapacity(Bun.env.BACKUP_DATA)]);
  if (mainDisk?.used > backupDisk?.total) {
    await stream.writeln(`\u274C Failed! Backup storage does not have enough spaces.`);
    return false;
  }
  const process2 = Bun.spawn(["rsync", "-ahv", "--delete", '--exclude={"/dev/*","/proc/*","/sys/*","/tmp/*","/run/*","/mnt/*","/media/*"}', `${Bun.env.MAIN_PATH}/`, `${Bun.env.BACKUP_DATA}/`], {
    stderr: "pipe",
    stdout: "pipe"
  });
  try {
    const reader = process2.stdout.getReader();
    const decoder = new TextDecoder;
    while (true) {
      const { value, done } = await reader.read();
      if (done)
        break;
      const eachLine = decoder.decode(value, { stream: true }).trim();
      await stream.writeln(eachLine);
    }
  } catch (error) {
    await insertErrorLog("db/main.ts", `backupFiles`, error);
  } finally {
    process2.kill();
  }
  return await process2.exited === 0;
};
var restoreToDB = async () => {
  const { stderr, exitCode } = await $2`psql $DB_URL -f $DB_BACKUP`.quiet();
  exitCode !== 0 ? await insertErrorLog("db/main.ts", `restoreToDB`, stderr) : console.log(`RESTORE successfully to the DB!`);
  return exitCode === 0;
};

// server/init_sys.ts
var isDevMode = Bun.env.NODE_ENV === "dev";
var isProduction = Bun.env.NODE_ENV === "production";
var isSystemInitialized = await checkInitialized();
if (!isSystemInitialized) {
  console.log("\uD83D\uDD27 Initializing Server...");
  const dbCreated = await createDBMS();
  console.log("\uD83D\uDCE6 Database created:", dbCreated);
  const systemInitialized = await initializeSystem();
  if (!systemInitialized) {
    console.error("\u274C Failed to initialize the system.");
    process.exit(1);
  }
}

// node_modules/hono/dist/adapter/bun/serve-static.js
import { stat } from "fs/promises";
import { join } from "path";

// node_modules/hono/dist/utils/compress.js
var COMPRESSIBLE_CONTENT_TYPE_REGEX = /^\s*(?:text\/(?!event-stream(?:[;\s]|$))[^;\s]+|application\/(?:javascript|json|xml|xml-dtd|ecmascript|dart|postscript|rtf|tar|toml|vnd\.dart|vnd\.ms-fontobject|vnd\.ms-opentype|wasm|x-httpd-php|x-javascript|x-ns-proxy-autoconfig|x-sh|x-tar|x-virtualbox-hdd|x-virtualbox-ova|x-virtualbox-ovf|x-virtualbox-vbox|x-virtualbox-vdi|x-virtualbox-vhd|x-virtualbox-vmdk|x-www-form-urlencoded)|font\/(?:otf|ttf)|image\/(?:bmp|vnd\.adobe\.photoshop|vnd\.microsoft\.icon|vnd\.ms-dds|x-icon|x-ms-bmp)|message\/rfc822|model\/gltf-binary|x-shader\/x-fragment|x-shader\/x-vertex|[^;\s]+?\+(?:json|text|xml|yaml))(?:[;\s]|$)/i;

// node_modules/hono/dist/utils/mime.js
var getMimeType = (filename, mimes = baseMimes) => {
  const regexp = /\.([a-zA-Z0-9]+?)$/;
  const match = filename.match(regexp);
  if (!match) {
    return;
  }
  let mimeType = mimes[match[1]];
  if (mimeType && mimeType.startsWith("text")) {
    mimeType += "; charset=utf-8";
  }
  return mimeType;
};
var _baseMimes = {
  aac: "audio/aac",
  avi: "video/x-msvideo",
  avif: "image/avif",
  av1: "video/av1",
  bin: "application/octet-stream",
  bmp: "image/bmp",
  css: "text/css",
  csv: "text/csv",
  eot: "application/vnd.ms-fontobject",
  epub: "application/epub+zip",
  gif: "image/gif",
  gz: "application/gzip",
  htm: "text/html",
  html: "text/html",
  ico: "image/x-icon",
  ics: "text/calendar",
  jpeg: "image/jpeg",
  jpg: "image/jpeg",
  js: "text/javascript",
  json: "application/json",
  jsonld: "application/ld+json",
  map: "application/json",
  mid: "audio/x-midi",
  midi: "audio/x-midi",
  mjs: "text/javascript",
  mp3: "audio/mpeg",
  mp4: "video/mp4",
  mpeg: "video/mpeg",
  oga: "audio/ogg",
  ogv: "video/ogg",
  ogx: "application/ogg",
  opus: "audio/opus",
  otf: "font/otf",
  pdf: "application/pdf",
  png: "image/png",
  rtf: "application/rtf",
  svg: "image/svg+xml",
  tif: "image/tiff",
  tiff: "image/tiff",
  ts: "video/mp2t",
  ttf: "font/ttf",
  txt: "text/plain",
  wasm: "application/wasm",
  webm: "video/webm",
  weba: "audio/webm",
  webmanifest: "application/manifest+json",
  webp: "image/webp",
  woff: "font/woff",
  woff2: "font/woff2",
  xhtml: "application/xhtml+xml",
  xml: "application/xml",
  zip: "application/zip",
  "3gp": "video/3gpp",
  "3g2": "video/3gpp2",
  gltf: "model/gltf+json",
  glb: "model/gltf-binary"
};
var baseMimes = _baseMimes;

// node_modules/hono/dist/middleware/serve-static/path.js
var defaultJoin = (...paths) => {
  let result = paths.filter((p) => p !== "").join("/");
  result = result.replace(/(?<=\/)\/+/g, "");
  const segments = result.split("/");
  const resolved = [];
  for (const segment of segments) {
    if (segment === ".." && resolved.length > 0 && resolved.at(-1) !== "..") {
      resolved.pop();
    } else if (segment !== ".") {
      resolved.push(segment);
    }
  }
  return resolved.join("/") || ".";
};

// node_modules/hono/dist/middleware/serve-static/index.js
var ENCODINGS = {
  br: ".br",
  zstd: ".zst",
  gzip: ".gz"
};
var ENCODINGS_ORDERED_KEYS = Object.keys(ENCODINGS);
var DEFAULT_DOCUMENT = "index.html";
var serveStatic = (options) => {
  const root = options.root ?? "./";
  const optionPath = options.path;
  const join = options.join ?? defaultJoin;
  return async (c, next) => {
    if (c.finalized) {
      return next();
    }
    let filename;
    if (options.path) {
      filename = options.path;
    } else {
      try {
        filename = decodeURIComponent(c.req.path);
        if (/(?:^|[\/\\])\.\.(?:$|[\/\\])/.test(filename)) {
          throw new Error;
        }
      } catch {
        await options.onNotFound?.(c.req.path, c);
        return next();
      }
    }
    let path2 = join(root, !optionPath && options.rewriteRequestPath ? options.rewriteRequestPath(filename) : filename);
    if (options.isDir && await options.isDir(path2)) {
      path2 = join(path2, DEFAULT_DOCUMENT);
    }
    const getContent = options.getContent;
    let content = await getContent(path2, c);
    if (content instanceof Response) {
      return c.newResponse(content.body, content);
    }
    if (content) {
      const mimeType = options.mimes && getMimeType(path2, options.mimes) || getMimeType(path2);
      c.header("Content-Type", mimeType || "application/octet-stream");
      if (options.precompressed && (!mimeType || COMPRESSIBLE_CONTENT_TYPE_REGEX.test(mimeType))) {
        const acceptEncodingSet = new Set(c.req.header("Accept-Encoding")?.split(",").map((encoding) => encoding.trim()));
        for (const encoding of ENCODINGS_ORDERED_KEYS) {
          if (!acceptEncodingSet.has(encoding)) {
            continue;
          }
          const compressedContent = await getContent(path2 + ENCODINGS[encoding], c);
          if (compressedContent) {
            content = compressedContent;
            c.header("Content-Encoding", encoding);
            c.header("Vary", "Accept-Encoding", { append: true });
            break;
          }
        }
      }
      await options.onFound?.(path2, c);
      return c.body(content);
    }
    await options.onNotFound?.(path2, c);
    await next();
    return;
  };
};

// node_modules/hono/dist/adapter/bun/serve-static.js
var serveStatic2 = (options) => {
  return async function serveStatic2(c, next) {
    const getContent = async (path2) => {
      const file = Bun.file(path2);
      return await file.exists() ? file : null;
    };
    const isDir = async (path2) => {
      let isDir2;
      try {
        const stats = await stat(path2);
        isDir2 = stats.isDirectory();
      } catch {}
      return isDir2;
    };
    return serveStatic({
      ...options,
      getContent,
      join,
      isDir
    })(c, next);
  };
};

// node_modules/hono/dist/router.js
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
};

// node_modules/hono/dist/utils/constants.js
var COMPOSED_HANDLER = "__COMPOSED_HANDLER";

// node_modules/hono/dist/helper/ssg/middleware.js
var X_HONO_DISABLE_SSG_HEADER_KEY = "x-hono-disable-ssg";
var SSG_DISABLED_RESPONSE = (() => {
  try {
    return new Response("SSG is disabled", {
      status: 404,
      headers: { [X_HONO_DISABLE_SSG_HEADER_KEY]: "true" }
    });
  } catch {
    return null;
  }
})();
// node_modules/hono/dist/adapter/bun/ssg.js
var { write } = Bun;

// node_modules/hono/dist/helper/websocket/index.js
var WSContext = class {
  #init;
  constructor(init) {
    this.#init = init;
    this.raw = init.raw;
    this.url = init.url ? new URL(init.url) : null;
    this.protocol = init.protocol ?? null;
  }
  send(source, options) {
    this.#init.send(source, options ?? {});
  }
  raw;
  binaryType = "arraybuffer";
  get readyState() {
    return this.#init.readyState;
  }
  url;
  protocol;
  close(code, reason) {
    this.#init.close(code, reason);
  }
};
var defineWebSocketHelper = (handler) => {
  return (...args) => {
    if (typeof args[0] === "function") {
      const [createEvents, options] = args;
      return async function upgradeWebSocket(c, next) {
        const events = await createEvents(c);
        const result = await handler(c, events, options);
        if (result) {
          return result;
        }
        await next();
      };
    } else {
      const [c, events, options] = args;
      return (async () => {
        const upgraded = await handler(c, events, options);
        if (!upgraded) {
          throw new Error("Failed to upgrade WebSocket");
        }
        return upgraded;
      })();
    }
  };
};

// node_modules/hono/dist/adapter/bun/server.js
var getBunServer = (c) => ("server" in c.env) ? c.env.server : c.env;

// node_modules/hono/dist/adapter/bun/websocket.js
var upgradeWebSocket = defineWebSocketHelper((c, events) => {
  const server = getBunServer(c);
  if (!server) {
    throw new TypeError("env has to include the 2nd argument of fetch.");
  }
  const upgradeResult = server.upgrade(c.req.raw, {
    data: {
      events,
      url: new URL(c.req.url),
      protocol: c.req.url
    }
  });
  if (upgradeResult) {
    return new Response(null);
  }
  return;
});

// node_modules/hono/dist/adapter/bun/conninfo.js
var getConnInfo = (c) => {
  const server = getBunServer(c);
  if (!server) {
    throw new TypeError("env has to include the 2nd argument of fetch.");
  }
  if (typeof server.requestIP !== "function") {
    throw new TypeError("server.requestIP is not a function.");
  }
  const info = server.requestIP(c.req.raw);
  if (!info) {
    return {
      remote: {}
    };
  }
  return {
    remote: {
      address: info.address,
      addressType: info.family === "IPv6" || info.family === "IPv4" ? info.family : undefined,
      port: info.port
    }
  };
};

// node_modules/hono/dist/compose.js
var compose = (middleware, onError, onNotFound) => {
  return (context, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let res;
      let isError = false;
      let handler;
      if (middleware[i]) {
        handler = middleware[i][0][0];
        context.req.routeIndex = i;
      } else {
        handler = i === middleware.length && next || undefined;
      }
      if (handler) {
        try {
          res = await handler(context, () => dispatch(i + 1));
        } catch (err) {
          if (err instanceof Error && onError) {
            context.error = err;
            res = await onError(err, context);
            isError = true;
          } else {
            throw err;
          }
        }
      } else {
        if (context.finalized === false && onNotFound) {
          res = await onNotFound(context);
        }
      }
      if (res && (context.finalized === false || isError)) {
        context.res = res;
      }
      return context;
    }
  };
};

// node_modules/hono/dist/http-exception.js
var HTTPException = class extends Error {
  res;
  status;
  constructor(status = 500, options) {
    super(options?.message, { cause: options?.cause });
    this.res = options?.res;
    this.status = status;
  }
  getResponse() {
    if (this.res) {
      const newResponse = new Response(this.res.body, {
        status: this.status,
        headers: this.res.headers
      });
      return newResponse;
    }
    return new Response(this.message, {
      status: this.status
    });
  }
};

// node_modules/hono/dist/request/constants.js
var GET_MATCH_RESULT = Symbol();

// node_modules/hono/dist/utils/body.js
var parseBody = async (request, options = /* @__PURE__ */ Object.create(null)) => {
  const { all = false, dot = false } = options;
  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
  const contentType = headers.get("Content-Type");
  if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
    return parseFormData(request, { all, dot });
  }
  return {};
};
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key, value]) => {
      const shouldParseDotValues = key.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value);
        delete form[key];
      }
    });
  }
  return form;
}
var handleParsingAllValues = (form, key, value) => {
  if (form[key] !== undefined) {
    if (Array.isArray(form[key])) {
      form[key].push(value);
    } else {
      form[key] = [form[key], value];
    }
  } else {
    if (!key.endsWith("[]")) {
      form[key] = value;
    } else {
      form[key] = [value];
    }
  }
};
var handleParsingNestedValues = (form, key, value) => {
  let nestedForm = form;
  const keys = key.split(".");
  keys.forEach((key2, index) => {
    if (index === keys.length - 1) {
      nestedForm[key2] = value;
    } else {
      if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
        nestedForm[key2] = /* @__PURE__ */ Object.create(null);
      }
      nestedForm = nestedForm[key2];
    }
  });
};

// node_modules/hono/dist/utils/url.js
var splitPath = (path2) => {
  const paths = path2.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
};
var splitRoutingPath = (routePath) => {
  const { groups, path: path2 } = extractGroupsFromPath(routePath);
  const paths = splitPath(path2);
  return replaceGroupMarks(paths, groups);
};
var extractGroupsFromPath = (path2) => {
  const groups = [];
  path2 = path2.replace(/\{[^}]+\}/g, (match, index) => {
    const mark = `@${index}`;
    groups.push([mark, match]);
    return mark;
  });
  return { groups, path: path2 };
};
var replaceGroupMarks = (paths, groups) => {
  for (let i = groups.length - 1;i >= 0; i--) {
    const [mark] = groups[i];
    for (let j = paths.length - 1;j >= 0; j--) {
      if (paths[j].includes(mark)) {
        paths[j] = paths[j].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths;
};
var patternCache = {};
var getPattern = (label, next) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    const cacheKey = `${label}#${next}`;
    if (!patternCache[cacheKey]) {
      if (match[2]) {
        patternCache[cacheKey] = next && next[0] !== ":" && next[0] !== "*" ? [cacheKey, match[1], new RegExp(`^${match[2]}(?=/${next})`)] : [label, match[1], new RegExp(`^${match[2]}$`)];
      } else {
        patternCache[cacheKey] = [label, match[1], true];
      }
    }
    return patternCache[cacheKey];
  }
  return null;
};
var tryDecode = (str, decoder) => {
  try {
    return decoder(str);
  } catch {
    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {
      try {
        return decoder(match);
      } catch {
        return match;
      }
    });
  }
};
var tryDecodeURI = (str) => tryDecode(str, decodeURI);
var getPath = (request) => {
  const url = request.url;
  const start = url.indexOf("/", url.indexOf(":") + 4);
  let i = start;
  for (;i < url.length; i++) {
    const charCode = url.charCodeAt(i);
    if (charCode === 37) {
      const queryIndex = url.indexOf("?", i);
      const path2 = url.slice(start, queryIndex === -1 ? undefined : queryIndex);
      return tryDecodeURI(path2.includes("%25") ? path2.replace(/%25/g, "%2525") : path2);
    } else if (charCode === 63) {
      break;
    }
  }
  return url.slice(start, i);
};
var getPathNoStrict = (request) => {
  const result = getPath(request);
  return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
};
var mergePath = (base, sub, ...rest) => {
  if (rest.length) {
    sub = mergePath(sub, ...rest);
  }
  return `${base?.[0] === "/" ? "" : "/"}${base}${sub === "/" ? "" : `${base?.at(-1) === "/" ? "" : "/"}${sub?.[0] === "/" ? sub.slice(1) : sub}`}`;
};
var checkOptionalParameter = (path2) => {
  if (path2.charCodeAt(path2.length - 1) !== 63 || !path2.includes(":")) {
    return null;
  }
  const segments = path2.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v, i, a) => a.indexOf(v) === i);
};
var _decodeURI = (value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return value.indexOf("%") !== -1 ? tryDecode(value, decodeURIComponent_) : value;
};
var _getQueryParam = (url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf("?", 8);
    if (keyIndex2 === -1) {
      return;
    }
    if (!url.startsWith(key, keyIndex2 + 1)) {
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? undefined : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return;
    }
  }
  const results = {};
  encoded ??= /[%+]/.test(url);
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(keyIndex + 1, valueIndex === -1 ? nextKeyIndex === -1 ? undefined : nextKeyIndex : valueIndex);
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? undefined : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = [];
      }
      results[name].push(value);
    } else {
      results[name] ??= value;
    }
  }
  return key ? results[key] : results;
};
var getQueryParam = _getQueryParam;
var getQueryParams = (url, key) => {
  return _getQueryParam(url, key, true);
};
var decodeURIComponent_ = decodeURIComponent;

// node_modules/hono/dist/request.js
var tryDecodeURIComponent = (str) => tryDecode(str, decodeURIComponent_);
var HonoRequest = class {
  raw;
  #validatedData;
  #matchResult;
  routeIndex = 0;
  path;
  bodyCache = {};
  constructor(request, path2 = "/", matchResult = [[]]) {
    this.raw = request;
    this.path = path2;
    this.#matchResult = matchResult;
    this.#validatedData = {};
  }
  param(key) {
    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();
  }
  #getDecodedParam(key) {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key];
    const param = this.#getParamValue(paramKey);
    return param && /\%/.test(param) ? tryDecodeURIComponent(param) : param;
  }
  #getAllDecodedParams() {
    const decoded = {};
    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
    for (const key of keys) {
      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
      if (value !== undefined) {
        decoded[key] = /\%/.test(value) ? tryDecodeURIComponent(value) : value;
      }
    }
    return decoded;
  }
  #getParamValue(paramKey) {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name) {
      return this.raw.headers.get(name) ?? undefined;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    return this.bodyCache.parsedBody ??= await parseBody(this, options);
  }
  #cachedBody = (key) => {
    const { bodyCache, raw } = this;
    const cachedBody = bodyCache[key];
    if (cachedBody) {
      return cachedBody;
    }
    const anyCachedKey = Object.keys(bodyCache)[0];
    if (anyCachedKey) {
      return bodyCache[anyCachedKey].then((body) => {
        if (anyCachedKey === "json") {
          body = JSON.stringify(body);
        }
        return new Response(body)[key]();
      });
    }
    return bodyCache[key] = raw[key]();
  };
  json() {
    return this.#cachedBody("text").then((text) => JSON.parse(text));
  }
  text() {
    return this.#cachedBody("text");
  }
  arrayBuffer() {
    return this.#cachedBody("arrayBuffer");
  }
  blob() {
    return this.#cachedBody("blob");
  }
  formData() {
    return this.#cachedBody("formData");
  }
  addValidatedData(target, data) {
    this.#validatedData[target] = data;
  }
  valid(target) {
    return this.#validatedData[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get [GET_MATCH_RESULT]() {
    return this.#matchResult;
  }
  get matchedRoutes() {
    return this.#matchResult[0].map(([[, route]]) => route);
  }
  get routePath() {
    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
};

// node_modules/hono/dist/utils/html.js
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw = (value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
};
var resolveCallback = async (str, phase, preserveCallbacks, context, buffer) => {
  if (typeof str === "object" && !(str instanceof String)) {
    if (!(str instanceof Promise)) {
      str = str.toString();
    }
    if (str instanceof Promise) {
      str = await str;
    }
  }
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then((res) => Promise.all(res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))).then(() => buffer[0]));
  if (preserveCallbacks) {
    return raw(await resStr, callbacks);
  } else {
    return resStr;
  }
};

// node_modules/hono/dist/context.js
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setDefaultContentType = (contentType, headers) => {
  return {
    "Content-Type": contentType,
    ...headers
  };
};
var Context = class {
  #rawRequest;
  #req;
  env = {};
  #var;
  finalized = false;
  error;
  #status;
  #executionCtx;
  #res;
  #layout;
  #renderer;
  #notFoundHandler;
  #preparedHeaders;
  #matchResult;
  #path;
  constructor(req, options) {
    this.#rawRequest = req;
    if (options) {
      this.#executionCtx = options.executionCtx;
      this.env = options.env;
      this.#notFoundHandler = options.notFoundHandler;
      this.#path = options.path;
      this.#matchResult = options.matchResult;
    }
  }
  get req() {
    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
    return this.#req;
  }
  get event() {
    if (this.#executionCtx && "respondWith" in this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    return this.#res ||= new Response(null, {
      headers: this.#preparedHeaders ??= new Headers
    });
  }
  set res(_res) {
    if (this.#res && _res) {
      _res = new Response(_res.body, _res);
      for (const [k, v] of this.#res.headers.entries()) {
        if (k === "content-type") {
          continue;
        }
        if (k === "set-cookie") {
          const cookies = this.#res.headers.getSetCookie();
          _res.headers.delete("set-cookie");
          for (const cookie of cookies) {
            _res.headers.append("set-cookie", cookie);
          }
        } else {
          _res.headers.set(k, v);
        }
      }
    }
    this.#res = _res;
    this.finalized = true;
  }
  render = (...args) => {
    this.#renderer ??= (content) => this.html(content);
    return this.#renderer(...args);
  };
  setLayout = (layout) => this.#layout = layout;
  getLayout = () => this.#layout;
  setRenderer = (renderer) => {
    this.#renderer = renderer;
  };
  header = (name, value, options) => {
    if (this.finalized) {
      this.#res = new Response(this.#res.body, this.#res);
    }
    const headers = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers;
    if (value === undefined) {
      headers.delete(name);
    } else if (options?.append) {
      headers.append(name, value);
    } else {
      headers.set(name, value);
    }
  };
  status = (status) => {
    this.#status = status;
  };
  set = (key, value) => {
    this.#var ??= /* @__PURE__ */ new Map;
    this.#var.set(key, value);
  };
  get = (key) => {
    return this.#var ? this.#var.get(key) : undefined;
  };
  get var() {
    if (!this.#var) {
      return {};
    }
    return Object.fromEntries(this.#var);
  }
  #newResponse(data, arg, headers) {
    const responseHeaders = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers;
    if (typeof arg === "object" && "headers" in arg) {
      const argHeaders = arg.headers instanceof Headers ? arg.headers : new Headers(arg.headers);
      for (const [key, value] of argHeaders) {
        if (key.toLowerCase() === "set-cookie") {
          responseHeaders.append(key, value);
        } else {
          responseHeaders.set(key, value);
        }
      }
    }
    if (headers) {
      for (const [k, v] of Object.entries(headers)) {
        if (typeof v === "string") {
          responseHeaders.set(k, v);
        } else {
          responseHeaders.delete(k);
          for (const v2 of v) {
            responseHeaders.append(k, v2);
          }
        }
      }
    }
    const status = typeof arg === "number" ? arg : arg?.status ?? this.#status;
    return new Response(data, { status, headers: responseHeaders });
  }
  newResponse = (...args) => this.#newResponse(...args);
  body = (data, arg, headers) => this.#newResponse(data, arg, headers);
  text = (text, arg, headers) => {
    return !this.#preparedHeaders && !this.#status && !arg && !headers && !this.finalized ? new Response(text) : this.#newResponse(text, arg, setDefaultContentType(TEXT_PLAIN, headers));
  };
  json = (object, arg, headers) => {
    return this.#newResponse(JSON.stringify(object), arg, setDefaultContentType("application/json", headers));
  };
  html = (html, arg, headers) => {
    const res = (html2) => this.#newResponse(html2, arg, setDefaultContentType("text/html; charset=UTF-8", headers));
    return typeof html === "object" ? resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then(res) : res(html);
  };
  redirect = (location, status) => {
    const locationString = String(location);
    this.header("Location", !/[^\x00-\xFF]/.test(locationString) ? locationString : encodeURI(locationString));
    return this.newResponse(null, status ?? 302);
  };
  notFound = () => {
    this.#notFoundHandler ??= () => new Response;
    return this.#notFoundHandler(this);
  };
};

// node_modules/hono/dist/hono-base.js
var notFoundHandler = (c) => {
  return c.text("404 Not Found", 404);
};
var errorHandler = (err, c) => {
  if ("getResponse" in err) {
    const res = err.getResponse();
    return c.newResponse(res.body, res);
  }
  console.error(err);
  return c.text("Internal Server Error", 500);
};
var Hono = class {
  get;
  post;
  put;
  delete;
  options;
  patch;
  all;
  on;
  use;
  router;
  getPath;
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.#addRoute(method, this.#path, args1);
        }
        args.forEach((handler) => {
          this.#addRoute(method, this.#path, handler);
        });
        return this;
      };
    });
    this.on = (method, path2, ...handlers) => {
      for (const p of [path2].flat()) {
        this.#path = p;
        for (const m of [method].flat()) {
          handlers.map((handler) => {
            this.#addRoute(m.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers.unshift(arg1);
      }
      handlers.forEach((handler) => {
        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const { strict, ...optionsWithoutStrict } = options;
    Object.assign(this, optionsWithoutStrict);
    this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;
  }
  #clone() {
    const clone = new Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone.errorHandler = this.errorHandler;
    clone.#notFoundHandler = this.#notFoundHandler;
    clone.routes = this.routes;
    return clone;
  }
  #notFoundHandler = notFoundHandler;
  errorHandler = errorHandler;
  route(path2, app) {
    const subApp = this.basePath(path2);
    app.routes.map((r) => {
      let handler;
      if (app.errorHandler === errorHandler) {
        handler = r.handler;
      } else {
        handler = async (c, next) => (await compose([], app.errorHandler)(c, () => r.handler(c, next))).res;
        handler[COMPOSED_HANDLER] = r.handler;
      }
      subApp.#addRoute(r.method, r.path, handler);
    });
    return this;
  }
  basePath(path2) {
    const subApp = this.#clone();
    subApp._basePath = mergePath(this._basePath, path2);
    return subApp;
  }
  onError = (handler) => {
    this.errorHandler = handler;
    return this;
  };
  notFound = (handler) => {
    this.#notFoundHandler = handler;
    return this;
  };
  mount(path2, applicationHandler, options) {
    let replaceRequest;
    let optionHandler;
    if (options) {
      if (typeof options === "function") {
        optionHandler = options;
      } else {
        optionHandler = options.optionHandler;
        if (options.replaceRequest === false) {
          replaceRequest = (request) => request;
        } else {
          replaceRequest = options.replaceRequest;
        }
      }
    }
    const getOptions = optionHandler ? (c) => {
      const options2 = optionHandler(c);
      return Array.isArray(options2) ? options2 : [options2];
    } : (c) => {
      let executionContext = undefined;
      try {
        executionContext = c.executionCtx;
      } catch {}
      return [c.env, executionContext];
    };
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path2);
      const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
      return (request) => {
        const url = new URL(request.url);
        url.pathname = url.pathname.slice(pathPrefixLength) || "/";
        return new Request(url, request);
      };
    })();
    const handler = async (c, next) => {
      const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));
      if (res) {
        return res;
      }
      await next();
    };
    this.#addRoute(METHOD_NAME_ALL, mergePath(path2, "*"), handler);
    return this;
  }
  #addRoute(method, path2, handler) {
    method = method.toUpperCase();
    path2 = mergePath(this._basePath, path2);
    const r = { basePath: this._basePath, path: path2, method, handler };
    this.router.add(method, path2, [handler, r]);
    this.routes.push(r);
  }
  #handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  #dispatch(request, executionCtx, env, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env, "GET")))();
    }
    const path2 = this.getPath(request, { env });
    const matchResult = this.router.match(method, path2);
    const c = new Context(request, {
      path: path2,
      matchResult,
      env,
      executionCtx,
      notFoundHandler: this.#notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c, async () => {
          c.res = await this.#notFoundHandler(c);
        });
      } catch (err) {
        return this.#handleError(err, c);
      }
      return res instanceof Promise ? res.then((resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);
    }
    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);
    return (async () => {
      try {
        const context = await composed(c);
        if (!context.finalized) {
          throw new Error("Context is not finalized. Did you forget to return a Response object or `await next()`?");
        }
        return context.res;
      } catch (err) {
        return this.#handleError(err, c);
      }
    })();
  }
  fetch = (request, ...rest) => {
    return this.#dispatch(request, rest[1], rest[0], request.method);
  };
  request = (input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);
    }
    input = input.toString();
    return this.fetch(new Request(/^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`, requestInit), Env, executionCtx);
  };
  fire = () => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.#dispatch(event.request, event, undefined, event.request.method));
    });
  };
};

// node_modules/hono/dist/router/reg-exp-router/matcher.js
var emptyParam = [];
function match(method, path2) {
  const matchers = this.buildAllMatchers();
  const match2 = (method2, path22) => {
    const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
    const staticMatch = matcher[2][path22];
    if (staticMatch) {
      return staticMatch;
    }
    const match3 = path22.match(matcher[0]);
    if (!match3) {
      return [[], emptyParam];
    }
    const index = match3.indexOf("", 1);
    return [matcher[1][index], match3];
  };
  this.match = match2;
  return match2(method, path2);
}

// node_modules/hono/dist/router/reg-exp-router/node.js
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a, b) {
  if (a.length === 1) {
    return b.length === 1 ? a < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
var Node = class {
  #index;
  #varIndex;
  #children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.#index !== undefined) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.#index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        if (regexpStr === ".*") {
          throw PATH_ERROR;
        }
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.#children[regexpStr];
      if (!node) {
        if (Object.keys(this.#children).some((k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[regexpStr] = new Node;
        if (name !== "") {
          node.#varIndex = context.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.#varIndex]);
      }
    } else {
      node = this.#children[token];
      if (!node) {
        if (Object.keys(this.#children).some((k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[token] = new Node;
      }
    }
    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.#children).sort(compareKey);
    const strList = childKeys.map((k) => {
      const c = this.#children[k];
      return (typeof c.#varIndex === "number" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\${k}` : k) + c.buildRegExpStr();
    });
    if (typeof this.#index === "number") {
      strList.unshift(`#${this.#index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// node_modules/hono/dist/router/reg-exp-router/trie.js
var Trie = class {
  #context = { varIndex: 0 };
  #root = new Node;
  insert(path2, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i = 0;; ) {
      let replaced = false;
      path2 = path2.replace(/\{[^}]+\}/g, (m) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path2.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1;i >= 0; i--) {
      const [mark] = groups[i];
      for (let j = tokens.length - 1;j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.#root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (handlerIndex !== undefined) {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (paramIndex !== undefined) {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// node_modules/hono/dist/router/reg-exp-router/router.js
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path2) {
  return wildcardRegExpCache[path2] ??= new RegExp(path2 === "*" ? "" : `^${path2.replace(/\/\*$|([.\\+*[^\]$()])/g, (_, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)")}$`);
}
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie;
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map((route) => [!/\*|\/:/.test(route[0]), ...route]).sort(([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length);
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length;i < len; i++) {
    const [pathErrorCheckOnly, path2, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path2] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path2, j, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path2) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers.map(([h, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (;paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length;i < len; i++) {
    for (let j = 0, len2 = handlerData[i].length;j < len2; j++) {
      const map = handlerData[i][j]?.[1];
      if (!map) {
        continue;
      }
      const keys = Object.keys(map);
      for (let k = 0, len3 = keys.length;k < len3; k++) {
        map[keys[k]] = paramReplacementMap[map[keys[k]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
function findMiddleware(middleware, path2) {
  if (!middleware) {
    return;
  }
  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path2)) {
      return [...middleware[k]];
    }
  }
  return;
}
var RegExpRouter = class {
  name = "RegExpRouter";
  #middleware;
  #routes;
  constructor() {
    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path2, handler) {
    const middleware = this.#middleware;
    const routes = this.#routes;
    if (!middleware || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {
          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];
        });
      });
    }
    if (path2 === "/*") {
      path2 = "*";
    }
    const paramCount = (path2.match(/\/:/g) || []).length;
    if (/\*$/.test(path2)) {
      const re = buildWildcardRegExp(path2);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m) => {
          middleware[m][path2] ||= findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || [];
        });
      } else {
        middleware[method][path2] ||= findMiddleware(middleware[method], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || [];
      }
      Object.keys(middleware).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(middleware[m]).forEach((p) => {
            re.test(p) && middleware[m][p].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(routes[m]).forEach((p) => re.test(p) && routes[m][p].push([handler, paramCount]));
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path2) || [path2];
    for (let i = 0, len = paths.length;i < len; i++) {
      const path22 = paths[i];
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          routes[m][path22] ||= [
            ...findMiddleware(middleware[m], path22) || findMiddleware(middleware[METHOD_NAME_ALL], path22) || []
          ];
          routes[m][path22].push([handler, paramCount - len + i + 1]);
        }
      });
    }
  }
  match = match;
  buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {
      matchers[method] ||= this.#buildMatcher(method);
    });
    this.#middleware = this.#routes = undefined;
    clearWildcardRegExpCache();
    return matchers;
  }
  #buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.#middleware, this.#routes].forEach((r) => {
      const ownRoute = r[method] ? Object.keys(r[method]).map((path2) => [path2, r[method][path2]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(...Object.keys(r[METHOD_NAME_ALL]).map((path2) => [path2, r[METHOD_NAME_ALL][path2]]));
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// node_modules/hono/dist/router/reg-exp-router/prepared-router.js
var PreparedRegExpRouter = class {
  name = "PreparedRegExpRouter";
  #matchers;
  #relocateMap;
  constructor(matchers, relocateMap) {
    this.#matchers = matchers;
    this.#relocateMap = relocateMap;
  }
  #addWildcard(method, handlerData) {
    const matcher = this.#matchers[method];
    matcher[1].forEach((list) => list && list.push(handlerData));
    Object.values(matcher[2]).forEach((list) => list[0].push(handlerData));
  }
  #addPath(method, path2, handler, indexes, map) {
    const matcher = this.#matchers[method];
    if (!map) {
      matcher[2][path2][0].push([handler, {}]);
    } else {
      indexes.forEach((index) => {
        if (typeof index === "number") {
          matcher[1][index].push([handler, map]);
        } else {
          matcher[2][index || path2][0].push([handler, map]);
        }
      });
    }
  }
  add(method, path2, handler) {
    if (!this.#matchers[method]) {
      const all = this.#matchers[METHOD_NAME_ALL];
      const staticMap = {};
      for (const key in all[2]) {
        staticMap[key] = [all[2][key][0].slice(), emptyParam];
      }
      this.#matchers[method] = [
        all[0],
        all[1].map((list) => Array.isArray(list) ? list.slice() : 0),
        staticMap
      ];
    }
    if (path2 === "/*" || path2 === "*") {
      const handlerData = [handler, {}];
      if (method === METHOD_NAME_ALL) {
        for (const m in this.#matchers) {
          this.#addWildcard(m, handlerData);
        }
      } else {
        this.#addWildcard(method, handlerData);
      }
      return;
    }
    const data = this.#relocateMap[path2];
    if (!data) {
      throw new Error(`Path ${path2} is not registered`);
    }
    for (const [indexes, map] of data) {
      if (method === METHOD_NAME_ALL) {
        for (const m in this.#matchers) {
          this.#addPath(m, path2, handler, indexes, map);
        }
      } else {
        this.#addPath(method, path2, handler, indexes, map);
      }
    }
  }
  buildAllMatchers() {
    return this.#matchers;
  }
  match = match;
};

// node_modules/hono/dist/router/smart-router/router.js
var SmartRouter = class {
  name = "SmartRouter";
  #routers = [];
  #routes = [];
  constructor(init) {
    this.#routers = init.routers;
  }
  add(method, path2, handler) {
    if (!this.#routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.#routes.push([method, path2, handler]);
  }
  match(method, path2) {
    if (!this.#routes) {
      throw new Error("Fatal error");
    }
    const routers = this.#routers;
    const routes = this.#routes;
    const len = routers.length;
    let i = 0;
    let res;
    for (;i < len; i++) {
      const router = routers[i];
      try {
        for (let i2 = 0, len2 = routes.length;i2 < len2; i2++) {
          router.add(...routes[i2]);
        }
        res = router.match(method, path2);
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue;
        }
        throw e;
      }
      this.match = router.match.bind(router);
      this.#routers = [router];
      this.#routes = undefined;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.#routes || this.#routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.#routers[0];
  }
};

// node_modules/hono/dist/router/trie-router/node.js
var emptyParams = /* @__PURE__ */ Object.create(null);
var Node2 = class {
  #methods;
  #children;
  #patterns;
  #order = 0;
  #params = emptyParams;
  constructor(method, handler, children) {
    this.#children = children || /* @__PURE__ */ Object.create(null);
    this.#methods = [];
    if (method && handler) {
      const m = /* @__PURE__ */ Object.create(null);
      m[method] = { handler, possibleKeys: [], score: 0 };
      this.#methods = [m];
    }
    this.#patterns = [];
  }
  insert(method, path2, handler) {
    this.#order = ++this.#order;
    let curNode = this;
    const parts = splitRoutingPath(path2);
    const possibleKeys = [];
    for (let i = 0, len = parts.length;i < len; i++) {
      const p = parts[i];
      const nextP = parts[i + 1];
      const pattern = getPattern(p, nextP);
      const key = Array.isArray(pattern) ? pattern[0] : p;
      if (key in curNode.#children) {
        curNode = curNode.#children[key];
        if (pattern) {
          possibleKeys.push(pattern[1]);
        }
        continue;
      }
      curNode.#children[key] = new Node2;
      if (pattern) {
        curNode.#patterns.push(pattern);
        possibleKeys.push(pattern[1]);
      }
      curNode = curNode.#children[key];
    }
    curNode.#methods.push({
      [method]: {
        handler,
        possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),
        score: this.#order
      }
    });
    return curNode;
  }
  #getHandlerSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i = 0, len = node.#methods.length;i < len; i++) {
      const m = node.#methods[i];
      const handlerSet = m[method] || m[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== undefined) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSets.push(handlerSet);
        if (nodeParams !== emptyParams || params && params !== emptyParams) {
          for (let i2 = 0, len2 = handlerSet.possibleKeys.length;i2 < len2; i2++) {
            const key = handlerSet.possibleKeys[i2];
            const processed = processedSet[handlerSet.score];
            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];
            processedSet[handlerSet.score] = true;
          }
        }
      }
    }
    return handlerSets;
  }
  search(method, path2) {
    const handlerSets = [];
    this.#params = emptyParams;
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path2);
    const curNodesQueue = [];
    for (let i = 0, len = parts.length;i < len; i++) {
      const part = parts[i];
      const isLast = i === len - 1;
      const tempNodes = [];
      for (let j = 0, len2 = curNodes.length;j < len2; j++) {
        const node = curNodes[j];
        const nextNode = node.#children[part];
        if (nextNode) {
          nextNode.#params = node.#params;
          if (isLast) {
            if (nextNode.#children["*"]) {
              handlerSets.push(...this.#getHandlerSets(nextNode.#children["*"], method, node.#params));
            }
            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k = 0, len3 = node.#patterns.length;k < len3; k++) {
          const pattern = node.#patterns[k];
          const params = node.#params === emptyParams ? {} : { ...node.#params };
          if (pattern === "*") {
            const astNode = node.#children["*"];
            if (astNode) {
              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
              astNode.#params = params;
              tempNodes.push(astNode);
            }
            continue;
          }
          const [key, name, matcher] = pattern;
          if (!part && !(matcher instanceof RegExp)) {
            continue;
          }
          const child = node.#children[key];
          const restPathString = parts.slice(i).join("/");
          if (matcher instanceof RegExp) {
            const m = matcher.exec(restPathString);
            if (m) {
              params[name] = m[0];
              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
              if (Object.keys(child.#children).length) {
                child.#params = params;
                const componentCount = m[0].match(/\//)?.length ?? 0;
                const targetCurNodes = curNodesQueue[componentCount] ||= [];
                targetCurNodes.push(child);
              }
              continue;
            }
          }
          if (matcher === true || matcher.test(part)) {
            params[name] = part;
            if (isLast) {
              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
              if (child.#children["*"]) {
                handlerSets.push(...this.#getHandlerSets(child.#children["*"], method, params, node.#params));
              }
            } else {
              child.#params = params;
              tempNodes.push(child);
            }
          }
        }
      }
      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);
    }
    if (handlerSets.length > 1) {
      handlerSets.sort((a, b) => {
        return a.score - b.score;
      });
    }
    return [handlerSets.map(({ handler, params }) => [handler, params])];
  }
};

// node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  name = "TrieRouter";
  #node;
  constructor() {
    this.#node = new Node2;
  }
  add(method, path2, handler) {
    const results = checkOptionalParameter(path2);
    if (results) {
      for (let i = 0, len = results.length;i < len; i++) {
        this.#node.insert(method, results[i], handler);
      }
      return;
    }
    this.#node.insert(method, path2, handler);
  }
  match(method, path2) {
    return this.#node.search(method, path2);
  }
};

// node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter, new TrieRouter]
    });
  }
};

// node_modules/hono/dist/middleware/cors/index.js
var cors = (options) => {
  const defaults = {
    origin: "*",
    allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH"],
    allowHeaders: [],
    exposeHeaders: []
  };
  const opts = {
    ...defaults,
    ...options
  };
  const findAllowOrigin = ((optsOrigin) => {
    if (typeof optsOrigin === "string") {
      if (optsOrigin === "*") {
        return () => optsOrigin;
      } else {
        return (origin) => optsOrigin === origin ? origin : null;
      }
    } else if (typeof optsOrigin === "function") {
      return optsOrigin;
    } else {
      return (origin) => optsOrigin.includes(origin) ? origin : null;
    }
  })(opts.origin);
  const findAllowMethods = ((optsAllowMethods) => {
    if (typeof optsAllowMethods === "function") {
      return optsAllowMethods;
    } else if (Array.isArray(optsAllowMethods)) {
      return () => optsAllowMethods;
    } else {
      return () => [];
    }
  })(opts.allowMethods);
  return async function cors2(c, next) {
    function set(key, value) {
      c.res.headers.set(key, value);
    }
    const allowOrigin = await findAllowOrigin(c.req.header("origin") || "", c);
    if (allowOrigin) {
      set("Access-Control-Allow-Origin", allowOrigin);
    }
    if (opts.credentials) {
      set("Access-Control-Allow-Credentials", "true");
    }
    if (opts.exposeHeaders?.length) {
      set("Access-Control-Expose-Headers", opts.exposeHeaders.join(","));
    }
    if (c.req.method === "OPTIONS") {
      if (opts.origin !== "*") {
        set("Vary", "Origin");
      }
      if (opts.maxAge != null) {
        set("Access-Control-Max-Age", opts.maxAge.toString());
      }
      const allowMethods = await findAllowMethods(c.req.header("origin") || "", c);
      if (allowMethods.length) {
        set("Access-Control-Allow-Methods", allowMethods.join(","));
      }
      let headers = opts.allowHeaders;
      if (!headers?.length) {
        const requestHeaders = c.req.header("Access-Control-Request-Headers");
        if (requestHeaders) {
          headers = requestHeaders.split(/\s*,\s*/);
        }
      }
      if (headers?.length) {
        set("Access-Control-Allow-Headers", headers.join(","));
        c.res.headers.append("Vary", "Access-Control-Request-Headers");
      }
      c.res.headers.delete("Content-Length");
      c.res.headers.delete("Content-Type");
      return new Response(null, {
        headers: c.res.headers,
        status: 204,
        statusText: "No Content"
      });
    }
    await next();
    if (opts.origin !== "*") {
      c.header("Vary", "Origin", { append: true });
    }
  };
};

// node_modules/hono/dist/middleware/csrf/index.js
var secFetchSiteValues = ["same-origin", "same-site", "none", "cross-site"];
var isSecFetchSite = (value) => secFetchSiteValues.includes(value);
var isSafeMethodRe = /^(GET|HEAD)$/;
var isRequestedByFormElementRe = /^\b(application\/x-www-form-urlencoded|multipart\/form-data|text\/plain)\b/i;
var csrf = (options) => {
  const originHandler = ((optsOrigin) => {
    if (!optsOrigin) {
      return (origin, c) => origin === new URL(c.req.url).origin;
    } else if (typeof optsOrigin === "string") {
      return (origin) => origin === optsOrigin;
    } else if (typeof optsOrigin === "function") {
      return optsOrigin;
    } else {
      return (origin) => optsOrigin.includes(origin);
    }
  })(options?.origin);
  const isAllowedOrigin = (origin, c) => {
    if (origin === undefined) {
      return false;
    }
    return originHandler(origin, c);
  };
  const secFetchSiteHandler = ((optsSecFetchSite) => {
    if (!optsSecFetchSite) {
      return (secFetchSite) => secFetchSite === "same-origin";
    } else if (typeof optsSecFetchSite === "string") {
      return (secFetchSite) => secFetchSite === optsSecFetchSite;
    } else if (typeof optsSecFetchSite === "function") {
      return optsSecFetchSite;
    } else {
      return (secFetchSite) => optsSecFetchSite.includes(secFetchSite);
    }
  })(options?.secFetchSite);
  const isAllowedSecFetchSite = (secFetchSite, c) => {
    if (secFetchSite === undefined) {
      return false;
    }
    if (!isSecFetchSite(secFetchSite)) {
      return false;
    }
    return secFetchSiteHandler(secFetchSite, c);
  };
  return async function csrf2(c, next) {
    if (!isSafeMethodRe.test(c.req.method) && isRequestedByFormElementRe.test(c.req.header("content-type") || "text/plain") && !isAllowedSecFetchSite(c.req.header("sec-fetch-site"), c) && !isAllowedOrigin(c.req.header("origin"), c)) {
      const res = new Response("Forbidden", { status: 403 });
      throw new HTTPException(403, { res });
    }
    await next();
  };
};

// node_modules/hono/dist/utils/color.js
function getColorEnabled() {
  const { process: process2, Deno } = globalThis;
  const isNoColor = typeof Deno?.noColor === "boolean" ? Deno.noColor : process2 !== undefined ? "NO_COLOR" in process2?.env : false;
  return !isNoColor;
}
async function getColorEnabledAsync() {
  const { navigator } = globalThis;
  const cfWorkers = "cloudflare:workers";
  const isNoColor = navigator !== undefined && navigator.userAgent === "Cloudflare-Workers" ? await (async () => {
    try {
      return "NO_COLOR" in ((await import(cfWorkers)).env ?? {});
    } catch {
      return false;
    }
  })() : !getColorEnabled();
  return !isNoColor;
}

// node_modules/hono/dist/middleware/logger/index.js
var humanize = (times) => {
  const [delimiter, separator] = [",", "."];
  const orderTimes = times.map((v) => v.replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1" + delimiter));
  return orderTimes.join(separator);
};
var time = (start) => {
  const delta = Date.now() - start;
  return humanize([delta < 1000 ? delta + "ms" : Math.round(delta / 1000) + "s"]);
};
var colorStatus = async (status) => {
  const colorEnabled = await getColorEnabledAsync();
  if (colorEnabled) {
    switch (status / 100 | 0) {
      case 5:
        return `\x1B[31m${status}\x1B[0m`;
      case 4:
        return `\x1B[33m${status}\x1B[0m`;
      case 3:
        return `\x1B[36m${status}\x1B[0m`;
      case 2:
        return `\x1B[32m${status}\x1B[0m`;
    }
  }
  return `${status}`;
};
async function log(fn, prefix, method, path2, status = 0, elapsed) {
  const out = prefix === "<--" ? `${prefix} ${method} ${path2}` : `${prefix} ${method} ${path2} ${await colorStatus(status)} ${elapsed}`;
  fn(out);
}
var logger = (fn = console.log) => {
  return async function logger2(c, next) {
    const { method, url } = c.req;
    const path2 = url.slice(url.indexOf("/", 8));
    await log(fn, "<--", method, path2);
    const start = Date.now();
    await next();
    await log(fn, "-->", method, path2, c.res.status, time(start));
  };
};

// node_modules/hono/dist/middleware/secure-headers/secure-headers.js
var HEADERS_MAP = {
  crossOriginEmbedderPolicy: ["Cross-Origin-Embedder-Policy", "require-corp"],
  crossOriginResourcePolicy: ["Cross-Origin-Resource-Policy", "same-origin"],
  crossOriginOpenerPolicy: ["Cross-Origin-Opener-Policy", "same-origin"],
  originAgentCluster: ["Origin-Agent-Cluster", "?1"],
  referrerPolicy: ["Referrer-Policy", "no-referrer"],
  strictTransportSecurity: ["Strict-Transport-Security", "max-age=15552000; includeSubDomains"],
  xContentTypeOptions: ["X-Content-Type-Options", "nosniff"],
  xDnsPrefetchControl: ["X-DNS-Prefetch-Control", "off"],
  xDownloadOptions: ["X-Download-Options", "noopen"],
  xFrameOptions: ["X-Frame-Options", "SAMEORIGIN"],
  xPermittedCrossDomainPolicies: ["X-Permitted-Cross-Domain-Policies", "none"],
  xXssProtection: ["X-XSS-Protection", "0"]
};
var DEFAULT_OPTIONS = {
  crossOriginEmbedderPolicy: false,
  crossOriginResourcePolicy: true,
  crossOriginOpenerPolicy: true,
  originAgentCluster: true,
  referrerPolicy: true,
  strictTransportSecurity: true,
  xContentTypeOptions: true,
  xDnsPrefetchControl: true,
  xDownloadOptions: true,
  xFrameOptions: true,
  xPermittedCrossDomainPolicies: true,
  xXssProtection: true,
  removePoweredBy: true,
  permissionsPolicy: {}
};
var secureHeaders = (customOptions) => {
  const options = { ...DEFAULT_OPTIONS, ...customOptions };
  const headersToSet = getFilteredHeaders(options);
  const callbacks = [];
  if (options.contentSecurityPolicy) {
    const [callback, value] = getCSPDirectives(options.contentSecurityPolicy);
    if (callback) {
      callbacks.push(callback);
    }
    headersToSet.push(["Content-Security-Policy", value]);
  }
  if (options.contentSecurityPolicyReportOnly) {
    const [callback, value] = getCSPDirectives(options.contentSecurityPolicyReportOnly);
    if (callback) {
      callbacks.push(callback);
    }
    headersToSet.push(["Content-Security-Policy-Report-Only", value]);
  }
  if (options.permissionsPolicy && Object.keys(options.permissionsPolicy).length > 0) {
    headersToSet.push([
      "Permissions-Policy",
      getPermissionsPolicyDirectives(options.permissionsPolicy)
    ]);
  }
  if (options.reportingEndpoints) {
    headersToSet.push(["Reporting-Endpoints", getReportingEndpoints(options.reportingEndpoints)]);
  }
  if (options.reportTo) {
    headersToSet.push(["Report-To", getReportToOptions(options.reportTo)]);
  }
  return async function secureHeaders2(ctx, next) {
    const headersToSetForReq = callbacks.length === 0 ? headersToSet : callbacks.reduce((acc, cb) => cb(ctx, acc), headersToSet);
    await next();
    setHeaders(ctx, headersToSetForReq);
    if (options?.removePoweredBy) {
      ctx.res.headers.delete("X-Powered-By");
    }
  };
};
function getFilteredHeaders(options) {
  return Object.entries(HEADERS_MAP).filter(([key]) => options[key]).map(([key, defaultValue]) => {
    const overrideValue = options[key];
    return typeof overrideValue === "string" ? [defaultValue[0], overrideValue] : defaultValue;
  });
}
function getCSPDirectives(contentSecurityPolicy) {
  const callbacks = [];
  const resultValues = [];
  for (const [directive, value] of Object.entries(contentSecurityPolicy)) {
    const valueArray = Array.isArray(value) ? value : [value];
    valueArray.forEach((value2, i) => {
      if (typeof value2 === "function") {
        const index = i * 2 + 2 + resultValues.length;
        callbacks.push((ctx, values) => {
          values[index] = value2(ctx, directive);
        });
      }
    });
    resultValues.push(directive.replace(/[A-Z]+(?![a-z])|[A-Z]/g, (match2, offset) => offset ? "-" + match2.toLowerCase() : match2.toLowerCase()), ...valueArray.flatMap((value2) => [" ", value2]), "; ");
  }
  resultValues.pop();
  return callbacks.length === 0 ? [undefined, resultValues.join("")] : [
    (ctx, headersToSet) => headersToSet.map((values) => {
      if (values[0] === "Content-Security-Policy" || values[0] === "Content-Security-Policy-Report-Only") {
        const clone = values[1].slice();
        callbacks.forEach((cb) => {
          cb(ctx, clone);
        });
        return [values[0], clone.join("")];
      } else {
        return values;
      }
    }),
    resultValues
  ];
}
function getPermissionsPolicyDirectives(policy) {
  return Object.entries(policy).map(([directive, value]) => {
    const kebabDirective = camelToKebab(directive);
    if (typeof value === "boolean") {
      return `${kebabDirective}=${value ? "*" : "none"}`;
    }
    if (Array.isArray(value)) {
      if (value.length === 0) {
        return `${kebabDirective}=()`;
      }
      if (value.length === 1 && (value[0] === "*" || value[0] === "none")) {
        return `${kebabDirective}=${value[0]}`;
      }
      const allowlist = value.map((item) => ["self", "src"].includes(item) ? item : `"${item}"`);
      return `${kebabDirective}=(${allowlist.join(" ")})`;
    }
    return "";
  }).filter(Boolean).join(", ");
}
function camelToKebab(str) {
  return str.replace(/([a-z\d])([A-Z])/g, "$1-$2").toLowerCase();
}
function getReportingEndpoints(reportingEndpoints = []) {
  return reportingEndpoints.map((endpoint) => `${endpoint.name}="${endpoint.url}"`).join(", ");
}
function getReportToOptions(reportTo = []) {
  return reportTo.map((option) => JSON.stringify(option)).join(", ");
}
function setHeaders(ctx, headersToSet) {
  headersToSet.forEach(([header, value]) => {
    ctx.res.headers.set(header, value);
  });
}

// node_modules/hono/dist/utils/cookie.js
var algorithm = { name: "HMAC", hash: "SHA-256" };
var getCryptoKey = async (secret) => {
  const secretBuf = typeof secret === "string" ? new TextEncoder().encode(secret) : secret;
  return await crypto.subtle.importKey("raw", secretBuf, algorithm, false, ["sign", "verify"]);
};
var makeSignature = async (value, secret) => {
  const key = await getCryptoKey(secret);
  const signature = await crypto.subtle.sign(algorithm.name, key, new TextEncoder().encode(value));
  return btoa(String.fromCharCode(...new Uint8Array(signature)));
};
var verifySignature = async (base64Signature, value, secret) => {
  try {
    const signatureBinStr = atob(base64Signature);
    const signature = new Uint8Array(signatureBinStr.length);
    for (let i = 0, len = signatureBinStr.length;i < len; i++) {
      signature[i] = signatureBinStr.charCodeAt(i);
    }
    return await crypto.subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value));
  } catch {
    return false;
  }
};
var validCookieNameRegEx = /^[\w!#$%&'*.^`|~+-]+$/;
var validCookieValueRegEx = /^[ !#-:<-[\]-~]*$/;
var parse = (cookie, name) => {
  if (name && cookie.indexOf(name) === -1) {
    return {};
  }
  const pairs = cookie.trim().split(";");
  const parsedCookie = {};
  for (let pairStr of pairs) {
    pairStr = pairStr.trim();
    const valueStartPos = pairStr.indexOf("=");
    if (valueStartPos === -1) {
      continue;
    }
    const cookieName = pairStr.substring(0, valueStartPos).trim();
    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {
      continue;
    }
    let cookieValue = pairStr.substring(valueStartPos + 1).trim();
    if (cookieValue.startsWith('"') && cookieValue.endsWith('"')) {
      cookieValue = cookieValue.slice(1, -1);
    }
    if (validCookieValueRegEx.test(cookieValue)) {
      parsedCookie[cookieName] = cookieValue.indexOf("%") !== -1 ? tryDecode(cookieValue, decodeURIComponent_) : cookieValue;
      if (name) {
        break;
      }
    }
  }
  return parsedCookie;
};
var parseSigned = async (cookie, secret, name) => {
  const parsedCookie = {};
  const secretKey = await getCryptoKey(secret);
  for (const [key, value] of Object.entries(parse(cookie, name))) {
    const signatureStartPos = value.lastIndexOf(".");
    if (signatureStartPos < 1) {
      continue;
    }
    const signedValue = value.substring(0, signatureStartPos);
    const signature = value.substring(signatureStartPos + 1);
    if (signature.length !== 44 || !signature.endsWith("=")) {
      continue;
    }
    const isVerified = await verifySignature(signature, signedValue, secretKey);
    parsedCookie[key] = isVerified ? signedValue : false;
  }
  return parsedCookie;
};
var _serialize = (name, value, opt = {}) => {
  let cookie = `${name}=${value}`;
  if (name.startsWith("__Secure-") && !opt.secure) {
    throw new Error("__Secure- Cookie must have Secure attributes");
  }
  if (name.startsWith("__Host-")) {
    if (!opt.secure) {
      throw new Error("__Host- Cookie must have Secure attributes");
    }
    if (opt.path !== "/") {
      throw new Error('__Host- Cookie must have Path attributes with "/"');
    }
    if (opt.domain) {
      throw new Error("__Host- Cookie must not have Domain attributes");
    }
  }
  if (opt && typeof opt.maxAge === "number" && opt.maxAge >= 0) {
    if (opt.maxAge > 34560000) {
      throw new Error("Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.");
    }
    cookie += `; Max-Age=${opt.maxAge | 0}`;
  }
  if (opt.domain && opt.prefix !== "host") {
    cookie += `; Domain=${opt.domain}`;
  }
  if (opt.path) {
    cookie += `; Path=${opt.path}`;
  }
  if (opt.expires) {
    if (opt.expires.getTime() - Date.now() > 34560000000) {
      throw new Error("Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.");
    }
    cookie += `; Expires=${opt.expires.toUTCString()}`;
  }
  if (opt.httpOnly) {
    cookie += "; HttpOnly";
  }
  if (opt.secure) {
    cookie += "; Secure";
  }
  if (opt.sameSite) {
    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;
  }
  if (opt.priority) {
    cookie += `; Priority=${opt.priority.charAt(0).toUpperCase() + opt.priority.slice(1)}`;
  }
  if (opt.partitioned) {
    if (!opt.secure) {
      throw new Error("Partitioned Cookie must have Secure attributes");
    }
    cookie += "; Partitioned";
  }
  return cookie;
};
var serialize = (name, value, opt) => {
  value = encodeURIComponent(value);
  return _serialize(name, value, opt);
};
var serializeSigned = async (name, value, secret, opt = {}) => {
  const signature = await makeSignature(value, secret);
  value = `${value}.${signature}`;
  value = encodeURIComponent(value);
  return _serialize(name, value, opt);
};

// node_modules/hono/dist/helper/cookie/index.js
var getCookie = (c, key, prefix) => {
  const cookie = c.req.raw.headers.get("Cookie");
  if (typeof key === "string") {
    if (!cookie) {
      return;
    }
    let finalKey = key;
    if (prefix === "secure") {
      finalKey = "__Secure-" + key;
    } else if (prefix === "host") {
      finalKey = "__Host-" + key;
    }
    const obj2 = parse(cookie, finalKey);
    return obj2[finalKey];
  }
  if (!cookie) {
    return {};
  }
  const obj = parse(cookie);
  return obj;
};
var getSignedCookie = async (c, secret, key, prefix) => {
  const cookie = c.req.raw.headers.get("Cookie");
  if (typeof key === "string") {
    if (!cookie) {
      return;
    }
    let finalKey = key;
    if (prefix === "secure") {
      finalKey = "__Secure-" + key;
    } else if (prefix === "host") {
      finalKey = "__Host-" + key;
    }
    const obj2 = await parseSigned(cookie, secret, finalKey);
    return obj2[finalKey];
  }
  if (!cookie) {
    return {};
  }
  const obj = await parseSigned(cookie, secret);
  return obj;
};
var generateCookie = (name, value, opt) => {
  let cookie;
  if (opt?.prefix === "secure") {
    cookie = serialize("__Secure-" + name, value, { path: "/", ...opt, secure: true });
  } else if (opt?.prefix === "host") {
    cookie = serialize("__Host-" + name, value, {
      ...opt,
      path: "/",
      secure: true,
      domain: undefined
    });
  } else {
    cookie = serialize(name, value, { path: "/", ...opt });
  }
  return cookie;
};
var setCookie = (c, name, value, opt) => {
  const cookie = generateCookie(name, value, opt);
  c.header("Set-Cookie", cookie, { append: true });
};
var generateSignedCookie = async (name, value, secret, opt) => {
  let cookie;
  if (opt?.prefix === "secure") {
    cookie = await serializeSigned("__Secure-" + name, value, secret, {
      path: "/",
      ...opt,
      secure: true
    });
  } else if (opt?.prefix === "host") {
    cookie = await serializeSigned("__Host-" + name, value, secret, {
      ...opt,
      path: "/",
      secure: true,
      domain: undefined
    });
  } else {
    cookie = await serializeSigned(name, value, secret, { path: "/", ...opt });
  }
  return cookie;
};
var setSignedCookie = async (c, name, value, secret, opt) => {
  const cookie = await generateSignedCookie(name, value, secret, opt);
  c.header("set-cookie", cookie, { append: true });
};
var deleteCookie = (c, name, opt) => {
  const deletedCookie = getCookie(c, name, opt?.prefix);
  setCookie(c, name, "", { ...opt, maxAge: 0 });
  return deletedCookie;
};

// node_modules/hono/dist/helper/factory/index.js
var Factory = class {
  initApp;
  #defaultAppOptions;
  constructor(init) {
    this.initApp = init?.initApp;
    this.#defaultAppOptions = init?.defaultAppOptions;
  }
  createApp = (options) => {
    const app = new Hono2(options && this.#defaultAppOptions ? { ...this.#defaultAppOptions, ...options } : options ?? this.#defaultAppOptions);
    if (this.initApp) {
      this.initApp(app);
    }
    return app;
  };
  createMiddleware = (middleware) => middleware;
  createHandlers = (...handlers) => {
    return handlers.filter((handler) => handler !== undefined);
  };
};
var createMiddleware = (middleware) => middleware;

// server/routes/authHelper/_cookies.ts
import crypto2 from "crypto";

// node_modules/zod/v3/external.js
var exports_external = {};
__export(exports_external, {
  void: () => voidType,
  util: () => util,
  unknown: () => unknownType,
  union: () => unionType,
  undefined: () => undefinedType,
  tuple: () => tupleType,
  transformer: () => effectsType,
  symbol: () => symbolType,
  string: () => stringType,
  strictObject: () => strictObjectType,
  setErrorMap: () => setErrorMap,
  set: () => setType,
  record: () => recordType,
  quotelessJson: () => quotelessJson,
  promise: () => promiseType,
  preprocess: () => preprocessType,
  pipeline: () => pipelineType,
  ostring: () => ostring,
  optional: () => optionalType,
  onumber: () => onumber,
  oboolean: () => oboolean,
  objectUtil: () => objectUtil,
  object: () => objectType,
  number: () => numberType,
  nullable: () => nullableType,
  null: () => nullType,
  never: () => neverType,
  nativeEnum: () => nativeEnumType,
  nan: () => nanType,
  map: () => mapType,
  makeIssue: () => makeIssue,
  literal: () => literalType,
  lazy: () => lazyType,
  late: () => late,
  isValid: () => isValid,
  isDirty: () => isDirty,
  isAsync: () => isAsync,
  isAborted: () => isAborted,
  intersection: () => intersectionType,
  instanceof: () => instanceOfType,
  getParsedType: () => getParsedType,
  getErrorMap: () => getErrorMap,
  function: () => functionType,
  enum: () => enumType,
  effect: () => effectsType,
  discriminatedUnion: () => discriminatedUnionType,
  defaultErrorMap: () => en_default,
  datetimeRegex: () => datetimeRegex,
  date: () => dateType,
  custom: () => custom,
  coerce: () => coerce,
  boolean: () => booleanType,
  bigint: () => bigIntType,
  array: () => arrayType,
  any: () => anyType,
  addIssueToContext: () => addIssueToContext,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransformer: () => ZodEffects,
  ZodSymbol: () => ZodSymbol,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodSchema: () => ZodType,
  ZodRecord: () => ZodRecord,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPipeline: () => ZodPipeline,
  ZodParsedType: () => ZodParsedType,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNever: () => ZodNever,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEffects: () => ZodEffects,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCatch: () => ZodCatch,
  ZodBranded: () => ZodBranded,
  ZodBoolean: () => ZodBoolean,
  ZodBigInt: () => ZodBigInt,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  Schema: () => ZodType,
  ParseStatus: () => ParseStatus,
  OK: () => OK,
  NEVER: () => NEVER,
  INVALID: () => INVALID,
  EMPTY_PATH: () => EMPTY_PATH,
  DIRTY: () => DIRTY,
  BRAND: () => BRAND
});

// node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {};
  function assertIs(_arg) {}
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};

// node_modules/zod/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var en_default = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
// node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === en_default ? undefined : en_default
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
class ParseInputLazyPath {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {} else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}

class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
// server/routes/authHelper/_cookies.ts
var SESSION_KEY = "auth_token";
var SET_USER_SESSION = "user_session_id";
var sessionStore = new Map;
var userAuthSchema = exports_external.object({
  username: exports_external.string().regex(/^[a-zA-Z0-9\s]*$/, "The string should not contain special characters").optional(),
  email: exports_external.string().email("Invalid email address")
});
var setSecureCookie = async (c, name, value) => {
  await setSignedCookie(c, name, JSON.stringify(value), Bun.env.SECRET_KEY, {
    httpOnly: true,
    maxAge: 15,
    sameSite: !isDevMode ? "Strict" : "Lax",
    secure: isProduction,
    ...isProduction ? { domain: Bun.env.DOMAIN_NAME } : {}
  });
};
var getSecureCookie = async (c, name) => {
  const cookie = await getSignedCookie(c, Bun.env.SECRET_KEY, name);
  return cookie && typeof cookie === "string" ? JSON.parse(cookie) : null;
};
var clearCookie = (c, name) => {
  deleteCookie(c, name);
};
var createAuthSession = async (c, user) => {
  deleteOldUserSession(user.userEmail);
  const sessionId = generateSid();
  sessionStore.set(sessionId, user);
  await setSignedCookie(c, SESSION_KEY, sessionId, Bun.env.SECRET_KEY, {
    httpOnly: true,
    path: "/",
    maxAge: 24 * 60 * 60,
    sameSite: !isDevMode ? "Strict" : "Lax",
    secure: isProduction,
    ...isProduction ? { domain: Bun.env.DOMAIN_NAME } : {}
  });
};
var generateSid = () => crypto2.randomBytes(32).toString("hex");
var deleteOldUserSession = (userEmail) => {
  sessionStore.forEach((userValue, sessionId) => {
    if (userValue.userEmail === userEmail)
      sessionStore.delete(sessionId);
  });
};

// server/middleware/validateAuth.ts
var getUserBySession = (c) => {
  const sessionId = c.get(SET_USER_SESSION);
  if (!sessionId)
    return {};
  return sessionStore.get(sessionId);
};
var logUserInDB = (isLoggedIn = false) => createMiddleware(async (c, next) => {
  try {
    const emailFromQuery = c.req.query("email");
    const info = getConnInfo(c);
    const uAgent = c.req.header("user-agent");
    let userLog = { user_agent: uAgent, ip_address: info.remote.address, email: emailFromQuery };
    if (isLoggedIn) {
      userLog = { ...userLog, ...{ last_logged_in: "NOW()" } };
    }
    await sql`INSERT INTO "multi_schema"."UserLog" ${sql(userLog)}`.catch((e) => console.log("Failed to Log User on Login", e));
    return await next();
  } catch (error) {
    console.log("middleware/validate - logUserInDB error");
    return c.json({ error: "An error occurs while user is trying to sign in" }, 500);
  }
});
var isAuthenticate = createMiddleware(async (c, next) => {
  const sessionId = await getSignedCookie(c, Bun.env.SECRET_KEY, SESSION_KEY);
  if (sessionId && sessionStore.has(sessionId)) {
    c.set(SET_USER_SESSION, sessionId);
    return await next();
  }
  return c.json({ error: "Warning: Unauthorized Access" }, 401);
});
var isAdmin = createMiddleware(async (c, next) => {
  const userInfo = getUserBySession(c);
  if (userInfo && userInfo.roleType === "admin")
    return await next();
  return c.json({ error: "Warning:  Unauthorized Access Attempt \u2013 Permission Denied" }, 403);
});

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoBase64URL.js
var exports_isoBase64URL = {};
__export(exports_isoBase64URL, {
  trimPadding: () => trimPadding,
  toUTF8String: () => toUTF8String,
  toBuffer: () => toBuffer,
  toBase64: () => toBase64,
  isBase64URL: () => isBase64URL,
  isBase64: () => isBase64,
  fromUTF8String: () => fromUTF8String,
  fromBuffer: () => fromBuffer
});

// node_modules/@hexagon/base64/src/base64.js
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var charsUrl = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
var genLookup = (target) => {
  const lookupTemp = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
  const len = chars.length;
  for (let i = 0;i < len; i++) {
    lookupTemp[target.charCodeAt(i)] = i;
  }
  return lookupTemp;
};
var lookup = genLookup(chars);
var lookupUrl = genLookup(charsUrl);
var base64UrlPattern = /^[-A-Za-z0-9\-_]*$/;
var base64Pattern = /^[-A-Za-z0-9+/]*={0,3}$/;
var base64 = {};
base64.toArrayBuffer = (data, urlMode) => {
  const len = data.length;
  let bufferLength = data.length * 0.75, i, p = 0, encoded1, encoded2, encoded3, encoded4;
  if (data[data.length - 1] === "=") {
    bufferLength--;
    if (data[data.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer), target = urlMode ? lookupUrl : lookup;
  for (i = 0;i < len; i += 4) {
    encoded1 = target[data.charCodeAt(i)];
    encoded2 = target[data.charCodeAt(i + 1)];
    encoded3 = target[data.charCodeAt(i + 2)];
    encoded4 = target[data.charCodeAt(i + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
base64.fromArrayBuffer = (arrBuf, urlMode) => {
  const bytes = new Uint8Array(arrBuf);
  let i, result = "";
  const len = bytes.length, target = urlMode ? charsUrl : chars;
  for (i = 0;i < len; i += 3) {
    result += target[bytes[i] >> 2];
    result += target[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
    result += target[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
    result += target[bytes[i + 2] & 63];
  }
  const remainder = len % 3;
  if (remainder === 2) {
    result = result.substring(0, result.length - 1) + (urlMode ? "" : "=");
  } else if (remainder === 1) {
    result = result.substring(0, result.length - 2) + (urlMode ? "" : "==");
  }
  return result;
};
base64.toString = (str, urlMode) => {
  return new TextDecoder().decode(base64.toArrayBuffer(str, urlMode));
};
base64.fromString = (str, urlMode) => {
  return base64.fromArrayBuffer(new TextEncoder().encode(str), urlMode);
};
base64.validate = (encoded, urlMode) => {
  if (!(typeof encoded === "string" || encoded instanceof String)) {
    return false;
  }
  try {
    return urlMode ? base64UrlPattern.test(encoded) : base64Pattern.test(encoded);
  } catch (_e) {
    return false;
  }
};
base64.base64 = base64;
var base64_default = base64;

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoBase64URL.js
function toBuffer(base64urlString, from = "base64url") {
  const _buffer = base64_default.toArrayBuffer(base64urlString, from === "base64url");
  return new Uint8Array(_buffer);
}
function fromBuffer(buffer, to = "base64url") {
  const _normalized = new Uint8Array(buffer);
  return base64_default.fromArrayBuffer(_normalized.buffer, to === "base64url");
}
function toBase64(base64urlString) {
  const fromBase64Url = base64_default.toArrayBuffer(base64urlString, true);
  const toBase642 = base64_default.fromArrayBuffer(fromBase64Url);
  return toBase642;
}
function fromUTF8String(utf8String) {
  return base64_default.fromString(utf8String, true);
}
function toUTF8String(base64urlString) {
  return base64_default.toString(base64urlString, true);
}
function isBase64(input) {
  return base64_default.validate(input, false);
}
function isBase64URL(input) {
  input = trimPadding(input);
  return base64_default.validate(input, true);
}
function trimPadding(input) {
  return input.replace(/=/g, "");
}
// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCBOR.js
var exports_isoCBOR = {};
__export(exports_isoCBOR, {
  encode: () => encode,
  decodeFirst: () => decodeFirst
});

// node_modules/@levischuck/tiny-cbor/esm/cbor/cbor_internal.js
function decodeLength(data, argument, index) {
  if (argument < 24) {
    return [argument, 1];
  }
  const remainingDataLength = data.byteLength - index - 1;
  const view = new DataView(data.buffer, index + 1);
  let output;
  let bytes = 0;
  switch (argument) {
    case 24: {
      if (remainingDataLength > 0) {
        output = view.getUint8(0);
        bytes = 2;
      }
      break;
    }
    case 25: {
      if (remainingDataLength > 1) {
        output = view.getUint16(0, false);
        bytes = 3;
      }
      break;
    }
    case 26: {
      if (remainingDataLength > 3) {
        output = view.getUint32(0, false);
        bytes = 5;
      }
      break;
    }
    case 27: {
      if (remainingDataLength > 7) {
        const bigOutput = view.getBigUint64(0, false);
        if (bigOutput >= 24n && bigOutput <= Number.MAX_SAFE_INTEGER) {
          return [Number(bigOutput), 9];
        }
      }
      break;
    }
  }
  if (output && output >= 24) {
    return [output, bytes];
  }
  throw new Error("Length not supported or not well formed");
}
var MAJOR_TYPE_UNSIGNED_INTEGER = 0;
var MAJOR_TYPE_NEGATIVE_INTEGER = 1;
var MAJOR_TYPE_BYTE_STRING = 2;
var MAJOR_TYPE_TEXT_STRING = 3;
var MAJOR_TYPE_ARRAY = 4;
var MAJOR_TYPE_MAP = 5;
var MAJOR_TYPE_TAG = 6;
var MAJOR_TYPE_SIMPLE_OR_FLOAT = 7;
function encodeLength(major, argument) {
  const majorEncoded = major << 5;
  if (argument < 0) {
    throw new Error("CBOR Data Item argument must not be negative");
  }
  let bigintArgument;
  if (typeof argument == "number") {
    if (!Number.isInteger(argument)) {
      throw new Error("CBOR Data Item argument must be an integer");
    }
    bigintArgument = BigInt(argument);
  } else {
    bigintArgument = argument;
  }
  if (major == MAJOR_TYPE_NEGATIVE_INTEGER) {
    if (bigintArgument == 0n) {
      throw new Error("CBOR Data Item argument cannot be zero when negative");
    }
    bigintArgument = bigintArgument - 1n;
  }
  if (bigintArgument > 18446744073709551615n) {
    throw new Error("CBOR number out of range");
  }
  const buffer = new Uint8Array(8);
  const view = new DataView(buffer.buffer);
  view.setBigUint64(0, bigintArgument, false);
  if (bigintArgument <= 23) {
    return [majorEncoded | buffer[7]];
  } else if (bigintArgument <= 255) {
    return [majorEncoded | 24, buffer[7]];
  } else if (bigintArgument <= 65535) {
    return [majorEncoded | 25, ...buffer.slice(6)];
  } else if (bigintArgument <= 4294967295) {
    return [
      majorEncoded | 26,
      ...buffer.slice(4)
    ];
  } else {
    return [
      majorEncoded | 27,
      ...buffer
    ];
  }
}

// node_modules/@levischuck/tiny-cbor/esm/cbor/cbor.js
class CBORTag {
  constructor(tag, value) {
    Object.defineProperty(this, "tagId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "tagValue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.tagId = tag;
    this.tagValue = value;
  }
  get tag() {
    return this.tagId;
  }
  get value() {
    return this.tagValue;
  }
}
function decodeUnsignedInteger(data, argument, index) {
  return decodeLength(data, argument, index);
}
function decodeNegativeInteger(data, argument, index) {
  const [value, length] = decodeUnsignedInteger(data, argument, index);
  return [-value - 1, length];
}
function decodeByteString(data, argument, index) {
  const [lengthValue, lengthConsumed] = decodeLength(data, argument, index);
  const dataStartIndex = index + lengthConsumed;
  return [
    new Uint8Array(data.buffer.slice(dataStartIndex, dataStartIndex + lengthValue)),
    lengthConsumed + lengthValue
  ];
}
var TEXT_DECODER = new TextDecoder;
function decodeString(data, argument, index) {
  const [value, length] = decodeByteString(data, argument, index);
  return [TEXT_DECODER.decode(value), length];
}
function decodeArray(data, argument, index) {
  if (argument === 0) {
    return [[], 1];
  }
  const [length, lengthConsumed] = decodeLength(data, argument, index);
  let consumedLength = lengthConsumed;
  const value = [];
  for (let i = 0;i < length; i++) {
    const remainingDataLength = data.byteLength - index - consumedLength;
    if (remainingDataLength <= 0) {
      throw new Error("array is not supported or well formed");
    }
    const [decodedValue, consumed] = decodeNext(data, index + consumedLength);
    value.push(decodedValue);
    consumedLength += consumed;
  }
  return [value, consumedLength];
}
var MAP_ERROR = "Map is not supported or well formed";
function decodeMap(data, argument, index) {
  if (argument === 0) {
    return [new Map, 1];
  }
  const [length, lengthConsumed] = decodeLength(data, argument, index);
  let consumedLength = lengthConsumed;
  const result = new Map;
  for (let i = 0;i < length; i++) {
    let remainingDataLength = data.byteLength - index - consumedLength;
    if (remainingDataLength <= 0) {
      throw new Error(MAP_ERROR);
    }
    const [key, keyConsumed] = decodeNext(data, index + consumedLength);
    consumedLength += keyConsumed;
    remainingDataLength -= keyConsumed;
    if (remainingDataLength <= 0) {
      throw new Error(MAP_ERROR);
    }
    if (typeof key !== "string" && typeof key !== "number") {
      throw new Error(MAP_ERROR);
    }
    if (result.has(key)) {
      throw new Error(MAP_ERROR);
    }
    const [value, valueConsumed] = decodeNext(data, index + consumedLength);
    consumedLength += valueConsumed;
    result.set(key, value);
  }
  return [result, consumedLength];
}
function decodeFloat16(data, index) {
  if (index + 3 > data.byteLength) {
    throw new Error("CBOR stream ended before end of Float 16");
  }
  const result = data.getUint16(index + 1, false);
  if (result == 31744) {
    return [Infinity, 3];
  } else if (result == 32256) {
    return [NaN, 3];
  } else if (result == 64512) {
    return [-Infinity, 3];
  }
  throw new Error("Float16 data is unsupported");
}
function decodeFloat32(data, index) {
  if (index + 5 > data.byteLength) {
    throw new Error("CBOR stream ended before end of Float 32");
  }
  const result = data.getFloat32(index + 1, false);
  return [result, 5];
}
function decodeFloat64(data, index) {
  if (index + 9 > data.byteLength) {
    throw new Error("CBOR stream ended before end of Float 64");
  }
  const result = data.getFloat64(index + 1, false);
  return [result, 9];
}
function decodeTag(data, argument, index) {
  const [tag, tagBytes] = decodeLength(data, argument, index);
  const [value, valueBytes] = decodeNext(data, index + tagBytes);
  return [new CBORTag(tag, value), tagBytes + valueBytes];
}
function decodeNext(data, index) {
  if (index >= data.byteLength) {
    throw new Error("CBOR stream ended before tag value");
  }
  const byte = data.getUint8(index);
  const majorType = byte >> 5;
  const argument = byte & 31;
  switch (majorType) {
    case MAJOR_TYPE_UNSIGNED_INTEGER: {
      return decodeUnsignedInteger(data, argument, index);
    }
    case MAJOR_TYPE_NEGATIVE_INTEGER: {
      return decodeNegativeInteger(data, argument, index);
    }
    case MAJOR_TYPE_BYTE_STRING: {
      return decodeByteString(data, argument, index);
    }
    case MAJOR_TYPE_TEXT_STRING: {
      return decodeString(data, argument, index);
    }
    case MAJOR_TYPE_ARRAY: {
      return decodeArray(data, argument, index);
    }
    case MAJOR_TYPE_MAP: {
      return decodeMap(data, argument, index);
    }
    case MAJOR_TYPE_TAG: {
      return decodeTag(data, argument, index);
    }
    case MAJOR_TYPE_SIMPLE_OR_FLOAT: {
      switch (argument) {
        case 20:
          return [false, 1];
        case 21:
          return [true, 1];
        case 22:
          return [null, 1];
        case 23:
          return [undefined, 1];
        case 25:
          return decodeFloat16(data, index);
        case 26:
          return decodeFloat32(data, index);
        case 27:
          return decodeFloat64(data, index);
      }
    }
  }
  throw new Error(`Unsupported or not well formed at ${index}`);
}
function encodeSimple(data) {
  if (data === true) {
    return 245;
  } else if (data === false) {
    return 244;
  } else if (data === null) {
    return 246;
  }
  return 247;
}
function encodeFloat(data) {
  if (Math.fround(data) == data || !Number.isFinite(data) || Number.isNaN(data)) {
    const output = new Uint8Array(5);
    output[0] = 250;
    const view = new DataView(output.buffer);
    view.setFloat32(1, data, false);
    return output;
  } else {
    const output = new Uint8Array(9);
    output[0] = 251;
    const view = new DataView(output.buffer);
    view.setFloat64(1, data, false);
    return output;
  }
}
function encodeNumber(data) {
  if (typeof data == "number") {
    if (Number.isSafeInteger(data)) {
      if (data < 0) {
        return encodeLength(MAJOR_TYPE_NEGATIVE_INTEGER, Math.abs(data));
      } else {
        return encodeLength(MAJOR_TYPE_UNSIGNED_INTEGER, data);
      }
    }
    return [encodeFloat(data)];
  } else {
    if (data < 0n) {
      return encodeLength(MAJOR_TYPE_NEGATIVE_INTEGER, data * -1n);
    } else {
      return encodeLength(MAJOR_TYPE_UNSIGNED_INTEGER, data);
    }
  }
}
var ENCODER = new TextEncoder;
function encodeString(data, output) {
  output.push(...encodeLength(MAJOR_TYPE_TEXT_STRING, data.length));
  output.push(ENCODER.encode(data));
}
function encodeBytes(data, output) {
  output.push(...encodeLength(MAJOR_TYPE_BYTE_STRING, data.length));
  output.push(data);
}
function encodeArray(data, output) {
  output.push(...encodeLength(MAJOR_TYPE_ARRAY, data.length));
  for (const element of data) {
    encodePartialCBOR(element, output);
  }
}
function encodeMap(data, output) {
  output.push(new Uint8Array(encodeLength(MAJOR_TYPE_MAP, data.size)));
  for (const [key, value] of data.entries()) {
    encodePartialCBOR(key, output);
    encodePartialCBOR(value, output);
  }
}
function encodeTag(tag, output) {
  output.push(...encodeLength(MAJOR_TYPE_TAG, tag.tag));
  encodePartialCBOR(tag.value, output);
}
function encodePartialCBOR(data, output) {
  if (typeof data == "boolean" || data === null || data == undefined) {
    output.push(encodeSimple(data));
    return;
  }
  if (typeof data == "number" || typeof data == "bigint") {
    output.push(...encodeNumber(data));
    return;
  }
  if (typeof data == "string") {
    encodeString(data, output);
    return;
  }
  if (data instanceof Uint8Array) {
    encodeBytes(data, output);
    return;
  }
  if (Array.isArray(data)) {
    encodeArray(data, output);
    return;
  }
  if (data instanceof Map) {
    encodeMap(data, output);
    return;
  }
  if (data instanceof CBORTag) {
    encodeTag(data, output);
    return;
  }
  throw new Error("Not implemented");
}
function decodePartialCBOR(data, index) {
  if (data.byteLength === 0 || data.byteLength <= index || index < 0) {
    throw new Error("No data");
  }
  if (data instanceof Uint8Array) {
    return decodeNext(new DataView(data.buffer), index);
  } else if (data instanceof ArrayBuffer) {
    return decodeNext(new DataView(data), index);
  }
  return decodeNext(data, index);
}
function encodeCBOR(data) {
  const results = [];
  encodePartialCBOR(data, results);
  let length = 0;
  for (const result of results) {
    if (typeof result == "number") {
      length += 1;
    } else {
      length += result.length;
    }
  }
  const output = new Uint8Array(length);
  let index = 0;
  for (const result of results) {
    if (typeof result == "number") {
      output[index] = result;
      index += 1;
    } else {
      output.set(result, index);
      index += result.length;
    }
  }
  return output;
}
// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCBOR.js
function decodeFirst(input) {
  const _input = new Uint8Array(input);
  const decoded = decodePartialCBOR(_input, 0);
  const [first] = decoded;
  return first;
}
function encode(input) {
  return encodeCBOR(input);
}
// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/index.js
var exports_isoCrypto = {};
__export(exports_isoCrypto, {
  verify: () => verify,
  getRandomValues: () => getRandomValues,
  digest: () => digest
});

// node_modules/@simplewebauthn/server/esm/helpers/cose.js
function isCOSEPublicKeyOKP(cosePublicKey) {
  const kty = cosePublicKey.get(COSEKEYS.kty);
  return isCOSEKty(kty) && kty === COSEKTY.OKP;
}
function isCOSEPublicKeyEC2(cosePublicKey) {
  const kty = cosePublicKey.get(COSEKEYS.kty);
  return isCOSEKty(kty) && kty === COSEKTY.EC2;
}
function isCOSEPublicKeyRSA(cosePublicKey) {
  const kty = cosePublicKey.get(COSEKEYS.kty);
  return isCOSEKty(kty) && kty === COSEKTY.RSA;
}
var COSEKEYS;
(function(COSEKEYS2) {
  COSEKEYS2[COSEKEYS2["kty"] = 1] = "kty";
  COSEKEYS2[COSEKEYS2["alg"] = 3] = "alg";
  COSEKEYS2[COSEKEYS2["crv"] = -1] = "crv";
  COSEKEYS2[COSEKEYS2["x"] = -2] = "x";
  COSEKEYS2[COSEKEYS2["y"] = -3] = "y";
  COSEKEYS2[COSEKEYS2["n"] = -1] = "n";
  COSEKEYS2[COSEKEYS2["e"] = -2] = "e";
})(COSEKEYS || (COSEKEYS = {}));
var COSEKTY;
(function(COSEKTY2) {
  COSEKTY2[COSEKTY2["OKP"] = 1] = "OKP";
  COSEKTY2[COSEKTY2["EC2"] = 2] = "EC2";
  COSEKTY2[COSEKTY2["RSA"] = 3] = "RSA";
})(COSEKTY || (COSEKTY = {}));
function isCOSEKty(kty) {
  return Object.values(COSEKTY).indexOf(kty) >= 0;
}
var COSECRV;
(function(COSECRV2) {
  COSECRV2[COSECRV2["P256"] = 1] = "P256";
  COSECRV2[COSECRV2["P384"] = 2] = "P384";
  COSECRV2[COSECRV2["P521"] = 3] = "P521";
  COSECRV2[COSECRV2["ED25519"] = 6] = "ED25519";
  COSECRV2[COSECRV2["SECP256K1"] = 8] = "SECP256K1";
})(COSECRV || (COSECRV = {}));
function isCOSECrv(crv) {
  return Object.values(COSECRV).indexOf(crv) >= 0;
}
var COSEALG;
(function(COSEALG2) {
  COSEALG2[COSEALG2["ES256"] = -7] = "ES256";
  COSEALG2[COSEALG2["EdDSA"] = -8] = "EdDSA";
  COSEALG2[COSEALG2["ES384"] = -35] = "ES384";
  COSEALG2[COSEALG2["ES512"] = -36] = "ES512";
  COSEALG2[COSEALG2["PS256"] = -37] = "PS256";
  COSEALG2[COSEALG2["PS384"] = -38] = "PS384";
  COSEALG2[COSEALG2["PS512"] = -39] = "PS512";
  COSEALG2[COSEALG2["ES256K"] = -47] = "ES256K";
  COSEALG2[COSEALG2["RS256"] = -257] = "RS256";
  COSEALG2[COSEALG2["RS384"] = -258] = "RS384";
  COSEALG2[COSEALG2["RS512"] = -259] = "RS512";
  COSEALG2[COSEALG2["RS1"] = -65535] = "RS1";
})(COSEALG || (COSEALG = {}));
function isCOSEAlg(alg) {
  return Object.values(COSEALG).indexOf(alg) >= 0;
}

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/mapCoseAlgToWebCryptoAlg.js
function mapCoseAlgToWebCryptoAlg(alg) {
  if ([COSEALG.RS1].indexOf(alg) >= 0) {
    return "SHA-1";
  } else if ([COSEALG.ES256, COSEALG.PS256, COSEALG.RS256].indexOf(alg) >= 0) {
    return "SHA-256";
  } else if ([COSEALG.ES384, COSEALG.PS384, COSEALG.RS384].indexOf(alg) >= 0) {
    return "SHA-384";
  } else if ([COSEALG.ES512, COSEALG.PS512, COSEALG.RS512, COSEALG.EdDSA].indexOf(alg) >= 0) {
    return "SHA-512";
  }
  throw new Error(`Could not map COSE alg value of ${alg} to a WebCrypto alg`);
}

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/getWebCrypto.js
var webCrypto = undefined;
function getWebCrypto() {
  const toResolve = new Promise((resolve, reject) => {
    if (webCrypto) {
      return resolve(webCrypto);
    }
    const _globalThisCrypto = _getWebCryptoInternals.stubThisGlobalThisCrypto();
    if (_globalThisCrypto) {
      webCrypto = _globalThisCrypto;
      return resolve(webCrypto);
    }
    return reject(new MissingWebCrypto);
  });
  return toResolve;
}

class MissingWebCrypto extends Error {
  constructor() {
    const message = "An instance of the Crypto API could not be located";
    super(message);
    this.name = "MissingWebCrypto";
  }
}
var _getWebCryptoInternals = {
  stubThisGlobalThisCrypto: () => globalThis.crypto,
  setCachedCrypto: (newCrypto) => {
    webCrypto = newCrypto;
  }
};

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/digest.js
async function digest(data, algorithm2) {
  const WebCrypto = await getWebCrypto();
  const subtleAlgorithm = mapCoseAlgToWebCryptoAlg(algorithm2);
  const hashed = await WebCrypto.subtle.digest(subtleAlgorithm, data);
  return new Uint8Array(hashed);
}
// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/getRandomValues.js
async function getRandomValues(array) {
  const WebCrypto = await getWebCrypto();
  WebCrypto.getRandomValues(array);
  return array;
}
// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/importKey.js
async function importKey(opts) {
  const WebCrypto = await getWebCrypto();
  const { keyData, algorithm: algorithm2 } = opts;
  return WebCrypto.subtle.importKey("jwk", keyData, algorithm2, false, [
    "verify"
  ]);
}

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/verifyEC2.js
async function verifyEC2(opts) {
  const { cosePublicKey, signature, data, shaHashOverride } = opts;
  const WebCrypto = await getWebCrypto();
  const alg = cosePublicKey.get(COSEKEYS.alg);
  const crv = cosePublicKey.get(COSEKEYS.crv);
  const x = cosePublicKey.get(COSEKEYS.x);
  const y = cosePublicKey.get(COSEKEYS.y);
  if (!alg) {
    throw new Error("Public key was missing alg (EC2)");
  }
  if (!crv) {
    throw new Error("Public key was missing crv (EC2)");
  }
  if (!x) {
    throw new Error("Public key was missing x (EC2)");
  }
  if (!y) {
    throw new Error("Public key was missing y (EC2)");
  }
  let _crv;
  if (crv === COSECRV.P256) {
    _crv = "P-256";
  } else if (crv === COSECRV.P384) {
    _crv = "P-384";
  } else if (crv === COSECRV.P521) {
    _crv = "P-521";
  } else {
    throw new Error(`Unexpected COSE crv value of ${crv} (EC2)`);
  }
  const keyData = {
    kty: "EC",
    crv: _crv,
    x: exports_isoBase64URL.fromBuffer(x),
    y: exports_isoBase64URL.fromBuffer(y),
    ext: false
  };
  const keyAlgorithm = {
    name: "ECDSA",
    namedCurve: _crv
  };
  const key = await importKey({
    keyData,
    algorithm: keyAlgorithm
  });
  let subtleAlg = mapCoseAlgToWebCryptoAlg(alg);
  if (shaHashOverride) {
    subtleAlg = mapCoseAlgToWebCryptoAlg(shaHashOverride);
  }
  const verifyAlgorithm = {
    name: "ECDSA",
    hash: { name: subtleAlg }
  };
  return WebCrypto.subtle.verify(verifyAlgorithm, key, signature, data);
}

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/mapCoseAlgToWebCryptoKeyAlgName.js
function mapCoseAlgToWebCryptoKeyAlgName(alg) {
  if ([COSEALG.EdDSA].indexOf(alg) >= 0) {
    return "Ed25519";
  } else if ([COSEALG.ES256, COSEALG.ES384, COSEALG.ES512, COSEALG.ES256K].indexOf(alg) >= 0) {
    return "ECDSA";
  } else if ([COSEALG.RS256, COSEALG.RS384, COSEALG.RS512, COSEALG.RS1].indexOf(alg) >= 0) {
    return "RSASSA-PKCS1-v1_5";
  } else if ([COSEALG.PS256, COSEALG.PS384, COSEALG.PS512].indexOf(alg) >= 0) {
    return "RSA-PSS";
  }
  throw new Error(`Could not map COSE alg value of ${alg} to a WebCrypto key alg name`);
}

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/verifyRSA.js
async function verifyRSA(opts) {
  const { cosePublicKey, signature, data, shaHashOverride } = opts;
  const WebCrypto = await getWebCrypto();
  const alg = cosePublicKey.get(COSEKEYS.alg);
  const n = cosePublicKey.get(COSEKEYS.n);
  const e = cosePublicKey.get(COSEKEYS.e);
  if (!alg) {
    throw new Error("Public key was missing alg (RSA)");
  }
  if (!isCOSEAlg(alg)) {
    throw new Error(`Public key had invalid alg ${alg} (RSA)`);
  }
  if (!n) {
    throw new Error("Public key was missing n (RSA)");
  }
  if (!e) {
    throw new Error("Public key was missing e (RSA)");
  }
  const keyData = {
    kty: "RSA",
    alg: "",
    n: exports_isoBase64URL.fromBuffer(n),
    e: exports_isoBase64URL.fromBuffer(e),
    ext: false
  };
  const keyAlgorithm = {
    name: mapCoseAlgToWebCryptoKeyAlgName(alg),
    hash: { name: mapCoseAlgToWebCryptoAlg(alg) }
  };
  const verifyAlgorithm = {
    name: mapCoseAlgToWebCryptoKeyAlgName(alg)
  };
  if (shaHashOverride) {
    keyAlgorithm.hash.name = mapCoseAlgToWebCryptoAlg(shaHashOverride);
  }
  if (keyAlgorithm.name === "RSASSA-PKCS1-v1_5") {
    if (keyAlgorithm.hash.name === "SHA-256") {
      keyData.alg = "RS256";
    } else if (keyAlgorithm.hash.name === "SHA-384") {
      keyData.alg = "RS384";
    } else if (keyAlgorithm.hash.name === "SHA-512") {
      keyData.alg = "RS512";
    } else if (keyAlgorithm.hash.name === "SHA-1") {
      keyData.alg = "RS1";
    }
  } else if (keyAlgorithm.name === "RSA-PSS") {
    let saltLength = 0;
    if (keyAlgorithm.hash.name === "SHA-256") {
      keyData.alg = "PS256";
      saltLength = 32;
    } else if (keyAlgorithm.hash.name === "SHA-384") {
      keyData.alg = "PS384";
      saltLength = 48;
    } else if (keyAlgorithm.hash.name === "SHA-512") {
      keyData.alg = "PS512";
      saltLength = 64;
    }
    verifyAlgorithm.saltLength = saltLength;
  } else {
    throw new Error(`Unexpected RSA key algorithm ${alg} (${keyAlgorithm.name})`);
  }
  const key = await importKey({
    keyData,
    algorithm: keyAlgorithm
  });
  return WebCrypto.subtle.verify(verifyAlgorithm, key, signature, data);
}

// node_modules/@simplewebauthn/server/esm/helpers/convertAAGUIDToString.js
function convertAAGUIDToString(aaguid) {
  const hex = exports_isoUint8Array.toHex(aaguid);
  const segments = [
    hex.slice(0, 8),
    hex.slice(8, 12),
    hex.slice(12, 16),
    hex.slice(16, 20),
    hex.slice(20, 32)
  ];
  return segments.join("-");
}
// node_modules/@simplewebauthn/server/esm/helpers/convertCertBufferToPEM.js
function convertCertBufferToPEM(certBuffer) {
  let b64cert;
  if (typeof certBuffer === "string") {
    if (exports_isoBase64URL.isBase64URL(certBuffer)) {
      b64cert = exports_isoBase64URL.toBase64(certBuffer);
    } else if (exports_isoBase64URL.isBase64(certBuffer)) {
      b64cert = certBuffer;
    } else {
      throw new Error("Certificate is not a valid base64 or base64url string");
    }
  } else {
    b64cert = exports_isoBase64URL.fromBuffer(certBuffer, "base64");
  }
  let PEMKey = "";
  for (let i = 0;i < Math.ceil(b64cert.length / 64); i += 1) {
    const start = 64 * i;
    PEMKey += `${b64cert.substr(start, 64)}
`;
  }
  PEMKey = `-----BEGIN CERTIFICATE-----
${PEMKey}-----END CERTIFICATE-----
`;
  return PEMKey;
}
// node_modules/@simplewebauthn/server/esm/helpers/convertCOSEtoPKCS.js
function convertCOSEtoPKCS(cosePublicKey) {
  const struct = exports_isoCBOR.decodeFirst(cosePublicKey);
  const tag = Uint8Array.from([4]);
  const x = struct.get(COSEKEYS.x);
  const y = struct.get(COSEKEYS.y);
  if (!x) {
    throw new Error("COSE public key was missing x");
  }
  if (y) {
    return exports_isoUint8Array.concat([tag, x, y]);
  }
  return exports_isoUint8Array.concat([tag, x]);
}
// node_modules/@simplewebauthn/server/esm/helpers/decodeAttestationObject.js
function decodeAttestationObject(attestationObject) {
  return _decodeAttestationObjectInternals.stubThis(exports_isoCBOR.decodeFirst(attestationObject));
}
var _decodeAttestationObjectInternals = {
  stubThis: (value) => value
};
// node_modules/@simplewebauthn/server/esm/helpers/decodeClientDataJSON.js
function decodeClientDataJSON(data) {
  const toString = exports_isoBase64URL.toUTF8String(data);
  const clientData = JSON.parse(toString);
  return _decodeClientDataJSONInternals.stubThis(clientData);
}
var _decodeClientDataJSONInternals = {
  stubThis: (value) => value
};
// node_modules/@simplewebauthn/server/esm/helpers/decodeCredentialPublicKey.js
function decodeCredentialPublicKey(publicKey) {
  return _decodeCredentialPublicKeyInternals.stubThis(exports_isoCBOR.decodeFirst(publicKey));
}
var _decodeCredentialPublicKeyInternals = {
  stubThis: (value) => value
};
// node_modules/@simplewebauthn/server/esm/helpers/generateUserID.js
async function generateUserID() {
  const newUserID = new Uint8Array(32);
  await exports_isoCrypto.getRandomValues(newUserID);
  return _generateUserIDInternals.stubThis(newUserID);
}
var _generateUserIDInternals = {
  stubThis: (value) => value
};
// node_modules/asn1js/build/index.es.js
var exports_index_es = {};
__export(exports_index_es, {
  verifySchema: () => verifySchema,
  fromBER: () => fromBER,
  compareSchema: () => compareSchema,
  VisibleString: () => VisibleString,
  ViewWriter: () => ViewWriter,
  VideotexString: () => VideotexString,
  ValueBlock: () => ValueBlock,
  Utf8String: () => Utf8String,
  UniversalString: () => UniversalString,
  UTCTime: () => UTCTime,
  TimeOfDay: () => TimeOfDay,
  TeletexString: () => TeletexString,
  TIME: () => TIME,
  Set: () => Set2,
  Sequence: () => Sequence,
  Repeated: () => Repeated,
  RelativeObjectIdentifier: () => RelativeObjectIdentifier,
  RawData: () => RawData,
  PrintableString: () => PrintableString,
  Primitive: () => Primitive,
  OctetString: () => OctetString,
  ObjectIdentifier: () => ObjectIdentifier,
  NumericString: () => NumericString,
  Null: () => Null,
  Integer: () => Integer,
  IA5String: () => IA5String,
  HexBlock: () => HexBlock,
  GraphicString: () => GraphicString,
  GeneralizedTime: () => GeneralizedTime,
  GeneralString: () => GeneralString,
  Enumerated: () => Enumerated,
  EndOfContent: () => EndOfContent,
  Duration: () => Duration,
  DateTime: () => DateTime,
  DATE: () => DATE,
  Constructed: () => Constructed,
  Choice: () => Choice,
  CharacterString: () => CharacterString,
  Boolean: () => Boolean2,
  BmpString: () => BmpString,
  BitString: () => BitString,
  BaseStringBlock: () => BaseStringBlock,
  BaseBlock: () => BaseBlock,
  Any: () => Any
});

// node_modules/pvtsutils/build/index.es.js
/*!
 * MIT License
 * 
 * Copyright (c) 2017-2024 Peculiar Ventures, LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */
var ARRAY_BUFFER_NAME = "[object ArrayBuffer]";

class BufferSourceConverter {
  static isArrayBuffer(data) {
    return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
  }
  static toArrayBuffer(data) {
    if (this.isArrayBuffer(data)) {
      return data;
    }
    if (data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    return this.toUint8Array(data.buffer).slice(data.byteOffset, data.byteOffset + data.byteLength).buffer;
  }
  static toUint8Array(data) {
    return this.toView(data, Uint8Array);
  }
  static toView(data, type) {
    if (data.constructor === type) {
      return data;
    }
    if (this.isArrayBuffer(data)) {
      return new type(data);
    }
    if (this.isArrayBufferView(data)) {
      return new type(data.buffer, data.byteOffset, data.byteLength);
    }
    throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
  }
  static isBufferSource(data) {
    return this.isArrayBufferView(data) || this.isArrayBuffer(data);
  }
  static isArrayBufferView(data) {
    return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);
  }
  static isEqual(a, b) {
    const aView = BufferSourceConverter.toUint8Array(a);
    const bView = BufferSourceConverter.toUint8Array(b);
    if (aView.length !== bView.byteLength) {
      return false;
    }
    for (let i = 0;i < aView.length; i++) {
      if (aView[i] !== bView[i]) {
        return false;
      }
    }
    return true;
  }
  static concat(...args) {
    let buffers;
    if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {
      buffers = args[0];
    } else if (Array.isArray(args[0]) && args[1] instanceof Function) {
      buffers = args[0];
    } else {
      if (args[args.length - 1] instanceof Function) {
        buffers = args.slice(0, args.length - 1);
      } else {
        buffers = args;
      }
    }
    let size = 0;
    for (const buffer of buffers) {
      size += buffer.byteLength;
    }
    const res = new Uint8Array(size);
    let offset = 0;
    for (const buffer of buffers) {
      const view = this.toUint8Array(buffer);
      res.set(view, offset);
      offset += view.length;
    }
    if (args[args.length - 1] instanceof Function) {
      return this.toView(res, args[args.length - 1]);
    }
    return res.buffer;
  }
}
var STRING_TYPE = "string";
var HEX_REGEX = /^[0-9a-f\s]+$/i;
var BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
var BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;

class Utf8Converter {
  static fromString(text) {
    const s = unescape(encodeURIComponent(text));
    const uintArray = new Uint8Array(s.length);
    for (let i = 0;i < s.length; i++) {
      uintArray[i] = s.charCodeAt(i);
    }
    return uintArray.buffer;
  }
  static toString(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    let encodedString = "";
    for (let i = 0;i < buf.length; i++) {
      encodedString += String.fromCharCode(buf[i]);
    }
    const decodedString = decodeURIComponent(escape(encodedString));
    return decodedString;
  }
}

class Utf16Converter {
  static toString(buffer, littleEndian = false) {
    const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);
    const dataView = new DataView(arrayBuffer);
    let res = "";
    for (let i = 0;i < arrayBuffer.byteLength; i += 2) {
      const code = dataView.getUint16(i, littleEndian);
      res += String.fromCharCode(code);
    }
    return res;
  }
  static fromString(text, littleEndian = false) {
    const res = new ArrayBuffer(text.length * 2);
    const dataView = new DataView(res);
    for (let i = 0;i < text.length; i++) {
      dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);
    }
    return res;
  }
}

class Convert {
  static isHex(data) {
    return typeof data === STRING_TYPE && HEX_REGEX.test(data);
  }
  static isBase64(data) {
    return typeof data === STRING_TYPE && BASE64_REGEX.test(data);
  }
  static isBase64Url(data) {
    return typeof data === STRING_TYPE && BASE64URL_REGEX.test(data);
  }
  static ToString(buffer, enc = "utf8") {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    switch (enc.toLowerCase()) {
      case "utf8":
        return this.ToUtf8String(buf);
      case "binary":
        return this.ToBinary(buf);
      case "hex":
        return this.ToHex(buf);
      case "base64":
        return this.ToBase64(buf);
      case "base64url":
        return this.ToBase64Url(buf);
      case "utf16le":
        return Utf16Converter.toString(buf, true);
      case "utf16":
      case "utf16be":
        return Utf16Converter.toString(buf);
      default:
        throw new Error(`Unknown type of encoding '${enc}'`);
    }
  }
  static FromString(str, enc = "utf8") {
    if (!str) {
      return new ArrayBuffer(0);
    }
    switch (enc.toLowerCase()) {
      case "utf8":
        return this.FromUtf8String(str);
      case "binary":
        return this.FromBinary(str);
      case "hex":
        return this.FromHex(str);
      case "base64":
        return this.FromBase64(str);
      case "base64url":
        return this.FromBase64Url(str);
      case "utf16le":
        return Utf16Converter.fromString(str, true);
      case "utf16":
      case "utf16be":
        return Utf16Converter.fromString(str);
      default:
        throw new Error(`Unknown type of encoding '${enc}'`);
    }
  }
  static ToBase64(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    if (typeof btoa !== "undefined") {
      const binary = this.ToString(buf, "binary");
      return btoa(binary);
    } else {
      return Buffer.from(buf).toString("base64");
    }
  }
  static FromBase64(base642) {
    const formatted = this.formatString(base642);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!Convert.isBase64(formatted)) {
      throw new TypeError("Argument 'base64Text' is not Base64 encoded");
    }
    if (typeof atob !== "undefined") {
      return this.FromBinary(atob(formatted));
    } else {
      return new Uint8Array(Buffer.from(formatted, "base64")).buffer;
    }
  }
  static FromBase64Url(base64url) {
    const formatted = this.formatString(base64url);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!Convert.isBase64Url(formatted)) {
      throw new TypeError("Argument 'base64url' is not Base64Url encoded");
    }
    return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
  }
  static ToBase64Url(data) {
    return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
  }
  static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {
    switch (encoding) {
      case "ascii":
        return this.FromBinary(text);
      case "utf8":
        return Utf8Converter.fromString(text);
      case "utf16":
      case "utf16be":
        return Utf16Converter.fromString(text);
      case "utf16le":
      case "usc2":
        return Utf16Converter.fromString(text, true);
      default:
        throw new Error(`Unknown type of encoding '${encoding}'`);
    }
  }
  static ToUtf8String(buffer, encoding = Convert.DEFAULT_UTF8_ENCODING) {
    switch (encoding) {
      case "ascii":
        return this.ToBinary(buffer);
      case "utf8":
        return Utf8Converter.toString(buffer);
      case "utf16":
      case "utf16be":
        return Utf16Converter.toString(buffer);
      case "utf16le":
      case "usc2":
        return Utf16Converter.toString(buffer, true);
      default:
        throw new Error(`Unknown type of encoding '${encoding}'`);
    }
  }
  static FromBinary(text) {
    const stringLength = text.length;
    const resultView = new Uint8Array(stringLength);
    for (let i = 0;i < stringLength; i++) {
      resultView[i] = text.charCodeAt(i);
    }
    return resultView.buffer;
  }
  static ToBinary(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    let res = "";
    for (let i = 0;i < buf.length; i++) {
      res += String.fromCharCode(buf[i]);
    }
    return res;
  }
  static ToHex(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    let result = "";
    const len = buf.length;
    for (let i = 0;i < len; i++) {
      const byte = buf[i];
      if (byte < 16) {
        result += "0";
      }
      result += byte.toString(16);
    }
    return result;
  }
  static FromHex(hexString) {
    let formatted = this.formatString(hexString);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!Convert.isHex(formatted)) {
      throw new TypeError("Argument 'hexString' is not HEX encoded");
    }
    if (formatted.length % 2) {
      formatted = `0${formatted}`;
    }
    const res = new Uint8Array(formatted.length / 2);
    for (let i = 0;i < formatted.length; i = i + 2) {
      const c = formatted.slice(i, i + 2);
      res[i / 2] = parseInt(c, 16);
    }
    return res.buffer;
  }
  static ToUtf16String(buffer, littleEndian = false) {
    return Utf16Converter.toString(buffer, littleEndian);
  }
  static FromUtf16String(text, littleEndian = false) {
    return Utf16Converter.fromString(text, littleEndian);
  }
  static Base64Padding(base642) {
    const padCount = 4 - base642.length % 4;
    if (padCount < 4) {
      for (let i = 0;i < padCount; i++) {
        base642 += "=";
      }
    }
    return base642;
  }
  static formatString(data) {
    return (data === null || data === undefined ? undefined : data.replace(/[\n\r\t ]/g, "")) || "";
  }
}
Convert.DEFAULT_UTF8_ENCODING = "utf8";
function combine(...buf) {
  const totalByteLength = buf.map((item) => item.byteLength).reduce((prev, cur) => prev + cur);
  const res = new Uint8Array(totalByteLength);
  let currentPos = 0;
  buf.map((item) => new Uint8Array(item)).forEach((arr) => {
    for (const item2 of arr) {
      res[currentPos++] = item2;
    }
  });
  return res.buffer;
}
function isEqual(bytes1, bytes2) {
  if (!(bytes1 && bytes2)) {
    return false;
  }
  if (bytes1.byteLength !== bytes2.byteLength) {
    return false;
  }
  const b1 = new Uint8Array(bytes1);
  const b2 = new Uint8Array(bytes2);
  for (let i = 0;i < bytes1.byteLength; i++) {
    if (b1[i] !== b2[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/pvutils/build/utils.es.js
/*!
 Copyright (c) Peculiar Ventures, LLC
*/
function utilFromBase(inputBuffer, inputBase) {
  let result = 0;
  if (inputBuffer.length === 1) {
    return inputBuffer[0];
  }
  for (let i = inputBuffer.length - 1;i >= 0; i--) {
    result += inputBuffer[inputBuffer.length - 1 - i] * Math.pow(2, inputBase * i);
  }
  return result;
}
function utilToBase(value, base, reserved = -1) {
  const internalReserved = reserved;
  let internalValue = value;
  let result = 0;
  let biggest = Math.pow(2, base);
  for (let i = 1;i < 8; i++) {
    if (value < biggest) {
      let retBuf;
      if (internalReserved < 0) {
        retBuf = new ArrayBuffer(i);
        result = i;
      } else {
        if (internalReserved < i) {
          return new ArrayBuffer(0);
        }
        retBuf = new ArrayBuffer(internalReserved);
        result = internalReserved;
      }
      const retView = new Uint8Array(retBuf);
      for (let j = i - 1;j >= 0; j--) {
        const basis = Math.pow(2, j * base);
        retView[result - j - 1] = Math.floor(internalValue / basis);
        internalValue -= retView[result - j - 1] * basis;
      }
      return retBuf;
    }
    biggest *= Math.pow(2, base);
  }
  return new ArrayBuffer(0);
}
function utilConcatView(...views) {
  let outputLength = 0;
  let prevLength = 0;
  for (const view of views) {
    outputLength += view.length;
  }
  const retBuf = new ArrayBuffer(outputLength);
  const retView = new Uint8Array(retBuf);
  for (const view of views) {
    retView.set(view, prevLength);
    prevLength += view.length;
  }
  return retView;
}
function utilDecodeTC() {
  const buf = new Uint8Array(this.valueHex);
  if (this.valueHex.byteLength >= 2) {
    const condition1 = buf[0] === 255 && buf[1] & 128;
    const condition2 = buf[0] === 0 && (buf[1] & 128) === 0;
    if (condition1 || condition2) {
      this.warnings.push("Needlessly long format");
    }
  }
  const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
  const bigIntView = new Uint8Array(bigIntBuffer);
  for (let i = 0;i < this.valueHex.byteLength; i++) {
    bigIntView[i] = 0;
  }
  bigIntView[0] = buf[0] & 128;
  const bigInt = utilFromBase(bigIntView, 8);
  const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
  const smallIntView = new Uint8Array(smallIntBuffer);
  for (let j = 0;j < this.valueHex.byteLength; j++) {
    smallIntView[j] = buf[j];
  }
  smallIntView[0] &= 127;
  const smallInt = utilFromBase(smallIntView, 8);
  return smallInt - bigInt;
}
function utilEncodeTC(value) {
  const modValue = value < 0 ? value * -1 : value;
  let bigInt = 128;
  for (let i = 1;i < 8; i++) {
    if (modValue <= bigInt) {
      if (value < 0) {
        const smallInt = bigInt - modValue;
        const retBuf2 = utilToBase(smallInt, 8, i);
        const retView2 = new Uint8Array(retBuf2);
        retView2[0] |= 128;
        return retBuf2;
      }
      let retBuf = utilToBase(modValue, 8, i);
      let retView = new Uint8Array(retBuf);
      if (retView[0] & 128) {
        const tempBuf = retBuf.slice(0);
        const tempView = new Uint8Array(tempBuf);
        retBuf = new ArrayBuffer(retBuf.byteLength + 1);
        retView = new Uint8Array(retBuf);
        for (let k = 0;k < tempBuf.byteLength; k++) {
          retView[k + 1] = tempView[k];
        }
        retView[0] = 0;
      }
      return retBuf;
    }
    bigInt *= Math.pow(2, 8);
  }
  return new ArrayBuffer(0);
}
function isEqualBuffer(inputBuffer1, inputBuffer2) {
  if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
    return false;
  }
  const view1 = new Uint8Array(inputBuffer1);
  const view2 = new Uint8Array(inputBuffer2);
  for (let i = 0;i < view1.length; i++) {
    if (view1[i] !== view2[i]) {
      return false;
    }
  }
  return true;
}
function padNumber(inputNumber, fullLength) {
  const str = inputNumber.toString(10);
  if (fullLength < str.length) {
    return "";
  }
  const dif = fullLength - str.length;
  const padding = new Array(dif);
  for (let i = 0;i < dif; i++) {
    padding[i] = "0";
  }
  const paddingString = padding.join("");
  return paddingString.concat(str);
}
var log2 = Math.log(2);

// node_modules/asn1js/build/index.es.js
/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
function assertBigInt() {
  if (typeof BigInt === "undefined") {
    throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
  }
}
function concat(buffers) {
  let outputLength = 0;
  let prevLength = 0;
  for (let i = 0;i < buffers.length; i++) {
    const buffer = buffers[i];
    outputLength += buffer.byteLength;
  }
  const retView = new Uint8Array(outputLength);
  for (let i = 0;i < buffers.length; i++) {
    const buffer = buffers[i];
    retView.set(new Uint8Array(buffer), prevLength);
    prevLength += buffer.byteLength;
  }
  return retView.buffer;
}
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
  if (!(inputBuffer instanceof Uint8Array)) {
    baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
    return false;
  }
  if (!inputBuffer.byteLength) {
    baseBlock.error = "Wrong parameter: inputBuffer has zero length";
    return false;
  }
  if (inputOffset < 0) {
    baseBlock.error = "Wrong parameter: inputOffset less than zero";
    return false;
  }
  if (inputLength < 0) {
    baseBlock.error = "Wrong parameter: inputLength less than zero";
    return false;
  }
  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
    baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
    return false;
  }
  return true;
}

class ViewWriter {
  constructor() {
    this.items = [];
  }
  write(buf) {
    this.items.push(buf);
  }
  final() {
    return concat(this.items);
  }
}
var powers2 = [new Uint8Array([1])];
var digitsString = "0123456789";
var NAME = "name";
var VALUE_HEX_VIEW = "valueHexView";
var IS_HEX_ONLY = "isHexOnly";
var ID_BLOCK = "idBlock";
var TAG_CLASS = "tagClass";
var TAG_NUMBER = "tagNumber";
var IS_CONSTRUCTED = "isConstructed";
var FROM_BER = "fromBER";
var TO_BER = "toBER";
var LOCAL = "local";
var EMPTY_STRING = "";
var EMPTY_BUFFER = new ArrayBuffer(0);
var EMPTY_VIEW = new Uint8Array(0);
var END_OF_CONTENT_NAME = "EndOfContent";
var OCTET_STRING_NAME = "OCTET STRING";
var BIT_STRING_NAME = "BIT STRING";
function HexBlock(BaseClass) {
  var _a;
  return _a = class Some extends BaseClass {
    constructor(...args) {
      var _a2;
      super(...args);
      const params = args[0] || {};
      this.isHexOnly = (_a2 = params.isHexOnly) !== null && _a2 !== undefined ? _a2 : false;
      this.valueHexView = params.valueHex ? BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;
    }
    get valueHex() {
      return this.valueHexView.slice().buffer;
    }
    set valueHex(value) {
      this.valueHexView = new Uint8Array(value);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      if (!checkBufferParams(this, view, inputOffset, inputLength)) {
        return -1;
      }
      const endLength = inputOffset + inputLength;
      this.valueHexView = view.subarray(inputOffset, endLength);
      if (!this.valueHexView.length) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      }
      this.blockLength = inputLength;
      return endLength;
    }
    toBER(sizeOnly = false) {
      if (!this.isHexOnly) {
        this.error = "Flag 'isHexOnly' is not set, abort";
        return EMPTY_BUFFER;
      }
      if (sizeOnly) {
        return new ArrayBuffer(this.valueHexView.byteLength);
      }
      return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        isHexOnly: this.isHexOnly,
        valueHex: Convert.ToHex(this.valueHexView)
      };
    }
  }, _a.NAME = "hexBlock", _a;
}

class LocalBaseBlock {
  constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW } = {}) {
    this.blockLength = blockLength;
    this.error = error;
    this.warnings = warnings;
    this.valueBeforeDecodeView = BufferSourceConverter.toUint8Array(valueBeforeDecode);
  }
  static blockName() {
    return this.NAME;
  }
  get valueBeforeDecode() {
    return this.valueBeforeDecodeView.slice().buffer;
  }
  set valueBeforeDecode(value) {
    this.valueBeforeDecodeView = new Uint8Array(value);
  }
  toJSON() {
    return {
      blockName: this.constructor.NAME,
      blockLength: this.blockLength,
      error: this.error,
      warnings: this.warnings,
      valueBeforeDecode: Convert.ToHex(this.valueBeforeDecodeView)
    };
  }
}
LocalBaseBlock.NAME = "baseBlock";

class ValueBlock extends LocalBaseBlock {
  fromBER(inputBuffer, inputOffset, inputLength) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
  toBER(sizeOnly, writer) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
}
ValueBlock.NAME = "valueBlock";

class LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {
  constructor({ idBlock = {} } = {}) {
    var _a, _b, _c, _d;
    super();
    if (idBlock) {
      this.isHexOnly = (_a = idBlock.isHexOnly) !== null && _a !== undefined ? _a : false;
      this.valueHexView = idBlock.valueHex ? BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;
      this.tagClass = (_b = idBlock.tagClass) !== null && _b !== undefined ? _b : -1;
      this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== undefined ? _c : -1;
      this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== undefined ? _d : false;
    } else {
      this.tagClass = -1;
      this.tagNumber = -1;
      this.isConstructed = false;
    }
  }
  toBER(sizeOnly = false) {
    let firstOctet = 0;
    switch (this.tagClass) {
      case 1:
        firstOctet |= 0;
        break;
      case 2:
        firstOctet |= 64;
        break;
      case 3:
        firstOctet |= 128;
        break;
      case 4:
        firstOctet |= 192;
        break;
      default:
        this.error = "Unknown tag class";
        return EMPTY_BUFFER;
    }
    if (this.isConstructed)
      firstOctet |= 32;
    if (this.tagNumber < 31 && !this.isHexOnly) {
      const retView2 = new Uint8Array(1);
      if (!sizeOnly) {
        let number = this.tagNumber;
        number &= 31;
        firstOctet |= number;
        retView2[0] = firstOctet;
      }
      return retView2.buffer;
    }
    if (!this.isHexOnly) {
      const encodedBuf = utilToBase(this.tagNumber, 7);
      const encodedView = new Uint8Array(encodedBuf);
      const size = encodedBuf.byteLength;
      const retView2 = new Uint8Array(size + 1);
      retView2[0] = firstOctet | 31;
      if (!sizeOnly) {
        for (let i = 0;i < size - 1; i++)
          retView2[i + 1] = encodedView[i] | 128;
        retView2[size] = encodedView[size - 1];
      }
      return retView2.buffer;
    }
    const retView = new Uint8Array(this.valueHexView.byteLength + 1);
    retView[0] = firstOctet | 31;
    if (!sizeOnly) {
      const curView = this.valueHexView;
      for (let i = 0;i < curView.length - 1; i++)
        retView[i + 1] = curView[i] | 128;
      retView[this.valueHexView.byteLength] = curView[curView.length - 1];
    }
    return retView.buffer;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    const tagClassMask = intBuffer[0] & 192;
    switch (tagClassMask) {
      case 0:
        this.tagClass = 1;
        break;
      case 64:
        this.tagClass = 2;
        break;
      case 128:
        this.tagClass = 3;
        break;
      case 192:
        this.tagClass = 4;
        break;
      default:
        this.error = "Unknown tag class";
        return -1;
    }
    this.isConstructed = (intBuffer[0] & 32) === 32;
    this.isHexOnly = false;
    const tagNumberMask = intBuffer[0] & 31;
    if (tagNumberMask !== 31) {
      this.tagNumber = tagNumberMask;
      this.blockLength = 1;
    } else {
      let count = 1;
      let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
      let tagNumberBufferMaxLength = 255;
      while (intBuffer[count] & 128) {
        intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
        count++;
        if (count >= intBuffer.length) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (count === tagNumberBufferMaxLength) {
          tagNumberBufferMaxLength += 255;
          const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);
          for (let i = 0;i < intTagNumberBuffer.length; i++)
            tempBufferView2[i] = intTagNumberBuffer[i];
          intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
        }
      }
      this.blockLength = count + 1;
      intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
      const tempBufferView = new Uint8Array(count);
      for (let i = 0;i < count; i++)
        tempBufferView[i] = intTagNumberBuffer[i];
      intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
      intTagNumberBuffer.set(tempBufferView);
      if (this.blockLength <= 9)
        this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
      else {
        this.isHexOnly = true;
        this.warnings.push("Tag too long, represented as hex-coded");
      }
    }
    if (this.tagClass === 1 && this.isConstructed) {
      switch (this.tagNumber) {
        case 1:
        case 2:
        case 5:
        case 6:
        case 9:
        case 13:
        case 14:
        case 23:
        case 24:
        case 31:
        case 32:
        case 33:
        case 34:
          this.error = "Constructed encoding used for primitive type";
          return -1;
      }
    }
    return inputOffset + this.blockLength;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      tagClass: this.tagClass,
      tagNumber: this.tagNumber,
      isConstructed: this.isConstructed
    };
  }
}
LocalIdentificationBlock.NAME = "identificationBlock";

class LocalLengthBlock extends LocalBaseBlock {
  constructor({ lenBlock = {} } = {}) {
    var _a, _b, _c;
    super();
    this.isIndefiniteForm = (_a = lenBlock.isIndefiniteForm) !== null && _a !== undefined ? _a : false;
    this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== undefined ? _b : false;
    this.length = (_c = lenBlock.length) !== null && _c !== undefined ? _c : 0;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, view, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    if (intBuffer[0] === 255) {
      this.error = "Length block 0xFF is reserved by standard";
      return -1;
    }
    this.isIndefiniteForm = intBuffer[0] === 128;
    if (this.isIndefiniteForm) {
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    this.longFormUsed = !!(intBuffer[0] & 128);
    if (this.longFormUsed === false) {
      this.length = intBuffer[0];
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    const count = intBuffer[0] & 127;
    if (count > 8) {
      this.error = "Too big integer";
      return -1;
    }
    if (count + 1 > intBuffer.length) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    const lenOffset = inputOffset + 1;
    const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
    if (lengthBufferView[count - 1] === 0)
      this.warnings.push("Needlessly long encoded length");
    this.length = utilFromBase(lengthBufferView, 8);
    if (this.longFormUsed && this.length <= 127)
      this.warnings.push("Unnecessary usage of long length form");
    this.blockLength = count + 1;
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly = false) {
    let retBuf;
    let retView;
    if (this.length > 127)
      this.longFormUsed = true;
    if (this.isIndefiniteForm) {
      retBuf = new ArrayBuffer(1);
      if (sizeOnly === false) {
        retView = new Uint8Array(retBuf);
        retView[0] = 128;
      }
      return retBuf;
    }
    if (this.longFormUsed) {
      const encodedBuf = utilToBase(this.length, 8);
      if (encodedBuf.byteLength > 127) {
        this.error = "Too big length";
        return EMPTY_BUFFER;
      }
      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
      if (sizeOnly)
        return retBuf;
      const encodedView = new Uint8Array(encodedBuf);
      retView = new Uint8Array(retBuf);
      retView[0] = encodedBuf.byteLength | 128;
      for (let i = 0;i < encodedBuf.byteLength; i++)
        retView[i + 1] = encodedView[i];
      return retBuf;
    }
    retBuf = new ArrayBuffer(1);
    if (sizeOnly === false) {
      retView = new Uint8Array(retBuf);
      retView[0] = this.length;
    }
    return retBuf;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      longFormUsed: this.longFormUsed,
      length: this.length
    };
  }
}
LocalLengthBlock.NAME = "lengthBlock";
var typeStore = {};

class BaseBlock extends LocalBaseBlock {
  constructor({ name = EMPTY_STRING, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType) {
    super(parameters);
    this.name = name;
    this.optional = optional;
    if (primitiveSchema) {
      this.primitiveSchema = primitiveSchema;
    }
    this.idBlock = new LocalIdentificationBlock(parameters);
    this.lenBlock = new LocalLengthBlock(parameters);
    this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter;
    if (!writer) {
      prepareIndefiniteForm(this);
    }
    const idBlockBuf = this.idBlock.toBER(sizeOnly);
    _writer.write(idBlockBuf);
    if (this.lenBlock.isIndefiniteForm) {
      _writer.write(new Uint8Array([128]).buffer);
      this.valueBlock.toBER(sizeOnly, _writer);
      _writer.write(new ArrayBuffer(2));
    } else {
      const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
      this.lenBlock.length = valueBlockBuf.byteLength;
      const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
      _writer.write(lenBlockBuf);
      _writer.write(valueBlockBuf);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      idBlock: this.idBlock.toJSON(),
      lenBlock: this.lenBlock.toJSON(),
      valueBlock: this.valueBlock.toJSON(),
      name: this.name,
      optional: this.optional
    };
    if (this.primitiveSchema)
      object.primitiveSchema = this.primitiveSchema.toJSON();
    return object;
  }
  toString(encoding = "ascii") {
    if (encoding === "ascii") {
      return this.onAsciiEncoding();
    }
    return Convert.ToHex(this.toBER());
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`;
  }
  isEqual(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof this.constructor)) {
      return false;
    }
    const thisRaw = this.toBER();
    const otherRaw = other.toBER();
    return isEqualBuffer(thisRaw, otherRaw);
  }
}
BaseBlock.NAME = "BaseBlock";
function prepareIndefiniteForm(baseBlock) {
  if (baseBlock instanceof typeStore.Constructed) {
    for (const value of baseBlock.valueBlock.value) {
      if (prepareIndefiniteForm(value)) {
        baseBlock.lenBlock.isIndefiniteForm = true;
      }
    }
  }
  return !!baseBlock.lenBlock.isIndefiniteForm;
}

class BaseStringBlock extends BaseBlock {
  constructor({ value = EMPTY_STRING, ...parameters } = {}, stringValueBlockType) {
    super(parameters, stringValueBlockType);
    if (value) {
      this.fromString(value);
    }
  }
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    this.fromBuffer(this.valueBlock.valueHexView);
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
  }
}
BaseStringBlock.NAME = "BaseStringBlock";

class LocalPrimitiveValueBlock extends HexBlock(ValueBlock) {
  constructor({ isHexOnly = true, ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = isHexOnly;
  }
}
LocalPrimitiveValueBlock.NAME = "PrimitiveValueBlock";
var _a$w;

class Primitive extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalPrimitiveValueBlock);
    this.idBlock.isConstructed = false;
  }
}
_a$w = Primitive;
(() => {
  typeStore.Primitive = _a$w;
})();
Primitive.NAME = "PRIMITIVE";
function localChangeType(inputObject, newType) {
  if (inputObject instanceof newType) {
    return inputObject;
  }
  const newObject = new newType;
  newObject.idBlock = inputObject.idBlock;
  newObject.lenBlock = inputObject.lenBlock;
  newObject.warnings = inputObject.warnings;
  newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
  return newObject;
}
function localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
  const incomingOffset = inputOffset;
  let returnObject = new BaseBlock({}, ValueBlock);
  const baseBlock = new LocalBaseBlock;
  if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {
    returnObject.error = baseBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
  if (!intBuffer.length) {
    returnObject.error = "Zero buffer length";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.idBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.idBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.idBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.idBlock.blockLength;
  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.lenBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.lenBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.lenBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.lenBlock.blockLength;
  if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
    returnObject.error = "Indefinite length form used for primitive encoding form";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let newASN1Type = BaseBlock;
  switch (returnObject.idBlock.tagClass) {
    case 1:
      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
        returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
        return {
          offset: -1,
          result: returnObject
        };
      }
      switch (returnObject.idBlock.tagNumber) {
        case 0:
          if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
            returnObject.error = "Type [UNIVERSAL 0] is reserved";
            return {
              offset: -1,
              result: returnObject
            };
          }
          newASN1Type = typeStore.EndOfContent;
          break;
        case 1:
          newASN1Type = typeStore.Boolean;
          break;
        case 2:
          newASN1Type = typeStore.Integer;
          break;
        case 3:
          newASN1Type = typeStore.BitString;
          break;
        case 4:
          newASN1Type = typeStore.OctetString;
          break;
        case 5:
          newASN1Type = typeStore.Null;
          break;
        case 6:
          newASN1Type = typeStore.ObjectIdentifier;
          break;
        case 10:
          newASN1Type = typeStore.Enumerated;
          break;
        case 12:
          newASN1Type = typeStore.Utf8String;
          break;
        case 13:
          newASN1Type = typeStore.RelativeObjectIdentifier;
          break;
        case 14:
          newASN1Type = typeStore.TIME;
          break;
        case 15:
          returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
          return {
            offset: -1,
            result: returnObject
          };
        case 16:
          newASN1Type = typeStore.Sequence;
          break;
        case 17:
          newASN1Type = typeStore.Set;
          break;
        case 18:
          newASN1Type = typeStore.NumericString;
          break;
        case 19:
          newASN1Type = typeStore.PrintableString;
          break;
        case 20:
          newASN1Type = typeStore.TeletexString;
          break;
        case 21:
          newASN1Type = typeStore.VideotexString;
          break;
        case 22:
          newASN1Type = typeStore.IA5String;
          break;
        case 23:
          newASN1Type = typeStore.UTCTime;
          break;
        case 24:
          newASN1Type = typeStore.GeneralizedTime;
          break;
        case 25:
          newASN1Type = typeStore.GraphicString;
          break;
        case 26:
          newASN1Type = typeStore.VisibleString;
          break;
        case 27:
          newASN1Type = typeStore.GeneralString;
          break;
        case 28:
          newASN1Type = typeStore.UniversalString;
          break;
        case 29:
          newASN1Type = typeStore.CharacterString;
          break;
        case 30:
          newASN1Type = typeStore.BmpString;
          break;
        case 31:
          newASN1Type = typeStore.DATE;
          break;
        case 32:
          newASN1Type = typeStore.TimeOfDay;
          break;
        case 33:
          newASN1Type = typeStore.DateTime;
          break;
        case 34:
          newASN1Type = typeStore.Duration;
          break;
        default: {
          const newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed : new typeStore.Primitive;
          newObject.idBlock = returnObject.idBlock;
          newObject.lenBlock = returnObject.lenBlock;
          newObject.warnings = returnObject.warnings;
          returnObject = newObject;
        }
      }
      break;
    case 2:
    case 3:
    case 4:
    default: {
      newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;
    }
  }
  returnObject = localChangeType(returnObject, newASN1Type);
  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
  returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
  return {
    offset: resultOffset,
    result: returnObject
  };
}
function fromBER(inputBuffer) {
  if (!inputBuffer.byteLength) {
    const result = new BaseBlock({}, ValueBlock);
    result.error = "Input buffer has zero length";
    return {
      offset: -1,
      result
    };
  }
  return localFromBER(BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
}
function checkLen(indefiniteLength, length) {
  if (indefiniteLength) {
    return 1;
  }
  return length;
}

class LocalConstructedValueBlock extends ValueBlock {
  constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {
    super(parameters);
    this.value = value;
    this.isIndefiniteForm = isIndefiniteForm;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, view, inputOffset, inputLength)) {
      return -1;
    }
    this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
    if (this.valueBeforeDecodeView.length === 0) {
      this.warnings.push("Zero buffer length");
      return inputOffset;
    }
    let currentOffset = inputOffset;
    while (checkLen(this.isIndefiniteForm, inputLength) > 0) {
      const returnObject = localFromBER(view, currentOffset, inputLength);
      if (returnObject.offset === -1) {
        this.error = returnObject.result.error;
        this.warnings.concat(returnObject.result.warnings);
        return -1;
      }
      currentOffset = returnObject.offset;
      this.blockLength += returnObject.result.blockLength;
      inputLength -= returnObject.result.blockLength;
      this.value.push(returnObject.result);
      if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {
        break;
      }
    }
    if (this.isIndefiniteForm) {
      if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {
        this.value.pop();
      } else {
        this.warnings.push("No EndOfContent block encoded");
      }
    }
    return currentOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter;
    for (let i = 0;i < this.value.length; i++) {
      this.value[i].toBER(sizeOnly, _writer);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      value: []
    };
    for (const value of this.value) {
      object.value.push(value.toJSON());
    }
    return object;
  }
}
LocalConstructedValueBlock.NAME = "ConstructedValueBlock";
var _a$v;

class Constructed extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalConstructedValueBlock);
    this.idBlock.isConstructed = true;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    const values = [];
    for (const value of this.valueBlock.value) {
      values.push(value.toString("ascii").split(`
`).map((o) => `  ${o}`).join(`
`));
    }
    const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
    return values.length ? `${blockName} :
${values.join(`
`)}` : `${blockName} :`;
  }
}
_a$v = Constructed;
(() => {
  typeStore.Constructed = _a$v;
})();
Constructed.NAME = "CONSTRUCTED";

class LocalEndOfContentValueBlock extends ValueBlock {
  fromBER(inputBuffer, inputOffset, inputLength) {
    return inputOffset;
  }
  toBER(sizeOnly) {
    return EMPTY_BUFFER;
  }
}
LocalEndOfContentValueBlock.override = "EndOfContentValueBlock";
var _a$u;

class EndOfContent extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalEndOfContentValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 0;
  }
}
_a$u = EndOfContent;
(() => {
  typeStore.EndOfContent = _a$u;
})();
EndOfContent.NAME = END_OF_CONTENT_NAME;
var _a$t;

class Null extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, ValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 5;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (this.lenBlock.length > 0)
      this.warnings.push("Non-zero length of value block for Null type");
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    this.blockLength += inputLength;
    if (inputOffset + inputLength > inputBuffer.byteLength) {
      this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
      return -1;
    }
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    const retBuf = new ArrayBuffer(2);
    if (!sizeOnly) {
      const retView = new Uint8Array(retBuf);
      retView[0] = 5;
      retView[1] = 0;
    }
    if (writer) {
      writer.write(retBuf);
    }
    return retBuf;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME}`;
  }
}
_a$t = Null;
(() => {
  typeStore.Null = _a$t;
})();
Null.NAME = "NULL";

class LocalBooleanValueBlock extends HexBlock(ValueBlock) {
  constructor({ value, ...parameters } = {}) {
    super(parameters);
    if (parameters.valueHex) {
      this.valueHexView = BufferSourceConverter.toUint8Array(parameters.valueHex);
    } else {
      this.valueHexView = new Uint8Array(1);
    }
    if (value) {
      this.value = value;
    }
  }
  get value() {
    for (const octet of this.valueHexView) {
      if (octet > 0) {
        return true;
      }
    }
    return false;
  }
  set value(value) {
    this.valueHexView[0] = value ? 255 : 0;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (inputLength > 1)
      this.warnings.push("Boolean value encoded in more then 1 octet");
    this.isHexOnly = true;
    utilDecodeTC.call(this);
    this.blockLength = inputLength;
    return inputOffset + inputLength;
  }
  toBER() {
    return this.valueHexView.slice();
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalBooleanValueBlock.NAME = "BooleanValueBlock";
var _a$s;

class Boolean2 extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalBooleanValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 1;
  }
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.getValue}`;
  }
}
_a$s = Boolean2;
(() => {
  typeStore.Boolean = _a$s;
})();
Boolean2.NAME = "BOOLEAN";

class LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {
  constructor({ isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.isConstructed = isConstructed;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = 0;
    if (this.isConstructed) {
      this.isHexOnly = false;
      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (let i = 0;i < this.value.length; i++) {
        const currentBlockName = this.value[i].constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== OCTET_STRING_NAME) {
          this.error = "OCTET STRING may consists of OCTET STRINGs only";
          return -1;
        }
      }
    } else {
      this.isHexOnly = true;
      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
      this.blockLength = inputLength;
    }
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed)
      return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
    return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isConstructed: this.isConstructed
    };
  }
}
LocalOctetStringValueBlock.NAME = "OctetStringValueBlock";
var _a$r;

class OctetString extends BaseBlock {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b, _c;
    (_b = parameters.isConstructed) !== null && _b !== undefined || (parameters.isConstructed = !!((_c = parameters.value) === null || _c === undefined ? undefined : _c.length));
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalOctetStringValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 4;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    if (inputLength === 0) {
      if (this.idBlock.error.length === 0)
        this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0)
        this.blockLength += this.lenBlock.blockLength;
      return inputOffset;
    }
    if (!this.valueBlock.isConstructed) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      const buf = view.subarray(inputOffset, inputOffset + inputLength);
      try {
        if (buf.byteLength) {
          const asn = localFromBER(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength) {
            this.valueBlock.value = [asn.result];
          }
        }
      } catch (e) {}
    }
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed.prototype.onAsciiEncoding.call(this);
    }
    return `${this.constructor.NAME} : ${Convert.ToHex(this.valueBlock.valueHexView)}`;
  }
  getValue() {
    if (!this.idBlock.isConstructed) {
      return this.valueBlock.valueHexView.slice().buffer;
    }
    const array = [];
    for (const content of this.valueBlock.value) {
      if (content instanceof OctetString) {
        array.push(content.valueBlock.valueHexView);
      }
    }
    return BufferSourceConverter.concat(array);
  }
}
_a$r = OctetString;
(() => {
  typeStore.OctetString = _a$r;
})();
OctetString.NAME = OCTET_STRING_NAME;

class LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {
  constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.unusedBits = unusedBits;
    this.isConstructed = isConstructed;
    this.blockLength = this.valueHexView.byteLength;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    let resultOffset = -1;
    if (this.isConstructed) {
      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (const value of this.value) {
        const currentBlockName = value.constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== BIT_STRING_NAME) {
          this.error = "BIT STRING may consists of BIT STRINGs only";
          return -1;
        }
        const valueBlock = value.valueBlock;
        if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
          this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
          return -1;
        }
        this.unusedBits = valueBlock.unusedBits;
      }
      return resultOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.unusedBits = intBuffer[0];
    if (this.unusedBits > 7) {
      this.error = "Unused bits for BitString must be in range 0-7";
      return -1;
    }
    if (!this.unusedBits) {
      const buf = intBuffer.subarray(1);
      try {
        if (buf.byteLength) {
          const asn = localFromBER(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength - 1) {
            this.value = [asn.result];
          }
        }
      } catch (e) {}
    }
    this.valueHexView = intBuffer.subarray(1);
    this.blockLength = intBuffer.length;
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed) {
      return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
    }
    if (sizeOnly) {
      return new ArrayBuffer(this.valueHexView.byteLength + 1);
    }
    if (!this.valueHexView.byteLength) {
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(this.valueHexView.length + 1);
    retView[0] = this.unusedBits;
    retView.set(this.valueHexView, 1);
    return retView.buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      unusedBits: this.unusedBits,
      isConstructed: this.isConstructed
    };
  }
}
LocalBitStringValueBlock.NAME = "BitStringValueBlock";
var _a$q;

class BitString extends BaseBlock {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b, _c;
    (_b = parameters.isConstructed) !== null && _b !== undefined || (parameters.isConstructed = !!((_c = parameters.value) === null || _c === undefined ? undefined : _c.length));
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalBitStringValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 3;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed.prototype.onAsciiEncoding.call(this);
    } else {
      const bits = [];
      const valueHex = this.valueBlock.valueHexView;
      for (const byte of valueHex) {
        bits.push(byte.toString(2).padStart(8, "0"));
      }
      const bitsStr = bits.join("");
      return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;
    }
  }
}
_a$q = BitString;
(() => {
  typeStore.BitString = _a$q;
})();
BitString.NAME = BIT_STRING_NAME;
var _a$p;
function viewAdd(first, second) {
  const c = new Uint8Array([0]);
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  let firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value = 0;
  const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
  let counter = 0;
  for (let i = max;i >= 0; i--, counter++) {
    switch (true) {
      case counter < secondViewCopy.length:
        value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
        break;
      default:
        value = firstViewCopy[firstViewCopyLength - counter] + c[0];
    }
    c[0] = value / 10;
    switch (true) {
      case counter >= firstViewCopy.length:
        firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
        break;
      default:
        firstViewCopy[firstViewCopyLength - counter] = value % 10;
    }
  }
  if (c[0] > 0)
    firstViewCopy = utilConcatView(c, firstViewCopy);
  return firstViewCopy;
}
function power2(n) {
  if (n >= powers2.length) {
    for (let p = powers2.length;p <= n; p++) {
      const c = new Uint8Array([0]);
      let digits = powers2[p - 1].slice(0);
      for (let i = digits.length - 1;i >= 0; i--) {
        const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
        c[0] = newValue[0] / 10;
        digits[i] = newValue[0] % 10;
      }
      if (c[0] > 0)
        digits = utilConcatView(c, digits);
      powers2.push(digits);
    }
  }
  return powers2[n];
}
function viewSub(first, second) {
  let b = 0;
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  const firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value;
  let counter = 0;
  for (let i = secondViewCopyLength;i >= 0; i--, counter++) {
    value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
    switch (true) {
      case value < 0:
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
        break;
      default:
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
    }
  }
  if (b > 0) {
    for (let i = firstViewCopyLength - secondViewCopyLength + 1;i >= 0; i--, counter++) {
      value = firstViewCopy[firstViewCopyLength - counter] - b;
      if (value < 0) {
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
      } else {
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
        break;
      }
    }
  }
  return firstViewCopy.slice();
}

class LocalIntegerValueBlock extends HexBlock(ValueBlock) {
  constructor({ value, ...parameters } = {}) {
    super(parameters);
    this._valueDec = 0;
    if (parameters.valueHex) {
      this.setValueHex();
    }
    if (value !== undefined) {
      this.valueDec = value;
    }
  }
  setValueHex() {
    if (this.valueHexView.length >= 4) {
      this.warnings.push("Too big Integer for decoding, hex only");
      this.isHexOnly = true;
      this._valueDec = 0;
    } else {
      this.isHexOnly = false;
      if (this.valueHexView.length > 0) {
        this._valueDec = utilDecodeTC.call(this);
      }
    }
  }
  set valueDec(v) {
    this._valueDec = v;
    this.isHexOnly = false;
    this.valueHexView = new Uint8Array(utilEncodeTC(v));
  }
  get valueDec() {
    return this._valueDec;
  }
  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
    if (offset === -1)
      return offset;
    const view = this.valueHexView;
    if (view[0] === 0 && (view[1] & 128) !== 0) {
      this.valueHexView = view.subarray(1);
    } else {
      if (expectedLength !== 0) {
        if (view.length < expectedLength) {
          if (expectedLength - view.length > 1)
            expectedLength = view.length + 1;
          this.valueHexView = view.subarray(expectedLength - view.length);
        }
      }
    }
    return offset;
  }
  toDER(sizeOnly = false) {
    const view = this.valueHexView;
    switch (true) {
      case (view[0] & 128) !== 0:
        {
          const updatedView = new Uint8Array(this.valueHexView.length + 1);
          updatedView[0] = 0;
          updatedView.set(view, 1);
          this.valueHexView = updatedView;
        }
        break;
      case (view[0] === 0 && (view[1] & 128) === 0):
        {
          this.valueHexView = this.valueHexView.subarray(1);
        }
        break;
    }
    return this.toBER(sizeOnly);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
    if (resultOffset === -1) {
      return resultOffset;
    }
    this.setValueHex();
    return resultOffset;
  }
  toBER(sizeOnly) {
    return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
  toString() {
    const firstBit = this.valueHexView.length * 8 - 1;
    let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
    let bitNumber = 0;
    let currentByte;
    const asn1View = this.valueHexView;
    let result = "";
    let flag = false;
    for (let byteNumber = asn1View.byteLength - 1;byteNumber >= 0; byteNumber--) {
      currentByte = asn1View[byteNumber];
      for (let i = 0;i < 8; i++) {
        if ((currentByte & 1) === 1) {
          switch (bitNumber) {
            case firstBit:
              digits = viewSub(power2(bitNumber), digits);
              result = "-";
              break;
            default:
              digits = viewAdd(digits, power2(bitNumber));
          }
        }
        bitNumber++;
        currentByte >>= 1;
      }
    }
    for (let i = 0;i < digits.length; i++) {
      if (digits[i])
        flag = true;
      if (flag)
        result += digitsString.charAt(digits[i]);
    }
    if (flag === false)
      result += digitsString.charAt(0);
    return result;
  }
}
_a$p = LocalIntegerValueBlock;
LocalIntegerValueBlock.NAME = "IntegerValueBlock";
(() => {
  Object.defineProperty(_a$p.prototype, "valueHex", {
    set: function(v) {
      this.valueHexView = new Uint8Array(v);
      this.setValueHex();
    },
    get: function() {
      return this.valueHexView.slice().buffer;
    }
  });
})();
var _a$o;

class Integer extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalIntegerValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 2;
  }
  toBigInt() {
    assertBigInt();
    return BigInt(this.valueBlock.toString());
  }
  static fromBigInt(value) {
    assertBigInt();
    const bigIntValue = BigInt(value);
    const writer = new ViewWriter;
    const hex = bigIntValue.toString(16).replace(/^-/, "");
    const view = new Uint8Array(Convert.FromHex(hex));
    if (bigIntValue < 0) {
      const first = new Uint8Array(view.length + (view[0] & 128 ? 1 : 0));
      first[0] |= 128;
      const firstInt = BigInt(`0x${Convert.ToHex(first)}`);
      const secondInt = firstInt + bigIntValue;
      const second = BufferSourceConverter.toUint8Array(Convert.FromHex(secondInt.toString(16)));
      second[0] |= 128;
      writer.write(second);
    } else {
      if (view[0] & 128) {
        writer.write(new Uint8Array([0]));
      }
      writer.write(view);
    }
    const res = new Integer({
      valueHex: writer.final()
    });
    return res;
  }
  convertToDER() {
    const integer = new Integer({ valueHex: this.valueBlock.valueHexView });
    integer.valueBlock.toDER();
    return integer;
  }
  convertFromDER() {
    return new Integer({
      valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
    });
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
  }
}
_a$o = Integer;
(() => {
  typeStore.Integer = _a$o;
})();
Integer.NAME = "INTEGER";
var _a$n;

class Enumerated extends Integer {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 10;
  }
}
_a$n = Enumerated;
(() => {
  typeStore.Enumerated = _a$n;
})();
Enumerated.NAME = "ENUMERATED";

class LocalSidValueBlock extends HexBlock(ValueBlock) {
  constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
    this.isFirstSid = isFirstSid;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0;i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0;i < this.blockLength; i++) {
      tempView[i] = this.valueHexView[i];
    }
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  set valueBigInt(value) {
    assertBigInt();
    let bits = BigInt(value).toString(2);
    while (bits.length % 7) {
      bits = "0" + bits;
    }
    const bytes = new Uint8Array(bits.length / 7);
    for (let i = 0;i < bytes.length; i++) {
      bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 128 : 0);
    }
    this.fromBER(bytes.buffer, 0, bytes.length);
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0;i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0;i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      if (this.isFirstSid) {
        let sidValue = this.valueDec;
        if (this.valueDec <= 39)
          result = "0.";
        else {
          if (this.valueDec <= 79) {
            result = "1.";
            sidValue -= 40;
          } else {
            result = "2.";
            sidValue -= 80;
          }
        }
        result += sidValue.toString();
      } else
        result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec,
      isFirstSid: this.isFirstSid
    };
  }
}
LocalSidValueBlock.NAME = "sidBlock";

class LocalObjectIdentifierValueBlock extends ValueBlock {
  constructor({ value = EMPTY_STRING, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalSidValueBlock;
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      if (this.value.length === 0)
        sidBlock.isFirstSid = true;
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly) {
    const retBuffers = [];
    for (let i = 0;i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER;
      }
      retBuffers.push(valueBuf);
    }
    return concat(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    let flag = false;
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      if (flag) {
        const sidBlock = this.value[0];
        let plus = 0;
        switch (sidBlock.valueDec) {
          case 0:
            break;
          case 1:
            plus = 40;
            break;
          case 2:
            plus = 80;
            break;
          default:
            this.value = [];
            return;
        }
        const parsedSID = parseInt(sid, 10);
        if (isNaN(parsedSID))
          return;
        sidBlock.valueDec = parsedSID + plus;
        flag = false;
      } else {
        const sidBlock = new LocalSidValueBlock;
        if (sid > Number.MAX_SAFE_INTEGER) {
          assertBigInt();
          const sidValue = BigInt(sid);
          sidBlock.valueBigInt = sidValue;
        } else {
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec))
            return;
        }
        if (!this.value.length) {
          sidBlock.isFirstSid = true;
          flag = true;
        }
        this.value.push(sidBlock);
      }
    } while (pos2 !== -1);
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0;i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        if (this.value[i].isFirstSid)
          result = `2.{${sidStr} - 80}`;
        else
          result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0;i < this.value.length; i++) {
      object.sidArray.push(this.value[i].toJSON());
    }
    return object;
  }
}
LocalObjectIdentifierValueBlock.NAME = "ObjectIdentifierValueBlock";
var _a$m;

class ObjectIdentifier extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalObjectIdentifierValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 6;
  }
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$m = ObjectIdentifier;
(() => {
  typeStore.ObjectIdentifier = _a$m;
})();
ObjectIdentifier.NAME = "OBJECT IDENTIFIER";

class LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {
  constructor({ valueDec = 0, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (inputLength === 0)
      return inputOffset;
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength))
      return -1;
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0;i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0;i < this.blockLength; i++)
      tempView[i] = this.valueHexView[i];
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0;i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0;i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView.buffer;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
}
LocalRelativeSidValueBlock.NAME = "relativeSidBlock";

class LocalRelativeObjectIdentifierValueBlock extends ValueBlock {
  constructor({ value = EMPTY_STRING, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalRelativeSidValueBlock;
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    const retBuffers = [];
    for (let i = 0;i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER;
      }
      retBuffers.push(valueBuf);
    }
    return concat(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      const sidBlock = new LocalRelativeSidValueBlock;
      sidBlock.valueDec = parseInt(sid, 10);
      if (isNaN(sidBlock.valueDec))
        return true;
      this.value.push(sidBlock);
    } while (pos2 !== -1);
    return true;
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0;i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0;i < this.value.length; i++)
      object.sidArray.push(this.value[i].toJSON());
    return object;
  }
}
LocalRelativeObjectIdentifierValueBlock.NAME = "RelativeObjectIdentifierValueBlock";
var _a$l;

class RelativeObjectIdentifier extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalRelativeObjectIdentifierValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 13;
  }
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$l = RelativeObjectIdentifier;
(() => {
  typeStore.RelativeObjectIdentifier = _a$l;
})();
RelativeObjectIdentifier.NAME = "RelativeObjectIdentifier";
var _a$k;

class Sequence extends Constructed {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 16;
  }
}
_a$k = Sequence;
(() => {
  typeStore.Sequence = _a$k;
})();
Sequence.NAME = "SEQUENCE";
var _a$j;

class Set2 extends Constructed {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 17;
  }
}
_a$j = Set2;
(() => {
  typeStore.Set = _a$j;
})();
Set2.NAME = "SET";

class LocalStringValueBlock extends HexBlock(ValueBlock) {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = true;
    this.value = EMPTY_STRING;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalStringValueBlock.NAME = "StringValueBlock";

class LocalSimpleStringValueBlock extends LocalStringValueBlock {
}
LocalSimpleStringValueBlock.NAME = "SimpleStringValueBlock";

class LocalSimpleStringBlock extends BaseStringBlock {
  constructor({ ...parameters } = {}) {
    super(parameters, LocalSimpleStringValueBlock);
  }
  fromBuffer(inputBuffer) {
    this.valueBlock.value = String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer));
  }
  fromString(inputString) {
    const strLen = inputString.length;
    const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
    for (let i = 0;i < strLen; i++)
      view[i] = inputString.charCodeAt(i);
    this.valueBlock.value = inputString;
  }
}
LocalSimpleStringBlock.NAME = "SIMPLE STRING";

class LocalUtf8StringValueBlock extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
    try {
      this.valueBlock.value = Convert.ToUtf8String(inputBuffer);
    } catch (ex) {
      this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
      this.valueBlock.value = Convert.ToBinary(inputBuffer);
    }
  }
  fromString(inputString) {
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf8String(inputString));
    this.valueBlock.value = inputString;
  }
}
LocalUtf8StringValueBlock.NAME = "Utf8StringValueBlock";
var _a$i;

class Utf8String extends LocalUtf8StringValueBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 12;
  }
}
_a$i = Utf8String;
(() => {
  typeStore.Utf8String = _a$i;
})();
Utf8String.NAME = "UTF8String";

class LocalBmpStringValueBlock extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    this.valueBlock.value = Convert.ToUtf16String(inputBuffer);
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
  }
  fromString(inputString) {
    this.valueBlock.value = inputString;
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf16String(inputString));
  }
}
LocalBmpStringValueBlock.NAME = "BmpStringValueBlock";
var _a$h;

class BmpString extends LocalBmpStringValueBlock {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 30;
  }
}
_a$h = BmpString;
(() => {
  typeStore.BmpString = _a$h;
})();
BmpString.NAME = "BMPString";

class LocalUniversalStringValueBlock extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
    const valueView = new Uint8Array(copyBuffer);
    for (let i = 0;i < valueView.length; i += 4) {
      valueView[i] = valueView[i + 3];
      valueView[i + 1] = valueView[i + 2];
      valueView[i + 2] = 0;
      valueView[i + 3] = 0;
    }
    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
  }
  fromString(inputString) {
    const strLength = inputString.length;
    const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
    for (let i = 0;i < strLength; i++) {
      const codeBuf = utilToBase(inputString.charCodeAt(i), 8);
      const codeView = new Uint8Array(codeBuf);
      if (codeView.length > 4)
        continue;
      const dif = 4 - codeView.length;
      for (let j = codeView.length - 1;j >= 0; j--)
        valueHexView[i * 4 + j + dif] = codeView[j];
    }
    this.valueBlock.value = inputString;
  }
}
LocalUniversalStringValueBlock.NAME = "UniversalStringValueBlock";
var _a$g;

class UniversalString extends LocalUniversalStringValueBlock {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 28;
  }
}
_a$g = UniversalString;
(() => {
  typeStore.UniversalString = _a$g;
})();
UniversalString.NAME = "UniversalString";
var _a$f;

class NumericString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 18;
  }
}
_a$f = NumericString;
(() => {
  typeStore.NumericString = _a$f;
})();
NumericString.NAME = "NumericString";
var _a$e;

class PrintableString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 19;
  }
}
_a$e = PrintableString;
(() => {
  typeStore.PrintableString = _a$e;
})();
PrintableString.NAME = "PrintableString";
var _a$d;

class TeletexString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 20;
  }
}
_a$d = TeletexString;
(() => {
  typeStore.TeletexString = _a$d;
})();
TeletexString.NAME = "TeletexString";
var _a$c;

class VideotexString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 21;
  }
}
_a$c = VideotexString;
(() => {
  typeStore.VideotexString = _a$c;
})();
VideotexString.NAME = "VideotexString";
var _a$b;

class IA5String extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 22;
  }
}
_a$b = IA5String;
(() => {
  typeStore.IA5String = _a$b;
})();
IA5String.NAME = "IA5String";
var _a$a;

class GraphicString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 25;
  }
}
_a$a = GraphicString;
(() => {
  typeStore.GraphicString = _a$a;
})();
GraphicString.NAME = "GraphicString";
var _a$9;

class VisibleString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 26;
  }
}
_a$9 = VisibleString;
(() => {
  typeStore.VisibleString = _a$9;
})();
VisibleString.NAME = "VisibleString";
var _a$8;

class GeneralString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 27;
  }
}
_a$8 = GeneralString;
(() => {
  typeStore.GeneralString = _a$8;
})();
GeneralString.NAME = "GeneralString";
var _a$7;

class CharacterString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 29;
  }
}
_a$7 = CharacterString;
(() => {
  typeStore.CharacterString = _a$7;
})();
CharacterString.NAME = "CharacterString";
var _a$6;

class UTCTime extends VisibleString {
  constructor({ value, valueDate, ...parameters } = {}) {
    super(parameters);
    this.year = 0;
    this.month = 0;
    this.day = 0;
    this.hour = 0;
    this.minute = 0;
    this.second = 0;
    if (value) {
      this.fromString(value);
      this.valueBlock.valueHexView = new Uint8Array(value.length);
      for (let i = 0;i < value.length; i++)
        this.valueBlock.valueHexView[i] = value.charCodeAt(i);
    }
    if (valueDate) {
      this.fromDate(valueDate);
      this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
    }
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 23;
  }
  fromBuffer(inputBuffer) {
    this.fromString(String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer)));
  }
  toBuffer() {
    const str = this.toString();
    const buffer = new ArrayBuffer(str.length);
    const view = new Uint8Array(buffer);
    for (let i = 0;i < str.length; i++)
      view[i] = str.charCodeAt(i);
    return buffer;
  }
  fromDate(inputDate) {
    this.year = inputDate.getUTCFullYear();
    this.month = inputDate.getUTCMonth() + 1;
    this.day = inputDate.getUTCDate();
    this.hour = inputDate.getUTCHours();
    this.minute = inputDate.getUTCMinutes();
    this.second = inputDate.getUTCSeconds();
  }
  toDate() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
  }
  fromString(inputString) {
    const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
    const parserArray = parser.exec(inputString);
    if (parserArray === null) {
      this.error = "Wrong input string for conversion";
      return;
    }
    const year = parseInt(parserArray[1], 10);
    if (year >= 50)
      this.year = 1900 + year;
    else
      this.year = 2000 + year;
    this.month = parseInt(parserArray[2], 10);
    this.day = parseInt(parserArray[3], 10);
    this.hour = parseInt(parserArray[4], 10);
    this.minute = parseInt(parserArray[5], 10);
    this.second = parseInt(parserArray[6], 10);
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = new Array(7);
      outputArray[0] = padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);
      outputArray[1] = padNumber(this.month, 2);
      outputArray[2] = padNumber(this.day, 2);
      outputArray[3] = padNumber(this.hour, 2);
      outputArray[4] = padNumber(this.minute, 2);
      outputArray[5] = padNumber(this.second, 2);
      outputArray[6] = "Z";
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second
    };
  }
}
_a$6 = UTCTime;
(() => {
  typeStore.UTCTime = _a$6;
})();
UTCTime.NAME = "UTCTime";
var _a$5;

class GeneralizedTime extends UTCTime {
  constructor(parameters = {}) {
    var _b;
    super(parameters);
    (_b = this.millisecond) !== null && _b !== undefined || (this.millisecond = 0);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 24;
  }
  fromDate(inputDate) {
    super.fromDate(inputDate);
    this.millisecond = inputDate.getUTCMilliseconds();
  }
  toDate() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));
  }
  fromString(inputString) {
    let isUTC = false;
    let timeString = "";
    let dateTimeString = "";
    let fractionPart = 0;
    let parser;
    let hourDifference = 0;
    let minuteDifference = 0;
    if (inputString[inputString.length - 1] === "Z") {
      timeString = inputString.substring(0, inputString.length - 1);
      isUTC = true;
    } else {
      const number = new Number(inputString[inputString.length - 1]);
      if (isNaN(number.valueOf()))
        throw new Error("Wrong input string for conversion");
      timeString = inputString;
    }
    if (isUTC) {
      if (timeString.indexOf("+") !== -1)
        throw new Error("Wrong input string for conversion");
      if (timeString.indexOf("-") !== -1)
        throw new Error("Wrong input string for conversion");
    } else {
      let multiplier = 1;
      let differencePosition = timeString.indexOf("+");
      let differenceString = "";
      if (differencePosition === -1) {
        differencePosition = timeString.indexOf("-");
        multiplier = -1;
      }
      if (differencePosition !== -1) {
        differenceString = timeString.substring(differencePosition + 1);
        timeString = timeString.substring(0, differencePosition);
        if (differenceString.length !== 2 && differenceString.length !== 4)
          throw new Error("Wrong input string for conversion");
        let number = parseInt(differenceString.substring(0, 2), 10);
        if (isNaN(number.valueOf()))
          throw new Error("Wrong input string for conversion");
        hourDifference = multiplier * number;
        if (differenceString.length === 4) {
          number = parseInt(differenceString.substring(2, 4), 10);
          if (isNaN(number.valueOf()))
            throw new Error("Wrong input string for conversion");
          minuteDifference = multiplier * number;
        }
      }
    }
    let fractionPointPosition = timeString.indexOf(".");
    if (fractionPointPosition === -1)
      fractionPointPosition = timeString.indexOf(",");
    if (fractionPointPosition !== -1) {
      const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
      if (isNaN(fractionPartCheck.valueOf()))
        throw new Error("Wrong input string for conversion");
      fractionPart = fractionPartCheck.valueOf();
      dateTimeString = timeString.substring(0, fractionPointPosition);
    } else
      dateTimeString = timeString;
    switch (true) {
      case dateTimeString.length === 8:
        parser = /(\d{4})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1)
          throw new Error("Wrong input string for conversion");
        break;
      case dateTimeString.length === 10:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.minute = Math.floor(fractionResult);
          fractionResult = 60 * (fractionResult - this.minute);
          this.second = Math.floor(fractionResult);
          fractionResult = 1000 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 12:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.second = Math.floor(fractionResult);
          fractionResult = 1000 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 14:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          const fractionResult = 1000 * fractionPart;
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      default:
        throw new Error("Wrong input string for conversion");
    }
    const parserArray = parser.exec(dateTimeString);
    if (parserArray === null)
      throw new Error("Wrong input string for conversion");
    for (let j = 1;j < parserArray.length; j++) {
      switch (j) {
        case 1:
          this.year = parseInt(parserArray[j], 10);
          break;
        case 2:
          this.month = parseInt(parserArray[j], 10);
          break;
        case 3:
          this.day = parseInt(parserArray[j], 10);
          break;
        case 4:
          this.hour = parseInt(parserArray[j], 10) + hourDifference;
          break;
        case 5:
          this.minute = parseInt(parserArray[j], 10) + minuteDifference;
          break;
        case 6:
          this.second = parseInt(parserArray[j], 10);
          break;
        default:
          throw new Error("Wrong input string for conversion");
      }
    }
    if (isUTC === false) {
      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
      this.year = tempDate.getUTCFullYear();
      this.month = tempDate.getUTCMonth();
      this.day = tempDate.getUTCDay();
      this.hour = tempDate.getUTCHours();
      this.minute = tempDate.getUTCMinutes();
      this.second = tempDate.getUTCSeconds();
      this.millisecond = tempDate.getUTCMilliseconds();
    }
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = [];
      outputArray.push(padNumber(this.year, 4));
      outputArray.push(padNumber(this.month, 2));
      outputArray.push(padNumber(this.day, 2));
      outputArray.push(padNumber(this.hour, 2));
      outputArray.push(padNumber(this.minute, 2));
      outputArray.push(padNumber(this.second, 2));
      if (this.millisecond !== 0) {
        outputArray.push(".");
        outputArray.push(padNumber(this.millisecond, 3));
      }
      outputArray.push("Z");
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  toJSON() {
    return {
      ...super.toJSON(),
      millisecond: this.millisecond
    };
  }
}
_a$5 = GeneralizedTime;
(() => {
  typeStore.GeneralizedTime = _a$5;
})();
GeneralizedTime.NAME = "GeneralizedTime";
var _a$4;

class DATE extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 31;
  }
}
_a$4 = DATE;
(() => {
  typeStore.DATE = _a$4;
})();
DATE.NAME = "DATE";
var _a$3;

class TimeOfDay extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 32;
  }
}
_a$3 = TimeOfDay;
(() => {
  typeStore.TimeOfDay = _a$3;
})();
TimeOfDay.NAME = "TimeOfDay";
var _a$2;

class DateTime extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 33;
  }
}
_a$2 = DateTime;
(() => {
  typeStore.DateTime = _a$2;
})();
DateTime.NAME = "DateTime";
var _a$1;

class Duration extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 34;
  }
}
_a$1 = Duration;
(() => {
  typeStore.Duration = _a$1;
})();
Duration.NAME = "Duration";
var _a;

class TIME extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 14;
  }
}
_a = TIME;
(() => {
  typeStore.TIME = _a;
})();
TIME.NAME = "TIME";

class Any {
  constructor({ name = EMPTY_STRING, optional = false } = {}) {
    this.name = name;
    this.optional = optional;
  }
}

class Choice extends Any {
  constructor({ value = [], ...parameters } = {}) {
    super(parameters);
    this.value = value;
  }
}

class Repeated extends Any {
  constructor({ value = new Any, local = false, ...parameters } = {}) {
    super(parameters);
    this.value = value;
    this.local = local;
  }
}

class RawData {
  constructor({ data = EMPTY_VIEW } = {}) {
    this.dataView = BufferSourceConverter.toUint8Array(data);
  }
  get data() {
    return this.dataView.slice().buffer;
  }
  set data(value) {
    this.dataView = BufferSourceConverter.toUint8Array(value);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const endLength = inputOffset + inputLength;
    this.dataView = BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
    return endLength;
  }
  toBER(sizeOnly) {
    return this.dataView.slice().buffer;
  }
}
function compareSchema(root, inputData, inputSchema) {
  if (inputSchema instanceof Choice) {
    for (let j = 0;j < inputSchema.value.length; j++) {
      const result = compareSchema(root, inputData, inputSchema.value[j]);
      if (result.verified) {
        return {
          verified: true,
          result: root
        };
      }
    }
    {
      const _result = {
        verified: false,
        result: {
          error: "Wrong values for Choice type"
        }
      };
      if (inputSchema.hasOwnProperty(NAME))
        _result.name = inputSchema.name;
      return _result;
    }
  }
  if (inputSchema instanceof Any) {
    if (inputSchema.hasOwnProperty(NAME))
      root[inputSchema.name] = inputData;
    return {
      verified: true,
      result: root
    };
  }
  if (root instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong root object" }
    };
  }
  if (inputData instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 data" }
    };
  }
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (ID_BLOCK in inputSchema === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (FROM_BER in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (TO_BER in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  const encodedId = inputSchema.idBlock.toBER(false);
  if (encodedId.byteLength === 0) {
    return {
      verified: false,
      result: { error: "Error encoding idBlock for ASN.1 schema" }
    };
  }
  const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
  if (decodedOffset === -1) {
    return {
      verified: false,
      result: { error: "Error decoding idBlock for ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
    return {
      verified: false,
      result: root
    };
  }
  if (!(IS_HEX_ONLY in inputSchema.idBlock)) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.isHexOnly) {
    if (VALUE_HEX_VIEW in inputSchema.idBlock === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    const schemaView = inputSchema.idBlock.valueHexView;
    const asn1View = inputData.idBlock.valueHexView;
    if (schemaView.length !== asn1View.length) {
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0;i < schemaView.length; i++) {
      if (schemaView[i] !== asn1View[1]) {
        return {
          verified: false,
          result: root
        };
      }
    }
  }
  if (inputSchema.name) {
    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
    if (inputSchema.name)
      root[inputSchema.name] = inputData;
  }
  if (inputSchema instanceof typeStore.Constructed) {
    let admission = 0;
    let result = {
      verified: false,
      result: {
        error: "Unknown error"
      }
    };
    let maxLength = inputSchema.valueBlock.value.length;
    if (maxLength > 0) {
      if (inputSchema.valueBlock.value[0] instanceof Repeated) {
        maxLength = inputData.valueBlock.value.length;
      }
    }
    if (maxLength === 0) {
      return {
        verified: true,
        result: root
      };
    }
    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
      let _optional = true;
      for (let i = 0;i < inputSchema.valueBlock.value.length; i++)
        _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);
      if (_optional) {
        return {
          verified: true,
          result: root
        };
      }
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name)
          delete root[inputSchema.name];
      }
      root.error = "Inconsistent object length";
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0;i < maxLength; i++) {
      if (i - admission >= inputData.valueBlock.value.length) {
        if (inputSchema.valueBlock.value[i].optional === false) {
          const _result = {
            verified: false,
            result: root
          };
          root.error = "Inconsistent length between ASN.1 data and schema";
          if (inputSchema.name) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
            if (inputSchema.name) {
              delete root[inputSchema.name];
              _result.name = inputSchema.name;
            }
          }
          return _result;
        }
      } else {
        if (inputSchema.valueBlock.value[0] instanceof Repeated) {
          result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[0].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
          if (NAME in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
            let arrayRoot = {};
            if (LOCAL in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local)
              arrayRoot = inputData;
            else
              arrayRoot = root;
            if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
              arrayRoot[inputSchema.valueBlock.value[0].name] = [];
            arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
          }
        } else {
          result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[i].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
        }
      }
    }
    if (result.verified === false) {
      const _result = {
        verified: false,
        result: root
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return {
      verified: true,
      result: root
    };
  }
  if (inputSchema.primitiveSchema && VALUE_HEX_VIEW in inputData.valueBlock) {
    const asn1 = localFromBER(inputData.valueBlock.valueHexView);
    if (asn1.offset === -1) {
      const _result = {
        verified: false,
        result: asn1.result
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return compareSchema(root, asn1.result, inputSchema.primitiveSchema);
  }
  return {
    verified: true,
    result: root
  };
}
function verifySchema(inputBuffer, inputSchema) {
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema type" }
    };
  }
  const asn1 = localFromBER(BufferSourceConverter.toUint8Array(inputBuffer));
  if (asn1.offset === -1) {
    return {
      verified: false,
      result: asn1.result
    };
  }
  return compareSchema(asn1.result, asn1.result, inputSchema);
}

// node_modules/@peculiar/asn1-schema/build/es2015/enums.js
var AsnTypeTypes;
(function(AsnTypeTypes2) {
  AsnTypeTypes2[AsnTypeTypes2["Sequence"] = 0] = "Sequence";
  AsnTypeTypes2[AsnTypeTypes2["Set"] = 1] = "Set";
  AsnTypeTypes2[AsnTypeTypes2["Choice"] = 2] = "Choice";
})(AsnTypeTypes || (AsnTypeTypes = {}));
var AsnPropTypes;
(function(AsnPropTypes2) {
  AsnPropTypes2[AsnPropTypes2["Any"] = 1] = "Any";
  AsnPropTypes2[AsnPropTypes2["Boolean"] = 2] = "Boolean";
  AsnPropTypes2[AsnPropTypes2["OctetString"] = 3] = "OctetString";
  AsnPropTypes2[AsnPropTypes2["BitString"] = 4] = "BitString";
  AsnPropTypes2[AsnPropTypes2["Integer"] = 5] = "Integer";
  AsnPropTypes2[AsnPropTypes2["Enumerated"] = 6] = "Enumerated";
  AsnPropTypes2[AsnPropTypes2["ObjectIdentifier"] = 7] = "ObjectIdentifier";
  AsnPropTypes2[AsnPropTypes2["Utf8String"] = 8] = "Utf8String";
  AsnPropTypes2[AsnPropTypes2["BmpString"] = 9] = "BmpString";
  AsnPropTypes2[AsnPropTypes2["UniversalString"] = 10] = "UniversalString";
  AsnPropTypes2[AsnPropTypes2["NumericString"] = 11] = "NumericString";
  AsnPropTypes2[AsnPropTypes2["PrintableString"] = 12] = "PrintableString";
  AsnPropTypes2[AsnPropTypes2["TeletexString"] = 13] = "TeletexString";
  AsnPropTypes2[AsnPropTypes2["VideotexString"] = 14] = "VideotexString";
  AsnPropTypes2[AsnPropTypes2["IA5String"] = 15] = "IA5String";
  AsnPropTypes2[AsnPropTypes2["GraphicString"] = 16] = "GraphicString";
  AsnPropTypes2[AsnPropTypes2["VisibleString"] = 17] = "VisibleString";
  AsnPropTypes2[AsnPropTypes2["GeneralString"] = 18] = "GeneralString";
  AsnPropTypes2[AsnPropTypes2["CharacterString"] = 19] = "CharacterString";
  AsnPropTypes2[AsnPropTypes2["UTCTime"] = 20] = "UTCTime";
  AsnPropTypes2[AsnPropTypes2["GeneralizedTime"] = 21] = "GeneralizedTime";
  AsnPropTypes2[AsnPropTypes2["DATE"] = 22] = "DATE";
  AsnPropTypes2[AsnPropTypes2["TimeOfDay"] = 23] = "TimeOfDay";
  AsnPropTypes2[AsnPropTypes2["DateTime"] = 24] = "DateTime";
  AsnPropTypes2[AsnPropTypes2["Duration"] = 25] = "Duration";
  AsnPropTypes2[AsnPropTypes2["TIME"] = 26] = "TIME";
  AsnPropTypes2[AsnPropTypes2["Null"] = 27] = "Null";
})(AsnPropTypes || (AsnPropTypes = {}));

// node_modules/@peculiar/asn1-schema/build/es2015/types/bit_string.js
class BitString2 {
  constructor(params, unusedBits = 0) {
    this.unusedBits = 0;
    this.value = new ArrayBuffer(0);
    if (params) {
      if (typeof params === "number") {
        this.fromNumber(params);
      } else if (BufferSourceConverter.isBufferSource(params)) {
        this.unusedBits = unusedBits;
        this.value = BufferSourceConverter.toArrayBuffer(params);
      } else {
        throw TypeError("Unsupported type of 'params' argument for BitString");
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof BitString)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 BitString");
    }
    this.unusedBits = asn.valueBlock.unusedBits;
    this.value = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new BitString({ unusedBits: this.unusedBits, valueHex: this.value });
  }
  toSchema(name) {
    return new BitString({ name });
  }
  toNumber() {
    let res = "";
    const uintArray = new Uint8Array(this.value);
    for (const octet of uintArray) {
      res += octet.toString(2).padStart(8, "0");
    }
    res = res.split("").reverse().join("");
    if (this.unusedBits) {
      res = res.slice(this.unusedBits).padStart(this.unusedBits, "0");
    }
    return parseInt(res, 2);
  }
  fromNumber(value) {
    let bits = value.toString(2);
    const octetSize = bits.length + 7 >> 3;
    this.unusedBits = (octetSize << 3) - bits.length;
    const octets = new Uint8Array(octetSize);
    bits = bits.padStart(octetSize << 3, "0").split("").reverse().join("");
    let index = 0;
    while (index < octetSize) {
      octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);
      index++;
    }
    this.value = octets.buffer;
  }
}
// node_modules/@peculiar/asn1-schema/build/es2015/types/octet_string.js
class OctetString2 {
  get byteLength() {
    return this.buffer.byteLength;
  }
  get byteOffset() {
    return 0;
  }
  constructor(param) {
    if (typeof param === "number") {
      this.buffer = new ArrayBuffer(param);
    } else {
      if (BufferSourceConverter.isBufferSource(param)) {
        this.buffer = BufferSourceConverter.toArrayBuffer(param);
      } else if (Array.isArray(param)) {
        this.buffer = new Uint8Array(param);
      } else {
        this.buffer = new ArrayBuffer(0);
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof OctetString)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString");
    }
    this.buffer = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new OctetString({ valueHex: this.buffer });
  }
  toSchema(name) {
    return new OctetString({ name });
  }
}
// node_modules/@peculiar/asn1-schema/build/es2015/converters.js
var AsnAnyConverter = {
  fromASN: (value) => value instanceof Null ? null : value.valueBeforeDecodeView,
  toASN: (value) => {
    if (value === null) {
      return new Null;
    }
    const schema = fromBER(value);
    if (schema.result.error) {
      throw new Error(schema.result.error);
    }
    return schema.result;
  }
};
var AsnIntegerConverter = {
  fromASN: (value) => value.valueBlock.valueHexView.byteLength >= 4 ? value.valueBlock.toString() : value.valueBlock.valueDec,
  toASN: (value) => new Integer({ value: +value })
};
var AsnEnumeratedConverter = {
  fromASN: (value) => value.valueBlock.valueDec,
  toASN: (value) => new Enumerated({ value })
};
var AsnIntegerArrayBufferConverter = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new Integer({ valueHex: value })
};
var AsnBitStringConverter = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new BitString({ valueHex: value })
};
var AsnObjectIdentifierConverter = {
  fromASN: (value) => value.valueBlock.toString(),
  toASN: (value) => new ObjectIdentifier({ value })
};
var AsnBooleanConverter = {
  fromASN: (value) => value.valueBlock.value,
  toASN: (value) => new Boolean2({ value })
};
var AsnOctetStringConverter = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new OctetString({ valueHex: value })
};
function createStringConverter(Asn1Type) {
  return {
    fromASN: (value) => value.valueBlock.value,
    toASN: (value) => new Asn1Type({ value })
  };
}
var AsnUtf8StringConverter = createStringConverter(Utf8String);
var AsnBmpStringConverter = createStringConverter(BmpString);
var AsnUniversalStringConverter = createStringConverter(UniversalString);
var AsnNumericStringConverter = createStringConverter(NumericString);
var AsnPrintableStringConverter = createStringConverter(PrintableString);
var AsnTeletexStringConverter = createStringConverter(TeletexString);
var AsnVideotexStringConverter = createStringConverter(VideotexString);
var AsnIA5StringConverter = createStringConverter(IA5String);
var AsnGraphicStringConverter = createStringConverter(GraphicString);
var AsnVisibleStringConverter = createStringConverter(VisibleString);
var AsnGeneralStringConverter = createStringConverter(GeneralString);
var AsnCharacterStringConverter = createStringConverter(CharacterString);
var AsnUTCTimeConverter = {
  fromASN: (value) => value.toDate(),
  toASN: (value) => new UTCTime({ valueDate: value })
};
var AsnGeneralizedTimeConverter = {
  fromASN: (value) => value.toDate(),
  toASN: (value) => new GeneralizedTime({ valueDate: value })
};
var AsnNullConverter = {
  fromASN: () => null,
  toASN: () => {
    return new Null;
  }
};
function defaultConverter(type) {
  switch (type) {
    case AsnPropTypes.Any:
      return AsnAnyConverter;
    case AsnPropTypes.BitString:
      return AsnBitStringConverter;
    case AsnPropTypes.BmpString:
      return AsnBmpStringConverter;
    case AsnPropTypes.Boolean:
      return AsnBooleanConverter;
    case AsnPropTypes.CharacterString:
      return AsnCharacterStringConverter;
    case AsnPropTypes.Enumerated:
      return AsnEnumeratedConverter;
    case AsnPropTypes.GeneralString:
      return AsnGeneralStringConverter;
    case AsnPropTypes.GeneralizedTime:
      return AsnGeneralizedTimeConverter;
    case AsnPropTypes.GraphicString:
      return AsnGraphicStringConverter;
    case AsnPropTypes.IA5String:
      return AsnIA5StringConverter;
    case AsnPropTypes.Integer:
      return AsnIntegerConverter;
    case AsnPropTypes.Null:
      return AsnNullConverter;
    case AsnPropTypes.NumericString:
      return AsnNumericStringConverter;
    case AsnPropTypes.ObjectIdentifier:
      return AsnObjectIdentifierConverter;
    case AsnPropTypes.OctetString:
      return AsnOctetStringConverter;
    case AsnPropTypes.PrintableString:
      return AsnPrintableStringConverter;
    case AsnPropTypes.TeletexString:
      return AsnTeletexStringConverter;
    case AsnPropTypes.UTCTime:
      return AsnUTCTimeConverter;
    case AsnPropTypes.UniversalString:
      return AsnUniversalStringConverter;
    case AsnPropTypes.Utf8String:
      return AsnUtf8StringConverter;
    case AsnPropTypes.VideotexString:
      return AsnVideotexStringConverter;
    case AsnPropTypes.VisibleString:
      return AsnVisibleStringConverter;
    default:
      return null;
  }
}
// node_modules/@peculiar/asn1-schema/build/es2015/helper.js
function isConvertible(target) {
  if (typeof target === "function" && target.prototype) {
    if (target.prototype.toASN && target.prototype.fromASN) {
      return true;
    } else {
      return isConvertible(target.prototype);
    }
  } else {
    return !!(target && typeof target === "object" && ("toASN" in target) && ("fromASN" in target));
  }
}
function isTypeOfArray(target) {
  var _a2;
  if (target) {
    const proto = Object.getPrototypeOf(target);
    if (((_a2 = proto === null || proto === undefined ? undefined : proto.prototype) === null || _a2 === undefined ? undefined : _a2.constructor) === Array) {
      return true;
    }
    return isTypeOfArray(proto);
  }
  return false;
}
function isArrayEqual(bytes1, bytes2) {
  if (!(bytes1 && bytes2)) {
    return false;
  }
  if (bytes1.byteLength !== bytes2.byteLength) {
    return false;
  }
  const b1 = new Uint8Array(bytes1);
  const b2 = new Uint8Array(bytes2);
  for (let i = 0;i < bytes1.byteLength; i++) {
    if (b1[i] !== b2[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@peculiar/asn1-schema/build/es2015/schema.js
class AsnSchemaStorage {
  constructor() {
    this.items = new WeakMap;
  }
  has(target) {
    return this.items.has(target);
  }
  get(target, checkSchema = false) {
    const schema = this.items.get(target);
    if (!schema) {
      throw new Error(`Cannot get schema for '${target.prototype.constructor.name}' target`);
    }
    if (checkSchema && !schema.schema) {
      throw new Error(`Schema '${target.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);
    }
    return schema;
  }
  cache(target) {
    const schema = this.get(target);
    if (!schema.schema) {
      schema.schema = this.create(target, true);
    }
  }
  createDefault(target) {
    const schema = {
      type: AsnTypeTypes.Sequence,
      items: {}
    };
    const parentSchema = this.findParentSchema(target);
    if (parentSchema) {
      Object.assign(schema, parentSchema);
      schema.items = Object.assign({}, schema.items, parentSchema.items);
    }
    return schema;
  }
  create(target, useNames) {
    const schema = this.items.get(target) || this.createDefault(target);
    const asn1Value = [];
    for (const key in schema.items) {
      const item = schema.items[key];
      const name = useNames ? key : "";
      let asn1Item;
      if (typeof item.type === "number") {
        const Asn1TypeName = AsnPropTypes[item.type];
        const Asn1Type = exports_index_es[Asn1TypeName];
        if (!Asn1Type) {
          throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
        }
        asn1Item = new Asn1Type({ name });
      } else if (isConvertible(item.type)) {
        const instance = new item.type;
        asn1Item = instance.toSchema(name);
      } else if (item.optional) {
        const itemSchema = this.get(item.type);
        if (itemSchema.type === AsnTypeTypes.Choice) {
          asn1Item = new Any({ name });
        } else {
          asn1Item = this.create(item.type, false);
          asn1Item.name = name;
        }
      } else {
        asn1Item = new Any({ name });
      }
      const optional = !!item.optional || item.defaultValue !== undefined;
      if (item.repeated) {
        asn1Item.name = "";
        const Container = item.repeated === "set" ? Set2 : Sequence;
        asn1Item = new Container({
          name: "",
          value: [
            new Repeated({
              name,
              value: asn1Item
            })
          ]
        });
      }
      if (item.context !== null && item.context !== undefined) {
        if (item.implicit) {
          if (typeof item.type === "number" || isConvertible(item.type)) {
            const Container = item.repeated ? Constructed : Primitive;
            asn1Value.push(new Container({
              name,
              optional,
              idBlock: {
                tagClass: 3,
                tagNumber: item.context
              }
            }));
          } else {
            this.cache(item.type);
            const isRepeated = !!item.repeated;
            let value = !isRepeated ? this.get(item.type, true).schema : asn1Item;
            value = "valueBlock" in value ? value.valueBlock.value : value.value;
            asn1Value.push(new Constructed({
              name: !isRepeated ? name : "",
              optional,
              idBlock: {
                tagClass: 3,
                tagNumber: item.context
              },
              value
            }));
          }
        } else {
          asn1Value.push(new Constructed({
            optional,
            idBlock: {
              tagClass: 3,
              tagNumber: item.context
            },
            value: [asn1Item]
          }));
        }
      } else {
        asn1Item.optional = optional;
        asn1Value.push(asn1Item);
      }
    }
    switch (schema.type) {
      case AsnTypeTypes.Sequence:
        return new Sequence({ value: asn1Value, name: "" });
      case AsnTypeTypes.Set:
        return new Set2({ value: asn1Value, name: "" });
      case AsnTypeTypes.Choice:
        return new Choice({ value: asn1Value, name: "" });
      default:
        throw new Error(`Unsupported ASN1 type in use`);
    }
  }
  set(target, schema) {
    this.items.set(target, schema);
    return this;
  }
  findParentSchema(target) {
    const parent = Object.getPrototypeOf(target);
    if (parent) {
      const schema = this.items.get(parent);
      return schema || this.findParentSchema(parent);
    }
    return null;
  }
}

// node_modules/@peculiar/asn1-schema/build/es2015/storage.js
var schemaStorage = new AsnSchemaStorage;

// node_modules/@peculiar/asn1-schema/build/es2015/decorators.js
var AsnType = (options) => (target) => {
  let schema;
  if (!schemaStorage.has(target)) {
    schema = schemaStorage.createDefault(target);
    schemaStorage.set(target, schema);
  } else {
    schema = schemaStorage.get(target);
  }
  Object.assign(schema, options);
};
var AsnProp = (options) => (target, propertyKey) => {
  let schema;
  if (!schemaStorage.has(target.constructor)) {
    schema = schemaStorage.createDefault(target.constructor);
    schemaStorage.set(target.constructor, schema);
  } else {
    schema = schemaStorage.get(target.constructor);
  }
  const copyOptions = Object.assign({}, options);
  if (typeof copyOptions.type === "number" && !copyOptions.converter) {
    const defaultConverter2 = defaultConverter(options.type);
    if (!defaultConverter2) {
      throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target.constructor.name}`);
    }
    copyOptions.converter = defaultConverter2;
  }
  schema.items[propertyKey] = copyOptions;
};
// node_modules/@peculiar/asn1-schema/build/es2015/errors/schema_validation.js
class AsnSchemaValidationError extends Error {
  constructor() {
    super(...arguments);
    this.schemas = [];
  }
}
// node_modules/@peculiar/asn1-schema/build/es2015/parser.js
class AsnParser {
  static parse(data, target) {
    const asn1Parsed = fromBER(data);
    if (asn1Parsed.result.error) {
      throw new Error(asn1Parsed.result.error);
    }
    const res = this.fromASN(asn1Parsed.result, target);
    return res;
  }
  static fromASN(asn1Schema, target) {
    var _a2;
    try {
      if (isConvertible(target)) {
        const value = new target;
        return value.fromASN(asn1Schema);
      }
      const schema = schemaStorage.get(target);
      schemaStorage.cache(target);
      let targetSchema = schema.schema;
      if (asn1Schema.constructor === Constructed && schema.type !== AsnTypeTypes.Choice) {
        targetSchema = new Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: asn1Schema.idBlock.tagNumber
          },
          value: schema.schema.valueBlock.value
        });
        for (const key in schema.items) {
          delete asn1Schema[key];
        }
      }
      const asn1ComparedSchema = compareSchema({}, asn1Schema, targetSchema);
      if (!asn1ComparedSchema.verified) {
        throw new AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);
      }
      const res = new target;
      if (isTypeOfArray(target)) {
        if (!(("value" in asn1Schema.valueBlock) && Array.isArray(asn1Schema.valueBlock.value))) {
          throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);
        }
        const itemType = schema.itemType;
        if (typeof itemType === "number") {
          const converter = defaultConverter(itemType);
          if (!converter) {
            throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
          }
          return target.from(asn1Schema.valueBlock.value, (element) => converter.fromASN(element));
        } else {
          return target.from(asn1Schema.valueBlock.value, (element) => this.fromASN(element, itemType));
        }
      }
      for (const key in schema.items) {
        const asn1SchemaValue = asn1ComparedSchema.result[key];
        if (!asn1SchemaValue) {
          continue;
        }
        const schemaItem = schema.items[key];
        const schemaItemType = schemaItem.type;
        if (typeof schemaItemType === "number" || isConvertible(schemaItemType)) {
          const converter = (_a2 = schemaItem.converter) !== null && _a2 !== undefined ? _a2 : isConvertible(schemaItemType) ? new schemaItemType : null;
          if (!converter) {
            throw new Error("Converter is empty");
          }
          if (schemaItem.repeated) {
            if (schemaItem.implicit) {
              const Container = schemaItem.repeated === "sequence" ? Sequence : Set2;
              const newItem = new Container;
              newItem.valueBlock = asn1SchemaValue.valueBlock;
              const newItemAsn = fromBER(newItem.toBER(false));
              if (newItemAsn.offset === -1) {
                throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);
              }
              if (!(("value" in newItemAsn.result.valueBlock) && Array.isArray(newItemAsn.result.valueBlock.value))) {
                throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");
              }
              const value = newItemAsn.result.valueBlock.value;
              res[key] = Array.from(value, (element) => converter.fromASN(element));
            } else {
              res[key] = Array.from(asn1SchemaValue, (element) => converter.fromASN(element));
            }
          } else {
            let value = asn1SchemaValue;
            if (schemaItem.implicit) {
              let newItem;
              if (isConvertible(schemaItemType)) {
                newItem = new schemaItemType().toSchema("");
              } else {
                const Asn1TypeName = AsnPropTypes[schemaItemType];
                const Asn1Type = exports_index_es[Asn1TypeName];
                if (!Asn1Type) {
                  throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);
                }
                newItem = new Asn1Type;
              }
              newItem.valueBlock = value.valueBlock;
              value = fromBER(newItem.toBER(false)).result;
            }
            res[key] = converter.fromASN(value);
          }
        } else {
          if (schemaItem.repeated) {
            if (!Array.isArray(asn1SchemaValue)) {
              throw new Error("Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.");
            }
            res[key] = Array.from(asn1SchemaValue, (element) => this.fromASN(element, schemaItemType));
          } else {
            res[key] = this.fromASN(asn1SchemaValue, schemaItemType);
          }
        }
      }
      return res;
    } catch (error) {
      if (error instanceof AsnSchemaValidationError) {
        error.schemas.push(target.name);
      }
      throw error;
    }
  }
}
// node_modules/@peculiar/asn1-schema/build/es2015/serializer.js
class AsnSerializer {
  static serialize(obj) {
    if (obj instanceof BaseBlock) {
      return obj.toBER(false);
    }
    return this.toASN(obj).toBER(false);
  }
  static toASN(obj) {
    if (obj && typeof obj === "object" && isConvertible(obj)) {
      return obj.toASN();
    }
    if (!(obj && typeof obj === "object")) {
      throw new TypeError("Parameter 1 should be type of Object.");
    }
    const target = obj.constructor;
    const schema = schemaStorage.get(target);
    schemaStorage.cache(target);
    let asn1Value = [];
    if (schema.itemType) {
      if (!Array.isArray(obj)) {
        throw new TypeError("Parameter 1 should be type of Array.");
      }
      if (typeof schema.itemType === "number") {
        const converter = defaultConverter(schema.itemType);
        if (!converter) {
          throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
        }
        asn1Value = obj.map((o) => converter.toASN(o));
      } else {
        asn1Value = obj.map((o) => this.toAsnItem({ type: schema.itemType }, "[]", target, o));
      }
    } else {
      for (const key in schema.items) {
        const schemaItem = schema.items[key];
        const objProp = obj[key];
        if (objProp === undefined || schemaItem.defaultValue === objProp || typeof schemaItem.defaultValue === "object" && typeof objProp === "object" && isArrayEqual(this.serialize(schemaItem.defaultValue), this.serialize(objProp))) {
          continue;
        }
        const asn1Item = AsnSerializer.toAsnItem(schemaItem, key, target, objProp);
        if (typeof schemaItem.context === "number") {
          if (schemaItem.implicit) {
            if (!schemaItem.repeated && (typeof schemaItem.type === "number" || isConvertible(schemaItem.type))) {
              const value = {};
              value.valueHex = asn1Item instanceof Null ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();
              asn1Value.push(new Primitive({
                optional: schemaItem.optional,
                idBlock: {
                  tagClass: 3,
                  tagNumber: schemaItem.context
                },
                ...value
              }));
            } else {
              asn1Value.push(new Constructed({
                optional: schemaItem.optional,
                idBlock: {
                  tagClass: 3,
                  tagNumber: schemaItem.context
                },
                value: asn1Item.valueBlock.value
              }));
            }
          } else {
            asn1Value.push(new Constructed({
              optional: schemaItem.optional,
              idBlock: {
                tagClass: 3,
                tagNumber: schemaItem.context
              },
              value: [asn1Item]
            }));
          }
        } else if (schemaItem.repeated) {
          asn1Value = asn1Value.concat(asn1Item);
        } else {
          asn1Value.push(asn1Item);
        }
      }
    }
    let asnSchema;
    switch (schema.type) {
      case AsnTypeTypes.Sequence:
        asnSchema = new Sequence({ value: asn1Value });
        break;
      case AsnTypeTypes.Set:
        asnSchema = new Set2({ value: asn1Value });
        break;
      case AsnTypeTypes.Choice:
        if (!asn1Value[0]) {
          throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);
        }
        asnSchema = asn1Value[0];
        break;
    }
    return asnSchema;
  }
  static toAsnItem(schemaItem, key, target, objProp) {
    let asn1Item;
    if (typeof schemaItem.type === "number") {
      const converter = schemaItem.converter;
      if (!converter) {
        throw new Error(`Property '${key}' doesn't have converter for type ${AsnPropTypes[schemaItem.type]} in schema '${target.name}'`);
      }
      if (schemaItem.repeated) {
        if (!Array.isArray(objProp)) {
          throw new TypeError("Parameter 'objProp' should be type of Array.");
        }
        const items = Array.from(objProp, (element) => converter.toASN(element));
        const Container = schemaItem.repeated === "sequence" ? Sequence : Set2;
        asn1Item = new Container({
          value: items
        });
      } else {
        asn1Item = converter.toASN(objProp);
      }
    } else {
      if (schemaItem.repeated) {
        if (!Array.isArray(objProp)) {
          throw new TypeError("Parameter 'objProp' should be type of Array.");
        }
        const items = Array.from(objProp, (element) => this.toASN(element));
        const Container = schemaItem.repeated === "sequence" ? Sequence : Set2;
        asn1Item = new Container({
          value: items
        });
      } else {
        asn1Item = this.toASN(objProp);
      }
    }
    return asn1Item;
  }
}
// node_modules/@peculiar/asn1-schema/build/es2015/objects.js
class AsnArray extends Array {
  constructor(items = []) {
    if (typeof items === "number") {
      super(items);
    } else {
      super();
      for (const item of items) {
        this.push(item);
      }
    }
  }
}
// node_modules/@peculiar/asn1-schema/build/es2015/convert.js
class AsnConvert {
  static serialize(obj) {
    return AsnSerializer.serialize(obj);
  }
  static parse(data, target) {
    return AsnParser.parse(data, target);
  }
  static toString(data) {
    const buf = BufferSourceConverter.isBufferSource(data) ? BufferSourceConverter.toArrayBuffer(data) : AsnConvert.serialize(data);
    const asn = fromBER(buf);
    if (asn.offset === -1) {
      throw new Error(`Cannot decode ASN.1 data. ${asn.result.error}`);
    }
    return asn.result.toString();
  }
}
// node_modules/tslib/modules/index.js
var import_tslib = __toESM(require_tslib(), 1);
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension
} = import_tslib.default;

// node_modules/@peculiar/asn1-x509/build/es2015/ip_converter.js
var ip = __toESM(require_ipaddr(), 1);
class IpConverter {
  static decodeIP(value) {
    if (value.length === 64 && parseInt(value, 16) === 0) {
      return "::/0";
    }
    if (value.length !== 16) {
      return value;
    }
    const mask = parseInt(value.slice(8), 16).toString(2).split("").reduce((a, k) => a + +k, 0);
    let ip2 = value.slice(0, 8).replace(/(.{2})/g, (match2) => `${parseInt(match2, 16)}.`);
    ip2 = ip2.slice(0, -1);
    return `${ip2}/${mask}`;
  }
  static toString(buf) {
    if (buf.byteLength === 4 || buf.byteLength === 16) {
      const uint8 = new Uint8Array(buf);
      const addr = ip.fromByteArray(Array.from(uint8));
      return addr.toString();
    }
    return this.decodeIP(Convert.ToHex(buf));
  }
  static fromString(text) {
    const addr = ip.parse(text);
    return new Uint8Array(addr.toByteArray()).buffer;
  }
}

// node_modules/@peculiar/asn1-x509/build/es2015/name.js
var RelativeDistinguishedName_1;
var RDNSequence_1;
var Name_1;
var DirectoryString = class DirectoryString2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.bmpString || this.printableString || this.teletexString || this.universalString || this.utf8String || "";
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.TeletexString })
], DirectoryString.prototype, "teletexString", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.PrintableString })
], DirectoryString.prototype, "printableString", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.UniversalString })
], DirectoryString.prototype, "universalString", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Utf8String })
], DirectoryString.prototype, "utf8String", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.BmpString })
], DirectoryString.prototype, "bmpString", undefined);
DirectoryString = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], DirectoryString);
var AttributeValue = class AttributeValue2 extends DirectoryString {
  constructor(params = {}) {
    super(params);
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || (this.anyValue ? Convert.ToHex(this.anyValue) : super.toString());
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.IA5String })
], AttributeValue.prototype, "ia5String", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Any })
], AttributeValue.prototype, "anyValue", undefined);
AttributeValue = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], AttributeValue);
class AttributeTypeAndValue {
  constructor(params = {}) {
    this.type = "";
    this.value = new AttributeValue;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], AttributeTypeAndValue.prototype, "type", undefined);
__decorate([
  AsnProp({ type: AttributeValue })
], AttributeTypeAndValue.prototype, "value", undefined);
var RelativeDistinguishedName = RelativeDistinguishedName_1 = class RelativeDistinguishedName2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RelativeDistinguishedName_1.prototype);
  }
};
RelativeDistinguishedName = RelativeDistinguishedName_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Set, itemType: AttributeTypeAndValue })
], RelativeDistinguishedName);
var RDNSequence = RDNSequence_1 = class RDNSequence2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RDNSequence_1.prototype);
  }
};
RDNSequence = RDNSequence_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: RelativeDistinguishedName })
], RDNSequence);
var Name = Name_1 = class Name2 extends RDNSequence {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Name_1.prototype);
  }
};
Name = Name_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence })
], Name);

// node_modules/@peculiar/asn1-x509/build/es2015/general_name.js
var AsnIpConverter = {
  fromASN: (value) => IpConverter.toString(AsnOctetStringConverter.fromASN(value)),
  toASN: (value) => AsnOctetStringConverter.toASN(IpConverter.fromString(value))
};

class OtherName {
  constructor(params = {}) {
    this.typeId = "";
    this.value = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], OtherName.prototype, "typeId", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Any, context: 0 })
], OtherName.prototype, "value", undefined);

class EDIPartyName {
  constructor(params = {}) {
    this.partyName = new DirectoryString;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: DirectoryString, optional: true, context: 0, implicit: true })
], EDIPartyName.prototype, "nameAssigner", undefined);
__decorate([
  AsnProp({ type: DirectoryString, context: 1, implicit: true })
], EDIPartyName.prototype, "partyName", undefined);
var GeneralName = class GeneralName2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: OtherName, context: 0, implicit: true })
], GeneralName.prototype, "otherName", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.IA5String, context: 1, implicit: true })
], GeneralName.prototype, "rfc822Name", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.IA5String, context: 2, implicit: true })
], GeneralName.prototype, "dNSName", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Any, context: 3, implicit: true })
], GeneralName.prototype, "x400Address", undefined);
__decorate([
  AsnProp({ type: Name, context: 4, implicit: false })
], GeneralName.prototype, "directoryName", undefined);
__decorate([
  AsnProp({ type: EDIPartyName, context: 5 })
], GeneralName.prototype, "ediPartyName", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.IA5String, context: 6, implicit: true })
], GeneralName.prototype, "uniformResourceIdentifier", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.OctetString, context: 7, implicit: true, converter: AsnIpConverter })
], GeneralName.prototype, "iPAddress", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier, context: 8, implicit: true })
], GeneralName.prototype, "registeredID", undefined);
GeneralName = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], GeneralName);

// node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js
var id_pkix = "1.3.6.1.5.5.7";
var id_pe = `${id_pkix}.1`;
var id_qt = `${id_pkix}.2`;
var id_kp = `${id_pkix}.3`;
var id_ad = `${id_pkix}.48`;
var id_qt_csp = `${id_qt}.1`;
var id_qt_unotice = `${id_qt}.2`;
var id_ad_ocsp = `${id_ad}.1`;
var id_ad_caIssuers = `${id_ad}.2`;
var id_ad_timeStamping = `${id_ad}.3`;
var id_ad_caRepository = `${id_ad}.5`;
var id_ce = "2.5.29";

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_information_access.js
var AuthorityInfoAccessSyntax_1;
var id_pe_authorityInfoAccess = `${id_pe}.1`;

class AccessDescription {
  constructor(params = {}) {
    this.accessMethod = "";
    this.accessLocation = new GeneralName;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], AccessDescription.prototype, "accessMethod", undefined);
__decorate([
  AsnProp({ type: GeneralName })
], AccessDescription.prototype, "accessLocation", undefined);
var AuthorityInfoAccessSyntax = AuthorityInfoAccessSyntax_1 = class AuthorityInfoAccessSyntax2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, AuthorityInfoAccessSyntax_1.prototype);
  }
};
AuthorityInfoAccessSyntax = AuthorityInfoAccessSyntax_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: AccessDescription })
], AuthorityInfoAccessSyntax);
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_key_identifier.js
var id_ce_authorityKeyIdentifier = `${id_ce}.35`;

class KeyIdentifier extends OctetString2 {
}

class AuthorityKeyIdentifier {
  constructor(params = {}) {
    if (params) {
      Object.assign(this, params);
    }
  }
}
__decorate([
  AsnProp({ type: KeyIdentifier, context: 0, optional: true, implicit: true })
], AuthorityKeyIdentifier.prototype, "keyIdentifier", undefined);
__decorate([
  AsnProp({ type: GeneralName, context: 1, optional: true, implicit: true, repeated: "sequence" })
], AuthorityKeyIdentifier.prototype, "authorityCertIssuer", undefined);
__decorate([
  AsnProp({
    type: AsnPropTypes.Integer,
    context: 2,
    optional: true,
    implicit: true,
    converter: AsnIntegerArrayBufferConverter
  })
], AuthorityKeyIdentifier.prototype, "authorityCertSerialNumber", undefined);
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/basic_constraints.js
var id_ce_basicConstraints = `${id_ce}.19`;

class BasicConstraints {
  constructor(params = {}) {
    this.cA = false;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Boolean, defaultValue: false })
], BasicConstraints.prototype, "cA", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, optional: true })
], BasicConstraints.prototype, "pathLenConstraint", undefined);
// node_modules/@peculiar/asn1-x509/build/es2015/general_names.js
var GeneralNames_1;
var GeneralNames = GeneralNames_1 = class GeneralNames2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralNames_1.prototype);
  }
};
GeneralNames = GeneralNames_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: GeneralName })
], GeneralNames);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_issuer.js
var CertificateIssuer_1;
var id_ce_certificateIssuer = `${id_ce}.29`;
var CertificateIssuer = CertificateIssuer_1 = class CertificateIssuer2 extends GeneralNames {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificateIssuer_1.prototype);
  }
};
CertificateIssuer = CertificateIssuer_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence })
], CertificateIssuer);
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_policies.js
var CertificatePolicies_1;
var id_ce_certificatePolicies = `${id_ce}.32`;
var id_ce_certificatePolicies_anyPolicy = `${id_ce_certificatePolicies}.0`;
var DisplayText = class DisplayText2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || this.visibleString || this.bmpString || this.utf8String || "";
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.IA5String })
], DisplayText.prototype, "ia5String", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.VisibleString })
], DisplayText.prototype, "visibleString", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.BmpString })
], DisplayText.prototype, "bmpString", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Utf8String })
], DisplayText.prototype, "utf8String", undefined);
DisplayText = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], DisplayText);
class NoticeReference {
  constructor(params = {}) {
    this.organization = new DisplayText;
    this.noticeNumbers = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: DisplayText })
], NoticeReference.prototype, "organization", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, repeated: "sequence" })
], NoticeReference.prototype, "noticeNumbers", undefined);

class UserNotice {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: NoticeReference, optional: true })
], UserNotice.prototype, "noticeRef", undefined);
__decorate([
  AsnProp({ type: DisplayText, optional: true })
], UserNotice.prototype, "explicitText", undefined);
var Qualifier = class Qualifier2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.IA5String })
], Qualifier.prototype, "cPSuri", undefined);
__decorate([
  AsnProp({ type: UserNotice })
], Qualifier.prototype, "userNotice", undefined);
Qualifier = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], Qualifier);
class PolicyQualifierInfo {
  constructor(params = {}) {
    this.policyQualifierId = "";
    this.qualifier = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], PolicyQualifierInfo.prototype, "policyQualifierId", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Any })
], PolicyQualifierInfo.prototype, "qualifier", undefined);

class PolicyInformation {
  constructor(params = {}) {
    this.policyIdentifier = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], PolicyInformation.prototype, "policyIdentifier", undefined);
__decorate([
  AsnProp({ type: PolicyQualifierInfo, repeated: "sequence", optional: true })
], PolicyInformation.prototype, "policyQualifiers", undefined);
var CertificatePolicies = CertificatePolicies_1 = class CertificatePolicies2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificatePolicies_1.prototype);
  }
};
CertificatePolicies = CertificatePolicies_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: PolicyInformation })
], CertificatePolicies);
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_number.js
var id_ce_cRLNumber = `${id_ce}.20`;
var CRLNumber = class CRLNumber2 {
  constructor(value = 0) {
    this.value = value;
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], CRLNumber.prototype, "value", undefined);
CRLNumber = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], CRLNumber);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_delta_indicator.js
var id_ce_deltaCRLIndicator = `${id_ce}.27`;
var BaseCRLNumber = class BaseCRLNumber2 extends CRLNumber {
};
BaseCRLNumber = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], BaseCRLNumber);
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_distribution_points.js
var CRLDistributionPoints_1;
var id_ce_cRLDistributionPoints = `${id_ce}.31`;
var ReasonFlags;
(function(ReasonFlags2) {
  ReasonFlags2[ReasonFlags2["unused"] = 1] = "unused";
  ReasonFlags2[ReasonFlags2["keyCompromise"] = 2] = "keyCompromise";
  ReasonFlags2[ReasonFlags2["cACompromise"] = 4] = "cACompromise";
  ReasonFlags2[ReasonFlags2["affiliationChanged"] = 8] = "affiliationChanged";
  ReasonFlags2[ReasonFlags2["superseded"] = 16] = "superseded";
  ReasonFlags2[ReasonFlags2["cessationOfOperation"] = 32] = "cessationOfOperation";
  ReasonFlags2[ReasonFlags2["certificateHold"] = 64] = "certificateHold";
  ReasonFlags2[ReasonFlags2["privilegeWithdrawn"] = 128] = "privilegeWithdrawn";
  ReasonFlags2[ReasonFlags2["aACompromise"] = 256] = "aACompromise";
})(ReasonFlags || (ReasonFlags = {}));

class Reason extends BitString2 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & ReasonFlags.aACompromise) {
      res.push("aACompromise");
    }
    if (flags & ReasonFlags.affiliationChanged) {
      res.push("affiliationChanged");
    }
    if (flags & ReasonFlags.cACompromise) {
      res.push("cACompromise");
    }
    if (flags & ReasonFlags.certificateHold) {
      res.push("certificateHold");
    }
    if (flags & ReasonFlags.cessationOfOperation) {
      res.push("cessationOfOperation");
    }
    if (flags & ReasonFlags.keyCompromise) {
      res.push("keyCompromise");
    }
    if (flags & ReasonFlags.privilegeWithdrawn) {
      res.push("privilegeWithdrawn");
    }
    if (flags & ReasonFlags.superseded) {
      res.push("superseded");
    }
    if (flags & ReasonFlags.unused) {
      res.push("unused");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
}
var DistributionPointName = class DistributionPointName2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: GeneralName, context: 0, repeated: "sequence", implicit: true })
], DistributionPointName.prototype, "fullName", undefined);
__decorate([
  AsnProp({ type: RelativeDistinguishedName, context: 1, implicit: true })
], DistributionPointName.prototype, "nameRelativeToCRLIssuer", undefined);
DistributionPointName = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], DistributionPointName);
class DistributionPoint {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: DistributionPointName, context: 0, optional: true })
], DistributionPoint.prototype, "distributionPoint", undefined);
__decorate([
  AsnProp({ type: Reason, context: 1, optional: true, implicit: true })
], DistributionPoint.prototype, "reasons", undefined);
__decorate([
  AsnProp({ type: GeneralName, context: 2, optional: true, repeated: "sequence", implicit: true })
], DistributionPoint.prototype, "cRLIssuer", undefined);
var CRLDistributionPoints = CRLDistributionPoints_1 = class CRLDistributionPoints2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CRLDistributionPoints_1.prototype);
  }
};
CRLDistributionPoints = CRLDistributionPoints_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: DistributionPoint })
], CRLDistributionPoints);
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_freshest.js
var FreshestCRL_1;
var id_ce_freshestCRL = `${id_ce}.46`;
var FreshestCRL = FreshestCRL_1 = class FreshestCRL2 extends CRLDistributionPoints {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, FreshestCRL_1.prototype);
  }
};
FreshestCRL = FreshestCRL_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: DistributionPoint })
], FreshestCRL);
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_issuing_distribution_point.js
var id_ce_issuingDistributionPoint = `${id_ce}.28`;

class IssuingDistributionPoint {
  constructor(params = {}) {
    this.onlyContainsUserCerts = IssuingDistributionPoint.ONLY;
    this.onlyContainsCACerts = IssuingDistributionPoint.ONLY;
    this.indirectCRL = IssuingDistributionPoint.ONLY;
    this.onlyContainsAttributeCerts = IssuingDistributionPoint.ONLY;
    Object.assign(this, params);
  }
}
IssuingDistributionPoint.ONLY = false;
__decorate([
  AsnProp({ type: DistributionPointName, context: 0, optional: true })
], IssuingDistributionPoint.prototype, "distributionPoint", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Boolean, context: 1, defaultValue: IssuingDistributionPoint.ONLY, implicit: true })
], IssuingDistributionPoint.prototype, "onlyContainsUserCerts", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Boolean, context: 2, defaultValue: IssuingDistributionPoint.ONLY, implicit: true })
], IssuingDistributionPoint.prototype, "onlyContainsCACerts", undefined);
__decorate([
  AsnProp({ type: Reason, context: 3, optional: true, implicit: true })
], IssuingDistributionPoint.prototype, "onlySomeReasons", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Boolean, context: 4, defaultValue: IssuingDistributionPoint.ONLY, implicit: true })
], IssuingDistributionPoint.prototype, "indirectCRL", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Boolean, context: 5, defaultValue: IssuingDistributionPoint.ONLY, implicit: true })
], IssuingDistributionPoint.prototype, "onlyContainsAttributeCerts", undefined);
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_reason.js
var id_ce_cRLReasons = `${id_ce}.21`;
var CRLReasons;
(function(CRLReasons2) {
  CRLReasons2[CRLReasons2["unspecified"] = 0] = "unspecified";
  CRLReasons2[CRLReasons2["keyCompromise"] = 1] = "keyCompromise";
  CRLReasons2[CRLReasons2["cACompromise"] = 2] = "cACompromise";
  CRLReasons2[CRLReasons2["affiliationChanged"] = 3] = "affiliationChanged";
  CRLReasons2[CRLReasons2["superseded"] = 4] = "superseded";
  CRLReasons2[CRLReasons2["cessationOfOperation"] = 5] = "cessationOfOperation";
  CRLReasons2[CRLReasons2["certificateHold"] = 6] = "certificateHold";
  CRLReasons2[CRLReasons2["removeFromCRL"] = 8] = "removeFromCRL";
  CRLReasons2[CRLReasons2["privilegeWithdrawn"] = 9] = "privilegeWithdrawn";
  CRLReasons2[CRLReasons2["aACompromise"] = 10] = "aACompromise";
})(CRLReasons || (CRLReasons = {}));
var CRLReason = class CRLReason2 {
  constructor(reason = CRLReasons.unspecified) {
    this.reason = CRLReasons.unspecified;
    this.reason = reason;
  }
  toJSON() {
    return CRLReasons[this.reason];
  }
  toString() {
    return this.toJSON();
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.Enumerated })
], CRLReason.prototype, "reason", undefined);
CRLReason = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], CRLReason);
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/extended_key_usage.js
var ExtendedKeyUsage_1;
var id_ce_extKeyUsage = `${id_ce}.37`;
var ExtendedKeyUsage = ExtendedKeyUsage_1 = class ExtendedKeyUsage2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, ExtendedKeyUsage_1.prototype);
  }
};
ExtendedKeyUsage = ExtendedKeyUsage_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: AsnPropTypes.ObjectIdentifier })
], ExtendedKeyUsage);
var anyExtendedKeyUsage = `${id_ce_extKeyUsage}.0`;
var id_kp_serverAuth = `${id_kp}.1`;
var id_kp_clientAuth = `${id_kp}.2`;
var id_kp_codeSigning = `${id_kp}.3`;
var id_kp_emailProtection = `${id_kp}.4`;
var id_kp_timeStamping = `${id_kp}.8`;
var id_kp_OCSPSigning = `${id_kp}.9`;
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/inhibit_any_policy.js
var id_ce_inhibitAnyPolicy = `${id_ce}.54`;
var InhibitAnyPolicy = class InhibitAnyPolicy2 {
  constructor(value = new ArrayBuffer(0)) {
    this.value = value;
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], InhibitAnyPolicy.prototype, "value", undefined);
InhibitAnyPolicy = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], InhibitAnyPolicy);
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/invalidity_date.js
var id_ce_invalidityDate = `${id_ce}.24`;
var InvalidityDate = class InvalidityDate2 {
  constructor(value) {
    this.value = new Date;
    if (value) {
      this.value = value;
    }
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.GeneralizedTime })
], InvalidityDate.prototype, "value", undefined);
InvalidityDate = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], InvalidityDate);
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/issuer_alternative_name.js
var IssueAlternativeName_1;
var id_ce_issuerAltName = `${id_ce}.18`;
var IssueAlternativeName = IssueAlternativeName_1 = class IssueAlternativeName2 extends GeneralNames {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, IssueAlternativeName_1.prototype);
  }
};
IssueAlternativeName = IssueAlternativeName_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence })
], IssueAlternativeName);
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/key_usage.js
var id_ce_keyUsage = `${id_ce}.15`;
var KeyUsageFlags;
(function(KeyUsageFlags2) {
  KeyUsageFlags2[KeyUsageFlags2["digitalSignature"] = 1] = "digitalSignature";
  KeyUsageFlags2[KeyUsageFlags2["nonRepudiation"] = 2] = "nonRepudiation";
  KeyUsageFlags2[KeyUsageFlags2["keyEncipherment"] = 4] = "keyEncipherment";
  KeyUsageFlags2[KeyUsageFlags2["dataEncipherment"] = 8] = "dataEncipherment";
  KeyUsageFlags2[KeyUsageFlags2["keyAgreement"] = 16] = "keyAgreement";
  KeyUsageFlags2[KeyUsageFlags2["keyCertSign"] = 32] = "keyCertSign";
  KeyUsageFlags2[KeyUsageFlags2["cRLSign"] = 64] = "cRLSign";
  KeyUsageFlags2[KeyUsageFlags2["encipherOnly"] = 128] = "encipherOnly";
  KeyUsageFlags2[KeyUsageFlags2["decipherOnly"] = 256] = "decipherOnly";
})(KeyUsageFlags || (KeyUsageFlags = {}));
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/name_constraints.js
var GeneralSubtrees_1;
var id_ce_nameConstraints = `${id_ce}.30`;

class GeneralSubtree {
  constructor(params = {}) {
    this.base = new GeneralName;
    this.minimum = 0;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: GeneralName })
], GeneralSubtree.prototype, "base", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, context: 0, defaultValue: 0, implicit: true })
], GeneralSubtree.prototype, "minimum", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, context: 1, optional: true, implicit: true })
], GeneralSubtree.prototype, "maximum", undefined);
var GeneralSubtrees = GeneralSubtrees_1 = class GeneralSubtrees2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralSubtrees_1.prototype);
  }
};
GeneralSubtrees = GeneralSubtrees_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: GeneralSubtree })
], GeneralSubtrees);
class NameConstraints {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: GeneralSubtrees, context: 0, optional: true, implicit: true })
], NameConstraints.prototype, "permittedSubtrees", undefined);
__decorate([
  AsnProp({ type: GeneralSubtrees, context: 1, optional: true, implicit: true })
], NameConstraints.prototype, "excludedSubtrees", undefined);
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_constraints.js
var id_ce_policyConstraints = `${id_ce}.36`;

class PolicyConstraints {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({
    type: AsnPropTypes.Integer,
    context: 0,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter
  })
], PolicyConstraints.prototype, "requireExplicitPolicy", undefined);
__decorate([
  AsnProp({
    type: AsnPropTypes.Integer,
    context: 1,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter
  })
], PolicyConstraints.prototype, "inhibitPolicyMapping", undefined);
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_mappings.js
var PolicyMappings_1;
var id_ce_policyMappings = `${id_ce}.33`;

class PolicyMapping {
  constructor(params = {}) {
    this.issuerDomainPolicy = "";
    this.subjectDomainPolicy = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], PolicyMapping.prototype, "issuerDomainPolicy", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], PolicyMapping.prototype, "subjectDomainPolicy", undefined);
var PolicyMappings = PolicyMappings_1 = class PolicyMappings2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, PolicyMappings_1.prototype);
  }
};
PolicyMappings = PolicyMappings_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: PolicyMapping })
], PolicyMappings);
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_alternative_name.js
var SubjectAlternativeName_1;
var id_ce_subjectAltName = `${id_ce}.17`;
var SubjectAlternativeName = SubjectAlternativeName_1 = class SubjectAlternativeName2 extends GeneralNames {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectAlternativeName_1.prototype);
  }
};
SubjectAlternativeName = SubjectAlternativeName_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence })
], SubjectAlternativeName);
// node_modules/@peculiar/asn1-x509/build/es2015/attribute.js
class Attribute {
  constructor(params = {}) {
    this.type = "";
    this.values = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], Attribute.prototype, "type", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Any, repeated: "set" })
], Attribute.prototype, "values", undefined);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_directory_attributes.js
var SubjectDirectoryAttributes_1;
var id_ce_subjectDirectoryAttributes = `${id_ce}.9`;
var SubjectDirectoryAttributes = SubjectDirectoryAttributes_1 = class SubjectDirectoryAttributes2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectDirectoryAttributes_1.prototype);
  }
};
SubjectDirectoryAttributes = SubjectDirectoryAttributes_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: Attribute })
], SubjectDirectoryAttributes);
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_key_identifier.js
var id_ce_subjectKeyIdentifier = `${id_ce}.14`;
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/private_key_usage_period.js
var id_ce_privateKeyUsagePeriod = `${id_ce}.16`;

class PrivateKeyUsagePeriod {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.GeneralizedTime, context: 0, implicit: true, optional: true })
], PrivateKeyUsagePeriod.prototype, "notBefore", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.GeneralizedTime, context: 1, implicit: true, optional: true })
], PrivateKeyUsagePeriod.prototype, "notAfter", undefined);
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/entrust_version_info.js
var EntrustInfoFlags;
(function(EntrustInfoFlags2) {
  EntrustInfoFlags2[EntrustInfoFlags2["keyUpdateAllowed"] = 1] = "keyUpdateAllowed";
  EntrustInfoFlags2[EntrustInfoFlags2["newExtensions"] = 2] = "newExtensions";
  EntrustInfoFlags2[EntrustInfoFlags2["pKIXCertificate"] = 4] = "pKIXCertificate";
})(EntrustInfoFlags || (EntrustInfoFlags = {}));

class EntrustInfo extends BitString2 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & EntrustInfoFlags.pKIXCertificate) {
      res.push("pKIXCertificate");
    }
    if (flags & EntrustInfoFlags.newExtensions) {
      res.push("newExtensions");
    }
    if (flags & EntrustInfoFlags.keyUpdateAllowed) {
      res.push("keyUpdateAllowed");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
}

class EntrustVersionInfo {
  constructor(params = {}) {
    this.entrustVers = "";
    this.entrustInfoFlags = new EntrustInfo;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.GeneralString })
], EntrustVersionInfo.prototype, "entrustVers", undefined);
__decorate([
  AsnProp({ type: EntrustInfo })
], EntrustVersionInfo.prototype, "entrustInfoFlags", undefined);
// node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_info_access.js
var SubjectInfoAccessSyntax_1;
var id_pe_subjectInfoAccess = `${id_pe}.11`;
var SubjectInfoAccessSyntax = SubjectInfoAccessSyntax_1 = class SubjectInfoAccessSyntax2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectInfoAccessSyntax_1.prototype);
  }
};
SubjectInfoAccessSyntax = SubjectInfoAccessSyntax_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: AccessDescription })
], SubjectInfoAccessSyntax);
// node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js
class AlgorithmIdentifier {
  constructor(params = {}) {
    this.algorithm = "";
    Object.assign(this, params);
  }
  isEqual(data) {
    return data instanceof AlgorithmIdentifier && data.algorithm == this.algorithm && (data.parameters && this.parameters && isEqual(data.parameters, this.parameters) || data.parameters === this.parameters);
  }
}
__decorate([
  AsnProp({
    type: AsnPropTypes.ObjectIdentifier
  })
], AlgorithmIdentifier.prototype, "algorithm", undefined);
__decorate([
  AsnProp({
    type: AsnPropTypes.Any,
    optional: true
  })
], AlgorithmIdentifier.prototype, "parameters", undefined);
// node_modules/@peculiar/asn1-x509/build/es2015/subject_public_key_info.js
class SubjectPublicKeyInfo {
  constructor(params = {}) {
    this.algorithm = new AlgorithmIdentifier;
    this.subjectPublicKey = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AlgorithmIdentifier })
], SubjectPublicKeyInfo.prototype, "algorithm", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.BitString })
], SubjectPublicKeyInfo.prototype, "subjectPublicKey", undefined);

// node_modules/@peculiar/asn1-x509/build/es2015/time.js
var Time = class Time2 {
  constructor(time2) {
    if (time2) {
      if (typeof time2 === "string" || typeof time2 === "number" || time2 instanceof Date) {
        const date = new Date(time2);
        if (date.getUTCFullYear() > 2049) {
          this.generalTime = date;
        } else {
          this.utcTime = date;
        }
      } else {
        Object.assign(this, time2);
      }
    }
  }
  getTime() {
    const time2 = this.utcTime || this.generalTime;
    if (!time2) {
      throw new Error("Cannot get time from CHOICE object");
    }
    return time2;
  }
};
__decorate([
  AsnProp({
    type: AsnPropTypes.UTCTime
  })
], Time.prototype, "utcTime", undefined);
__decorate([
  AsnProp({
    type: AsnPropTypes.GeneralizedTime
  })
], Time.prototype, "generalTime", undefined);
Time = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], Time);

// node_modules/@peculiar/asn1-x509/build/es2015/validity.js
class Validity {
  constructor(params) {
    this.notBefore = new Time(new Date);
    this.notAfter = new Time(new Date);
    if (params) {
      this.notBefore = new Time(params.notBefore);
      this.notAfter = new Time(params.notAfter);
    }
  }
}
__decorate([
  AsnProp({ type: Time })
], Validity.prototype, "notBefore", undefined);
__decorate([
  AsnProp({ type: Time })
], Validity.prototype, "notAfter", undefined);

// node_modules/@peculiar/asn1-x509/build/es2015/extension.js
var Extensions_1;

class Extension {
  constructor(params = {}) {
    this.extnID = "";
    this.critical = Extension.CRITICAL;
    this.extnValue = new OctetString2;
    Object.assign(this, params);
  }
}
Extension.CRITICAL = false;
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], Extension.prototype, "extnID", undefined);
__decorate([
  AsnProp({
    type: AsnPropTypes.Boolean,
    defaultValue: Extension.CRITICAL
  })
], Extension.prototype, "critical", undefined);
__decorate([
  AsnProp({ type: OctetString2 })
], Extension.prototype, "extnValue", undefined);
var Extensions = Extensions_1 = class Extensions2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Extensions_1.prototype);
  }
};
Extensions = Extensions_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: Extension })
], Extensions);

// node_modules/@peculiar/asn1-x509/build/es2015/types.js
var Version;
(function(Version2) {
  Version2[Version2["v1"] = 0] = "v1";
  Version2[Version2["v2"] = 1] = "v2";
  Version2[Version2["v3"] = 2] = "v3";
})(Version || (Version = {}));

// node_modules/@peculiar/asn1-x509/build/es2015/tbs_certificate.js
class TBSCertificate {
  constructor(params = {}) {
    this.version = Version.v1;
    this.serialNumber = new ArrayBuffer(0);
    this.signature = new AlgorithmIdentifier;
    this.issuer = new Name;
    this.validity = new Validity;
    this.subject = new Name;
    this.subjectPublicKeyInfo = new SubjectPublicKeyInfo;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({
    type: AsnPropTypes.Integer,
    context: 0,
    defaultValue: Version.v1
  })
], TBSCertificate.prototype, "version", undefined);
__decorate([
  AsnProp({
    type: AsnPropTypes.Integer,
    converter: AsnIntegerArrayBufferConverter
  })
], TBSCertificate.prototype, "serialNumber", undefined);
__decorate([
  AsnProp({ type: AlgorithmIdentifier })
], TBSCertificate.prototype, "signature", undefined);
__decorate([
  AsnProp({ type: Name })
], TBSCertificate.prototype, "issuer", undefined);
__decorate([
  AsnProp({ type: Validity })
], TBSCertificate.prototype, "validity", undefined);
__decorate([
  AsnProp({ type: Name })
], TBSCertificate.prototype, "subject", undefined);
__decorate([
  AsnProp({ type: SubjectPublicKeyInfo })
], TBSCertificate.prototype, "subjectPublicKeyInfo", undefined);
__decorate([
  AsnProp({
    type: AsnPropTypes.BitString,
    context: 1,
    implicit: true,
    optional: true
  })
], TBSCertificate.prototype, "issuerUniqueID", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.BitString, context: 2, implicit: true, optional: true })
], TBSCertificate.prototype, "subjectUniqueID", undefined);
__decorate([
  AsnProp({ type: Extensions, context: 3, optional: true })
], TBSCertificate.prototype, "extensions", undefined);

// node_modules/@peculiar/asn1-x509/build/es2015/certificate.js
class Certificate {
  constructor(params = {}) {
    this.tbsCertificate = new TBSCertificate;
    this.signatureAlgorithm = new AlgorithmIdentifier;
    this.signatureValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: TBSCertificate })
], Certificate.prototype, "tbsCertificate", undefined);
__decorate([
  AsnProp({ type: AlgorithmIdentifier })
], Certificate.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.BitString })
], Certificate.prototype, "signatureValue", undefined);
// node_modules/@peculiar/asn1-x509/build/es2015/tbs_cert_list.js
class RevokedCertificate {
  constructor(params = {}) {
    this.userCertificate = new ArrayBuffer(0);
    this.revocationDate = new Time;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RevokedCertificate.prototype, "userCertificate", undefined);
__decorate([
  AsnProp({ type: Time })
], RevokedCertificate.prototype, "revocationDate", undefined);
__decorate([
  AsnProp({ type: Extension, optional: true, repeated: "sequence" })
], RevokedCertificate.prototype, "crlEntryExtensions", undefined);

class TBSCertList {
  constructor(params = {}) {
    this.signature = new AlgorithmIdentifier;
    this.issuer = new Name;
    this.thisUpdate = new Time;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, optional: true })
], TBSCertList.prototype, "version", undefined);
__decorate([
  AsnProp({ type: AlgorithmIdentifier })
], TBSCertList.prototype, "signature", undefined);
__decorate([
  AsnProp({ type: Name })
], TBSCertList.prototype, "issuer", undefined);
__decorate([
  AsnProp({ type: Time })
], TBSCertList.prototype, "thisUpdate", undefined);
__decorate([
  AsnProp({ type: Time, optional: true })
], TBSCertList.prototype, "nextUpdate", undefined);
__decorate([
  AsnProp({ type: RevokedCertificate, repeated: "sequence", optional: true })
], TBSCertList.prototype, "revokedCertificates", undefined);
__decorate([
  AsnProp({ type: Extension, optional: true, context: 0, repeated: "sequence" })
], TBSCertList.prototype, "crlExtensions", undefined);

// node_modules/@peculiar/asn1-x509/build/es2015/certificate_list.js
class CertificateList {
  constructor(params = {}) {
    this.tbsCertList = new TBSCertList;
    this.signatureAlgorithm = new AlgorithmIdentifier;
    this.signature = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: TBSCertList })
], CertificateList.prototype, "tbsCertList", undefined);
__decorate([
  AsnProp({ type: AlgorithmIdentifier })
], CertificateList.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.BitString })
], CertificateList.prototype, "signature", undefined);
// node_modules/@simplewebauthn/server/esm/helpers/getCertificateInfo.js
var issuerSubjectIDKey = {
  "2.5.4.6": "C",
  "2.5.4.10": "O",
  "2.5.4.11": "OU",
  "2.5.4.3": "CN"
};
function getCertificateInfo(leafCertBuffer) {
  const x509 = AsnParser.parse(leafCertBuffer, Certificate);
  const parsedCert = x509.tbsCertificate;
  const issuer = { combined: "" };
  parsedCert.issuer.forEach(([iss]) => {
    const key = issuerSubjectIDKey[iss.type];
    if (key) {
      issuer[key] = iss.value.toString();
    }
  });
  issuer.combined = issuerSubjectToString(issuer);
  const subject = { combined: "" };
  parsedCert.subject.forEach(([iss]) => {
    const key = issuerSubjectIDKey[iss.type];
    if (key) {
      subject[key] = iss.value.toString();
    }
  });
  subject.combined = issuerSubjectToString(subject);
  let basicConstraintsCA = false;
  if (parsedCert.extensions) {
    for (const ext of parsedCert.extensions) {
      if (ext.extnID === id_ce_basicConstraints) {
        const basicConstraints = AsnParser.parse(ext.extnValue, BasicConstraints);
        basicConstraintsCA = basicConstraints.cA;
      }
    }
  }
  return {
    issuer,
    subject,
    version: parsedCert.version,
    basicConstraintsCA,
    notBefore: parsedCert.validity.notBefore.getTime(),
    notAfter: parsedCert.validity.notAfter.getTime(),
    parsedCertificate: x509
  };
}
function issuerSubjectToString(input) {
  const parts = [];
  if (input.C) {
    parts.push(input.C);
  }
  if (input.O) {
    parts.push(input.O);
  }
  if (input.OU) {
    parts.push(input.OU);
  }
  if (input.CN) {
    parts.push(input.CN);
  }
  return parts.join(" : ");
}
// node_modules/@peculiar/x509/build/x509.es.js
var import_reflect_metadata = __toESM(require_Reflect(), 1);

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-schema/node_modules/asn1js/build/index.es.js
var exports_index_es3 = {};
__export(exports_index_es3, {
  verifySchema: () => verifySchema2,
  fromBER: () => fromBER2,
  compareSchema: () => compareSchema2,
  VisibleString: () => VisibleString2,
  ViewWriter: () => ViewWriter2,
  VideotexString: () => VideotexString2,
  ValueBlock: () => ValueBlock2,
  Utf8String: () => Utf8String2,
  UniversalString: () => UniversalString2,
  UTCTime: () => UTCTime2,
  TimeOfDay: () => TimeOfDay2,
  TeletexString: () => TeletexString2,
  TIME: () => TIME2,
  Set: () => Set3,
  Sequence: () => Sequence2,
  Repeated: () => Repeated2,
  RelativeObjectIdentifier: () => RelativeObjectIdentifier2,
  RawData: () => RawData2,
  PrintableString: () => PrintableString2,
  Primitive: () => Primitive2,
  OctetString: () => OctetString3,
  ObjectIdentifier: () => ObjectIdentifier2,
  NumericString: () => NumericString2,
  Null: () => Null2,
  Integer: () => Integer2,
  IA5String: () => IA5String2,
  HexBlock: () => HexBlock2,
  GraphicString: () => GraphicString2,
  GeneralizedTime: () => GeneralizedTime2,
  GeneralString: () => GeneralString2,
  Enumerated: () => Enumerated2,
  EndOfContent: () => EndOfContent2,
  Duration: () => Duration2,
  DateTime: () => DateTime2,
  DATE: () => DATE2,
  Constructed: () => Constructed2,
  Choice: () => Choice2,
  CharacterString: () => CharacterString2,
  Boolean: () => Boolean3,
  BmpString: () => BmpString2,
  BitString: () => BitString3,
  BaseStringBlock: () => BaseStringBlock2,
  BaseBlock: () => BaseBlock2,
  Any: () => Any2
});
/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
function assertBigInt2() {
  if (typeof BigInt === "undefined") {
    throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
  }
}
function concat2(buffers) {
  let outputLength = 0;
  let prevLength = 0;
  for (let i = 0;i < buffers.length; i++) {
    const buffer = buffers[i];
    outputLength += buffer.byteLength;
  }
  const retView = new Uint8Array(outputLength);
  for (let i = 0;i < buffers.length; i++) {
    const buffer = buffers[i];
    retView.set(new Uint8Array(buffer), prevLength);
    prevLength += buffer.byteLength;
  }
  return retView.buffer;
}
function checkBufferParams2(baseBlock, inputBuffer, inputOffset, inputLength) {
  if (!(inputBuffer instanceof Uint8Array)) {
    baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
    return false;
  }
  if (!inputBuffer.byteLength) {
    baseBlock.error = "Wrong parameter: inputBuffer has zero length";
    return false;
  }
  if (inputOffset < 0) {
    baseBlock.error = "Wrong parameter: inputOffset less than zero";
    return false;
  }
  if (inputLength < 0) {
    baseBlock.error = "Wrong parameter: inputLength less than zero";
    return false;
  }
  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
    baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
    return false;
  }
  return true;
}

class ViewWriter2 {
  constructor() {
    this.items = [];
  }
  write(buf) {
    this.items.push(buf);
  }
  final() {
    return concat2(this.items);
  }
}
var powers22 = [new Uint8Array([1])];
var digitsString2 = "0123456789";
var NAME2 = "name";
var VALUE_HEX_VIEW2 = "valueHexView";
var IS_HEX_ONLY2 = "isHexOnly";
var ID_BLOCK2 = "idBlock";
var TAG_CLASS2 = "tagClass";
var TAG_NUMBER2 = "tagNumber";
var IS_CONSTRUCTED2 = "isConstructed";
var FROM_BER2 = "fromBER";
var TO_BER2 = "toBER";
var LOCAL2 = "local";
var EMPTY_STRING2 = "";
var EMPTY_BUFFER2 = new ArrayBuffer(0);
var EMPTY_VIEW2 = new Uint8Array(0);
var END_OF_CONTENT_NAME2 = "EndOfContent";
var OCTET_STRING_NAME2 = "OCTET STRING";
var BIT_STRING_NAME2 = "BIT STRING";
function HexBlock2(BaseClass) {
  var _a2;
  return _a2 = class Some extends BaseClass {
    get valueHex() {
      return this.valueHexView.slice().buffer;
    }
    set valueHex(value) {
      this.valueHexView = new Uint8Array(value);
    }
    constructor(...args) {
      var _b;
      super(...args);
      const params = args[0] || {};
      this.isHexOnly = (_b = params.isHexOnly) !== null && _b !== undefined ? _b : false;
      this.valueHexView = params.valueHex ? BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW2;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      if (!checkBufferParams2(this, view, inputOffset, inputLength)) {
        return -1;
      }
      const endLength = inputOffset + inputLength;
      this.valueHexView = view.subarray(inputOffset, endLength);
      if (!this.valueHexView.length) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      }
      this.blockLength = inputLength;
      return endLength;
    }
    toBER(sizeOnly = false) {
      if (!this.isHexOnly) {
        this.error = "Flag 'isHexOnly' is not set, abort";
        return EMPTY_BUFFER2;
      }
      if (sizeOnly) {
        return new ArrayBuffer(this.valueHexView.byteLength);
      }
      return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        isHexOnly: this.isHexOnly,
        valueHex: Convert.ToHex(this.valueHexView)
      };
    }
  }, _a2.NAME = "hexBlock", _a2;
}

class LocalBaseBlock2 {
  static blockName() {
    return this.NAME;
  }
  get valueBeforeDecode() {
    return this.valueBeforeDecodeView.slice().buffer;
  }
  set valueBeforeDecode(value) {
    this.valueBeforeDecodeView = new Uint8Array(value);
  }
  constructor({ blockLength = 0, error = EMPTY_STRING2, warnings = [], valueBeforeDecode = EMPTY_VIEW2 } = {}) {
    this.blockLength = blockLength;
    this.error = error;
    this.warnings = warnings;
    this.valueBeforeDecodeView = BufferSourceConverter.toUint8Array(valueBeforeDecode);
  }
  toJSON() {
    return {
      blockName: this.constructor.NAME,
      blockLength: this.blockLength,
      error: this.error,
      warnings: this.warnings,
      valueBeforeDecode: Convert.ToHex(this.valueBeforeDecodeView)
    };
  }
}
LocalBaseBlock2.NAME = "baseBlock";

class ValueBlock2 extends LocalBaseBlock2 {
  fromBER(_inputBuffer, _inputOffset, _inputLength) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
  toBER(_sizeOnly, _writer) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
}
ValueBlock2.NAME = "valueBlock";

class LocalIdentificationBlock2 extends HexBlock2(LocalBaseBlock2) {
  constructor({ idBlock = {} } = {}) {
    var _a2, _b, _c, _d;
    super();
    if (idBlock) {
      this.isHexOnly = (_a2 = idBlock.isHexOnly) !== null && _a2 !== undefined ? _a2 : false;
      this.valueHexView = idBlock.valueHex ? BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW2;
      this.tagClass = (_b = idBlock.tagClass) !== null && _b !== undefined ? _b : -1;
      this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== undefined ? _c : -1;
      this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== undefined ? _d : false;
    } else {
      this.tagClass = -1;
      this.tagNumber = -1;
      this.isConstructed = false;
    }
  }
  toBER(sizeOnly = false) {
    let firstOctet = 0;
    switch (this.tagClass) {
      case 1:
        firstOctet |= 0;
        break;
      case 2:
        firstOctet |= 64;
        break;
      case 3:
        firstOctet |= 128;
        break;
      case 4:
        firstOctet |= 192;
        break;
      default:
        this.error = "Unknown tag class";
        return EMPTY_BUFFER2;
    }
    if (this.isConstructed)
      firstOctet |= 32;
    if (this.tagNumber < 31 && !this.isHexOnly) {
      const retView2 = new Uint8Array(1);
      if (!sizeOnly) {
        let number = this.tagNumber;
        number &= 31;
        firstOctet |= number;
        retView2[0] = firstOctet;
      }
      return retView2.buffer;
    }
    if (!this.isHexOnly) {
      const encodedBuf = utilToBase(this.tagNumber, 7);
      const encodedView = new Uint8Array(encodedBuf);
      const size = encodedBuf.byteLength;
      const retView2 = new Uint8Array(size + 1);
      retView2[0] = firstOctet | 31;
      if (!sizeOnly) {
        for (let i = 0;i < size - 1; i++)
          retView2[i + 1] = encodedView[i] | 128;
        retView2[size] = encodedView[size - 1];
      }
      return retView2.buffer;
    }
    const retView = new Uint8Array(this.valueHexView.byteLength + 1);
    retView[0] = firstOctet | 31;
    if (!sizeOnly) {
      const curView = this.valueHexView;
      for (let i = 0;i < curView.length - 1; i++)
        retView[i + 1] = curView[i] | 128;
      retView[this.valueHexView.byteLength] = curView[curView.length - 1];
    }
    return retView.buffer;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams2(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    const tagClassMask = intBuffer[0] & 192;
    switch (tagClassMask) {
      case 0:
        this.tagClass = 1;
        break;
      case 64:
        this.tagClass = 2;
        break;
      case 128:
        this.tagClass = 3;
        break;
      case 192:
        this.tagClass = 4;
        break;
      default:
        this.error = "Unknown tag class";
        return -1;
    }
    this.isConstructed = (intBuffer[0] & 32) === 32;
    this.isHexOnly = false;
    const tagNumberMask = intBuffer[0] & 31;
    if (tagNumberMask !== 31) {
      this.tagNumber = tagNumberMask;
      this.blockLength = 1;
    } else {
      let count = 1;
      let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
      let tagNumberBufferMaxLength = 255;
      while (intBuffer[count] & 128) {
        intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
        count++;
        if (count >= intBuffer.length) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (count === tagNumberBufferMaxLength) {
          tagNumberBufferMaxLength += 255;
          const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);
          for (let i = 0;i < intTagNumberBuffer.length; i++)
            tempBufferView2[i] = intTagNumberBuffer[i];
          intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
        }
      }
      this.blockLength = count + 1;
      intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
      const tempBufferView = new Uint8Array(count);
      for (let i = 0;i < count; i++)
        tempBufferView[i] = intTagNumberBuffer[i];
      intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
      intTagNumberBuffer.set(tempBufferView);
      if (this.blockLength <= 9)
        this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
      else {
        this.isHexOnly = true;
        this.warnings.push("Tag too long, represented as hex-coded");
      }
    }
    if (this.tagClass === 1 && this.isConstructed) {
      switch (this.tagNumber) {
        case 1:
        case 2:
        case 5:
        case 6:
        case 9:
        case 13:
        case 14:
        case 23:
        case 24:
        case 31:
        case 32:
        case 33:
        case 34:
          this.error = "Constructed encoding used for primitive type";
          return -1;
      }
    }
    return inputOffset + this.blockLength;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      tagClass: this.tagClass,
      tagNumber: this.tagNumber,
      isConstructed: this.isConstructed
    };
  }
}
LocalIdentificationBlock2.NAME = "identificationBlock";

class LocalLengthBlock2 extends LocalBaseBlock2 {
  constructor({ lenBlock = {} } = {}) {
    var _a2, _b, _c;
    super();
    this.isIndefiniteForm = (_a2 = lenBlock.isIndefiniteForm) !== null && _a2 !== undefined ? _a2 : false;
    this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== undefined ? _b : false;
    this.length = (_c = lenBlock.length) !== null && _c !== undefined ? _c : 0;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams2(this, view, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    if (intBuffer[0] === 255) {
      this.error = "Length block 0xFF is reserved by standard";
      return -1;
    }
    this.isIndefiniteForm = intBuffer[0] === 128;
    if (this.isIndefiniteForm) {
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    this.longFormUsed = !!(intBuffer[0] & 128);
    if (this.longFormUsed === false) {
      this.length = intBuffer[0];
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    const count = intBuffer[0] & 127;
    if (count > 8) {
      this.error = "Too big integer";
      return -1;
    }
    if (count + 1 > intBuffer.length) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    const lenOffset = inputOffset + 1;
    const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
    if (lengthBufferView[count - 1] === 0)
      this.warnings.push("Needlessly long encoded length");
    this.length = utilFromBase(lengthBufferView, 8);
    if (this.longFormUsed && this.length <= 127)
      this.warnings.push("Unnecessary usage of long length form");
    this.blockLength = count + 1;
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly = false) {
    let retBuf;
    let retView;
    if (this.length > 127)
      this.longFormUsed = true;
    if (this.isIndefiniteForm) {
      retBuf = new ArrayBuffer(1);
      if (sizeOnly === false) {
        retView = new Uint8Array(retBuf);
        retView[0] = 128;
      }
      return retBuf;
    }
    if (this.longFormUsed) {
      const encodedBuf = utilToBase(this.length, 8);
      if (encodedBuf.byteLength > 127) {
        this.error = "Too big length";
        return EMPTY_BUFFER2;
      }
      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
      if (sizeOnly)
        return retBuf;
      const encodedView = new Uint8Array(encodedBuf);
      retView = new Uint8Array(retBuf);
      retView[0] = encodedBuf.byteLength | 128;
      for (let i = 0;i < encodedBuf.byteLength; i++)
        retView[i + 1] = encodedView[i];
      return retBuf;
    }
    retBuf = new ArrayBuffer(1);
    if (sizeOnly === false) {
      retView = new Uint8Array(retBuf);
      retView[0] = this.length;
    }
    return retBuf;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      longFormUsed: this.longFormUsed,
      length: this.length
    };
  }
}
LocalLengthBlock2.NAME = "lengthBlock";
var typeStore2 = {};

class BaseBlock2 extends LocalBaseBlock2 {
  constructor({ name: name2 = EMPTY_STRING2, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType) {
    super(parameters);
    this.name = name2;
    this.optional = optional;
    if (primitiveSchema) {
      this.primitiveSchema = primitiveSchema;
    }
    this.idBlock = new LocalIdentificationBlock2(parameters);
    this.lenBlock = new LocalLengthBlock2(parameters);
    this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock2(parameters);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter2;
    if (!writer) {
      prepareIndefiniteForm2(this);
    }
    const idBlockBuf = this.idBlock.toBER(sizeOnly);
    _writer.write(idBlockBuf);
    if (this.lenBlock.isIndefiniteForm) {
      _writer.write(new Uint8Array([128]).buffer);
      this.valueBlock.toBER(sizeOnly, _writer);
      _writer.write(new ArrayBuffer(2));
    } else {
      const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
      this.lenBlock.length = valueBlockBuf.byteLength;
      const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
      _writer.write(lenBlockBuf);
      _writer.write(valueBlockBuf);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER2;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      idBlock: this.idBlock.toJSON(),
      lenBlock: this.lenBlock.toJSON(),
      valueBlock: this.valueBlock.toJSON(),
      name: this.name,
      optional: this.optional
    };
    if (this.primitiveSchema)
      object.primitiveSchema = this.primitiveSchema.toJSON();
    return object;
  }
  toString(encoding = "ascii") {
    if (encoding === "ascii") {
      return this.onAsciiEncoding();
    }
    return Convert.ToHex(this.toBER());
  }
  onAsciiEncoding() {
    const name2 = this.constructor.NAME;
    const value = Convert.ToHex(this.valueBlock.valueBeforeDecodeView);
    return `${name2} : ${value}`;
  }
  isEqual(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof this.constructor)) {
      return false;
    }
    const thisRaw = this.toBER();
    const otherRaw = other.toBER();
    return isEqualBuffer(thisRaw, otherRaw);
  }
}
BaseBlock2.NAME = "BaseBlock";
function prepareIndefiniteForm2(baseBlock) {
  var _a2;
  if (baseBlock instanceof typeStore2.Constructed) {
    for (const value of baseBlock.valueBlock.value) {
      if (prepareIndefiniteForm2(value)) {
        baseBlock.lenBlock.isIndefiniteForm = true;
      }
    }
  }
  return !!((_a2 = baseBlock.lenBlock) === null || _a2 === undefined ? undefined : _a2.isIndefiniteForm);
}

class BaseStringBlock2 extends BaseBlock2 {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  constructor({ value = EMPTY_STRING2, ...parameters } = {}, stringValueBlockType) {
    super(parameters, stringValueBlockType);
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    this.fromBuffer(this.valueBlock.valueHexView);
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
  }
}
BaseStringBlock2.NAME = "BaseStringBlock";

class LocalPrimitiveValueBlock2 extends HexBlock2(ValueBlock2) {
  constructor({ isHexOnly = true, ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = isHexOnly;
  }
}
LocalPrimitiveValueBlock2.NAME = "PrimitiveValueBlock";
var _a$w2;

class Primitive2 extends BaseBlock2 {
  constructor(parameters = {}) {
    super(parameters, LocalPrimitiveValueBlock2);
    this.idBlock.isConstructed = false;
  }
}
_a$w2 = Primitive2;
(() => {
  typeStore2.Primitive = _a$w2;
})();
Primitive2.NAME = "PRIMITIVE";
function localChangeType2(inputObject, newType) {
  if (inputObject instanceof newType) {
    return inputObject;
  }
  const newObject = new newType;
  newObject.idBlock = inputObject.idBlock;
  newObject.lenBlock = inputObject.lenBlock;
  newObject.warnings = inputObject.warnings;
  newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
  return newObject;
}
function localFromBER2(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
  const incomingOffset = inputOffset;
  let returnObject = new BaseBlock2({}, ValueBlock2);
  const baseBlock = new LocalBaseBlock2;
  if (!checkBufferParams2(baseBlock, inputBuffer, inputOffset, inputLength)) {
    returnObject.error = baseBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
  if (!intBuffer.length) {
    returnObject.error = "Zero buffer length";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.idBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.idBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.idBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.idBlock.blockLength;
  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.lenBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.lenBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.lenBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.lenBlock.blockLength;
  if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
    returnObject.error = "Indefinite length form used for primitive encoding form";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let newASN1Type = BaseBlock2;
  switch (returnObject.idBlock.tagClass) {
    case 1:
      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
        returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
        return {
          offset: -1,
          result: returnObject
        };
      }
      switch (returnObject.idBlock.tagNumber) {
        case 0:
          if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
            returnObject.error = "Type [UNIVERSAL 0] is reserved";
            return {
              offset: -1,
              result: returnObject
            };
          }
          newASN1Type = typeStore2.EndOfContent;
          break;
        case 1:
          newASN1Type = typeStore2.Boolean;
          break;
        case 2:
          newASN1Type = typeStore2.Integer;
          break;
        case 3:
          newASN1Type = typeStore2.BitString;
          break;
        case 4:
          newASN1Type = typeStore2.OctetString;
          break;
        case 5:
          newASN1Type = typeStore2.Null;
          break;
        case 6:
          newASN1Type = typeStore2.ObjectIdentifier;
          break;
        case 10:
          newASN1Type = typeStore2.Enumerated;
          break;
        case 12:
          newASN1Type = typeStore2.Utf8String;
          break;
        case 13:
          newASN1Type = typeStore2.RelativeObjectIdentifier;
          break;
        case 14:
          newASN1Type = typeStore2.TIME;
          break;
        case 15:
          returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
          return {
            offset: -1,
            result: returnObject
          };
        case 16:
          newASN1Type = typeStore2.Sequence;
          break;
        case 17:
          newASN1Type = typeStore2.Set;
          break;
        case 18:
          newASN1Type = typeStore2.NumericString;
          break;
        case 19:
          newASN1Type = typeStore2.PrintableString;
          break;
        case 20:
          newASN1Type = typeStore2.TeletexString;
          break;
        case 21:
          newASN1Type = typeStore2.VideotexString;
          break;
        case 22:
          newASN1Type = typeStore2.IA5String;
          break;
        case 23:
          newASN1Type = typeStore2.UTCTime;
          break;
        case 24:
          newASN1Type = typeStore2.GeneralizedTime;
          break;
        case 25:
          newASN1Type = typeStore2.GraphicString;
          break;
        case 26:
          newASN1Type = typeStore2.VisibleString;
          break;
        case 27:
          newASN1Type = typeStore2.GeneralString;
          break;
        case 28:
          newASN1Type = typeStore2.UniversalString;
          break;
        case 29:
          newASN1Type = typeStore2.CharacterString;
          break;
        case 30:
          newASN1Type = typeStore2.BmpString;
          break;
        case 31:
          newASN1Type = typeStore2.DATE;
          break;
        case 32:
          newASN1Type = typeStore2.TimeOfDay;
          break;
        case 33:
          newASN1Type = typeStore2.DateTime;
          break;
        case 34:
          newASN1Type = typeStore2.Duration;
          break;
        default: {
          const newObject = returnObject.idBlock.isConstructed ? new typeStore2.Constructed : new typeStore2.Primitive;
          newObject.idBlock = returnObject.idBlock;
          newObject.lenBlock = returnObject.lenBlock;
          newObject.warnings = returnObject.warnings;
          returnObject = newObject;
        }
      }
      break;
    case 2:
    case 3:
    case 4:
    default: {
      newASN1Type = returnObject.idBlock.isConstructed ? typeStore2.Constructed : typeStore2.Primitive;
    }
  }
  returnObject = localChangeType2(returnObject, newASN1Type);
  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
  returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
  return {
    offset: resultOffset,
    result: returnObject
  };
}
function fromBER2(inputBuffer) {
  if (!inputBuffer.byteLength) {
    const result = new BaseBlock2({}, ValueBlock2);
    result.error = "Input buffer has zero length";
    return {
      offset: -1,
      result
    };
  }
  return localFromBER2(BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
}
function checkLen2(indefiniteLength, length) {
  if (indefiniteLength) {
    return 1;
  }
  return length;
}

class LocalConstructedValueBlock2 extends ValueBlock2 {
  constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {
    super(parameters);
    this.value = value;
    this.isIndefiniteForm = isIndefiniteForm;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams2(this, view, inputOffset, inputLength)) {
      return -1;
    }
    this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
    if (this.valueBeforeDecodeView.length === 0) {
      this.warnings.push("Zero buffer length");
      return inputOffset;
    }
    let currentOffset = inputOffset;
    while (checkLen2(this.isIndefiniteForm, inputLength) > 0) {
      const returnObject = localFromBER2(view, currentOffset, inputLength);
      if (returnObject.offset === -1) {
        this.error = returnObject.result.error;
        this.warnings.concat(returnObject.result.warnings);
        return -1;
      }
      currentOffset = returnObject.offset;
      this.blockLength += returnObject.result.blockLength;
      inputLength -= returnObject.result.blockLength;
      this.value.push(returnObject.result);
      if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME2) {
        break;
      }
    }
    if (this.isIndefiniteForm) {
      if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME2) {
        this.value.pop();
      } else {
        this.warnings.push("No EndOfContent block encoded");
      }
    }
    return currentOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter2;
    for (let i = 0;i < this.value.length; i++) {
      this.value[i].toBER(sizeOnly, _writer);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER2;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      value: []
    };
    for (const value of this.value) {
      object.value.push(value.toJSON());
    }
    return object;
  }
}
LocalConstructedValueBlock2.NAME = "ConstructedValueBlock";
var _a$v2;

class Constructed2 extends BaseBlock2 {
  constructor(parameters = {}) {
    super(parameters, LocalConstructedValueBlock2);
    this.idBlock.isConstructed = true;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    const values = [];
    for (const value of this.valueBlock.value) {
      values.push(value.toString("ascii").split(`
`).map((o) => `  ${o}`).join(`
`));
    }
    const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
    return values.length ? `${blockName} :
${values.join(`
`)}` : `${blockName} :`;
  }
}
_a$v2 = Constructed2;
(() => {
  typeStore2.Constructed = _a$v2;
})();
Constructed2.NAME = "CONSTRUCTED";

class LocalEndOfContentValueBlock2 extends ValueBlock2 {
  fromBER(inputBuffer, inputOffset, _inputLength) {
    return inputOffset;
  }
  toBER(_sizeOnly) {
    return EMPTY_BUFFER2;
  }
}
LocalEndOfContentValueBlock2.override = "EndOfContentValueBlock";
var _a$u2;

class EndOfContent2 extends BaseBlock2 {
  constructor(parameters = {}) {
    super(parameters, LocalEndOfContentValueBlock2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 0;
  }
}
_a$u2 = EndOfContent2;
(() => {
  typeStore2.EndOfContent = _a$u2;
})();
EndOfContent2.NAME = END_OF_CONTENT_NAME2;
var _a$t2;

class Null2 extends BaseBlock2 {
  constructor(parameters = {}) {
    super(parameters, ValueBlock2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 5;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (this.lenBlock.length > 0)
      this.warnings.push("Non-zero length of value block for Null type");
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    this.blockLength += inputLength;
    if (inputOffset + inputLength > inputBuffer.byteLength) {
      this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
      return -1;
    }
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    const retBuf = new ArrayBuffer(2);
    if (!sizeOnly) {
      const retView = new Uint8Array(retBuf);
      retView[0] = 5;
      retView[1] = 0;
    }
    if (writer) {
      writer.write(retBuf);
    }
    return retBuf;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME}`;
  }
}
_a$t2 = Null2;
(() => {
  typeStore2.Null = _a$t2;
})();
Null2.NAME = "NULL";

class LocalBooleanValueBlock2 extends HexBlock2(ValueBlock2) {
  get value() {
    for (const octet of this.valueHexView) {
      if (octet > 0) {
        return true;
      }
    }
    return false;
  }
  set value(value) {
    this.valueHexView[0] = value ? 255 : 0;
  }
  constructor({ value, ...parameters } = {}) {
    super(parameters);
    if (parameters.valueHex) {
      this.valueHexView = BufferSourceConverter.toUint8Array(parameters.valueHex);
    } else {
      this.valueHexView = new Uint8Array(1);
    }
    if (value) {
      this.value = value;
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams2(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (inputLength > 1)
      this.warnings.push("Boolean value encoded in more then 1 octet");
    this.isHexOnly = true;
    utilDecodeTC.call(this);
    this.blockLength = inputLength;
    return inputOffset + inputLength;
  }
  toBER() {
    return this.valueHexView.slice();
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalBooleanValueBlock2.NAME = "BooleanValueBlock";
var _a$s2;

class Boolean3 extends BaseBlock2 {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  constructor(parameters = {}) {
    super(parameters, LocalBooleanValueBlock2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 1;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.getValue}`;
  }
}
_a$s2 = Boolean3;
(() => {
  typeStore2.Boolean = _a$s2;
})();
Boolean3.NAME = "BOOLEAN";

class LocalOctetStringValueBlock2 extends HexBlock2(LocalConstructedValueBlock2) {
  constructor({ isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.isConstructed = isConstructed;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = 0;
    if (this.isConstructed) {
      this.isHexOnly = false;
      resultOffset = LocalConstructedValueBlock2.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (let i = 0;i < this.value.length; i++) {
        const currentBlockName = this.value[i].constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME2) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== OCTET_STRING_NAME2) {
          this.error = "OCTET STRING may consists of OCTET STRINGs only";
          return -1;
        }
      }
    } else {
      this.isHexOnly = true;
      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
      this.blockLength = inputLength;
    }
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed)
      return LocalConstructedValueBlock2.prototype.toBER.call(this, sizeOnly, writer);
    return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isConstructed: this.isConstructed
    };
  }
}
LocalOctetStringValueBlock2.NAME = "OctetStringValueBlock";
var _a$r2;

class OctetString3 extends BaseBlock2 {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b, _c;
    (_b = parameters.isConstructed) !== null && _b !== undefined || (parameters.isConstructed = !!((_c = parameters.value) === null || _c === undefined ? undefined : _c.length));
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalOctetStringValueBlock2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 4;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    if (inputLength === 0) {
      if (this.idBlock.error.length === 0)
        this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0)
        this.blockLength += this.lenBlock.blockLength;
      return inputOffset;
    }
    if (!this.valueBlock.isConstructed) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      const buf = view.subarray(inputOffset, inputOffset + inputLength);
      try {
        if (buf.byteLength) {
          const asn = localFromBER2(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength) {
            this.valueBlock.value = [asn.result];
          }
        }
      } catch {}
    }
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed2.prototype.onAsciiEncoding.call(this);
    }
    const name2 = this.constructor.NAME;
    const value = Convert.ToHex(this.valueBlock.valueHexView);
    return `${name2} : ${value}`;
  }
  getValue() {
    if (!this.idBlock.isConstructed) {
      return this.valueBlock.valueHexView.slice().buffer;
    }
    const array = [];
    for (const content of this.valueBlock.value) {
      if (content instanceof _a$r2) {
        array.push(content.valueBlock.valueHexView);
      }
    }
    return BufferSourceConverter.concat(array);
  }
}
_a$r2 = OctetString3;
(() => {
  typeStore2.OctetString = _a$r2;
})();
OctetString3.NAME = OCTET_STRING_NAME2;

class LocalBitStringValueBlock2 extends HexBlock2(LocalConstructedValueBlock2) {
  constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.unusedBits = unusedBits;
    this.isConstructed = isConstructed;
    this.blockLength = this.valueHexView.byteLength;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    let resultOffset = -1;
    if (this.isConstructed) {
      resultOffset = LocalConstructedValueBlock2.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (const value of this.value) {
        const currentBlockName = value.constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME2) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== BIT_STRING_NAME2) {
          this.error = "BIT STRING may consists of BIT STRINGs only";
          return -1;
        }
        const valueBlock = value.valueBlock;
        if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
          this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
          return -1;
        }
        this.unusedBits = valueBlock.unusedBits;
      }
      return resultOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams2(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.unusedBits = intBuffer[0];
    if (this.unusedBits > 7) {
      this.error = "Unused bits for BitString must be in range 0-7";
      return -1;
    }
    if (!this.unusedBits) {
      const buf = intBuffer.subarray(1);
      try {
        if (buf.byteLength) {
          const asn = localFromBER2(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength - 1) {
            this.value = [asn.result];
          }
        }
      } catch {}
    }
    this.valueHexView = intBuffer.subarray(1);
    this.blockLength = intBuffer.length;
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed) {
      return LocalConstructedValueBlock2.prototype.toBER.call(this, sizeOnly, writer);
    }
    if (sizeOnly) {
      return new ArrayBuffer(this.valueHexView.byteLength + 1);
    }
    if (!this.valueHexView.byteLength) {
      return EMPTY_BUFFER2;
    }
    const retView = new Uint8Array(this.valueHexView.length + 1);
    retView[0] = this.unusedBits;
    retView.set(this.valueHexView, 1);
    return retView.buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      unusedBits: this.unusedBits,
      isConstructed: this.isConstructed
    };
  }
}
LocalBitStringValueBlock2.NAME = "BitStringValueBlock";
var _a$q2;

class BitString3 extends BaseBlock2 {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b, _c;
    (_b = parameters.isConstructed) !== null && _b !== undefined || (parameters.isConstructed = !!((_c = parameters.value) === null || _c === undefined ? undefined : _c.length));
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalBitStringValueBlock2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 3;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed2.prototype.onAsciiEncoding.call(this);
    } else {
      const bits = [];
      const valueHex = this.valueBlock.valueHexView;
      for (const byte of valueHex) {
        bits.push(byte.toString(2).padStart(8, "0"));
      }
      const bitsStr = bits.join("");
      const name2 = this.constructor.NAME;
      const value = bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits);
      return `${name2} : ${value}`;
    }
  }
}
_a$q2 = BitString3;
(() => {
  typeStore2.BitString = _a$q2;
})();
BitString3.NAME = BIT_STRING_NAME2;
var _a$p2;
function viewAdd2(first, second) {
  const c = new Uint8Array([0]);
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  let firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value = 0;
  const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
  let counter = 0;
  for (let i = max;i >= 0; i--, counter++) {
    switch (true) {
      case counter < secondViewCopy.length:
        value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
        break;
      default:
        value = firstViewCopy[firstViewCopyLength - counter] + c[0];
    }
    c[0] = value / 10;
    switch (true) {
      case counter >= firstViewCopy.length:
        firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
        break;
      default:
        firstViewCopy[firstViewCopyLength - counter] = value % 10;
    }
  }
  if (c[0] > 0)
    firstViewCopy = utilConcatView(c, firstViewCopy);
  return firstViewCopy;
}
function power22(n) {
  if (n >= powers22.length) {
    for (let p = powers22.length;p <= n; p++) {
      const c = new Uint8Array([0]);
      let digits = powers22[p - 1].slice(0);
      for (let i = digits.length - 1;i >= 0; i--) {
        const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
        c[0] = newValue[0] / 10;
        digits[i] = newValue[0] % 10;
      }
      if (c[0] > 0)
        digits = utilConcatView(c, digits);
      powers22.push(digits);
    }
  }
  return powers22[n];
}
function viewSub2(first, second) {
  let b = 0;
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  const firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value;
  let counter = 0;
  for (let i = secondViewCopyLength;i >= 0; i--, counter++) {
    value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
    switch (true) {
      case value < 0:
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
        break;
      default:
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
    }
  }
  if (b > 0) {
    for (let i = firstViewCopyLength - secondViewCopyLength + 1;i >= 0; i--, counter++) {
      value = firstViewCopy[firstViewCopyLength - counter] - b;
      if (value < 0) {
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
      } else {
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
        break;
      }
    }
  }
  return firstViewCopy.slice();
}

class LocalIntegerValueBlock2 extends HexBlock2(ValueBlock2) {
  setValueHex() {
    if (this.valueHexView.length >= 4) {
      this.warnings.push("Too big Integer for decoding, hex only");
      this.isHexOnly = true;
      this._valueDec = 0;
    } else {
      this.isHexOnly = false;
      if (this.valueHexView.length > 0) {
        this._valueDec = utilDecodeTC.call(this);
      }
    }
  }
  constructor({ value, ...parameters } = {}) {
    super(parameters);
    this._valueDec = 0;
    if (parameters.valueHex) {
      this.setValueHex();
    }
    if (value !== undefined) {
      this.valueDec = value;
    }
  }
  set valueDec(v) {
    this._valueDec = v;
    this.isHexOnly = false;
    this.valueHexView = new Uint8Array(utilEncodeTC(v));
  }
  get valueDec() {
    return this._valueDec;
  }
  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
    if (offset === -1)
      return offset;
    const view = this.valueHexView;
    if (view[0] === 0 && (view[1] & 128) !== 0) {
      this.valueHexView = view.subarray(1);
    } else {
      if (expectedLength !== 0) {
        if (view.length < expectedLength) {
          if (expectedLength - view.length > 1)
            expectedLength = view.length + 1;
          this.valueHexView = view.subarray(expectedLength - view.length);
        }
      }
    }
    return offset;
  }
  toDER(sizeOnly = false) {
    const view = this.valueHexView;
    switch (true) {
      case (view[0] & 128) !== 0:
        {
          const updatedView = new Uint8Array(this.valueHexView.length + 1);
          updatedView[0] = 0;
          updatedView.set(view, 1);
          this.valueHexView = updatedView;
        }
        break;
      case (view[0] === 0 && (view[1] & 128) === 0):
        {
          this.valueHexView = this.valueHexView.subarray(1);
        }
        break;
    }
    return this.toBER(sizeOnly);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
    if (resultOffset === -1) {
      return resultOffset;
    }
    this.setValueHex();
    return resultOffset;
  }
  toBER(sizeOnly) {
    return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
  toString() {
    const firstBit = this.valueHexView.length * 8 - 1;
    let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
    let bitNumber = 0;
    let currentByte;
    const asn1View = this.valueHexView;
    let result = "";
    let flag = false;
    for (let byteNumber = asn1View.byteLength - 1;byteNumber >= 0; byteNumber--) {
      currentByte = asn1View[byteNumber];
      for (let i = 0;i < 8; i++) {
        if ((currentByte & 1) === 1) {
          switch (bitNumber) {
            case firstBit:
              digits = viewSub2(power22(bitNumber), digits);
              result = "-";
              break;
            default:
              digits = viewAdd2(digits, power22(bitNumber));
          }
        }
        bitNumber++;
        currentByte >>= 1;
      }
    }
    for (let i = 0;i < digits.length; i++) {
      if (digits[i])
        flag = true;
      if (flag)
        result += digitsString2.charAt(digits[i]);
    }
    if (flag === false)
      result += digitsString2.charAt(0);
    return result;
  }
}
_a$p2 = LocalIntegerValueBlock2;
LocalIntegerValueBlock2.NAME = "IntegerValueBlock";
(() => {
  Object.defineProperty(_a$p2.prototype, "valueHex", {
    set: function(v) {
      this.valueHexView = new Uint8Array(v);
      this.setValueHex();
    },
    get: function() {
      return this.valueHexView.slice().buffer;
    }
  });
})();
var _a$o2;

class Integer2 extends BaseBlock2 {
  constructor(parameters = {}) {
    super(parameters, LocalIntegerValueBlock2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 2;
  }
  toBigInt() {
    assertBigInt2();
    return BigInt(this.valueBlock.toString());
  }
  static fromBigInt(value) {
    assertBigInt2();
    const bigIntValue = BigInt(value);
    const writer = new ViewWriter2;
    const hex = bigIntValue.toString(16).replace(/^-/, "");
    const view = new Uint8Array(Convert.FromHex(hex));
    if (bigIntValue < 0) {
      const first = new Uint8Array(view.length + (view[0] & 128 ? 1 : 0));
      first[0] |= 128;
      const firstInt = BigInt(`0x${Convert.ToHex(first)}`);
      const secondInt = firstInt + bigIntValue;
      const second = BufferSourceConverter.toUint8Array(Convert.FromHex(secondInt.toString(16)));
      second[0] |= 128;
      writer.write(second);
    } else {
      if (view[0] & 128) {
        writer.write(new Uint8Array([0]));
      }
      writer.write(view);
    }
    const res = new _a$o2({ valueHex: writer.final() });
    return res;
  }
  convertToDER() {
    const integer = new _a$o2({ valueHex: this.valueBlock.valueHexView });
    integer.valueBlock.toDER();
    return integer;
  }
  convertFromDER() {
    return new _a$o2({
      valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
    });
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
  }
}
_a$o2 = Integer2;
(() => {
  typeStore2.Integer = _a$o2;
})();
Integer2.NAME = "INTEGER";
var _a$n2;

class Enumerated2 extends Integer2 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 10;
  }
}
_a$n2 = Enumerated2;
(() => {
  typeStore2.Enumerated = _a$n2;
})();
Enumerated2.NAME = "ENUMERATED";

class LocalSidValueBlock2 extends HexBlock2(ValueBlock2) {
  constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
    this.isFirstSid = isFirstSid;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams2(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0;i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0;i < this.blockLength; i++) {
      tempView[i] = this.valueHexView[i];
    }
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  set valueBigInt(value) {
    assertBigInt2();
    let bits = BigInt(value).toString(2);
    while (bits.length % 7) {
      bits = "0" + bits;
    }
    const bytes = new Uint8Array(bits.length / 7);
    for (let i = 0;i < bytes.length; i++) {
      bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 128 : 0);
    }
    this.fromBER(bytes.buffer, 0, bytes.length);
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0;i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER2;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0;i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      if (this.isFirstSid) {
        let sidValue = this.valueDec;
        if (this.valueDec <= 39)
          result = "0.";
        else {
          if (this.valueDec <= 79) {
            result = "1.";
            sidValue -= 40;
          } else {
            result = "2.";
            sidValue -= 80;
          }
        }
        result += sidValue.toString();
      } else
        result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec,
      isFirstSid: this.isFirstSid
    };
  }
}
LocalSidValueBlock2.NAME = "sidBlock";

class LocalObjectIdentifierValueBlock2 extends ValueBlock2 {
  constructor({ value = EMPTY_STRING2, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalSidValueBlock2;
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      if (this.value.length === 0)
        sidBlock.isFirstSid = true;
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly) {
    const retBuffers = [];
    for (let i = 0;i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER2;
      }
      retBuffers.push(valueBuf);
    }
    return concat2(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    let flag = false;
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      if (flag) {
        const sidBlock = this.value[0];
        let plus = 0;
        switch (sidBlock.valueDec) {
          case 0:
            break;
          case 1:
            plus = 40;
            break;
          case 2:
            plus = 80;
            break;
          default:
            this.value = [];
            return;
        }
        const parsedSID = parseInt(sid, 10);
        if (isNaN(parsedSID))
          return;
        sidBlock.valueDec = parsedSID + plus;
        flag = false;
      } else {
        const sidBlock = new LocalSidValueBlock2;
        if (sid > Number.MAX_SAFE_INTEGER) {
          assertBigInt2();
          const sidValue = BigInt(sid);
          sidBlock.valueBigInt = sidValue;
        } else {
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec))
            return;
        }
        if (!this.value.length) {
          sidBlock.isFirstSid = true;
          flag = true;
        }
        this.value.push(sidBlock);
      }
    } while (pos2 !== -1);
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0;i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        if (this.value[i].isFirstSid)
          result = `2.{${sidStr} - 80}`;
        else
          result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0;i < this.value.length; i++) {
      object.sidArray.push(this.value[i].toJSON());
    }
    return object;
  }
}
LocalObjectIdentifierValueBlock2.NAME = "ObjectIdentifierValueBlock";
var _a$m2;

class ObjectIdentifier2 extends BaseBlock2 {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  constructor(parameters = {}) {
    super(parameters, LocalObjectIdentifierValueBlock2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 6;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$m2 = ObjectIdentifier2;
(() => {
  typeStore2.ObjectIdentifier = _a$m2;
})();
ObjectIdentifier2.NAME = "OBJECT IDENTIFIER";

class LocalRelativeSidValueBlock2 extends HexBlock2(LocalBaseBlock2) {
  constructor({ valueDec = 0, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (inputLength === 0)
      return inputOffset;
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams2(this, inputView, inputOffset, inputLength))
      return -1;
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0;i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0;i < this.blockLength; i++)
      tempView[i] = this.valueHexView[i];
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0;i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER2;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0;i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView.buffer;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
}
LocalRelativeSidValueBlock2.NAME = "relativeSidBlock";

class LocalRelativeObjectIdentifierValueBlock2 extends ValueBlock2 {
  constructor({ value = EMPTY_STRING2, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalRelativeSidValueBlock2;
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly, _writer) {
    const retBuffers = [];
    for (let i = 0;i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER2;
      }
      retBuffers.push(valueBuf);
    }
    return concat2(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      const sidBlock = new LocalRelativeSidValueBlock2;
      sidBlock.valueDec = parseInt(sid, 10);
      if (isNaN(sidBlock.valueDec))
        return true;
      this.value.push(sidBlock);
    } while (pos2 !== -1);
    return true;
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0;i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0;i < this.value.length; i++)
      object.sidArray.push(this.value[i].toJSON());
    return object;
  }
}
LocalRelativeObjectIdentifierValueBlock2.NAME = "RelativeObjectIdentifierValueBlock";
var _a$l2;

class RelativeObjectIdentifier2 extends BaseBlock2 {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  constructor(parameters = {}) {
    super(parameters, LocalRelativeObjectIdentifierValueBlock2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 13;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$l2 = RelativeObjectIdentifier2;
(() => {
  typeStore2.RelativeObjectIdentifier = _a$l2;
})();
RelativeObjectIdentifier2.NAME = "RelativeObjectIdentifier";
var _a$k2;

class Sequence2 extends Constructed2 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 16;
  }
}
_a$k2 = Sequence2;
(() => {
  typeStore2.Sequence = _a$k2;
})();
Sequence2.NAME = "SEQUENCE";
var _a$j2;

class Set3 extends Constructed2 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 17;
  }
}
_a$j2 = Set3;
(() => {
  typeStore2.Set = _a$j2;
})();
Set3.NAME = "SET";

class LocalStringValueBlock2 extends HexBlock2(ValueBlock2) {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = true;
    this.value = EMPTY_STRING2;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalStringValueBlock2.NAME = "StringValueBlock";

class LocalSimpleStringValueBlock2 extends LocalStringValueBlock2 {
}
LocalSimpleStringValueBlock2.NAME = "SimpleStringValueBlock";

class LocalSimpleStringBlock2 extends BaseStringBlock2 {
  constructor({ ...parameters } = {}) {
    super(parameters, LocalSimpleStringValueBlock2);
  }
  fromBuffer(inputBuffer) {
    this.valueBlock.value = String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer));
  }
  fromString(inputString) {
    const strLen = inputString.length;
    const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
    for (let i = 0;i < strLen; i++)
      view[i] = inputString.charCodeAt(i);
    this.valueBlock.value = inputString;
  }
}
LocalSimpleStringBlock2.NAME = "SIMPLE STRING";

class LocalUtf8StringValueBlock2 extends LocalSimpleStringBlock2 {
  fromBuffer(inputBuffer) {
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
    try {
      this.valueBlock.value = Convert.ToUtf8String(inputBuffer);
    } catch (ex) {
      this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
      this.valueBlock.value = Convert.ToBinary(inputBuffer);
    }
  }
  fromString(inputString) {
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf8String(inputString));
    this.valueBlock.value = inputString;
  }
}
LocalUtf8StringValueBlock2.NAME = "Utf8StringValueBlock";
var _a$i2;

class Utf8String2 extends LocalUtf8StringValueBlock2 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 12;
  }
}
_a$i2 = Utf8String2;
(() => {
  typeStore2.Utf8String = _a$i2;
})();
Utf8String2.NAME = "UTF8String";

class LocalBmpStringValueBlock2 extends LocalSimpleStringBlock2 {
  fromBuffer(inputBuffer) {
    this.valueBlock.value = Convert.ToUtf16String(inputBuffer);
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
  }
  fromString(inputString) {
    this.valueBlock.value = inputString;
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf16String(inputString));
  }
}
LocalBmpStringValueBlock2.NAME = "BmpStringValueBlock";
var _a$h2;

class BmpString2 extends LocalBmpStringValueBlock2 {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 30;
  }
}
_a$h2 = BmpString2;
(() => {
  typeStore2.BmpString = _a$h2;
})();
BmpString2.NAME = "BMPString";

class LocalUniversalStringValueBlock2 extends LocalSimpleStringBlock2 {
  fromBuffer(inputBuffer) {
    const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
    const valueView = new Uint8Array(copyBuffer);
    for (let i = 0;i < valueView.length; i += 4) {
      valueView[i] = valueView[i + 3];
      valueView[i + 1] = valueView[i + 2];
      valueView[i + 2] = 0;
      valueView[i + 3] = 0;
    }
    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
  }
  fromString(inputString) {
    const strLength = inputString.length;
    const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
    for (let i = 0;i < strLength; i++) {
      const codeBuf = utilToBase(inputString.charCodeAt(i), 8);
      const codeView = new Uint8Array(codeBuf);
      if (codeView.length > 4)
        continue;
      const dif = 4 - codeView.length;
      for (let j = codeView.length - 1;j >= 0; j--)
        valueHexView[i * 4 + j + dif] = codeView[j];
    }
    this.valueBlock.value = inputString;
  }
}
LocalUniversalStringValueBlock2.NAME = "UniversalStringValueBlock";
var _a$g2;

class UniversalString2 extends LocalUniversalStringValueBlock2 {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 28;
  }
}
_a$g2 = UniversalString2;
(() => {
  typeStore2.UniversalString = _a$g2;
})();
UniversalString2.NAME = "UniversalString";
var _a$f2;

class NumericString2 extends LocalSimpleStringBlock2 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 18;
  }
}
_a$f2 = NumericString2;
(() => {
  typeStore2.NumericString = _a$f2;
})();
NumericString2.NAME = "NumericString";
var _a$e2;

class PrintableString2 extends LocalSimpleStringBlock2 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 19;
  }
}
_a$e2 = PrintableString2;
(() => {
  typeStore2.PrintableString = _a$e2;
})();
PrintableString2.NAME = "PrintableString";
var _a$d2;

class TeletexString2 extends LocalSimpleStringBlock2 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 20;
  }
}
_a$d2 = TeletexString2;
(() => {
  typeStore2.TeletexString = _a$d2;
})();
TeletexString2.NAME = "TeletexString";
var _a$c2;

class VideotexString2 extends LocalSimpleStringBlock2 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 21;
  }
}
_a$c2 = VideotexString2;
(() => {
  typeStore2.VideotexString = _a$c2;
})();
VideotexString2.NAME = "VideotexString";
var _a$b2;

class IA5String2 extends LocalSimpleStringBlock2 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 22;
  }
}
_a$b2 = IA5String2;
(() => {
  typeStore2.IA5String = _a$b2;
})();
IA5String2.NAME = "IA5String";
var _a$a2;

class GraphicString2 extends LocalSimpleStringBlock2 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 25;
  }
}
_a$a2 = GraphicString2;
(() => {
  typeStore2.GraphicString = _a$a2;
})();
GraphicString2.NAME = "GraphicString";
var _a$92;

class VisibleString2 extends LocalSimpleStringBlock2 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 26;
  }
}
_a$92 = VisibleString2;
(() => {
  typeStore2.VisibleString = _a$92;
})();
VisibleString2.NAME = "VisibleString";
var _a$82;

class GeneralString2 extends LocalSimpleStringBlock2 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 27;
  }
}
_a$82 = GeneralString2;
(() => {
  typeStore2.GeneralString = _a$82;
})();
GeneralString2.NAME = "GeneralString";
var _a$72;

class CharacterString2 extends LocalSimpleStringBlock2 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 29;
  }
}
_a$72 = CharacterString2;
(() => {
  typeStore2.CharacterString = _a$72;
})();
CharacterString2.NAME = "CharacterString";
var _a$62;

class UTCTime2 extends VisibleString2 {
  constructor({ value, valueDate, ...parameters } = {}) {
    super(parameters);
    this.year = 0;
    this.month = 0;
    this.day = 0;
    this.hour = 0;
    this.minute = 0;
    this.second = 0;
    if (value) {
      this.fromString(value);
      this.valueBlock.valueHexView = new Uint8Array(value.length);
      for (let i = 0;i < value.length; i++)
        this.valueBlock.valueHexView[i] = value.charCodeAt(i);
    }
    if (valueDate) {
      this.fromDate(valueDate);
      this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
    }
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 23;
  }
  fromBuffer(inputBuffer) {
    this.fromString(String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer)));
  }
  toBuffer() {
    const str = this.toString();
    const buffer = new ArrayBuffer(str.length);
    const view = new Uint8Array(buffer);
    for (let i = 0;i < str.length; i++)
      view[i] = str.charCodeAt(i);
    return buffer;
  }
  fromDate(inputDate) {
    this.year = inputDate.getUTCFullYear();
    this.month = inputDate.getUTCMonth() + 1;
    this.day = inputDate.getUTCDate();
    this.hour = inputDate.getUTCHours();
    this.minute = inputDate.getUTCMinutes();
    this.second = inputDate.getUTCSeconds();
  }
  toDate() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
  }
  fromString(inputString) {
    const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
    const parserArray = parser.exec(inputString);
    if (parserArray === null) {
      this.error = "Wrong input string for conversion";
      return;
    }
    const year = parseInt(parserArray[1], 10);
    if (year >= 50)
      this.year = 1900 + year;
    else
      this.year = 2000 + year;
    this.month = parseInt(parserArray[2], 10);
    this.day = parseInt(parserArray[3], 10);
    this.hour = parseInt(parserArray[4], 10);
    this.minute = parseInt(parserArray[5], 10);
    this.second = parseInt(parserArray[6], 10);
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = new Array(7);
      outputArray[0] = padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);
      outputArray[1] = padNumber(this.month, 2);
      outputArray[2] = padNumber(this.day, 2);
      outputArray[3] = padNumber(this.hour, 2);
      outputArray[4] = padNumber(this.minute, 2);
      outputArray[5] = padNumber(this.second, 2);
      outputArray[6] = "Z";
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second
    };
  }
}
_a$62 = UTCTime2;
(() => {
  typeStore2.UTCTime = _a$62;
})();
UTCTime2.NAME = "UTCTime";
var _a$52;

class GeneralizedTime2 extends UTCTime2 {
  constructor(parameters = {}) {
    var _b;
    super(parameters);
    (_b = this.millisecond) !== null && _b !== undefined || (this.millisecond = 0);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 24;
  }
  fromDate(inputDate) {
    super.fromDate(inputDate);
    this.millisecond = inputDate.getUTCMilliseconds();
  }
  toDate() {
    const utcDate = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond);
    return new Date(utcDate);
  }
  fromString(inputString) {
    let isUTC = false;
    let timeString = "";
    let dateTimeString = "";
    let fractionPart = 0;
    let parser;
    let hourDifference = 0;
    let minuteDifference = 0;
    if (inputString[inputString.length - 1] === "Z") {
      timeString = inputString.substring(0, inputString.length - 1);
      isUTC = true;
    } else {
      const number = new Number(inputString[inputString.length - 1]);
      if (isNaN(number.valueOf()))
        throw new Error("Wrong input string for conversion");
      timeString = inputString;
    }
    if (isUTC) {
      if (timeString.indexOf("+") !== -1)
        throw new Error("Wrong input string for conversion");
      if (timeString.indexOf("-") !== -1)
        throw new Error("Wrong input string for conversion");
    } else {
      let multiplier = 1;
      let differencePosition = timeString.indexOf("+");
      let differenceString = "";
      if (differencePosition === -1) {
        differencePosition = timeString.indexOf("-");
        multiplier = -1;
      }
      if (differencePosition !== -1) {
        differenceString = timeString.substring(differencePosition + 1);
        timeString = timeString.substring(0, differencePosition);
        if (differenceString.length !== 2 && differenceString.length !== 4)
          throw new Error("Wrong input string for conversion");
        let number = parseInt(differenceString.substring(0, 2), 10);
        if (isNaN(number.valueOf()))
          throw new Error("Wrong input string for conversion");
        hourDifference = multiplier * number;
        if (differenceString.length === 4) {
          number = parseInt(differenceString.substring(2, 4), 10);
          if (isNaN(number.valueOf()))
            throw new Error("Wrong input string for conversion");
          minuteDifference = multiplier * number;
        }
      }
    }
    let fractionPointPosition = timeString.indexOf(".");
    if (fractionPointPosition === -1)
      fractionPointPosition = timeString.indexOf(",");
    if (fractionPointPosition !== -1) {
      const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
      if (isNaN(fractionPartCheck.valueOf()))
        throw new Error("Wrong input string for conversion");
      fractionPart = fractionPartCheck.valueOf();
      dateTimeString = timeString.substring(0, fractionPointPosition);
    } else
      dateTimeString = timeString;
    switch (true) {
      case dateTimeString.length === 8:
        parser = /(\d{4})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1)
          throw new Error("Wrong input string for conversion");
        break;
      case dateTimeString.length === 10:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.minute = Math.floor(fractionResult);
          fractionResult = 60 * (fractionResult - this.minute);
          this.second = Math.floor(fractionResult);
          fractionResult = 1000 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 12:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.second = Math.floor(fractionResult);
          fractionResult = 1000 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 14:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          const fractionResult = 1000 * fractionPart;
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      default:
        throw new Error("Wrong input string for conversion");
    }
    const parserArray = parser.exec(dateTimeString);
    if (parserArray === null)
      throw new Error("Wrong input string for conversion");
    for (let j = 1;j < parserArray.length; j++) {
      switch (j) {
        case 1:
          this.year = parseInt(parserArray[j], 10);
          break;
        case 2:
          this.month = parseInt(parserArray[j], 10);
          break;
        case 3:
          this.day = parseInt(parserArray[j], 10);
          break;
        case 4:
          this.hour = parseInt(parserArray[j], 10) + hourDifference;
          break;
        case 5:
          this.minute = parseInt(parserArray[j], 10) + minuteDifference;
          break;
        case 6:
          this.second = parseInt(parserArray[j], 10);
          break;
        default:
          throw new Error("Wrong input string for conversion");
      }
    }
    if (isUTC === false) {
      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
      this.year = tempDate.getUTCFullYear();
      this.month = tempDate.getUTCMonth();
      this.day = tempDate.getUTCDay();
      this.hour = tempDate.getUTCHours();
      this.minute = tempDate.getUTCMinutes();
      this.second = tempDate.getUTCSeconds();
      this.millisecond = tempDate.getUTCMilliseconds();
    }
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = [];
      outputArray.push(padNumber(this.year, 4));
      outputArray.push(padNumber(this.month, 2));
      outputArray.push(padNumber(this.day, 2));
      outputArray.push(padNumber(this.hour, 2));
      outputArray.push(padNumber(this.minute, 2));
      outputArray.push(padNumber(this.second, 2));
      if (this.millisecond !== 0) {
        outputArray.push(".");
        outputArray.push(padNumber(this.millisecond, 3));
      }
      outputArray.push("Z");
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  toJSON() {
    return {
      ...super.toJSON(),
      millisecond: this.millisecond
    };
  }
}
_a$52 = GeneralizedTime2;
(() => {
  typeStore2.GeneralizedTime = _a$52;
})();
GeneralizedTime2.NAME = "GeneralizedTime";
var _a$42;

class DATE2 extends Utf8String2 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 31;
  }
}
_a$42 = DATE2;
(() => {
  typeStore2.DATE = _a$42;
})();
DATE2.NAME = "DATE";
var _a$32;

class TimeOfDay2 extends Utf8String2 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 32;
  }
}
_a$32 = TimeOfDay2;
(() => {
  typeStore2.TimeOfDay = _a$32;
})();
TimeOfDay2.NAME = "TimeOfDay";
var _a$22;

class DateTime2 extends Utf8String2 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 33;
  }
}
_a$22 = DateTime2;
(() => {
  typeStore2.DateTime = _a$22;
})();
DateTime2.NAME = "DateTime";
var _a$12;

class Duration2 extends Utf8String2 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 34;
  }
}
_a$12 = Duration2;
(() => {
  typeStore2.Duration = _a$12;
})();
Duration2.NAME = "Duration";
var _a2;

class TIME2 extends Utf8String2 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 14;
  }
}
_a2 = TIME2;
(() => {
  typeStore2.TIME = _a2;
})();
TIME2.NAME = "TIME";

class Any2 {
  constructor({ name: name2 = EMPTY_STRING2, optional = false } = {}) {
    this.name = name2;
    this.optional = optional;
  }
}

class Choice2 extends Any2 {
  constructor({ value = [], ...parameters } = {}) {
    super(parameters);
    this.value = value;
  }
}

class Repeated2 extends Any2 {
  constructor({ value = new Any2, local = false, ...parameters } = {}) {
    super(parameters);
    this.value = value;
    this.local = local;
  }
}

class RawData2 {
  get data() {
    return this.dataView.slice().buffer;
  }
  set data(value) {
    this.dataView = BufferSourceConverter.toUint8Array(value);
  }
  constructor({ data = EMPTY_VIEW2 } = {}) {
    this.dataView = BufferSourceConverter.toUint8Array(data);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const endLength = inputOffset + inputLength;
    this.dataView = BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
    return endLength;
  }
  toBER(_sizeOnly) {
    return this.dataView.slice().buffer;
  }
}
function compareSchema2(root, inputData, inputSchema) {
  if (inputSchema instanceof Choice2) {
    for (const element of inputSchema.value) {
      const result = compareSchema2(root, inputData, element);
      if (result.verified) {
        return {
          verified: true,
          result: root
        };
      }
    }
    {
      const _result = {
        verified: false,
        result: { error: "Wrong values for Choice type" }
      };
      if (inputSchema.hasOwnProperty(NAME2))
        _result.name = inputSchema.name;
      return _result;
    }
  }
  if (inputSchema instanceof Any2) {
    if (inputSchema.hasOwnProperty(NAME2))
      root[inputSchema.name] = inputData;
    return {
      verified: true,
      result: root
    };
  }
  if (root instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong root object" }
    };
  }
  if (inputData instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 data" }
    };
  }
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (ID_BLOCK2 in inputSchema === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (FROM_BER2 in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (TO_BER2 in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  const encodedId = inputSchema.idBlock.toBER(false);
  if (encodedId.byteLength === 0) {
    return {
      verified: false,
      result: { error: "Error encoding idBlock for ASN.1 schema" }
    };
  }
  const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
  if (decodedOffset === -1) {
    return {
      verified: false,
      result: { error: "Error decoding idBlock for ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS2) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER2) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED2) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
    return {
      verified: false,
      result: root
    };
  }
  if (!(IS_HEX_ONLY2 in inputSchema.idBlock)) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.isHexOnly) {
    if (VALUE_HEX_VIEW2 in inputSchema.idBlock === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    const schemaView = inputSchema.idBlock.valueHexView;
    const asn1View = inputData.idBlock.valueHexView;
    if (schemaView.length !== asn1View.length) {
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0;i < schemaView.length; i++) {
      if (schemaView[i] !== asn1View[1]) {
        return {
          verified: false,
          result: root
        };
      }
    }
  }
  if (inputSchema.name) {
    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING2);
    if (inputSchema.name)
      root[inputSchema.name] = inputData;
  }
  if (inputSchema instanceof typeStore2.Constructed) {
    let admission = 0;
    let result = {
      verified: false,
      result: { error: "Unknown error" }
    };
    let maxLength = inputSchema.valueBlock.value.length;
    if (maxLength > 0) {
      if (inputSchema.valueBlock.value[0] instanceof Repeated2) {
        maxLength = inputData.valueBlock.value.length;
      }
    }
    if (maxLength === 0) {
      return {
        verified: true,
        result: root
      };
    }
    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
      let _optional = true;
      for (let i = 0;i < inputSchema.valueBlock.value.length; i++)
        _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);
      if (_optional) {
        return {
          verified: true,
          result: root
        };
      }
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING2);
        if (inputSchema.name)
          delete root[inputSchema.name];
      }
      root.error = "Inconsistent object length";
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0;i < maxLength; i++) {
      if (i - admission >= inputData.valueBlock.value.length) {
        if (inputSchema.valueBlock.value[i].optional === false) {
          const _result = {
            verified: false,
            result: root
          };
          root.error = "Inconsistent length between ASN.1 data and schema";
          if (inputSchema.name) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING2);
            if (inputSchema.name) {
              delete root[inputSchema.name];
              _result.name = inputSchema.name;
            }
          }
          return _result;
        }
      } else {
        if (inputSchema.valueBlock.value[0] instanceof Repeated2) {
          result = compareSchema2(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[0].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING2);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
          if (NAME2 in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
            let arrayRoot = {};
            if (LOCAL2 in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local)
              arrayRoot = inputData;
            else
              arrayRoot = root;
            if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
              arrayRoot[inputSchema.valueBlock.value[0].name] = [];
            arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
          }
        } else {
          result = compareSchema2(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[i].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING2);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
        }
      }
    }
    if (result.verified === false) {
      const _result = {
        verified: false,
        result: root
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING2);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return {
      verified: true,
      result: root
    };
  }
  if (inputSchema.primitiveSchema && VALUE_HEX_VIEW2 in inputData.valueBlock) {
    const asn1 = localFromBER2(inputData.valueBlock.valueHexView);
    if (asn1.offset === -1) {
      const _result = {
        verified: false,
        result: asn1.result
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING2);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return compareSchema2(root, asn1.result, inputSchema.primitiveSchema);
  }
  return {
    verified: true,
    result: root
  };
}
function verifySchema2(inputBuffer, inputSchema) {
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema type" }
    };
  }
  const asn1 = localFromBER2(BufferSourceConverter.toUint8Array(inputBuffer));
  if (asn1.offset === -1) {
    return {
      verified: false,
      result: asn1.result
    };
  }
  return compareSchema2(asn1.result, asn1.result, inputSchema);
}

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-schema/build/es2015/enums.js
var AsnTypeTypes2;
(function(AsnTypeTypes3) {
  AsnTypeTypes3[AsnTypeTypes3["Sequence"] = 0] = "Sequence";
  AsnTypeTypes3[AsnTypeTypes3["Set"] = 1] = "Set";
  AsnTypeTypes3[AsnTypeTypes3["Choice"] = 2] = "Choice";
})(AsnTypeTypes2 || (AsnTypeTypes2 = {}));
var AsnPropTypes2;
(function(AsnPropTypes3) {
  AsnPropTypes3[AsnPropTypes3["Any"] = 1] = "Any";
  AsnPropTypes3[AsnPropTypes3["Boolean"] = 2] = "Boolean";
  AsnPropTypes3[AsnPropTypes3["OctetString"] = 3] = "OctetString";
  AsnPropTypes3[AsnPropTypes3["BitString"] = 4] = "BitString";
  AsnPropTypes3[AsnPropTypes3["Integer"] = 5] = "Integer";
  AsnPropTypes3[AsnPropTypes3["Enumerated"] = 6] = "Enumerated";
  AsnPropTypes3[AsnPropTypes3["ObjectIdentifier"] = 7] = "ObjectIdentifier";
  AsnPropTypes3[AsnPropTypes3["Utf8String"] = 8] = "Utf8String";
  AsnPropTypes3[AsnPropTypes3["BmpString"] = 9] = "BmpString";
  AsnPropTypes3[AsnPropTypes3["UniversalString"] = 10] = "UniversalString";
  AsnPropTypes3[AsnPropTypes3["NumericString"] = 11] = "NumericString";
  AsnPropTypes3[AsnPropTypes3["PrintableString"] = 12] = "PrintableString";
  AsnPropTypes3[AsnPropTypes3["TeletexString"] = 13] = "TeletexString";
  AsnPropTypes3[AsnPropTypes3["VideotexString"] = 14] = "VideotexString";
  AsnPropTypes3[AsnPropTypes3["IA5String"] = 15] = "IA5String";
  AsnPropTypes3[AsnPropTypes3["GraphicString"] = 16] = "GraphicString";
  AsnPropTypes3[AsnPropTypes3["VisibleString"] = 17] = "VisibleString";
  AsnPropTypes3[AsnPropTypes3["GeneralString"] = 18] = "GeneralString";
  AsnPropTypes3[AsnPropTypes3["CharacterString"] = 19] = "CharacterString";
  AsnPropTypes3[AsnPropTypes3["UTCTime"] = 20] = "UTCTime";
  AsnPropTypes3[AsnPropTypes3["GeneralizedTime"] = 21] = "GeneralizedTime";
  AsnPropTypes3[AsnPropTypes3["DATE"] = 22] = "DATE";
  AsnPropTypes3[AsnPropTypes3["TimeOfDay"] = 23] = "TimeOfDay";
  AsnPropTypes3[AsnPropTypes3["DateTime"] = 24] = "DateTime";
  AsnPropTypes3[AsnPropTypes3["Duration"] = 25] = "Duration";
  AsnPropTypes3[AsnPropTypes3["TIME"] = 26] = "TIME";
  AsnPropTypes3[AsnPropTypes3["Null"] = 27] = "Null";
})(AsnPropTypes2 || (AsnPropTypes2 = {}));

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-schema/build/es2015/types/bit_string.js
class BitString4 {
  constructor(params, unusedBits = 0) {
    this.unusedBits = 0;
    this.value = new ArrayBuffer(0);
    if (params) {
      if (typeof params === "number") {
        this.fromNumber(params);
      } else if (BufferSourceConverter.isBufferSource(params)) {
        this.unusedBits = unusedBits;
        this.value = BufferSourceConverter.toArrayBuffer(params);
      } else {
        throw TypeError("Unsupported type of 'params' argument for BitString");
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof BitString3)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 BitString");
    }
    this.unusedBits = asn.valueBlock.unusedBits;
    this.value = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new BitString3({ unusedBits: this.unusedBits, valueHex: this.value });
  }
  toSchema(name2) {
    return new BitString3({ name: name2 });
  }
  toNumber() {
    let res = "";
    const uintArray = new Uint8Array(this.value);
    for (const octet of uintArray) {
      res += octet.toString(2).padStart(8, "0");
    }
    res = res.split("").reverse().join("");
    if (this.unusedBits) {
      res = res.slice(this.unusedBits).padStart(this.unusedBits, "0");
    }
    return parseInt(res, 2);
  }
  fromNumber(value) {
    let bits = value.toString(2);
    const octetSize = bits.length + 7 >> 3;
    this.unusedBits = (octetSize << 3) - bits.length;
    const octets = new Uint8Array(octetSize);
    bits = bits.padStart(octetSize << 3, "0").split("").reverse().join("");
    let index = 0;
    while (index < octetSize) {
      octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);
      index++;
    }
    this.value = octets.buffer;
  }
}
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-schema/build/es2015/types/octet_string.js
class OctetString4 {
  get byteLength() {
    return this.buffer.byteLength;
  }
  get byteOffset() {
    return 0;
  }
  constructor(param) {
    if (typeof param === "number") {
      this.buffer = new ArrayBuffer(param);
    } else {
      if (BufferSourceConverter.isBufferSource(param)) {
        this.buffer = BufferSourceConverter.toArrayBuffer(param);
      } else if (Array.isArray(param)) {
        this.buffer = new Uint8Array(param);
      } else {
        this.buffer = new ArrayBuffer(0);
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof OctetString3)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString");
    }
    this.buffer = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new OctetString3({ valueHex: this.buffer });
  }
  toSchema(name2) {
    return new OctetString3({ name: name2 });
  }
}
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-schema/build/es2015/converters.js
var AsnAnyConverter2 = {
  fromASN: (value) => value instanceof Null2 ? null : value.valueBeforeDecodeView,
  toASN: (value) => {
    if (value === null) {
      return new Null2;
    }
    const schema = fromBER2(value);
    if (schema.result.error) {
      throw new Error(schema.result.error);
    }
    return schema.result;
  }
};
var AsnIntegerConverter2 = {
  fromASN: (value) => value.valueBlock.valueHexView.byteLength >= 4 ? value.valueBlock.toString() : value.valueBlock.valueDec,
  toASN: (value) => new Integer2({ value: +value })
};
var AsnEnumeratedConverter2 = {
  fromASN: (value) => value.valueBlock.valueDec,
  toASN: (value) => new Enumerated2({ value })
};
var AsnIntegerArrayBufferConverter2 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new Integer2({ valueHex: value })
};
var AsnBitStringConverter2 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new BitString3({ valueHex: value })
};
var AsnObjectIdentifierConverter2 = {
  fromASN: (value) => value.valueBlock.toString(),
  toASN: (value) => new ObjectIdentifier2({ value })
};
var AsnBooleanConverter2 = {
  fromASN: (value) => value.valueBlock.value,
  toASN: (value) => new Boolean3({ value })
};
var AsnOctetStringConverter2 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new OctetString3({ valueHex: value })
};
function createStringConverter2(Asn1Type) {
  return {
    fromASN: (value) => value.valueBlock.value,
    toASN: (value) => new Asn1Type({ value })
  };
}
var AsnUtf8StringConverter2 = createStringConverter2(Utf8String2);
var AsnBmpStringConverter2 = createStringConverter2(BmpString2);
var AsnUniversalStringConverter2 = createStringConverter2(UniversalString2);
var AsnNumericStringConverter2 = createStringConverter2(NumericString2);
var AsnPrintableStringConverter2 = createStringConverter2(PrintableString2);
var AsnTeletexStringConverter2 = createStringConverter2(TeletexString2);
var AsnVideotexStringConverter2 = createStringConverter2(VideotexString2);
var AsnIA5StringConverter2 = createStringConverter2(IA5String2);
var AsnGraphicStringConverter2 = createStringConverter2(GraphicString2);
var AsnVisibleStringConverter2 = createStringConverter2(VisibleString2);
var AsnGeneralStringConverter2 = createStringConverter2(GeneralString2);
var AsnCharacterStringConverter2 = createStringConverter2(CharacterString2);
var AsnUTCTimeConverter2 = {
  fromASN: (value) => value.toDate(),
  toASN: (value) => new UTCTime2({ valueDate: value })
};
var AsnGeneralizedTimeConverter2 = {
  fromASN: (value) => value.toDate(),
  toASN: (value) => new GeneralizedTime2({ valueDate: value })
};
var AsnNullConverter2 = {
  fromASN: () => null,
  toASN: () => {
    return new Null2;
  }
};
function defaultConverter2(type) {
  switch (type) {
    case AsnPropTypes2.Any:
      return AsnAnyConverter2;
    case AsnPropTypes2.BitString:
      return AsnBitStringConverter2;
    case AsnPropTypes2.BmpString:
      return AsnBmpStringConverter2;
    case AsnPropTypes2.Boolean:
      return AsnBooleanConverter2;
    case AsnPropTypes2.CharacterString:
      return AsnCharacterStringConverter2;
    case AsnPropTypes2.Enumerated:
      return AsnEnumeratedConverter2;
    case AsnPropTypes2.GeneralString:
      return AsnGeneralStringConverter2;
    case AsnPropTypes2.GeneralizedTime:
      return AsnGeneralizedTimeConverter2;
    case AsnPropTypes2.GraphicString:
      return AsnGraphicStringConverter2;
    case AsnPropTypes2.IA5String:
      return AsnIA5StringConverter2;
    case AsnPropTypes2.Integer:
      return AsnIntegerConverter2;
    case AsnPropTypes2.Null:
      return AsnNullConverter2;
    case AsnPropTypes2.NumericString:
      return AsnNumericStringConverter2;
    case AsnPropTypes2.ObjectIdentifier:
      return AsnObjectIdentifierConverter2;
    case AsnPropTypes2.OctetString:
      return AsnOctetStringConverter2;
    case AsnPropTypes2.PrintableString:
      return AsnPrintableStringConverter2;
    case AsnPropTypes2.TeletexString:
      return AsnTeletexStringConverter2;
    case AsnPropTypes2.UTCTime:
      return AsnUTCTimeConverter2;
    case AsnPropTypes2.UniversalString:
      return AsnUniversalStringConverter2;
    case AsnPropTypes2.Utf8String:
      return AsnUtf8StringConverter2;
    case AsnPropTypes2.VideotexString:
      return AsnVideotexStringConverter2;
    case AsnPropTypes2.VisibleString:
      return AsnVisibleStringConverter2;
    default:
      return null;
  }
}
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-schema/build/es2015/helper.js
function isConvertible2(target) {
  if (typeof target === "function" && target.prototype) {
    if (target.prototype.toASN && target.prototype.fromASN) {
      return true;
    } else {
      return isConvertible2(target.prototype);
    }
  } else {
    return !!(target && typeof target === "object" && ("toASN" in target) && ("fromASN" in target));
  }
}
function isTypeOfArray2(target) {
  var _a3;
  if (target) {
    const proto = Object.getPrototypeOf(target);
    if (((_a3 = proto === null || proto === undefined ? undefined : proto.prototype) === null || _a3 === undefined ? undefined : _a3.constructor) === Array) {
      return true;
    }
    return isTypeOfArray2(proto);
  }
  return false;
}
function isArrayEqual2(bytes1, bytes2) {
  if (!(bytes1 && bytes2)) {
    return false;
  }
  if (bytes1.byteLength !== bytes2.byteLength) {
    return false;
  }
  const b1 = new Uint8Array(bytes1);
  const b2 = new Uint8Array(bytes2);
  for (let i = 0;i < bytes1.byteLength; i++) {
    if (b1[i] !== b2[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-schema/build/es2015/schema.js
class AsnSchemaStorage2 {
  constructor() {
    this.items = new WeakMap;
  }
  has(target) {
    return this.items.has(target);
  }
  get(target, checkSchema = false) {
    const schema = this.items.get(target);
    if (!schema) {
      throw new Error(`Cannot get schema for '${target.prototype.constructor.name}' target`);
    }
    if (checkSchema && !schema.schema) {
      throw new Error(`Schema '${target.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);
    }
    return schema;
  }
  cache(target) {
    const schema = this.get(target);
    if (!schema.schema) {
      schema.schema = this.create(target, true);
    }
  }
  createDefault(target) {
    const schema = { type: AsnTypeTypes2.Sequence, items: {} };
    const parentSchema = this.findParentSchema(target);
    if (parentSchema) {
      Object.assign(schema, parentSchema);
      schema.items = Object.assign({}, schema.items, parentSchema.items);
    }
    return schema;
  }
  create(target, useNames) {
    const schema = this.items.get(target) || this.createDefault(target);
    const asn1Value = [];
    for (const key in schema.items) {
      const item = schema.items[key];
      const name2 = useNames ? key : "";
      let asn1Item;
      if (typeof item.type === "number") {
        const Asn1TypeName = AsnPropTypes2[item.type];
        const Asn1Type = exports_index_es3[Asn1TypeName];
        if (!Asn1Type) {
          throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
        }
        asn1Item = new Asn1Type({ name: name2 });
      } else if (isConvertible2(item.type)) {
        const instance = new item.type;
        asn1Item = instance.toSchema(name2);
      } else if (item.optional) {
        const itemSchema = this.get(item.type);
        if (itemSchema.type === AsnTypeTypes2.Choice) {
          asn1Item = new Any2({ name: name2 });
        } else {
          asn1Item = this.create(item.type, false);
          asn1Item.name = name2;
        }
      } else {
        asn1Item = new Any2({ name: name2 });
      }
      const optional = !!item.optional || item.defaultValue !== undefined;
      if (item.repeated) {
        asn1Item.name = "";
        const Container = item.repeated === "set" ? Set3 : Sequence2;
        asn1Item = new Container({
          name: "",
          value: [new Repeated2({ name: name2, value: asn1Item })]
        });
      }
      if (item.context !== null && item.context !== undefined) {
        if (item.implicit) {
          if (typeof item.type === "number" || isConvertible2(item.type)) {
            const Container = item.repeated ? Constructed2 : Primitive2;
            asn1Value.push(new Container({ name: name2, optional, idBlock: { tagClass: 3, tagNumber: item.context } }));
          } else {
            this.cache(item.type);
            const isRepeated = !!item.repeated;
            let value = !isRepeated ? this.get(item.type, true).schema : asn1Item;
            value = "valueBlock" in value ? value.valueBlock.value : value.value;
            asn1Value.push(new Constructed2({
              name: !isRepeated ? name2 : "",
              optional,
              idBlock: { tagClass: 3, tagNumber: item.context },
              value
            }));
          }
        } else {
          asn1Value.push(new Constructed2({
            optional,
            idBlock: { tagClass: 3, tagNumber: item.context },
            value: [asn1Item]
          }));
        }
      } else {
        asn1Item.optional = optional;
        asn1Value.push(asn1Item);
      }
    }
    switch (schema.type) {
      case AsnTypeTypes2.Sequence:
        return new Sequence2({ value: asn1Value, name: "" });
      case AsnTypeTypes2.Set:
        return new Set3({ value: asn1Value, name: "" });
      case AsnTypeTypes2.Choice:
        return new Choice2({ value: asn1Value, name: "" });
      default:
        throw new Error(`Unsupported ASN1 type in use`);
    }
  }
  set(target, schema) {
    this.items.set(target, schema);
    return this;
  }
  findParentSchema(target) {
    const parent = Object.getPrototypeOf(target);
    if (parent) {
      const schema = this.items.get(parent);
      return schema || this.findParentSchema(parent);
    }
    return null;
  }
}

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-schema/build/es2015/storage.js
var schemaStorage2 = new AsnSchemaStorage2;

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-schema/build/es2015/decorators.js
var AsnType2 = (options) => (target) => {
  let schema;
  if (!schemaStorage2.has(target)) {
    schema = schemaStorage2.createDefault(target);
    schemaStorage2.set(target, schema);
  } else {
    schema = schemaStorage2.get(target);
  }
  Object.assign(schema, options);
};
var AsnProp2 = (options) => (target, propertyKey) => {
  let schema;
  if (!schemaStorage2.has(target.constructor)) {
    schema = schemaStorage2.createDefault(target.constructor);
    schemaStorage2.set(target.constructor, schema);
  } else {
    schema = schemaStorage2.get(target.constructor);
  }
  const copyOptions = Object.assign({}, options);
  if (typeof copyOptions.type === "number" && !copyOptions.converter) {
    const defaultConverter3 = defaultConverter2(options.type);
    if (!defaultConverter3) {
      throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target.constructor.name}`);
    }
    copyOptions.converter = defaultConverter3;
  }
  copyOptions.raw = options.raw;
  schema.items[propertyKey] = copyOptions;
};
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-schema/build/es2015/errors/schema_validation.js
class AsnSchemaValidationError2 extends Error {
  constructor() {
    super(...arguments);
    this.schemas = [];
  }
}
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-schema/build/es2015/parser.js
class AsnParser2 {
  static parse(data, target) {
    const asn1Parsed = fromBER2(data);
    if (asn1Parsed.result.error) {
      throw new Error(asn1Parsed.result.error);
    }
    const res = this.fromASN(asn1Parsed.result, target);
    return res;
  }
  static fromASN(asn1Schema, target) {
    try {
      if (isConvertible2(target)) {
        const value = new target;
        return value.fromASN(asn1Schema);
      }
      const schema = schemaStorage2.get(target);
      schemaStorage2.cache(target);
      let targetSchema = schema.schema;
      const choiceResult = this.handleChoiceTypes(asn1Schema, schema, target, targetSchema);
      if (choiceResult === null || choiceResult === undefined ? undefined : choiceResult.result) {
        return choiceResult.result;
      }
      if (choiceResult === null || choiceResult === undefined ? undefined : choiceResult.targetSchema) {
        targetSchema = choiceResult.targetSchema;
      }
      const sequenceResult = this.handleSequenceTypes(asn1Schema, schema, target, targetSchema);
      if (sequenceResult && "isManualMapping" in sequenceResult) {
        return sequenceResult.result;
      }
      const asn1ComparedSchema = sequenceResult;
      const res = new target;
      if (isTypeOfArray2(target)) {
        return this.handleArrayTypes(asn1Schema, schema, target);
      }
      this.processSchemaItems(schema, asn1ComparedSchema, res);
      return res;
    } catch (error) {
      if (error instanceof AsnSchemaValidationError2) {
        error.schemas.push(target.name);
      }
      throw error;
    }
  }
  static handleChoiceTypes(asn1Schema, schema, target, targetSchema) {
    if (asn1Schema.constructor === Constructed2 && schema.type === AsnTypeTypes2.Choice && asn1Schema.idBlock.tagClass === 3) {
      for (const key in schema.items) {
        const schemaItem = schema.items[key];
        if (schemaItem.context === asn1Schema.idBlock.tagNumber && schemaItem.implicit) {
          if (typeof schemaItem.type === "function" && schemaStorage2.has(schemaItem.type)) {
            const fieldSchema = schemaStorage2.get(schemaItem.type);
            if (fieldSchema && fieldSchema.type === AsnTypeTypes2.Sequence) {
              const newSeq = new Sequence2;
              if ("value" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value) && "value" in newSeq.valueBlock) {
                newSeq.valueBlock.value = asn1Schema.valueBlock.value;
                const fieldValue = this.fromASN(newSeq, schemaItem.type);
                const res = new target;
                res[key] = fieldValue;
                return { result: res };
              }
            }
          }
        }
      }
    } else if (asn1Schema.constructor === Constructed2 && schema.type !== AsnTypeTypes2.Choice) {
      const newTargetSchema = new Constructed2({
        idBlock: {
          tagClass: 3,
          tagNumber: asn1Schema.idBlock.tagNumber
        },
        value: schema.schema.valueBlock.value
      });
      for (const key in schema.items) {
        delete asn1Schema[key];
      }
      return { targetSchema: newTargetSchema };
    }
    return null;
  }
  static handleSequenceTypes(asn1Schema, schema, target, targetSchema) {
    if (schema.type === AsnTypeTypes2.Sequence) {
      const optionalChoiceFields = Object.keys(schema.items).filter((key) => {
        const item = schema.items[key];
        return item.optional && typeof item.type === "function" && schemaStorage2.has(item.type) && schemaStorage2.get(item.type).type === AsnTypeTypes2.Choice;
      });
      if (optionalChoiceFields.length > 0 && "value" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value) && target.name === "CertReqMsg") {
        return this.handleManualMapping(asn1Schema, schema, target);
      }
      const asn1ComparedSchema = compareSchema2({}, asn1Schema, targetSchema);
      if (!asn1ComparedSchema.verified) {
        throw new AsnSchemaValidationError2(`Data does not match to ${target.name} ASN1 schema.${asn1ComparedSchema.result.error ? ` ${asn1ComparedSchema.result.error}` : ""}`);
      }
      return asn1ComparedSchema;
    } else {
      const asn1ComparedSchema = compareSchema2({}, asn1Schema, targetSchema);
      if (!asn1ComparedSchema.verified) {
        throw new AsnSchemaValidationError2(`Data does not match to ${target.name} ASN1 schema.${asn1ComparedSchema.result.error ? ` ${asn1ComparedSchema.result.error}` : ""}`);
      }
      return asn1ComparedSchema;
    }
  }
  static handleManualMapping(asn1Schema, schema, target) {
    const res = new target;
    const asn1Elements = asn1Schema.valueBlock.value;
    const schemaKeys = Object.keys(schema.items);
    let asn1Index = 0;
    for (let i = 0;i < schemaKeys.length; i++) {
      const key = schemaKeys[i];
      const schemaItem = schema.items[key];
      if (asn1Index >= asn1Elements.length)
        break;
      if (schemaItem.repeated) {
        res[key] = this.processRepeatedField(asn1Elements, asn1Index, schemaItem);
        break;
      } else if (typeof schemaItem.type === "number") {
        res[key] = this.processPrimitiveField(asn1Elements[asn1Index], schemaItem);
        asn1Index++;
      } else if (this.isOptionalChoiceField(schemaItem)) {
        const result = this.processOptionalChoiceField(asn1Elements[asn1Index], schemaItem);
        if (result.processed) {
          res[key] = result.value;
          asn1Index++;
        }
      } else {
        res[key] = this.fromASN(asn1Elements[asn1Index], schemaItem.type);
        asn1Index++;
      }
    }
    return { result: res, verified: true, isManualMapping: true };
  }
  static processRepeatedField(asn1Elements, asn1Index, schemaItem) {
    let elementsToProcess = asn1Elements.slice(asn1Index);
    if (elementsToProcess.length === 1 && elementsToProcess[0].constructor.name === "Sequence") {
      const seq = elementsToProcess[0];
      if (seq.valueBlock && seq.valueBlock.value && Array.isArray(seq.valueBlock.value)) {
        elementsToProcess = seq.valueBlock.value;
      }
    }
    if (typeof schemaItem.type === "number") {
      const converter = defaultConverter2(schemaItem.type);
      if (!converter)
        throw new Error(`No converter for ASN.1 type ${schemaItem.type}`);
      return elementsToProcess.filter((el) => el && el.valueBlock).map((el) => {
        try {
          return converter.fromASN(el);
        } catch {
          return;
        }
      }).filter((v) => v !== undefined);
    } else {
      return elementsToProcess.filter((el) => el && el.valueBlock).map((el) => {
        try {
          return this.fromASN(el, schemaItem.type);
        } catch {
          return;
        }
      }).filter((v) => v !== undefined);
    }
  }
  static processPrimitiveField(asn1Element, schemaItem) {
    const converter = defaultConverter2(schemaItem.type);
    if (!converter)
      throw new Error(`No converter for ASN.1 type ${schemaItem.type}`);
    return converter.fromASN(asn1Element);
  }
  static isOptionalChoiceField(schemaItem) {
    return schemaItem.optional && typeof schemaItem.type === "function" && schemaStorage2.has(schemaItem.type) && schemaStorage2.get(schemaItem.type).type === AsnTypeTypes2.Choice;
  }
  static processOptionalChoiceField(asn1Element, schemaItem) {
    try {
      const value = this.fromASN(asn1Element, schemaItem.type);
      return { processed: true, value };
    } catch (err) {
      if (err instanceof AsnSchemaValidationError2 && /Wrong values for Choice type/.test(err.message)) {
        return { processed: false };
      }
      throw err;
    }
  }
  static handleArrayTypes(asn1Schema, schema, target) {
    if (!(("value" in asn1Schema.valueBlock) && Array.isArray(asn1Schema.valueBlock.value))) {
      throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);
    }
    const itemType = schema.itemType;
    if (typeof itemType === "number") {
      const converter = defaultConverter2(itemType);
      if (!converter) {
        throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
      }
      return target.from(asn1Schema.valueBlock.value, (element) => converter.fromASN(element));
    } else {
      return target.from(asn1Schema.valueBlock.value, (element) => this.fromASN(element, itemType));
    }
  }
  static processSchemaItems(schema, asn1ComparedSchema, res) {
    for (const key in schema.items) {
      const asn1SchemaValue = asn1ComparedSchema.result[key];
      if (!asn1SchemaValue) {
        continue;
      }
      const schemaItem = schema.items[key];
      const schemaItemType = schemaItem.type;
      let parsedValue;
      if (typeof schemaItemType === "number" || isConvertible2(schemaItemType)) {
        parsedValue = this.processPrimitiveSchemaItem(asn1SchemaValue, schemaItem, schemaItemType);
      } else {
        parsedValue = this.processComplexSchemaItem(asn1SchemaValue, schemaItem, schemaItemType);
      }
      if (parsedValue && typeof parsedValue === "object" && "value" in parsedValue && "raw" in parsedValue) {
        res[key] = parsedValue.value;
        res[`${key}Raw`] = parsedValue.raw;
      } else {
        res[key] = parsedValue;
      }
    }
  }
  static processPrimitiveSchemaItem(asn1SchemaValue, schemaItem, schemaItemType) {
    var _a3;
    const converter = (_a3 = schemaItem.converter) !== null && _a3 !== undefined ? _a3 : isConvertible2(schemaItemType) ? new schemaItemType : null;
    if (!converter) {
      throw new Error("Converter is empty");
    }
    if (schemaItem.repeated) {
      return this.processRepeatedPrimitiveItem(asn1SchemaValue, schemaItem, converter);
    } else {
      return this.processSinglePrimitiveItem(asn1SchemaValue, schemaItem, schemaItemType, converter);
    }
  }
  static processRepeatedPrimitiveItem(asn1SchemaValue, schemaItem, converter) {
    if (schemaItem.implicit) {
      const Container = schemaItem.repeated === "sequence" ? Sequence2 : Set3;
      const newItem = new Container;
      newItem.valueBlock = asn1SchemaValue.valueBlock;
      const newItemAsn = fromBER2(newItem.toBER(false));
      if (newItemAsn.offset === -1) {
        throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);
      }
      if (!(("value" in newItemAsn.result.valueBlock) && Array.isArray(newItemAsn.result.valueBlock.value))) {
        throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");
      }
      const value = newItemAsn.result.valueBlock.value;
      return Array.from(value, (element) => converter.fromASN(element));
    } else {
      return Array.from(asn1SchemaValue, (element) => converter.fromASN(element));
    }
  }
  static processSinglePrimitiveItem(asn1SchemaValue, schemaItem, schemaItemType, converter) {
    let value = asn1SchemaValue;
    if (schemaItem.implicit) {
      let newItem;
      if (isConvertible2(schemaItemType)) {
        newItem = new schemaItemType().toSchema("");
      } else {
        const Asn1TypeName = AsnPropTypes2[schemaItemType];
        const Asn1Type = exports_index_es3[Asn1TypeName];
        if (!Asn1Type) {
          throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);
        }
        newItem = new Asn1Type;
      }
      newItem.valueBlock = value.valueBlock;
      value = fromBER2(newItem.toBER(false)).result;
    }
    return converter.fromASN(value);
  }
  static processComplexSchemaItem(asn1SchemaValue, schemaItem, schemaItemType) {
    if (schemaItem.repeated) {
      if (!Array.isArray(asn1SchemaValue)) {
        throw new Error("Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.");
      }
      return Array.from(asn1SchemaValue, (element) => this.fromASN(element, schemaItemType));
    } else {
      const valueToProcess = this.handleImplicitTagging(asn1SchemaValue, schemaItem, schemaItemType);
      if (this.isOptionalChoiceField(schemaItem)) {
        try {
          return this.fromASN(valueToProcess, schemaItemType);
        } catch (err) {
          if (err instanceof AsnSchemaValidationError2 && /Wrong values for Choice type/.test(err.message)) {
            return;
          }
          throw err;
        }
      } else {
        const parsedValue = this.fromASN(valueToProcess, schemaItemType);
        if (schemaItem.raw) {
          return {
            value: parsedValue,
            raw: asn1SchemaValue.valueBeforeDecodeView
          };
        }
        return parsedValue;
      }
    }
  }
  static handleImplicitTagging(asn1SchemaValue, schemaItem, schemaItemType) {
    if (schemaItem.implicit && typeof schemaItem.context === "number") {
      const schema = schemaStorage2.get(schemaItemType);
      if (schema.type === AsnTypeTypes2.Sequence) {
        const newSeq = new Sequence2;
        if ("value" in asn1SchemaValue.valueBlock && Array.isArray(asn1SchemaValue.valueBlock.value) && "value" in newSeq.valueBlock) {
          newSeq.valueBlock.value = asn1SchemaValue.valueBlock.value;
          return newSeq;
        }
      } else if (schema.type === AsnTypeTypes2.Set) {
        const newSet = new Set3;
        if ("value" in asn1SchemaValue.valueBlock && Array.isArray(asn1SchemaValue.valueBlock.value) && "value" in newSet.valueBlock) {
          newSet.valueBlock.value = asn1SchemaValue.valueBlock.value;
          return newSet;
        }
      }
    }
    return asn1SchemaValue;
  }
}
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-schema/build/es2015/serializer.js
class AsnSerializer2 {
  static serialize(obj) {
    if (obj instanceof BaseBlock2) {
      return obj.toBER(false);
    }
    return this.toASN(obj).toBER(false);
  }
  static toASN(obj) {
    if (obj && typeof obj === "object" && isConvertible2(obj)) {
      return obj.toASN();
    }
    if (!(obj && typeof obj === "object")) {
      throw new TypeError("Parameter 1 should be type of Object.");
    }
    const target = obj.constructor;
    const schema = schemaStorage2.get(target);
    schemaStorage2.cache(target);
    let asn1Value = [];
    if (schema.itemType) {
      if (!Array.isArray(obj)) {
        throw new TypeError("Parameter 1 should be type of Array.");
      }
      if (typeof schema.itemType === "number") {
        const converter = defaultConverter2(schema.itemType);
        if (!converter) {
          throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
        }
        asn1Value = obj.map((o) => converter.toASN(o));
      } else {
        asn1Value = obj.map((o) => this.toAsnItem({ type: schema.itemType }, "[]", target, o));
      }
    } else {
      for (const key in schema.items) {
        const schemaItem = schema.items[key];
        const objProp = obj[key];
        if (objProp === undefined || schemaItem.defaultValue === objProp || typeof schemaItem.defaultValue === "object" && typeof objProp === "object" && isArrayEqual2(this.serialize(schemaItem.defaultValue), this.serialize(objProp))) {
          continue;
        }
        const asn1Item = AsnSerializer2.toAsnItem(schemaItem, key, target, objProp);
        if (typeof schemaItem.context === "number") {
          if (schemaItem.implicit) {
            if (!schemaItem.repeated && (typeof schemaItem.type === "number" || isConvertible2(schemaItem.type))) {
              const value = {};
              value.valueHex = asn1Item instanceof Null2 ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();
              asn1Value.push(new Primitive2({
                optional: schemaItem.optional,
                idBlock: {
                  tagClass: 3,
                  tagNumber: schemaItem.context
                },
                ...value
              }));
            } else {
              asn1Value.push(new Constructed2({
                optional: schemaItem.optional,
                idBlock: {
                  tagClass: 3,
                  tagNumber: schemaItem.context
                },
                value: asn1Item.valueBlock.value
              }));
            }
          } else {
            asn1Value.push(new Constructed2({
              optional: schemaItem.optional,
              idBlock: {
                tagClass: 3,
                tagNumber: schemaItem.context
              },
              value: [asn1Item]
            }));
          }
        } else if (schemaItem.repeated) {
          asn1Value = asn1Value.concat(asn1Item);
        } else {
          asn1Value.push(asn1Item);
        }
      }
    }
    let asnSchema;
    switch (schema.type) {
      case AsnTypeTypes2.Sequence:
        asnSchema = new Sequence2({ value: asn1Value });
        break;
      case AsnTypeTypes2.Set:
        asnSchema = new Set3({ value: asn1Value });
        break;
      case AsnTypeTypes2.Choice:
        if (!asn1Value[0]) {
          throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);
        }
        asnSchema = asn1Value[0];
        break;
    }
    return asnSchema;
  }
  static toAsnItem(schemaItem, key, target, objProp) {
    let asn1Item;
    if (typeof schemaItem.type === "number") {
      const converter = schemaItem.converter;
      if (!converter) {
        throw new Error(`Property '${key}' doesn't have converter for type ${AsnPropTypes2[schemaItem.type]} in schema '${target.name}'`);
      }
      if (schemaItem.repeated) {
        if (!Array.isArray(objProp)) {
          throw new TypeError("Parameter 'objProp' should be type of Array.");
        }
        const items = Array.from(objProp, (element) => converter.toASN(element));
        const Container = schemaItem.repeated === "sequence" ? Sequence2 : Set3;
        asn1Item = new Container({
          value: items
        });
      } else {
        asn1Item = converter.toASN(objProp);
      }
    } else {
      if (schemaItem.repeated) {
        if (!Array.isArray(objProp)) {
          throw new TypeError("Parameter 'objProp' should be type of Array.");
        }
        const items = Array.from(objProp, (element) => this.toASN(element));
        const Container = schemaItem.repeated === "sequence" ? Sequence2 : Set3;
        asn1Item = new Container({
          value: items
        });
      } else {
        asn1Item = this.toASN(objProp);
      }
    }
    return asn1Item;
  }
}
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-schema/build/es2015/objects.js
class AsnArray2 extends Array {
  constructor(items = []) {
    if (typeof items === "number") {
      super(items);
    } else {
      super();
      for (const item of items) {
        this.push(item);
      }
    }
  }
}
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-schema/build/es2015/convert.js
class AsnConvert2 {
  static serialize(obj) {
    return AsnSerializer2.serialize(obj);
  }
  static parse(data, target) {
    return AsnParser2.parse(data, target);
  }
  static toString(data) {
    const buf = BufferSourceConverter.isBufferSource(data) ? BufferSourceConverter.toArrayBuffer(data) : AsnConvert2.serialize(data);
    const asn = fromBER2(buf);
    if (asn.offset === -1) {
      throw new Error(`Cannot decode ASN.1 data. ${asn.result.error}`);
    }
    return asn.result.toString();
  }
}
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/ip_converter.js
class IpConverter2 {
  static isIPv4(ip2) {
    return /^(\d{1,3}\.){3}\d{1,3}$/.test(ip2);
  }
  static parseIPv4(ip2) {
    const parts = ip2.split(".");
    if (parts.length !== 4) {
      throw new Error("Invalid IPv4 address");
    }
    return parts.map((part) => {
      const num = parseInt(part, 10);
      if (isNaN(num) || num < 0 || num > 255) {
        throw new Error("Invalid IPv4 address part");
      }
      return num;
    });
  }
  static parseIPv6(ip2) {
    const expandedIP = this.expandIPv6(ip2);
    const parts = expandedIP.split(":");
    if (parts.length !== 8) {
      throw new Error("Invalid IPv6 address");
    }
    return parts.reduce((bytes, part) => {
      const num = parseInt(part, 16);
      if (isNaN(num) || num < 0 || num > 65535) {
        throw new Error("Invalid IPv6 address part");
      }
      bytes.push(num >> 8 & 255);
      bytes.push(num & 255);
      return bytes;
    }, []);
  }
  static expandIPv6(ip2) {
    if (!ip2.includes("::")) {
      return ip2;
    }
    const parts = ip2.split("::");
    if (parts.length > 2) {
      throw new Error("Invalid IPv6 address");
    }
    const left = parts[0] ? parts[0].split(":") : [];
    const right = parts[1] ? parts[1].split(":") : [];
    const missing = 8 - (left.length + right.length);
    if (missing < 0) {
      throw new Error("Invalid IPv6 address");
    }
    return [...left, ...Array(missing).fill("0"), ...right].join(":");
  }
  static formatIPv6(bytes) {
    const parts = [];
    for (let i = 0;i < 16; i += 2) {
      parts.push((bytes[i] << 8 | bytes[i + 1]).toString(16));
    }
    return this.compressIPv6(parts.join(":"));
  }
  static compressIPv6(ip2) {
    const parts = ip2.split(":");
    let longestZeroStart = -1;
    let longestZeroLength = 0;
    let currentZeroStart = -1;
    let currentZeroLength = 0;
    for (let i = 0;i < parts.length; i++) {
      if (parts[i] === "0") {
        if (currentZeroStart === -1) {
          currentZeroStart = i;
        }
        currentZeroLength++;
      } else {
        if (currentZeroLength > longestZeroLength) {
          longestZeroStart = currentZeroStart;
          longestZeroLength = currentZeroLength;
        }
        currentZeroStart = -1;
        currentZeroLength = 0;
      }
    }
    if (currentZeroLength > longestZeroLength) {
      longestZeroStart = currentZeroStart;
      longestZeroLength = currentZeroLength;
    }
    if (longestZeroLength > 1) {
      const before = parts.slice(0, longestZeroStart).join(":");
      const after = parts.slice(longestZeroStart + longestZeroLength).join(":");
      return `${before}::${after}`;
    }
    return ip2;
  }
  static parseCIDR(text) {
    const [addr, prefixStr] = text.split("/");
    const prefix = parseInt(prefixStr, 10);
    if (this.isIPv4(addr)) {
      if (prefix < 0 || prefix > 32) {
        throw new Error("Invalid IPv4 prefix length");
      }
      return [this.parseIPv4(addr), prefix];
    } else {
      if (prefix < 0 || prefix > 128) {
        throw new Error("Invalid IPv6 prefix length");
      }
      return [this.parseIPv6(addr), prefix];
    }
  }
  static decodeIP(value) {
    if (value.length === 64 && parseInt(value, 16) === 0) {
      return "::/0";
    }
    if (value.length !== 16) {
      return value;
    }
    const mask = parseInt(value.slice(8), 16).toString(2).split("").reduce((a, k) => a + +k, 0);
    let ip2 = value.slice(0, 8).replace(/(.{2})/g, (match2) => `${parseInt(match2, 16)}.`);
    ip2 = ip2.slice(0, -1);
    return `${ip2}/${mask}`;
  }
  static toString(buf) {
    const uint8 = new Uint8Array(buf);
    if (uint8.length === 4) {
      return Array.from(uint8).join(".");
    }
    if (uint8.length === 16) {
      return this.formatIPv6(uint8);
    }
    if (uint8.length === 8 || uint8.length === 32) {
      const half = uint8.length / 2;
      const addrBytes = uint8.slice(0, half);
      const maskBytes = uint8.slice(half);
      const isAllZeros = uint8.every((byte) => byte === 0);
      if (isAllZeros) {
        return uint8.length === 8 ? "0.0.0.0/0" : "::/0";
      }
      const prefixLen = maskBytes.reduce((a, b) => a + (b.toString(2).match(/1/g) || []).length, 0);
      if (uint8.length === 8) {
        const addrStr = Array.from(addrBytes).join(".");
        return `${addrStr}/${prefixLen}`;
      } else {
        const addrStr = this.formatIPv6(addrBytes);
        return `${addrStr}/${prefixLen}`;
      }
    }
    return this.decodeIP(Convert.ToHex(buf));
  }
  static fromString(text) {
    if (text.includes("/")) {
      const [addr, prefix] = this.parseCIDR(text);
      const maskBytes = new Uint8Array(addr.length);
      let bitsLeft = prefix;
      for (let i = 0;i < maskBytes.length; i++) {
        if (bitsLeft >= 8) {
          maskBytes[i] = 255;
          bitsLeft -= 8;
        } else if (bitsLeft > 0) {
          maskBytes[i] = 255 << 8 - bitsLeft;
          bitsLeft = 0;
        }
      }
      const out = new Uint8Array(addr.length * 2);
      out.set(addr, 0);
      out.set(maskBytes, addr.length);
      return out.buffer;
    }
    const bytes = this.isIPv4(text) ? this.parseIPv4(text) : this.parseIPv6(text);
    return new Uint8Array(bytes).buffer;
  }
}

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/name.js
var RelativeDistinguishedName_12;
var RDNSequence_12;
var Name_12;
var DirectoryString3 = class DirectoryString4 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.bmpString || this.printableString || this.teletexString || this.universalString || this.utf8String || "";
  }
};
__decorate([
  AsnProp2({ type: AsnPropTypes2.TeletexString })
], DirectoryString3.prototype, "teletexString", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.PrintableString })
], DirectoryString3.prototype, "printableString", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.UniversalString })
], DirectoryString3.prototype, "universalString", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Utf8String })
], DirectoryString3.prototype, "utf8String", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.BmpString })
], DirectoryString3.prototype, "bmpString", undefined);
DirectoryString3 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Choice })
], DirectoryString3);
var AttributeValue3 = class AttributeValue4 extends DirectoryString3 {
  constructor(params = {}) {
    super(params);
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || (this.anyValue ? Convert.ToHex(this.anyValue) : super.toString());
  }
};
__decorate([
  AsnProp2({ type: AsnPropTypes2.IA5String })
], AttributeValue3.prototype, "ia5String", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Any })
], AttributeValue3.prototype, "anyValue", undefined);
AttributeValue3 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Choice })
], AttributeValue3);
class AttributeTypeAndValue2 {
  constructor(params = {}) {
    this.type = "";
    this.value = new AttributeValue3;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AsnPropTypes2.ObjectIdentifier })
], AttributeTypeAndValue2.prototype, "type", undefined);
__decorate([
  AsnProp2({ type: AttributeValue3 })
], AttributeTypeAndValue2.prototype, "value", undefined);
var RelativeDistinguishedName3 = RelativeDistinguishedName_12 = class RelativeDistinguishedName4 extends AsnArray2 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RelativeDistinguishedName_12.prototype);
  }
};
RelativeDistinguishedName3 = RelativeDistinguishedName_12 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Set, itemType: AttributeTypeAndValue2 })
], RelativeDistinguishedName3);
var RDNSequence3 = RDNSequence_12 = class RDNSequence4 extends AsnArray2 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RDNSequence_12.prototype);
  }
};
RDNSequence3 = RDNSequence_12 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence, itemType: RelativeDistinguishedName3 })
], RDNSequence3);
var Name3 = Name_12 = class Name4 extends RDNSequence3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Name_12.prototype);
  }
};
Name3 = Name_12 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence })
], Name3);

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/general_name.js
var AsnIpConverter2 = {
  fromASN: (value) => IpConverter2.toString(AsnOctetStringConverter2.fromASN(value)),
  toASN: (value) => AsnOctetStringConverter2.toASN(IpConverter2.fromString(value))
};

class OtherName2 {
  constructor(params = {}) {
    this.typeId = "";
    this.value = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AsnPropTypes2.ObjectIdentifier })
], OtherName2.prototype, "typeId", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Any, context: 0 })
], OtherName2.prototype, "value", undefined);

class EDIPartyName2 {
  constructor(params = {}) {
    this.partyName = new DirectoryString3;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: DirectoryString3, optional: true, context: 0, implicit: true })
], EDIPartyName2.prototype, "nameAssigner", undefined);
__decorate([
  AsnProp2({ type: DirectoryString3, context: 1, implicit: true })
], EDIPartyName2.prototype, "partyName", undefined);
var GeneralName3 = class GeneralName4 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp2({ type: OtherName2, context: 0, implicit: true })
], GeneralName3.prototype, "otherName", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.IA5String, context: 1, implicit: true })
], GeneralName3.prototype, "rfc822Name", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.IA5String, context: 2, implicit: true })
], GeneralName3.prototype, "dNSName", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Any, context: 3, implicit: true })
], GeneralName3.prototype, "x400Address", undefined);
__decorate([
  AsnProp2({ type: Name3, context: 4, implicit: false })
], GeneralName3.prototype, "directoryName", undefined);
__decorate([
  AsnProp2({ type: EDIPartyName2, context: 5 })
], GeneralName3.prototype, "ediPartyName", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.IA5String, context: 6, implicit: true })
], GeneralName3.prototype, "uniformResourceIdentifier", undefined);
__decorate([
  AsnProp2({
    type: AsnPropTypes2.OctetString,
    context: 7,
    implicit: true,
    converter: AsnIpConverter2
  })
], GeneralName3.prototype, "iPAddress", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.ObjectIdentifier, context: 8, implicit: true })
], GeneralName3.prototype, "registeredID", undefined);
GeneralName3 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Choice })
], GeneralName3);

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js
var id_pkix2 = "1.3.6.1.5.5.7";
var id_pe2 = `${id_pkix2}.1`;
var id_qt2 = `${id_pkix2}.2`;
var id_kp2 = `${id_pkix2}.3`;
var id_ad2 = `${id_pkix2}.48`;
var id_qt_csp2 = `${id_qt2}.1`;
var id_qt_unotice2 = `${id_qt2}.2`;
var id_ad_ocsp2 = `${id_ad2}.1`;
var id_ad_caIssuers2 = `${id_ad2}.2`;
var id_ad_timeStamping2 = `${id_ad2}.3`;
var id_ad_caRepository2 = `${id_ad2}.5`;
var id_ce2 = "2.5.29";

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_information_access.js
var AuthorityInfoAccessSyntax_12;
var id_pe_authorityInfoAccess2 = `${id_pe2}.1`;

class AccessDescription2 {
  constructor(params = {}) {
    this.accessMethod = "";
    this.accessLocation = new GeneralName3;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AsnPropTypes2.ObjectIdentifier })
], AccessDescription2.prototype, "accessMethod", undefined);
__decorate([
  AsnProp2({ type: GeneralName3 })
], AccessDescription2.prototype, "accessLocation", undefined);
var AuthorityInfoAccessSyntax3 = AuthorityInfoAccessSyntax_12 = class AuthorityInfoAccessSyntax4 extends AsnArray2 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, AuthorityInfoAccessSyntax_12.prototype);
  }
};
AuthorityInfoAccessSyntax3 = AuthorityInfoAccessSyntax_12 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence, itemType: AccessDescription2 })
], AuthorityInfoAccessSyntax3);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_key_identifier.js
var id_ce_authorityKeyIdentifier2 = `${id_ce2}.35`;

class KeyIdentifier2 extends OctetString4 {
}

class AuthorityKeyIdentifier2 {
  constructor(params = {}) {
    if (params) {
      Object.assign(this, params);
    }
  }
}
__decorate([
  AsnProp2({ type: KeyIdentifier2, context: 0, optional: true, implicit: true })
], AuthorityKeyIdentifier2.prototype, "keyIdentifier", undefined);
__decorate([
  AsnProp2({ type: GeneralName3, context: 1, optional: true, implicit: true, repeated: "sequence" })
], AuthorityKeyIdentifier2.prototype, "authorityCertIssuer", undefined);
__decorate([
  AsnProp2({
    type: AsnPropTypes2.Integer,
    context: 2,
    optional: true,
    implicit: true,
    converter: AsnIntegerArrayBufferConverter2
  })
], AuthorityKeyIdentifier2.prototype, "authorityCertSerialNumber", undefined);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/basic_constraints.js
var id_ce_basicConstraints2 = `${id_ce2}.19`;

class BasicConstraints2 {
  constructor(params = {}) {
    this.cA = false;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AsnPropTypes2.Boolean, defaultValue: false })
], BasicConstraints2.prototype, "cA", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, optional: true })
], BasicConstraints2.prototype, "pathLenConstraint", undefined);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/general_names.js
var GeneralNames_12;
var GeneralNames3 = GeneralNames_12 = class GeneralNames4 extends AsnArray2 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralNames_12.prototype);
  }
};
GeneralNames3 = GeneralNames_12 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence, itemType: GeneralName3 })
], GeneralNames3);

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_issuer.js
var CertificateIssuer_12;
var id_ce_certificateIssuer2 = `${id_ce2}.29`;
var CertificateIssuer3 = CertificateIssuer_12 = class CertificateIssuer4 extends GeneralNames3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificateIssuer_12.prototype);
  }
};
CertificateIssuer3 = CertificateIssuer_12 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence })
], CertificateIssuer3);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_policies.js
var CertificatePolicies_12;
var id_ce_certificatePolicies2 = `${id_ce2}.32`;
var id_ce_certificatePolicies_anyPolicy2 = `${id_ce_certificatePolicies2}.0`;
var DisplayText3 = class DisplayText4 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || this.visibleString || this.bmpString || this.utf8String || "";
  }
};
__decorate([
  AsnProp2({ type: AsnPropTypes2.IA5String })
], DisplayText3.prototype, "ia5String", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.VisibleString })
], DisplayText3.prototype, "visibleString", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.BmpString })
], DisplayText3.prototype, "bmpString", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Utf8String })
], DisplayText3.prototype, "utf8String", undefined);
DisplayText3 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Choice })
], DisplayText3);
class NoticeReference2 {
  constructor(params = {}) {
    this.organization = new DisplayText3;
    this.noticeNumbers = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: DisplayText3 })
], NoticeReference2.prototype, "organization", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, repeated: "sequence" })
], NoticeReference2.prototype, "noticeNumbers", undefined);

class UserNotice2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: NoticeReference2, optional: true })
], UserNotice2.prototype, "noticeRef", undefined);
__decorate([
  AsnProp2({ type: DisplayText3, optional: true })
], UserNotice2.prototype, "explicitText", undefined);
var Qualifier3 = class Qualifier4 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp2({ type: AsnPropTypes2.IA5String })
], Qualifier3.prototype, "cPSuri", undefined);
__decorate([
  AsnProp2({ type: UserNotice2 })
], Qualifier3.prototype, "userNotice", undefined);
Qualifier3 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Choice })
], Qualifier3);
class PolicyQualifierInfo2 {
  constructor(params = {}) {
    this.policyQualifierId = "";
    this.qualifier = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AsnPropTypes2.ObjectIdentifier })
], PolicyQualifierInfo2.prototype, "policyQualifierId", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Any })
], PolicyQualifierInfo2.prototype, "qualifier", undefined);

class PolicyInformation2 {
  constructor(params = {}) {
    this.policyIdentifier = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AsnPropTypes2.ObjectIdentifier })
], PolicyInformation2.prototype, "policyIdentifier", undefined);
__decorate([
  AsnProp2({ type: PolicyQualifierInfo2, repeated: "sequence", optional: true })
], PolicyInformation2.prototype, "policyQualifiers", undefined);
var CertificatePolicies3 = CertificatePolicies_12 = class CertificatePolicies4 extends AsnArray2 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificatePolicies_12.prototype);
  }
};
CertificatePolicies3 = CertificatePolicies_12 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence, itemType: PolicyInformation2 })
], CertificatePolicies3);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_number.js
var id_ce_cRLNumber2 = `${id_ce2}.20`;
var CRLNumber3 = class CRLNumber4 {
  constructor(value = 0) {
    this.value = value;
  }
};
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer })
], CRLNumber3.prototype, "value", undefined);
CRLNumber3 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Choice })
], CRLNumber3);

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_delta_indicator.js
var id_ce_deltaCRLIndicator2 = `${id_ce2}.27`;
var BaseCRLNumber3 = class BaseCRLNumber4 extends CRLNumber3 {
};
BaseCRLNumber3 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Choice })
], BaseCRLNumber3);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_distribution_points.js
var CRLDistributionPoints_12;
var id_ce_cRLDistributionPoints2 = `${id_ce2}.31`;
var ReasonFlags2;
(function(ReasonFlags3) {
  ReasonFlags3[ReasonFlags3["unused"] = 1] = "unused";
  ReasonFlags3[ReasonFlags3["keyCompromise"] = 2] = "keyCompromise";
  ReasonFlags3[ReasonFlags3["cACompromise"] = 4] = "cACompromise";
  ReasonFlags3[ReasonFlags3["affiliationChanged"] = 8] = "affiliationChanged";
  ReasonFlags3[ReasonFlags3["superseded"] = 16] = "superseded";
  ReasonFlags3[ReasonFlags3["cessationOfOperation"] = 32] = "cessationOfOperation";
  ReasonFlags3[ReasonFlags3["certificateHold"] = 64] = "certificateHold";
  ReasonFlags3[ReasonFlags3["privilegeWithdrawn"] = 128] = "privilegeWithdrawn";
  ReasonFlags3[ReasonFlags3["aACompromise"] = 256] = "aACompromise";
})(ReasonFlags2 || (ReasonFlags2 = {}));

class Reason2 extends BitString4 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & ReasonFlags2.aACompromise) {
      res.push("aACompromise");
    }
    if (flags & ReasonFlags2.affiliationChanged) {
      res.push("affiliationChanged");
    }
    if (flags & ReasonFlags2.cACompromise) {
      res.push("cACompromise");
    }
    if (flags & ReasonFlags2.certificateHold) {
      res.push("certificateHold");
    }
    if (flags & ReasonFlags2.cessationOfOperation) {
      res.push("cessationOfOperation");
    }
    if (flags & ReasonFlags2.keyCompromise) {
      res.push("keyCompromise");
    }
    if (flags & ReasonFlags2.privilegeWithdrawn) {
      res.push("privilegeWithdrawn");
    }
    if (flags & ReasonFlags2.superseded) {
      res.push("superseded");
    }
    if (flags & ReasonFlags2.unused) {
      res.push("unused");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
}
var DistributionPointName3 = class DistributionPointName4 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp2({ type: GeneralName3, context: 0, repeated: "sequence", implicit: true })
], DistributionPointName3.prototype, "fullName", undefined);
__decorate([
  AsnProp2({ type: RelativeDistinguishedName3, context: 1, implicit: true })
], DistributionPointName3.prototype, "nameRelativeToCRLIssuer", undefined);
DistributionPointName3 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Choice })
], DistributionPointName3);
class DistributionPoint2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: DistributionPointName3, context: 0, optional: true })
], DistributionPoint2.prototype, "distributionPoint", undefined);
__decorate([
  AsnProp2({ type: Reason2, context: 1, optional: true, implicit: true })
], DistributionPoint2.prototype, "reasons", undefined);
__decorate([
  AsnProp2({ type: GeneralName3, context: 2, optional: true, repeated: "sequence", implicit: true })
], DistributionPoint2.prototype, "cRLIssuer", undefined);
var CRLDistributionPoints3 = CRLDistributionPoints_12 = class CRLDistributionPoints4 extends AsnArray2 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CRLDistributionPoints_12.prototype);
  }
};
CRLDistributionPoints3 = CRLDistributionPoints_12 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence, itemType: DistributionPoint2 })
], CRLDistributionPoints3);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_freshest.js
var FreshestCRL_12;
var id_ce_freshestCRL2 = `${id_ce2}.46`;
var FreshestCRL3 = FreshestCRL_12 = class FreshestCRL4 extends CRLDistributionPoints3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, FreshestCRL_12.prototype);
  }
};
FreshestCRL3 = FreshestCRL_12 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence, itemType: DistributionPoint2 })
], FreshestCRL3);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_issuing_distribution_point.js
var id_ce_issuingDistributionPoint2 = `${id_ce2}.28`;

class IssuingDistributionPoint2 {
  constructor(params = {}) {
    this.onlyContainsUserCerts = IssuingDistributionPoint2.ONLY;
    this.onlyContainsCACerts = IssuingDistributionPoint2.ONLY;
    this.indirectCRL = IssuingDistributionPoint2.ONLY;
    this.onlyContainsAttributeCerts = IssuingDistributionPoint2.ONLY;
    Object.assign(this, params);
  }
}
IssuingDistributionPoint2.ONLY = false;
__decorate([
  AsnProp2({ type: DistributionPointName3, context: 0, optional: true })
], IssuingDistributionPoint2.prototype, "distributionPoint", undefined);
__decorate([
  AsnProp2({
    type: AsnPropTypes2.Boolean,
    context: 1,
    defaultValue: IssuingDistributionPoint2.ONLY,
    implicit: true
  })
], IssuingDistributionPoint2.prototype, "onlyContainsUserCerts", undefined);
__decorate([
  AsnProp2({
    type: AsnPropTypes2.Boolean,
    context: 2,
    defaultValue: IssuingDistributionPoint2.ONLY,
    implicit: true
  })
], IssuingDistributionPoint2.prototype, "onlyContainsCACerts", undefined);
__decorate([
  AsnProp2({ type: Reason2, context: 3, optional: true, implicit: true })
], IssuingDistributionPoint2.prototype, "onlySomeReasons", undefined);
__decorate([
  AsnProp2({
    type: AsnPropTypes2.Boolean,
    context: 4,
    defaultValue: IssuingDistributionPoint2.ONLY,
    implicit: true
  })
], IssuingDistributionPoint2.prototype, "indirectCRL", undefined);
__decorate([
  AsnProp2({
    type: AsnPropTypes2.Boolean,
    context: 5,
    defaultValue: IssuingDistributionPoint2.ONLY,
    implicit: true
  })
], IssuingDistributionPoint2.prototype, "onlyContainsAttributeCerts", undefined);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_reason.js
var id_ce_cRLReasons2 = `${id_ce2}.21`;
var CRLReasons2;
(function(CRLReasons3) {
  CRLReasons3[CRLReasons3["unspecified"] = 0] = "unspecified";
  CRLReasons3[CRLReasons3["keyCompromise"] = 1] = "keyCompromise";
  CRLReasons3[CRLReasons3["cACompromise"] = 2] = "cACompromise";
  CRLReasons3[CRLReasons3["affiliationChanged"] = 3] = "affiliationChanged";
  CRLReasons3[CRLReasons3["superseded"] = 4] = "superseded";
  CRLReasons3[CRLReasons3["cessationOfOperation"] = 5] = "cessationOfOperation";
  CRLReasons3[CRLReasons3["certificateHold"] = 6] = "certificateHold";
  CRLReasons3[CRLReasons3["removeFromCRL"] = 8] = "removeFromCRL";
  CRLReasons3[CRLReasons3["privilegeWithdrawn"] = 9] = "privilegeWithdrawn";
  CRLReasons3[CRLReasons3["aACompromise"] = 10] = "aACompromise";
})(CRLReasons2 || (CRLReasons2 = {}));
var CRLReason3 = class CRLReason4 {
  constructor(reason = CRLReasons2.unspecified) {
    this.reason = CRLReasons2.unspecified;
    this.reason = reason;
  }
  toJSON() {
    return CRLReasons2[this.reason];
  }
  toString() {
    return this.toJSON();
  }
};
__decorate([
  AsnProp2({ type: AsnPropTypes2.Enumerated })
], CRLReason3.prototype, "reason", undefined);
CRLReason3 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Choice })
], CRLReason3);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/extended_key_usage.js
var ExtendedKeyUsage_12;
var id_ce_extKeyUsage2 = `${id_ce2}.37`;
var ExtendedKeyUsage3 = ExtendedKeyUsage_12 = class ExtendedKeyUsage4 extends AsnArray2 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, ExtendedKeyUsage_12.prototype);
  }
};
ExtendedKeyUsage3 = ExtendedKeyUsage_12 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence, itemType: AsnPropTypes2.ObjectIdentifier })
], ExtendedKeyUsage3);
var anyExtendedKeyUsage2 = `${id_ce_extKeyUsage2}.0`;
var id_kp_serverAuth2 = `${id_kp2}.1`;
var id_kp_clientAuth2 = `${id_kp2}.2`;
var id_kp_codeSigning2 = `${id_kp2}.3`;
var id_kp_emailProtection2 = `${id_kp2}.4`;
var id_kp_timeStamping2 = `${id_kp2}.8`;
var id_kp_OCSPSigning2 = `${id_kp2}.9`;
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/inhibit_any_policy.js
var id_ce_inhibitAnyPolicy2 = `${id_ce2}.54`;
var InhibitAnyPolicy3 = class InhibitAnyPolicy4 {
  constructor(value = new ArrayBuffer(0)) {
    this.value = value;
  }
};
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, converter: AsnIntegerArrayBufferConverter2 })
], InhibitAnyPolicy3.prototype, "value", undefined);
InhibitAnyPolicy3 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Choice })
], InhibitAnyPolicy3);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/invalidity_date.js
var id_ce_invalidityDate2 = `${id_ce2}.24`;
var InvalidityDate3 = class InvalidityDate4 {
  constructor(value) {
    this.value = new Date;
    if (value) {
      this.value = value;
    }
  }
};
__decorate([
  AsnProp2({ type: AsnPropTypes2.GeneralizedTime })
], InvalidityDate3.prototype, "value", undefined);
InvalidityDate3 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Choice })
], InvalidityDate3);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/issuer_alternative_name.js
var IssueAlternativeName_12;
var id_ce_issuerAltName2 = `${id_ce2}.18`;
var IssueAlternativeName3 = IssueAlternativeName_12 = class IssueAlternativeName4 extends GeneralNames3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, IssueAlternativeName_12.prototype);
  }
};
IssueAlternativeName3 = IssueAlternativeName_12 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence })
], IssueAlternativeName3);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/key_usage.js
var id_ce_keyUsage2 = `${id_ce2}.15`;
var KeyUsageFlags2;
(function(KeyUsageFlags3) {
  KeyUsageFlags3[KeyUsageFlags3["digitalSignature"] = 1] = "digitalSignature";
  KeyUsageFlags3[KeyUsageFlags3["nonRepudiation"] = 2] = "nonRepudiation";
  KeyUsageFlags3[KeyUsageFlags3["keyEncipherment"] = 4] = "keyEncipherment";
  KeyUsageFlags3[KeyUsageFlags3["dataEncipherment"] = 8] = "dataEncipherment";
  KeyUsageFlags3[KeyUsageFlags3["keyAgreement"] = 16] = "keyAgreement";
  KeyUsageFlags3[KeyUsageFlags3["keyCertSign"] = 32] = "keyCertSign";
  KeyUsageFlags3[KeyUsageFlags3["cRLSign"] = 64] = "cRLSign";
  KeyUsageFlags3[KeyUsageFlags3["encipherOnly"] = 128] = "encipherOnly";
  KeyUsageFlags3[KeyUsageFlags3["decipherOnly"] = 256] = "decipherOnly";
})(KeyUsageFlags2 || (KeyUsageFlags2 = {}));

class KeyUsage extends BitString4 {
  toJSON() {
    const flag = this.toNumber();
    const res = [];
    if (flag & KeyUsageFlags2.cRLSign) {
      res.push("crlSign");
    }
    if (flag & KeyUsageFlags2.dataEncipherment) {
      res.push("dataEncipherment");
    }
    if (flag & KeyUsageFlags2.decipherOnly) {
      res.push("decipherOnly");
    }
    if (flag & KeyUsageFlags2.digitalSignature) {
      res.push("digitalSignature");
    }
    if (flag & KeyUsageFlags2.encipherOnly) {
      res.push("encipherOnly");
    }
    if (flag & KeyUsageFlags2.keyAgreement) {
      res.push("keyAgreement");
    }
    if (flag & KeyUsageFlags2.keyCertSign) {
      res.push("keyCertSign");
    }
    if (flag & KeyUsageFlags2.keyEncipherment) {
      res.push("keyEncipherment");
    }
    if (flag & KeyUsageFlags2.nonRepudiation) {
      res.push("nonRepudiation");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
}
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/name_constraints.js
var GeneralSubtrees_12;
var id_ce_nameConstraints2 = `${id_ce2}.30`;

class GeneralSubtree2 {
  constructor(params = {}) {
    this.base = new GeneralName3;
    this.minimum = 0;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: GeneralName3 })
], GeneralSubtree2.prototype, "base", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, context: 0, defaultValue: 0, implicit: true })
], GeneralSubtree2.prototype, "minimum", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, context: 1, optional: true, implicit: true })
], GeneralSubtree2.prototype, "maximum", undefined);
var GeneralSubtrees3 = GeneralSubtrees_12 = class GeneralSubtrees4 extends AsnArray2 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralSubtrees_12.prototype);
  }
};
GeneralSubtrees3 = GeneralSubtrees_12 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence, itemType: GeneralSubtree2 })
], GeneralSubtrees3);
class NameConstraints2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: GeneralSubtrees3, context: 0, optional: true, implicit: true })
], NameConstraints2.prototype, "permittedSubtrees", undefined);
__decorate([
  AsnProp2({ type: GeneralSubtrees3, context: 1, optional: true, implicit: true })
], NameConstraints2.prototype, "excludedSubtrees", undefined);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_constraints.js
var id_ce_policyConstraints2 = `${id_ce2}.36`;

class PolicyConstraints2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({
    type: AsnPropTypes2.Integer,
    context: 0,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter2
  })
], PolicyConstraints2.prototype, "requireExplicitPolicy", undefined);
__decorate([
  AsnProp2({
    type: AsnPropTypes2.Integer,
    context: 1,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter2
  })
], PolicyConstraints2.prototype, "inhibitPolicyMapping", undefined);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_mappings.js
var PolicyMappings_12;
var id_ce_policyMappings2 = `${id_ce2}.33`;

class PolicyMapping2 {
  constructor(params = {}) {
    this.issuerDomainPolicy = "";
    this.subjectDomainPolicy = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AsnPropTypes2.ObjectIdentifier })
], PolicyMapping2.prototype, "issuerDomainPolicy", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.ObjectIdentifier })
], PolicyMapping2.prototype, "subjectDomainPolicy", undefined);
var PolicyMappings3 = PolicyMappings_12 = class PolicyMappings4 extends AsnArray2 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, PolicyMappings_12.prototype);
  }
};
PolicyMappings3 = PolicyMappings_12 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence, itemType: PolicyMapping2 })
], PolicyMappings3);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_alternative_name.js
var SubjectAlternativeName_12;
var id_ce_subjectAltName2 = `${id_ce2}.17`;
var SubjectAlternativeName3 = SubjectAlternativeName_12 = class SubjectAlternativeName4 extends GeneralNames3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectAlternativeName_12.prototype);
  }
};
SubjectAlternativeName3 = SubjectAlternativeName_12 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence })
], SubjectAlternativeName3);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/attribute.js
class Attribute2 {
  constructor(params = {}) {
    this.type = "";
    this.values = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AsnPropTypes2.ObjectIdentifier })
], Attribute2.prototype, "type", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Any, repeated: "set" })
], Attribute2.prototype, "values", undefined);

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_directory_attributes.js
var SubjectDirectoryAttributes_12;
var id_ce_subjectDirectoryAttributes2 = `${id_ce2}.9`;
var SubjectDirectoryAttributes3 = SubjectDirectoryAttributes_12 = class SubjectDirectoryAttributes4 extends AsnArray2 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectDirectoryAttributes_12.prototype);
  }
};
SubjectDirectoryAttributes3 = SubjectDirectoryAttributes_12 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence, itemType: Attribute2 })
], SubjectDirectoryAttributes3);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_key_identifier.js
var id_ce_subjectKeyIdentifier2 = `${id_ce2}.14`;

class SubjectKeyIdentifier extends KeyIdentifier2 {
}
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/private_key_usage_period.js
var id_ce_privateKeyUsagePeriod2 = `${id_ce2}.16`;

class PrivateKeyUsagePeriod2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AsnPropTypes2.GeneralizedTime, context: 0, implicit: true, optional: true })
], PrivateKeyUsagePeriod2.prototype, "notBefore", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.GeneralizedTime, context: 1, implicit: true, optional: true })
], PrivateKeyUsagePeriod2.prototype, "notAfter", undefined);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/entrust_version_info.js
var EntrustInfoFlags2;
(function(EntrustInfoFlags3) {
  EntrustInfoFlags3[EntrustInfoFlags3["keyUpdateAllowed"] = 1] = "keyUpdateAllowed";
  EntrustInfoFlags3[EntrustInfoFlags3["newExtensions"] = 2] = "newExtensions";
  EntrustInfoFlags3[EntrustInfoFlags3["pKIXCertificate"] = 4] = "pKIXCertificate";
})(EntrustInfoFlags2 || (EntrustInfoFlags2 = {}));

class EntrustInfo2 extends BitString4 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & EntrustInfoFlags2.pKIXCertificate) {
      res.push("pKIXCertificate");
    }
    if (flags & EntrustInfoFlags2.newExtensions) {
      res.push("newExtensions");
    }
    if (flags & EntrustInfoFlags2.keyUpdateAllowed) {
      res.push("keyUpdateAllowed");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
}

class EntrustVersionInfo2 {
  constructor(params = {}) {
    this.entrustVers = "";
    this.entrustInfoFlags = new EntrustInfo2;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AsnPropTypes2.GeneralString })
], EntrustVersionInfo2.prototype, "entrustVers", undefined);
__decorate([
  AsnProp2({ type: EntrustInfo2 })
], EntrustVersionInfo2.prototype, "entrustInfoFlags", undefined);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_info_access.js
var SubjectInfoAccessSyntax_12;
var id_pe_subjectInfoAccess2 = `${id_pe2}.11`;
var SubjectInfoAccessSyntax3 = SubjectInfoAccessSyntax_12 = class SubjectInfoAccessSyntax4 extends AsnArray2 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectInfoAccessSyntax_12.prototype);
  }
};
SubjectInfoAccessSyntax3 = SubjectInfoAccessSyntax_12 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence, itemType: AccessDescription2 })
], SubjectInfoAccessSyntax3);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js
class AlgorithmIdentifier2 {
  constructor(params = {}) {
    this.algorithm = "";
    Object.assign(this, params);
  }
  isEqual(data) {
    return data instanceof AlgorithmIdentifier2 && data.algorithm == this.algorithm && (data.parameters && this.parameters && isEqual(data.parameters, this.parameters) || data.parameters === this.parameters);
  }
}
__decorate([
  AsnProp2({
    type: AsnPropTypes2.ObjectIdentifier
  })
], AlgorithmIdentifier2.prototype, "algorithm", undefined);
__decorate([
  AsnProp2({
    type: AsnPropTypes2.Any,
    optional: true
  })
], AlgorithmIdentifier2.prototype, "parameters", undefined);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/subject_public_key_info.js
class SubjectPublicKeyInfo2 {
  constructor(params = {}) {
    this.algorithm = new AlgorithmIdentifier2;
    this.subjectPublicKey = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AlgorithmIdentifier2 })
], SubjectPublicKeyInfo2.prototype, "algorithm", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.BitString })
], SubjectPublicKeyInfo2.prototype, "subjectPublicKey", undefined);

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/time.js
var Time3 = class Time4 {
  constructor(time3) {
    if (time3) {
      if (typeof time3 === "string" || typeof time3 === "number" || time3 instanceof Date) {
        const date = new Date(time3);
        if (date.getUTCFullYear() > 2049) {
          this.generalTime = date;
        } else {
          this.utcTime = date;
        }
      } else {
        Object.assign(this, time3);
      }
    }
  }
  getTime() {
    const time3 = this.utcTime || this.generalTime;
    if (!time3) {
      throw new Error("Cannot get time from CHOICE object");
    }
    return time3;
  }
};
__decorate([
  AsnProp2({
    type: AsnPropTypes2.UTCTime
  })
], Time3.prototype, "utcTime", undefined);
__decorate([
  AsnProp2({
    type: AsnPropTypes2.GeneralizedTime
  })
], Time3.prototype, "generalTime", undefined);
Time3 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Choice })
], Time3);

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/validity.js
class Validity2 {
  constructor(params) {
    this.notBefore = new Time3(new Date);
    this.notAfter = new Time3(new Date);
    if (params) {
      this.notBefore = new Time3(params.notBefore);
      this.notAfter = new Time3(params.notAfter);
    }
  }
}
__decorate([
  AsnProp2({ type: Time3 })
], Validity2.prototype, "notBefore", undefined);
__decorate([
  AsnProp2({ type: Time3 })
], Validity2.prototype, "notAfter", undefined);

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/extension.js
var Extensions_12;

class Extension2 {
  constructor(params = {}) {
    this.extnID = "";
    this.critical = Extension2.CRITICAL;
    this.extnValue = new OctetString4;
    Object.assign(this, params);
  }
}
Extension2.CRITICAL = false;
__decorate([
  AsnProp2({ type: AsnPropTypes2.ObjectIdentifier })
], Extension2.prototype, "extnID", undefined);
__decorate([
  AsnProp2({
    type: AsnPropTypes2.Boolean,
    defaultValue: Extension2.CRITICAL
  })
], Extension2.prototype, "critical", undefined);
__decorate([
  AsnProp2({ type: OctetString4 })
], Extension2.prototype, "extnValue", undefined);
var Extensions3 = Extensions_12 = class Extensions4 extends AsnArray2 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Extensions_12.prototype);
  }
};
Extensions3 = Extensions_12 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence, itemType: Extension2 })
], Extensions3);

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/types.js
var Version2;
(function(Version3) {
  Version3[Version3["v1"] = 0] = "v1";
  Version3[Version3["v2"] = 1] = "v2";
  Version3[Version3["v3"] = 2] = "v3";
})(Version2 || (Version2 = {}));

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/tbs_certificate.js
class TBSCertificate2 {
  constructor(params = {}) {
    this.version = Version2.v1;
    this.serialNumber = new ArrayBuffer(0);
    this.signature = new AlgorithmIdentifier2;
    this.issuer = new Name3;
    this.validity = new Validity2;
    this.subject = new Name3;
    this.subjectPublicKeyInfo = new SubjectPublicKeyInfo2;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({
    type: AsnPropTypes2.Integer,
    context: 0,
    defaultValue: Version2.v1
  })
], TBSCertificate2.prototype, "version", undefined);
__decorate([
  AsnProp2({
    type: AsnPropTypes2.Integer,
    converter: AsnIntegerArrayBufferConverter2
  })
], TBSCertificate2.prototype, "serialNumber", undefined);
__decorate([
  AsnProp2({ type: AlgorithmIdentifier2 })
], TBSCertificate2.prototype, "signature", undefined);
__decorate([
  AsnProp2({ type: Name3 })
], TBSCertificate2.prototype, "issuer", undefined);
__decorate([
  AsnProp2({ type: Validity2 })
], TBSCertificate2.prototype, "validity", undefined);
__decorate([
  AsnProp2({ type: Name3 })
], TBSCertificate2.prototype, "subject", undefined);
__decorate([
  AsnProp2({ type: SubjectPublicKeyInfo2 })
], TBSCertificate2.prototype, "subjectPublicKeyInfo", undefined);
__decorate([
  AsnProp2({
    type: AsnPropTypes2.BitString,
    context: 1,
    implicit: true,
    optional: true
  })
], TBSCertificate2.prototype, "issuerUniqueID", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.BitString, context: 2, implicit: true, optional: true })
], TBSCertificate2.prototype, "subjectUniqueID", undefined);
__decorate([
  AsnProp2({ type: Extensions3, context: 3, optional: true })
], TBSCertificate2.prototype, "extensions", undefined);

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/certificate.js
class Certificate2 {
  constructor(params = {}) {
    this.tbsCertificate = new TBSCertificate2;
    this.signatureAlgorithm = new AlgorithmIdentifier2;
    this.signatureValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: TBSCertificate2, raw: true })
], Certificate2.prototype, "tbsCertificate", undefined);
__decorate([
  AsnProp2({ type: AlgorithmIdentifier2 })
], Certificate2.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.BitString })
], Certificate2.prototype, "signatureValue", undefined);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/tbs_cert_list.js
class RevokedCertificate2 {
  constructor(params = {}) {
    this.userCertificate = new ArrayBuffer(0);
    this.revocationDate = new Time3;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, converter: AsnIntegerArrayBufferConverter2 })
], RevokedCertificate2.prototype, "userCertificate", undefined);
__decorate([
  AsnProp2({ type: Time3 })
], RevokedCertificate2.prototype, "revocationDate", undefined);
__decorate([
  AsnProp2({ type: Extension2, optional: true, repeated: "sequence" })
], RevokedCertificate2.prototype, "crlEntryExtensions", undefined);

class TBSCertList2 {
  constructor(params = {}) {
    this.signature = new AlgorithmIdentifier2;
    this.issuer = new Name3;
    this.thisUpdate = new Time3;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, optional: true })
], TBSCertList2.prototype, "version", undefined);
__decorate([
  AsnProp2({ type: AlgorithmIdentifier2 })
], TBSCertList2.prototype, "signature", undefined);
__decorate([
  AsnProp2({ type: Name3 })
], TBSCertList2.prototype, "issuer", undefined);
__decorate([
  AsnProp2({ type: Time3 })
], TBSCertList2.prototype, "thisUpdate", undefined);
__decorate([
  AsnProp2({ type: Time3, optional: true })
], TBSCertList2.prototype, "nextUpdate", undefined);
__decorate([
  AsnProp2({ type: RevokedCertificate2, repeated: "sequence", optional: true })
], TBSCertList2.prototype, "revokedCertificates", undefined);
__decorate([
  AsnProp2({ type: Extension2, optional: true, context: 0, repeated: "sequence" })
], TBSCertList2.prototype, "crlExtensions", undefined);

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-x509/build/es2015/certificate_list.js
class CertificateList2 {
  constructor(params = {}) {
    this.tbsCertList = new TBSCertList2;
    this.signatureAlgorithm = new AlgorithmIdentifier2;
    this.signature = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: TBSCertList2, raw: true })
], CertificateList2.prototype, "tbsCertList", undefined);
__decorate([
  AsnProp2({ type: AlgorithmIdentifier2 })
], CertificateList2.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.BitString })
], CertificateList2.prototype, "signature", undefined);
// node_modules/@peculiar/asn1-cms/node_modules/asn1js/build/index.es.js
var exports_index_es4 = {};
__export(exports_index_es4, {
  verifySchema: () => verifySchema3,
  fromBER: () => fromBER3,
  compareSchema: () => compareSchema3,
  VisibleString: () => VisibleString3,
  ViewWriter: () => ViewWriter3,
  VideotexString: () => VideotexString3,
  ValueBlock: () => ValueBlock3,
  Utf8String: () => Utf8String3,
  UniversalString: () => UniversalString3,
  UTCTime: () => UTCTime3,
  TimeOfDay: () => TimeOfDay3,
  TeletexString: () => TeletexString3,
  TIME: () => TIME3,
  Set: () => Set4,
  Sequence: () => Sequence3,
  Repeated: () => Repeated3,
  RelativeObjectIdentifier: () => RelativeObjectIdentifier3,
  RawData: () => RawData3,
  PrintableString: () => PrintableString3,
  Primitive: () => Primitive3,
  OctetString: () => OctetString5,
  ObjectIdentifier: () => ObjectIdentifier3,
  NumericString: () => NumericString3,
  Null: () => Null3,
  Integer: () => Integer3,
  IA5String: () => IA5String3,
  HexBlock: () => HexBlock3,
  GraphicString: () => GraphicString3,
  GeneralizedTime: () => GeneralizedTime3,
  GeneralString: () => GeneralString3,
  Enumerated: () => Enumerated3,
  EndOfContent: () => EndOfContent3,
  Duration: () => Duration3,
  DateTime: () => DateTime3,
  DATE: () => DATE3,
  Constructed: () => Constructed3,
  Choice: () => Choice3,
  CharacterString: () => CharacterString3,
  Boolean: () => Boolean4,
  BmpString: () => BmpString3,
  BitString: () => BitString5,
  BaseStringBlock: () => BaseStringBlock3,
  BaseBlock: () => BaseBlock3,
  Any: () => Any3
});
/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
function assertBigInt3() {
  if (typeof BigInt === "undefined") {
    throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
  }
}
function concat3(buffers) {
  let outputLength = 0;
  let prevLength = 0;
  for (let i = 0;i < buffers.length; i++) {
    const buffer = buffers[i];
    outputLength += buffer.byteLength;
  }
  const retView = new Uint8Array(outputLength);
  for (let i = 0;i < buffers.length; i++) {
    const buffer = buffers[i];
    retView.set(new Uint8Array(buffer), prevLength);
    prevLength += buffer.byteLength;
  }
  return retView.buffer;
}
function checkBufferParams3(baseBlock, inputBuffer, inputOffset, inputLength) {
  if (!(inputBuffer instanceof Uint8Array)) {
    baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
    return false;
  }
  if (!inputBuffer.byteLength) {
    baseBlock.error = "Wrong parameter: inputBuffer has zero length";
    return false;
  }
  if (inputOffset < 0) {
    baseBlock.error = "Wrong parameter: inputOffset less than zero";
    return false;
  }
  if (inputLength < 0) {
    baseBlock.error = "Wrong parameter: inputLength less than zero";
    return false;
  }
  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
    baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
    return false;
  }
  return true;
}

class ViewWriter3 {
  constructor() {
    this.items = [];
  }
  write(buf) {
    this.items.push(buf);
  }
  final() {
    return concat3(this.items);
  }
}
var powers23 = [new Uint8Array([1])];
var digitsString3 = "0123456789";
var NAME3 = "name";
var VALUE_HEX_VIEW3 = "valueHexView";
var IS_HEX_ONLY3 = "isHexOnly";
var ID_BLOCK3 = "idBlock";
var TAG_CLASS3 = "tagClass";
var TAG_NUMBER3 = "tagNumber";
var IS_CONSTRUCTED3 = "isConstructed";
var FROM_BER3 = "fromBER";
var TO_BER3 = "toBER";
var LOCAL3 = "local";
var EMPTY_STRING3 = "";
var EMPTY_BUFFER3 = new ArrayBuffer(0);
var EMPTY_VIEW3 = new Uint8Array(0);
var END_OF_CONTENT_NAME3 = "EndOfContent";
var OCTET_STRING_NAME3 = "OCTET STRING";
var BIT_STRING_NAME3 = "BIT STRING";
function HexBlock3(BaseClass) {
  var _a3;
  return _a3 = class Some extends BaseClass {
    get valueHex() {
      return this.valueHexView.slice().buffer;
    }
    set valueHex(value) {
      this.valueHexView = new Uint8Array(value);
    }
    constructor(...args) {
      var _b;
      super(...args);
      const params = args[0] || {};
      this.isHexOnly = (_b = params.isHexOnly) !== null && _b !== undefined ? _b : false;
      this.valueHexView = params.valueHex ? BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW3;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      if (!checkBufferParams3(this, view, inputOffset, inputLength)) {
        return -1;
      }
      const endLength = inputOffset + inputLength;
      this.valueHexView = view.subarray(inputOffset, endLength);
      if (!this.valueHexView.length) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      }
      this.blockLength = inputLength;
      return endLength;
    }
    toBER(sizeOnly = false) {
      if (!this.isHexOnly) {
        this.error = "Flag 'isHexOnly' is not set, abort";
        return EMPTY_BUFFER3;
      }
      if (sizeOnly) {
        return new ArrayBuffer(this.valueHexView.byteLength);
      }
      return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        isHexOnly: this.isHexOnly,
        valueHex: Convert.ToHex(this.valueHexView)
      };
    }
  }, _a3.NAME = "hexBlock", _a3;
}

class LocalBaseBlock3 {
  static blockName() {
    return this.NAME;
  }
  get valueBeforeDecode() {
    return this.valueBeforeDecodeView.slice().buffer;
  }
  set valueBeforeDecode(value) {
    this.valueBeforeDecodeView = new Uint8Array(value);
  }
  constructor({ blockLength = 0, error = EMPTY_STRING3, warnings = [], valueBeforeDecode = EMPTY_VIEW3 } = {}) {
    this.blockLength = blockLength;
    this.error = error;
    this.warnings = warnings;
    this.valueBeforeDecodeView = BufferSourceConverter.toUint8Array(valueBeforeDecode);
  }
  toJSON() {
    return {
      blockName: this.constructor.NAME,
      blockLength: this.blockLength,
      error: this.error,
      warnings: this.warnings,
      valueBeforeDecode: Convert.ToHex(this.valueBeforeDecodeView)
    };
  }
}
LocalBaseBlock3.NAME = "baseBlock";

class ValueBlock3 extends LocalBaseBlock3 {
  fromBER(_inputBuffer, _inputOffset, _inputLength) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
  toBER(_sizeOnly, _writer) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
}
ValueBlock3.NAME = "valueBlock";

class LocalIdentificationBlock3 extends HexBlock3(LocalBaseBlock3) {
  constructor({ idBlock = {} } = {}) {
    var _a3, _b, _c, _d;
    super();
    if (idBlock) {
      this.isHexOnly = (_a3 = idBlock.isHexOnly) !== null && _a3 !== undefined ? _a3 : false;
      this.valueHexView = idBlock.valueHex ? BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW3;
      this.tagClass = (_b = idBlock.tagClass) !== null && _b !== undefined ? _b : -1;
      this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== undefined ? _c : -1;
      this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== undefined ? _d : false;
    } else {
      this.tagClass = -1;
      this.tagNumber = -1;
      this.isConstructed = false;
    }
  }
  toBER(sizeOnly = false) {
    let firstOctet = 0;
    switch (this.tagClass) {
      case 1:
        firstOctet |= 0;
        break;
      case 2:
        firstOctet |= 64;
        break;
      case 3:
        firstOctet |= 128;
        break;
      case 4:
        firstOctet |= 192;
        break;
      default:
        this.error = "Unknown tag class";
        return EMPTY_BUFFER3;
    }
    if (this.isConstructed)
      firstOctet |= 32;
    if (this.tagNumber < 31 && !this.isHexOnly) {
      const retView2 = new Uint8Array(1);
      if (!sizeOnly) {
        let number = this.tagNumber;
        number &= 31;
        firstOctet |= number;
        retView2[0] = firstOctet;
      }
      return retView2.buffer;
    }
    if (!this.isHexOnly) {
      const encodedBuf = utilToBase(this.tagNumber, 7);
      const encodedView = new Uint8Array(encodedBuf);
      const size = encodedBuf.byteLength;
      const retView2 = new Uint8Array(size + 1);
      retView2[0] = firstOctet | 31;
      if (!sizeOnly) {
        for (let i = 0;i < size - 1; i++)
          retView2[i + 1] = encodedView[i] | 128;
        retView2[size] = encodedView[size - 1];
      }
      return retView2.buffer;
    }
    const retView = new Uint8Array(this.valueHexView.byteLength + 1);
    retView[0] = firstOctet | 31;
    if (!sizeOnly) {
      const curView = this.valueHexView;
      for (let i = 0;i < curView.length - 1; i++)
        retView[i + 1] = curView[i] | 128;
      retView[this.valueHexView.byteLength] = curView[curView.length - 1];
    }
    return retView.buffer;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams3(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    const tagClassMask = intBuffer[0] & 192;
    switch (tagClassMask) {
      case 0:
        this.tagClass = 1;
        break;
      case 64:
        this.tagClass = 2;
        break;
      case 128:
        this.tagClass = 3;
        break;
      case 192:
        this.tagClass = 4;
        break;
      default:
        this.error = "Unknown tag class";
        return -1;
    }
    this.isConstructed = (intBuffer[0] & 32) === 32;
    this.isHexOnly = false;
    const tagNumberMask = intBuffer[0] & 31;
    if (tagNumberMask !== 31) {
      this.tagNumber = tagNumberMask;
      this.blockLength = 1;
    } else {
      let count = 1;
      let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
      let tagNumberBufferMaxLength = 255;
      while (intBuffer[count] & 128) {
        intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
        count++;
        if (count >= intBuffer.length) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (count === tagNumberBufferMaxLength) {
          tagNumberBufferMaxLength += 255;
          const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);
          for (let i = 0;i < intTagNumberBuffer.length; i++)
            tempBufferView2[i] = intTagNumberBuffer[i];
          intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
        }
      }
      this.blockLength = count + 1;
      intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
      const tempBufferView = new Uint8Array(count);
      for (let i = 0;i < count; i++)
        tempBufferView[i] = intTagNumberBuffer[i];
      intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
      intTagNumberBuffer.set(tempBufferView);
      if (this.blockLength <= 9)
        this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
      else {
        this.isHexOnly = true;
        this.warnings.push("Tag too long, represented as hex-coded");
      }
    }
    if (this.tagClass === 1 && this.isConstructed) {
      switch (this.tagNumber) {
        case 1:
        case 2:
        case 5:
        case 6:
        case 9:
        case 13:
        case 14:
        case 23:
        case 24:
        case 31:
        case 32:
        case 33:
        case 34:
          this.error = "Constructed encoding used for primitive type";
          return -1;
      }
    }
    return inputOffset + this.blockLength;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      tagClass: this.tagClass,
      tagNumber: this.tagNumber,
      isConstructed: this.isConstructed
    };
  }
}
LocalIdentificationBlock3.NAME = "identificationBlock";

class LocalLengthBlock3 extends LocalBaseBlock3 {
  constructor({ lenBlock = {} } = {}) {
    var _a3, _b, _c;
    super();
    this.isIndefiniteForm = (_a3 = lenBlock.isIndefiniteForm) !== null && _a3 !== undefined ? _a3 : false;
    this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== undefined ? _b : false;
    this.length = (_c = lenBlock.length) !== null && _c !== undefined ? _c : 0;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams3(this, view, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    if (intBuffer[0] === 255) {
      this.error = "Length block 0xFF is reserved by standard";
      return -1;
    }
    this.isIndefiniteForm = intBuffer[0] === 128;
    if (this.isIndefiniteForm) {
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    this.longFormUsed = !!(intBuffer[0] & 128);
    if (this.longFormUsed === false) {
      this.length = intBuffer[0];
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    const count = intBuffer[0] & 127;
    if (count > 8) {
      this.error = "Too big integer";
      return -1;
    }
    if (count + 1 > intBuffer.length) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    const lenOffset = inputOffset + 1;
    const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
    if (lengthBufferView[count - 1] === 0)
      this.warnings.push("Needlessly long encoded length");
    this.length = utilFromBase(lengthBufferView, 8);
    if (this.longFormUsed && this.length <= 127)
      this.warnings.push("Unnecessary usage of long length form");
    this.blockLength = count + 1;
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly = false) {
    let retBuf;
    let retView;
    if (this.length > 127)
      this.longFormUsed = true;
    if (this.isIndefiniteForm) {
      retBuf = new ArrayBuffer(1);
      if (sizeOnly === false) {
        retView = new Uint8Array(retBuf);
        retView[0] = 128;
      }
      return retBuf;
    }
    if (this.longFormUsed) {
      const encodedBuf = utilToBase(this.length, 8);
      if (encodedBuf.byteLength > 127) {
        this.error = "Too big length";
        return EMPTY_BUFFER3;
      }
      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
      if (sizeOnly)
        return retBuf;
      const encodedView = new Uint8Array(encodedBuf);
      retView = new Uint8Array(retBuf);
      retView[0] = encodedBuf.byteLength | 128;
      for (let i = 0;i < encodedBuf.byteLength; i++)
        retView[i + 1] = encodedView[i];
      return retBuf;
    }
    retBuf = new ArrayBuffer(1);
    if (sizeOnly === false) {
      retView = new Uint8Array(retBuf);
      retView[0] = this.length;
    }
    return retBuf;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      longFormUsed: this.longFormUsed,
      length: this.length
    };
  }
}
LocalLengthBlock3.NAME = "lengthBlock";
var typeStore3 = {};

class BaseBlock3 extends LocalBaseBlock3 {
  constructor({ name: name3 = EMPTY_STRING3, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType) {
    super(parameters);
    this.name = name3;
    this.optional = optional;
    if (primitiveSchema) {
      this.primitiveSchema = primitiveSchema;
    }
    this.idBlock = new LocalIdentificationBlock3(parameters);
    this.lenBlock = new LocalLengthBlock3(parameters);
    this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock3(parameters);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter3;
    if (!writer) {
      prepareIndefiniteForm3(this);
    }
    const idBlockBuf = this.idBlock.toBER(sizeOnly);
    _writer.write(idBlockBuf);
    if (this.lenBlock.isIndefiniteForm) {
      _writer.write(new Uint8Array([128]).buffer);
      this.valueBlock.toBER(sizeOnly, _writer);
      _writer.write(new ArrayBuffer(2));
    } else {
      const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
      this.lenBlock.length = valueBlockBuf.byteLength;
      const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
      _writer.write(lenBlockBuf);
      _writer.write(valueBlockBuf);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER3;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      idBlock: this.idBlock.toJSON(),
      lenBlock: this.lenBlock.toJSON(),
      valueBlock: this.valueBlock.toJSON(),
      name: this.name,
      optional: this.optional
    };
    if (this.primitiveSchema)
      object.primitiveSchema = this.primitiveSchema.toJSON();
    return object;
  }
  toString(encoding = "ascii") {
    if (encoding === "ascii") {
      return this.onAsciiEncoding();
    }
    return Convert.ToHex(this.toBER());
  }
  onAsciiEncoding() {
    const name3 = this.constructor.NAME;
    const value = Convert.ToHex(this.valueBlock.valueBeforeDecodeView);
    return `${name3} : ${value}`;
  }
  isEqual(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof this.constructor)) {
      return false;
    }
    const thisRaw = this.toBER();
    const otherRaw = other.toBER();
    return isEqualBuffer(thisRaw, otherRaw);
  }
}
BaseBlock3.NAME = "BaseBlock";
function prepareIndefiniteForm3(baseBlock) {
  var _a3;
  if (baseBlock instanceof typeStore3.Constructed) {
    for (const value of baseBlock.valueBlock.value) {
      if (prepareIndefiniteForm3(value)) {
        baseBlock.lenBlock.isIndefiniteForm = true;
      }
    }
  }
  return !!((_a3 = baseBlock.lenBlock) === null || _a3 === undefined ? undefined : _a3.isIndefiniteForm);
}

class BaseStringBlock3 extends BaseBlock3 {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  constructor({ value = EMPTY_STRING3, ...parameters } = {}, stringValueBlockType) {
    super(parameters, stringValueBlockType);
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    this.fromBuffer(this.valueBlock.valueHexView);
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
  }
}
BaseStringBlock3.NAME = "BaseStringBlock";

class LocalPrimitiveValueBlock3 extends HexBlock3(ValueBlock3) {
  constructor({ isHexOnly = true, ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = isHexOnly;
  }
}
LocalPrimitiveValueBlock3.NAME = "PrimitiveValueBlock";
var _a$w3;

class Primitive3 extends BaseBlock3 {
  constructor(parameters = {}) {
    super(parameters, LocalPrimitiveValueBlock3);
    this.idBlock.isConstructed = false;
  }
}
_a$w3 = Primitive3;
(() => {
  typeStore3.Primitive = _a$w3;
})();
Primitive3.NAME = "PRIMITIVE";
function localChangeType3(inputObject, newType) {
  if (inputObject instanceof newType) {
    return inputObject;
  }
  const newObject = new newType;
  newObject.idBlock = inputObject.idBlock;
  newObject.lenBlock = inputObject.lenBlock;
  newObject.warnings = inputObject.warnings;
  newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
  return newObject;
}
function localFromBER3(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
  const incomingOffset = inputOffset;
  let returnObject = new BaseBlock3({}, ValueBlock3);
  const baseBlock = new LocalBaseBlock3;
  if (!checkBufferParams3(baseBlock, inputBuffer, inputOffset, inputLength)) {
    returnObject.error = baseBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
  if (!intBuffer.length) {
    returnObject.error = "Zero buffer length";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.idBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.idBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.idBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.idBlock.blockLength;
  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.lenBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.lenBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.lenBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.lenBlock.blockLength;
  if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
    returnObject.error = "Indefinite length form used for primitive encoding form";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let newASN1Type = BaseBlock3;
  switch (returnObject.idBlock.tagClass) {
    case 1:
      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
        returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
        return {
          offset: -1,
          result: returnObject
        };
      }
      switch (returnObject.idBlock.tagNumber) {
        case 0:
          if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
            returnObject.error = "Type [UNIVERSAL 0] is reserved";
            return {
              offset: -1,
              result: returnObject
            };
          }
          newASN1Type = typeStore3.EndOfContent;
          break;
        case 1:
          newASN1Type = typeStore3.Boolean;
          break;
        case 2:
          newASN1Type = typeStore3.Integer;
          break;
        case 3:
          newASN1Type = typeStore3.BitString;
          break;
        case 4:
          newASN1Type = typeStore3.OctetString;
          break;
        case 5:
          newASN1Type = typeStore3.Null;
          break;
        case 6:
          newASN1Type = typeStore3.ObjectIdentifier;
          break;
        case 10:
          newASN1Type = typeStore3.Enumerated;
          break;
        case 12:
          newASN1Type = typeStore3.Utf8String;
          break;
        case 13:
          newASN1Type = typeStore3.RelativeObjectIdentifier;
          break;
        case 14:
          newASN1Type = typeStore3.TIME;
          break;
        case 15:
          returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
          return {
            offset: -1,
            result: returnObject
          };
        case 16:
          newASN1Type = typeStore3.Sequence;
          break;
        case 17:
          newASN1Type = typeStore3.Set;
          break;
        case 18:
          newASN1Type = typeStore3.NumericString;
          break;
        case 19:
          newASN1Type = typeStore3.PrintableString;
          break;
        case 20:
          newASN1Type = typeStore3.TeletexString;
          break;
        case 21:
          newASN1Type = typeStore3.VideotexString;
          break;
        case 22:
          newASN1Type = typeStore3.IA5String;
          break;
        case 23:
          newASN1Type = typeStore3.UTCTime;
          break;
        case 24:
          newASN1Type = typeStore3.GeneralizedTime;
          break;
        case 25:
          newASN1Type = typeStore3.GraphicString;
          break;
        case 26:
          newASN1Type = typeStore3.VisibleString;
          break;
        case 27:
          newASN1Type = typeStore3.GeneralString;
          break;
        case 28:
          newASN1Type = typeStore3.UniversalString;
          break;
        case 29:
          newASN1Type = typeStore3.CharacterString;
          break;
        case 30:
          newASN1Type = typeStore3.BmpString;
          break;
        case 31:
          newASN1Type = typeStore3.DATE;
          break;
        case 32:
          newASN1Type = typeStore3.TimeOfDay;
          break;
        case 33:
          newASN1Type = typeStore3.DateTime;
          break;
        case 34:
          newASN1Type = typeStore3.Duration;
          break;
        default: {
          const newObject = returnObject.idBlock.isConstructed ? new typeStore3.Constructed : new typeStore3.Primitive;
          newObject.idBlock = returnObject.idBlock;
          newObject.lenBlock = returnObject.lenBlock;
          newObject.warnings = returnObject.warnings;
          returnObject = newObject;
        }
      }
      break;
    case 2:
    case 3:
    case 4:
    default: {
      newASN1Type = returnObject.idBlock.isConstructed ? typeStore3.Constructed : typeStore3.Primitive;
    }
  }
  returnObject = localChangeType3(returnObject, newASN1Type);
  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
  returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
  return {
    offset: resultOffset,
    result: returnObject
  };
}
function fromBER3(inputBuffer) {
  if (!inputBuffer.byteLength) {
    const result = new BaseBlock3({}, ValueBlock3);
    result.error = "Input buffer has zero length";
    return {
      offset: -1,
      result
    };
  }
  return localFromBER3(BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
}
function checkLen3(indefiniteLength, length) {
  if (indefiniteLength) {
    return 1;
  }
  return length;
}

class LocalConstructedValueBlock3 extends ValueBlock3 {
  constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {
    super(parameters);
    this.value = value;
    this.isIndefiniteForm = isIndefiniteForm;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams3(this, view, inputOffset, inputLength)) {
      return -1;
    }
    this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
    if (this.valueBeforeDecodeView.length === 0) {
      this.warnings.push("Zero buffer length");
      return inputOffset;
    }
    let currentOffset = inputOffset;
    while (checkLen3(this.isIndefiniteForm, inputLength) > 0) {
      const returnObject = localFromBER3(view, currentOffset, inputLength);
      if (returnObject.offset === -1) {
        this.error = returnObject.result.error;
        this.warnings.concat(returnObject.result.warnings);
        return -1;
      }
      currentOffset = returnObject.offset;
      this.blockLength += returnObject.result.blockLength;
      inputLength -= returnObject.result.blockLength;
      this.value.push(returnObject.result);
      if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME3) {
        break;
      }
    }
    if (this.isIndefiniteForm) {
      if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME3) {
        this.value.pop();
      } else {
        this.warnings.push("No EndOfContent block encoded");
      }
    }
    return currentOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter3;
    for (let i = 0;i < this.value.length; i++) {
      this.value[i].toBER(sizeOnly, _writer);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER3;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      value: []
    };
    for (const value of this.value) {
      object.value.push(value.toJSON());
    }
    return object;
  }
}
LocalConstructedValueBlock3.NAME = "ConstructedValueBlock";
var _a$v3;

class Constructed3 extends BaseBlock3 {
  constructor(parameters = {}) {
    super(parameters, LocalConstructedValueBlock3);
    this.idBlock.isConstructed = true;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    const values = [];
    for (const value of this.valueBlock.value) {
      values.push(value.toString("ascii").split(`
`).map((o) => `  ${o}`).join(`
`));
    }
    const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
    return values.length ? `${blockName} :
${values.join(`
`)}` : `${blockName} :`;
  }
}
_a$v3 = Constructed3;
(() => {
  typeStore3.Constructed = _a$v3;
})();
Constructed3.NAME = "CONSTRUCTED";

class LocalEndOfContentValueBlock3 extends ValueBlock3 {
  fromBER(inputBuffer, inputOffset, _inputLength) {
    return inputOffset;
  }
  toBER(_sizeOnly) {
    return EMPTY_BUFFER3;
  }
}
LocalEndOfContentValueBlock3.override = "EndOfContentValueBlock";
var _a$u3;

class EndOfContent3 extends BaseBlock3 {
  constructor(parameters = {}) {
    super(parameters, LocalEndOfContentValueBlock3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 0;
  }
}
_a$u3 = EndOfContent3;
(() => {
  typeStore3.EndOfContent = _a$u3;
})();
EndOfContent3.NAME = END_OF_CONTENT_NAME3;
var _a$t3;

class Null3 extends BaseBlock3 {
  constructor(parameters = {}) {
    super(parameters, ValueBlock3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 5;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (this.lenBlock.length > 0)
      this.warnings.push("Non-zero length of value block for Null type");
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    this.blockLength += inputLength;
    if (inputOffset + inputLength > inputBuffer.byteLength) {
      this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
      return -1;
    }
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    const retBuf = new ArrayBuffer(2);
    if (!sizeOnly) {
      const retView = new Uint8Array(retBuf);
      retView[0] = 5;
      retView[1] = 0;
    }
    if (writer) {
      writer.write(retBuf);
    }
    return retBuf;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME}`;
  }
}
_a$t3 = Null3;
(() => {
  typeStore3.Null = _a$t3;
})();
Null3.NAME = "NULL";

class LocalBooleanValueBlock3 extends HexBlock3(ValueBlock3) {
  get value() {
    for (const octet of this.valueHexView) {
      if (octet > 0) {
        return true;
      }
    }
    return false;
  }
  set value(value) {
    this.valueHexView[0] = value ? 255 : 0;
  }
  constructor({ value, ...parameters } = {}) {
    super(parameters);
    if (parameters.valueHex) {
      this.valueHexView = BufferSourceConverter.toUint8Array(parameters.valueHex);
    } else {
      this.valueHexView = new Uint8Array(1);
    }
    if (value) {
      this.value = value;
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams3(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (inputLength > 1)
      this.warnings.push("Boolean value encoded in more then 1 octet");
    this.isHexOnly = true;
    utilDecodeTC.call(this);
    this.blockLength = inputLength;
    return inputOffset + inputLength;
  }
  toBER() {
    return this.valueHexView.slice();
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalBooleanValueBlock3.NAME = "BooleanValueBlock";
var _a$s3;

class Boolean4 extends BaseBlock3 {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  constructor(parameters = {}) {
    super(parameters, LocalBooleanValueBlock3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 1;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.getValue}`;
  }
}
_a$s3 = Boolean4;
(() => {
  typeStore3.Boolean = _a$s3;
})();
Boolean4.NAME = "BOOLEAN";

class LocalOctetStringValueBlock3 extends HexBlock3(LocalConstructedValueBlock3) {
  constructor({ isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.isConstructed = isConstructed;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = 0;
    if (this.isConstructed) {
      this.isHexOnly = false;
      resultOffset = LocalConstructedValueBlock3.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (let i = 0;i < this.value.length; i++) {
        const currentBlockName = this.value[i].constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME3) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== OCTET_STRING_NAME3) {
          this.error = "OCTET STRING may consists of OCTET STRINGs only";
          return -1;
        }
      }
    } else {
      this.isHexOnly = true;
      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
      this.blockLength = inputLength;
    }
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed)
      return LocalConstructedValueBlock3.prototype.toBER.call(this, sizeOnly, writer);
    return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isConstructed: this.isConstructed
    };
  }
}
LocalOctetStringValueBlock3.NAME = "OctetStringValueBlock";
var _a$r3;

class OctetString5 extends BaseBlock3 {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b, _c;
    (_b = parameters.isConstructed) !== null && _b !== undefined || (parameters.isConstructed = !!((_c = parameters.value) === null || _c === undefined ? undefined : _c.length));
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalOctetStringValueBlock3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 4;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    if (inputLength === 0) {
      if (this.idBlock.error.length === 0)
        this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0)
        this.blockLength += this.lenBlock.blockLength;
      return inputOffset;
    }
    if (!this.valueBlock.isConstructed) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      const buf = view.subarray(inputOffset, inputOffset + inputLength);
      try {
        if (buf.byteLength) {
          const asn = localFromBER3(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength) {
            this.valueBlock.value = [asn.result];
          }
        }
      } catch {}
    }
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed3.prototype.onAsciiEncoding.call(this);
    }
    const name3 = this.constructor.NAME;
    const value = Convert.ToHex(this.valueBlock.valueHexView);
    return `${name3} : ${value}`;
  }
  getValue() {
    if (!this.idBlock.isConstructed) {
      return this.valueBlock.valueHexView.slice().buffer;
    }
    const array = [];
    for (const content of this.valueBlock.value) {
      if (content instanceof _a$r3) {
        array.push(content.valueBlock.valueHexView);
      }
    }
    return BufferSourceConverter.concat(array);
  }
}
_a$r3 = OctetString5;
(() => {
  typeStore3.OctetString = _a$r3;
})();
OctetString5.NAME = OCTET_STRING_NAME3;

class LocalBitStringValueBlock3 extends HexBlock3(LocalConstructedValueBlock3) {
  constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.unusedBits = unusedBits;
    this.isConstructed = isConstructed;
    this.blockLength = this.valueHexView.byteLength;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    let resultOffset = -1;
    if (this.isConstructed) {
      resultOffset = LocalConstructedValueBlock3.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (const value of this.value) {
        const currentBlockName = value.constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME3) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== BIT_STRING_NAME3) {
          this.error = "BIT STRING may consists of BIT STRINGs only";
          return -1;
        }
        const valueBlock = value.valueBlock;
        if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
          this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
          return -1;
        }
        this.unusedBits = valueBlock.unusedBits;
      }
      return resultOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams3(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.unusedBits = intBuffer[0];
    if (this.unusedBits > 7) {
      this.error = "Unused bits for BitString must be in range 0-7";
      return -1;
    }
    if (!this.unusedBits) {
      const buf = intBuffer.subarray(1);
      try {
        if (buf.byteLength) {
          const asn = localFromBER3(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength - 1) {
            this.value = [asn.result];
          }
        }
      } catch {}
    }
    this.valueHexView = intBuffer.subarray(1);
    this.blockLength = intBuffer.length;
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed) {
      return LocalConstructedValueBlock3.prototype.toBER.call(this, sizeOnly, writer);
    }
    if (sizeOnly) {
      return new ArrayBuffer(this.valueHexView.byteLength + 1);
    }
    if (!this.valueHexView.byteLength) {
      return EMPTY_BUFFER3;
    }
    const retView = new Uint8Array(this.valueHexView.length + 1);
    retView[0] = this.unusedBits;
    retView.set(this.valueHexView, 1);
    return retView.buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      unusedBits: this.unusedBits,
      isConstructed: this.isConstructed
    };
  }
}
LocalBitStringValueBlock3.NAME = "BitStringValueBlock";
var _a$q3;

class BitString5 extends BaseBlock3 {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b, _c;
    (_b = parameters.isConstructed) !== null && _b !== undefined || (parameters.isConstructed = !!((_c = parameters.value) === null || _c === undefined ? undefined : _c.length));
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalBitStringValueBlock3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 3;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed3.prototype.onAsciiEncoding.call(this);
    } else {
      const bits = [];
      const valueHex = this.valueBlock.valueHexView;
      for (const byte of valueHex) {
        bits.push(byte.toString(2).padStart(8, "0"));
      }
      const bitsStr = bits.join("");
      const name3 = this.constructor.NAME;
      const value = bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits);
      return `${name3} : ${value}`;
    }
  }
}
_a$q3 = BitString5;
(() => {
  typeStore3.BitString = _a$q3;
})();
BitString5.NAME = BIT_STRING_NAME3;
var _a$p3;
function viewAdd3(first, second) {
  const c = new Uint8Array([0]);
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  let firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value = 0;
  const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
  let counter = 0;
  for (let i = max;i >= 0; i--, counter++) {
    switch (true) {
      case counter < secondViewCopy.length:
        value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
        break;
      default:
        value = firstViewCopy[firstViewCopyLength - counter] + c[0];
    }
    c[0] = value / 10;
    switch (true) {
      case counter >= firstViewCopy.length:
        firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
        break;
      default:
        firstViewCopy[firstViewCopyLength - counter] = value % 10;
    }
  }
  if (c[0] > 0)
    firstViewCopy = utilConcatView(c, firstViewCopy);
  return firstViewCopy;
}
function power23(n) {
  if (n >= powers23.length) {
    for (let p = powers23.length;p <= n; p++) {
      const c = new Uint8Array([0]);
      let digits = powers23[p - 1].slice(0);
      for (let i = digits.length - 1;i >= 0; i--) {
        const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
        c[0] = newValue[0] / 10;
        digits[i] = newValue[0] % 10;
      }
      if (c[0] > 0)
        digits = utilConcatView(c, digits);
      powers23.push(digits);
    }
  }
  return powers23[n];
}
function viewSub3(first, second) {
  let b = 0;
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  const firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value;
  let counter = 0;
  for (let i = secondViewCopyLength;i >= 0; i--, counter++) {
    value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
    switch (true) {
      case value < 0:
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
        break;
      default:
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
    }
  }
  if (b > 0) {
    for (let i = firstViewCopyLength - secondViewCopyLength + 1;i >= 0; i--, counter++) {
      value = firstViewCopy[firstViewCopyLength - counter] - b;
      if (value < 0) {
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
      } else {
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
        break;
      }
    }
  }
  return firstViewCopy.slice();
}

class LocalIntegerValueBlock3 extends HexBlock3(ValueBlock3) {
  setValueHex() {
    if (this.valueHexView.length >= 4) {
      this.warnings.push("Too big Integer for decoding, hex only");
      this.isHexOnly = true;
      this._valueDec = 0;
    } else {
      this.isHexOnly = false;
      if (this.valueHexView.length > 0) {
        this._valueDec = utilDecodeTC.call(this);
      }
    }
  }
  constructor({ value, ...parameters } = {}) {
    super(parameters);
    this._valueDec = 0;
    if (parameters.valueHex) {
      this.setValueHex();
    }
    if (value !== undefined) {
      this.valueDec = value;
    }
  }
  set valueDec(v) {
    this._valueDec = v;
    this.isHexOnly = false;
    this.valueHexView = new Uint8Array(utilEncodeTC(v));
  }
  get valueDec() {
    return this._valueDec;
  }
  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
    if (offset === -1)
      return offset;
    const view = this.valueHexView;
    if (view[0] === 0 && (view[1] & 128) !== 0) {
      this.valueHexView = view.subarray(1);
    } else {
      if (expectedLength !== 0) {
        if (view.length < expectedLength) {
          if (expectedLength - view.length > 1)
            expectedLength = view.length + 1;
          this.valueHexView = view.subarray(expectedLength - view.length);
        }
      }
    }
    return offset;
  }
  toDER(sizeOnly = false) {
    const view = this.valueHexView;
    switch (true) {
      case (view[0] & 128) !== 0:
        {
          const updatedView = new Uint8Array(this.valueHexView.length + 1);
          updatedView[0] = 0;
          updatedView.set(view, 1);
          this.valueHexView = updatedView;
        }
        break;
      case (view[0] === 0 && (view[1] & 128) === 0):
        {
          this.valueHexView = this.valueHexView.subarray(1);
        }
        break;
    }
    return this.toBER(sizeOnly);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
    if (resultOffset === -1) {
      return resultOffset;
    }
    this.setValueHex();
    return resultOffset;
  }
  toBER(sizeOnly) {
    return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
  toString() {
    const firstBit = this.valueHexView.length * 8 - 1;
    let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
    let bitNumber = 0;
    let currentByte;
    const asn1View = this.valueHexView;
    let result = "";
    let flag = false;
    for (let byteNumber = asn1View.byteLength - 1;byteNumber >= 0; byteNumber--) {
      currentByte = asn1View[byteNumber];
      for (let i = 0;i < 8; i++) {
        if ((currentByte & 1) === 1) {
          switch (bitNumber) {
            case firstBit:
              digits = viewSub3(power23(bitNumber), digits);
              result = "-";
              break;
            default:
              digits = viewAdd3(digits, power23(bitNumber));
          }
        }
        bitNumber++;
        currentByte >>= 1;
      }
    }
    for (let i = 0;i < digits.length; i++) {
      if (digits[i])
        flag = true;
      if (flag)
        result += digitsString3.charAt(digits[i]);
    }
    if (flag === false)
      result += digitsString3.charAt(0);
    return result;
  }
}
_a$p3 = LocalIntegerValueBlock3;
LocalIntegerValueBlock3.NAME = "IntegerValueBlock";
(() => {
  Object.defineProperty(_a$p3.prototype, "valueHex", {
    set: function(v) {
      this.valueHexView = new Uint8Array(v);
      this.setValueHex();
    },
    get: function() {
      return this.valueHexView.slice().buffer;
    }
  });
})();
var _a$o3;

class Integer3 extends BaseBlock3 {
  constructor(parameters = {}) {
    super(parameters, LocalIntegerValueBlock3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 2;
  }
  toBigInt() {
    assertBigInt3();
    return BigInt(this.valueBlock.toString());
  }
  static fromBigInt(value) {
    assertBigInt3();
    const bigIntValue = BigInt(value);
    const writer = new ViewWriter3;
    const hex = bigIntValue.toString(16).replace(/^-/, "");
    const view = new Uint8Array(Convert.FromHex(hex));
    if (bigIntValue < 0) {
      const first = new Uint8Array(view.length + (view[0] & 128 ? 1 : 0));
      first[0] |= 128;
      const firstInt = BigInt(`0x${Convert.ToHex(first)}`);
      const secondInt = firstInt + bigIntValue;
      const second = BufferSourceConverter.toUint8Array(Convert.FromHex(secondInt.toString(16)));
      second[0] |= 128;
      writer.write(second);
    } else {
      if (view[0] & 128) {
        writer.write(new Uint8Array([0]));
      }
      writer.write(view);
    }
    const res = new _a$o3({ valueHex: writer.final() });
    return res;
  }
  convertToDER() {
    const integer = new _a$o3({ valueHex: this.valueBlock.valueHexView });
    integer.valueBlock.toDER();
    return integer;
  }
  convertFromDER() {
    return new _a$o3({
      valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
    });
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
  }
}
_a$o3 = Integer3;
(() => {
  typeStore3.Integer = _a$o3;
})();
Integer3.NAME = "INTEGER";
var _a$n3;

class Enumerated3 extends Integer3 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 10;
  }
}
_a$n3 = Enumerated3;
(() => {
  typeStore3.Enumerated = _a$n3;
})();
Enumerated3.NAME = "ENUMERATED";

class LocalSidValueBlock3 extends HexBlock3(ValueBlock3) {
  constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
    this.isFirstSid = isFirstSid;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams3(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0;i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0;i < this.blockLength; i++) {
      tempView[i] = this.valueHexView[i];
    }
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  set valueBigInt(value) {
    assertBigInt3();
    let bits = BigInt(value).toString(2);
    while (bits.length % 7) {
      bits = "0" + bits;
    }
    const bytes = new Uint8Array(bits.length / 7);
    for (let i = 0;i < bytes.length; i++) {
      bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 128 : 0);
    }
    this.fromBER(bytes.buffer, 0, bytes.length);
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0;i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER3;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0;i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      if (this.isFirstSid) {
        let sidValue = this.valueDec;
        if (this.valueDec <= 39)
          result = "0.";
        else {
          if (this.valueDec <= 79) {
            result = "1.";
            sidValue -= 40;
          } else {
            result = "2.";
            sidValue -= 80;
          }
        }
        result += sidValue.toString();
      } else
        result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec,
      isFirstSid: this.isFirstSid
    };
  }
}
LocalSidValueBlock3.NAME = "sidBlock";

class LocalObjectIdentifierValueBlock3 extends ValueBlock3 {
  constructor({ value = EMPTY_STRING3, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalSidValueBlock3;
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      if (this.value.length === 0)
        sidBlock.isFirstSid = true;
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly) {
    const retBuffers = [];
    for (let i = 0;i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER3;
      }
      retBuffers.push(valueBuf);
    }
    return concat3(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    let flag = false;
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      if (flag) {
        const sidBlock = this.value[0];
        let plus = 0;
        switch (sidBlock.valueDec) {
          case 0:
            break;
          case 1:
            plus = 40;
            break;
          case 2:
            plus = 80;
            break;
          default:
            this.value = [];
            return;
        }
        const parsedSID = parseInt(sid, 10);
        if (isNaN(parsedSID))
          return;
        sidBlock.valueDec = parsedSID + plus;
        flag = false;
      } else {
        const sidBlock = new LocalSidValueBlock3;
        if (sid > Number.MAX_SAFE_INTEGER) {
          assertBigInt3();
          const sidValue = BigInt(sid);
          sidBlock.valueBigInt = sidValue;
        } else {
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec))
            return;
        }
        if (!this.value.length) {
          sidBlock.isFirstSid = true;
          flag = true;
        }
        this.value.push(sidBlock);
      }
    } while (pos2 !== -1);
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0;i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        if (this.value[i].isFirstSid)
          result = `2.{${sidStr} - 80}`;
        else
          result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0;i < this.value.length; i++) {
      object.sidArray.push(this.value[i].toJSON());
    }
    return object;
  }
}
LocalObjectIdentifierValueBlock3.NAME = "ObjectIdentifierValueBlock";
var _a$m3;

class ObjectIdentifier3 extends BaseBlock3 {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  constructor(parameters = {}) {
    super(parameters, LocalObjectIdentifierValueBlock3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 6;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$m3 = ObjectIdentifier3;
(() => {
  typeStore3.ObjectIdentifier = _a$m3;
})();
ObjectIdentifier3.NAME = "OBJECT IDENTIFIER";

class LocalRelativeSidValueBlock3 extends HexBlock3(LocalBaseBlock3) {
  constructor({ valueDec = 0, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (inputLength === 0)
      return inputOffset;
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams3(this, inputView, inputOffset, inputLength))
      return -1;
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0;i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0;i < this.blockLength; i++)
      tempView[i] = this.valueHexView[i];
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0;i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER3;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0;i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView.buffer;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
}
LocalRelativeSidValueBlock3.NAME = "relativeSidBlock";

class LocalRelativeObjectIdentifierValueBlock3 extends ValueBlock3 {
  constructor({ value = EMPTY_STRING3, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalRelativeSidValueBlock3;
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly, _writer) {
    const retBuffers = [];
    for (let i = 0;i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER3;
      }
      retBuffers.push(valueBuf);
    }
    return concat3(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      const sidBlock = new LocalRelativeSidValueBlock3;
      sidBlock.valueDec = parseInt(sid, 10);
      if (isNaN(sidBlock.valueDec))
        return true;
      this.value.push(sidBlock);
    } while (pos2 !== -1);
    return true;
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0;i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0;i < this.value.length; i++)
      object.sidArray.push(this.value[i].toJSON());
    return object;
  }
}
LocalRelativeObjectIdentifierValueBlock3.NAME = "RelativeObjectIdentifierValueBlock";
var _a$l3;

class RelativeObjectIdentifier3 extends BaseBlock3 {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  constructor(parameters = {}) {
    super(parameters, LocalRelativeObjectIdentifierValueBlock3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 13;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$l3 = RelativeObjectIdentifier3;
(() => {
  typeStore3.RelativeObjectIdentifier = _a$l3;
})();
RelativeObjectIdentifier3.NAME = "RelativeObjectIdentifier";
var _a$k3;

class Sequence3 extends Constructed3 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 16;
  }
}
_a$k3 = Sequence3;
(() => {
  typeStore3.Sequence = _a$k3;
})();
Sequence3.NAME = "SEQUENCE";
var _a$j3;

class Set4 extends Constructed3 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 17;
  }
}
_a$j3 = Set4;
(() => {
  typeStore3.Set = _a$j3;
})();
Set4.NAME = "SET";

class LocalStringValueBlock3 extends HexBlock3(ValueBlock3) {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = true;
    this.value = EMPTY_STRING3;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalStringValueBlock3.NAME = "StringValueBlock";

class LocalSimpleStringValueBlock3 extends LocalStringValueBlock3 {
}
LocalSimpleStringValueBlock3.NAME = "SimpleStringValueBlock";

class LocalSimpleStringBlock3 extends BaseStringBlock3 {
  constructor({ ...parameters } = {}) {
    super(parameters, LocalSimpleStringValueBlock3);
  }
  fromBuffer(inputBuffer) {
    this.valueBlock.value = String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer));
  }
  fromString(inputString) {
    const strLen = inputString.length;
    const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
    for (let i = 0;i < strLen; i++)
      view[i] = inputString.charCodeAt(i);
    this.valueBlock.value = inputString;
  }
}
LocalSimpleStringBlock3.NAME = "SIMPLE STRING";

class LocalUtf8StringValueBlock3 extends LocalSimpleStringBlock3 {
  fromBuffer(inputBuffer) {
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
    try {
      this.valueBlock.value = Convert.ToUtf8String(inputBuffer);
    } catch (ex) {
      this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
      this.valueBlock.value = Convert.ToBinary(inputBuffer);
    }
  }
  fromString(inputString) {
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf8String(inputString));
    this.valueBlock.value = inputString;
  }
}
LocalUtf8StringValueBlock3.NAME = "Utf8StringValueBlock";
var _a$i3;

class Utf8String3 extends LocalUtf8StringValueBlock3 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 12;
  }
}
_a$i3 = Utf8String3;
(() => {
  typeStore3.Utf8String = _a$i3;
})();
Utf8String3.NAME = "UTF8String";

class LocalBmpStringValueBlock3 extends LocalSimpleStringBlock3 {
  fromBuffer(inputBuffer) {
    this.valueBlock.value = Convert.ToUtf16String(inputBuffer);
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
  }
  fromString(inputString) {
    this.valueBlock.value = inputString;
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf16String(inputString));
  }
}
LocalBmpStringValueBlock3.NAME = "BmpStringValueBlock";
var _a$h3;

class BmpString3 extends LocalBmpStringValueBlock3 {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 30;
  }
}
_a$h3 = BmpString3;
(() => {
  typeStore3.BmpString = _a$h3;
})();
BmpString3.NAME = "BMPString";

class LocalUniversalStringValueBlock3 extends LocalSimpleStringBlock3 {
  fromBuffer(inputBuffer) {
    const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
    const valueView = new Uint8Array(copyBuffer);
    for (let i = 0;i < valueView.length; i += 4) {
      valueView[i] = valueView[i + 3];
      valueView[i + 1] = valueView[i + 2];
      valueView[i + 2] = 0;
      valueView[i + 3] = 0;
    }
    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
  }
  fromString(inputString) {
    const strLength = inputString.length;
    const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
    for (let i = 0;i < strLength; i++) {
      const codeBuf = utilToBase(inputString.charCodeAt(i), 8);
      const codeView = new Uint8Array(codeBuf);
      if (codeView.length > 4)
        continue;
      const dif = 4 - codeView.length;
      for (let j = codeView.length - 1;j >= 0; j--)
        valueHexView[i * 4 + j + dif] = codeView[j];
    }
    this.valueBlock.value = inputString;
  }
}
LocalUniversalStringValueBlock3.NAME = "UniversalStringValueBlock";
var _a$g3;

class UniversalString3 extends LocalUniversalStringValueBlock3 {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 28;
  }
}
_a$g3 = UniversalString3;
(() => {
  typeStore3.UniversalString = _a$g3;
})();
UniversalString3.NAME = "UniversalString";
var _a$f3;

class NumericString3 extends LocalSimpleStringBlock3 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 18;
  }
}
_a$f3 = NumericString3;
(() => {
  typeStore3.NumericString = _a$f3;
})();
NumericString3.NAME = "NumericString";
var _a$e3;

class PrintableString3 extends LocalSimpleStringBlock3 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 19;
  }
}
_a$e3 = PrintableString3;
(() => {
  typeStore3.PrintableString = _a$e3;
})();
PrintableString3.NAME = "PrintableString";
var _a$d3;

class TeletexString3 extends LocalSimpleStringBlock3 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 20;
  }
}
_a$d3 = TeletexString3;
(() => {
  typeStore3.TeletexString = _a$d3;
})();
TeletexString3.NAME = "TeletexString";
var _a$c3;

class VideotexString3 extends LocalSimpleStringBlock3 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 21;
  }
}
_a$c3 = VideotexString3;
(() => {
  typeStore3.VideotexString = _a$c3;
})();
VideotexString3.NAME = "VideotexString";
var _a$b3;

class IA5String3 extends LocalSimpleStringBlock3 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 22;
  }
}
_a$b3 = IA5String3;
(() => {
  typeStore3.IA5String = _a$b3;
})();
IA5String3.NAME = "IA5String";
var _a$a3;

class GraphicString3 extends LocalSimpleStringBlock3 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 25;
  }
}
_a$a3 = GraphicString3;
(() => {
  typeStore3.GraphicString = _a$a3;
})();
GraphicString3.NAME = "GraphicString";
var _a$93;

class VisibleString3 extends LocalSimpleStringBlock3 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 26;
  }
}
_a$93 = VisibleString3;
(() => {
  typeStore3.VisibleString = _a$93;
})();
VisibleString3.NAME = "VisibleString";
var _a$83;

class GeneralString3 extends LocalSimpleStringBlock3 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 27;
  }
}
_a$83 = GeneralString3;
(() => {
  typeStore3.GeneralString = _a$83;
})();
GeneralString3.NAME = "GeneralString";
var _a$73;

class CharacterString3 extends LocalSimpleStringBlock3 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 29;
  }
}
_a$73 = CharacterString3;
(() => {
  typeStore3.CharacterString = _a$73;
})();
CharacterString3.NAME = "CharacterString";
var _a$63;

class UTCTime3 extends VisibleString3 {
  constructor({ value, valueDate, ...parameters } = {}) {
    super(parameters);
    this.year = 0;
    this.month = 0;
    this.day = 0;
    this.hour = 0;
    this.minute = 0;
    this.second = 0;
    if (value) {
      this.fromString(value);
      this.valueBlock.valueHexView = new Uint8Array(value.length);
      for (let i = 0;i < value.length; i++)
        this.valueBlock.valueHexView[i] = value.charCodeAt(i);
    }
    if (valueDate) {
      this.fromDate(valueDate);
      this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
    }
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 23;
  }
  fromBuffer(inputBuffer) {
    this.fromString(String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer)));
  }
  toBuffer() {
    const str = this.toString();
    const buffer = new ArrayBuffer(str.length);
    const view = new Uint8Array(buffer);
    for (let i = 0;i < str.length; i++)
      view[i] = str.charCodeAt(i);
    return buffer;
  }
  fromDate(inputDate) {
    this.year = inputDate.getUTCFullYear();
    this.month = inputDate.getUTCMonth() + 1;
    this.day = inputDate.getUTCDate();
    this.hour = inputDate.getUTCHours();
    this.minute = inputDate.getUTCMinutes();
    this.second = inputDate.getUTCSeconds();
  }
  toDate() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
  }
  fromString(inputString) {
    const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
    const parserArray = parser.exec(inputString);
    if (parserArray === null) {
      this.error = "Wrong input string for conversion";
      return;
    }
    const year = parseInt(parserArray[1], 10);
    if (year >= 50)
      this.year = 1900 + year;
    else
      this.year = 2000 + year;
    this.month = parseInt(parserArray[2], 10);
    this.day = parseInt(parserArray[3], 10);
    this.hour = parseInt(parserArray[4], 10);
    this.minute = parseInt(parserArray[5], 10);
    this.second = parseInt(parserArray[6], 10);
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = new Array(7);
      outputArray[0] = padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);
      outputArray[1] = padNumber(this.month, 2);
      outputArray[2] = padNumber(this.day, 2);
      outputArray[3] = padNumber(this.hour, 2);
      outputArray[4] = padNumber(this.minute, 2);
      outputArray[5] = padNumber(this.second, 2);
      outputArray[6] = "Z";
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second
    };
  }
}
_a$63 = UTCTime3;
(() => {
  typeStore3.UTCTime = _a$63;
})();
UTCTime3.NAME = "UTCTime";
var _a$53;

class GeneralizedTime3 extends UTCTime3 {
  constructor(parameters = {}) {
    var _b;
    super(parameters);
    (_b = this.millisecond) !== null && _b !== undefined || (this.millisecond = 0);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 24;
  }
  fromDate(inputDate) {
    super.fromDate(inputDate);
    this.millisecond = inputDate.getUTCMilliseconds();
  }
  toDate() {
    const utcDate = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond);
    return new Date(utcDate);
  }
  fromString(inputString) {
    let isUTC = false;
    let timeString = "";
    let dateTimeString = "";
    let fractionPart = 0;
    let parser;
    let hourDifference = 0;
    let minuteDifference = 0;
    if (inputString[inputString.length - 1] === "Z") {
      timeString = inputString.substring(0, inputString.length - 1);
      isUTC = true;
    } else {
      const number = new Number(inputString[inputString.length - 1]);
      if (isNaN(number.valueOf()))
        throw new Error("Wrong input string for conversion");
      timeString = inputString;
    }
    if (isUTC) {
      if (timeString.indexOf("+") !== -1)
        throw new Error("Wrong input string for conversion");
      if (timeString.indexOf("-") !== -1)
        throw new Error("Wrong input string for conversion");
    } else {
      let multiplier = 1;
      let differencePosition = timeString.indexOf("+");
      let differenceString = "";
      if (differencePosition === -1) {
        differencePosition = timeString.indexOf("-");
        multiplier = -1;
      }
      if (differencePosition !== -1) {
        differenceString = timeString.substring(differencePosition + 1);
        timeString = timeString.substring(0, differencePosition);
        if (differenceString.length !== 2 && differenceString.length !== 4)
          throw new Error("Wrong input string for conversion");
        let number = parseInt(differenceString.substring(0, 2), 10);
        if (isNaN(number.valueOf()))
          throw new Error("Wrong input string for conversion");
        hourDifference = multiplier * number;
        if (differenceString.length === 4) {
          number = parseInt(differenceString.substring(2, 4), 10);
          if (isNaN(number.valueOf()))
            throw new Error("Wrong input string for conversion");
          minuteDifference = multiplier * number;
        }
      }
    }
    let fractionPointPosition = timeString.indexOf(".");
    if (fractionPointPosition === -1)
      fractionPointPosition = timeString.indexOf(",");
    if (fractionPointPosition !== -1) {
      const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
      if (isNaN(fractionPartCheck.valueOf()))
        throw new Error("Wrong input string for conversion");
      fractionPart = fractionPartCheck.valueOf();
      dateTimeString = timeString.substring(0, fractionPointPosition);
    } else
      dateTimeString = timeString;
    switch (true) {
      case dateTimeString.length === 8:
        parser = /(\d{4})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1)
          throw new Error("Wrong input string for conversion");
        break;
      case dateTimeString.length === 10:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.minute = Math.floor(fractionResult);
          fractionResult = 60 * (fractionResult - this.minute);
          this.second = Math.floor(fractionResult);
          fractionResult = 1000 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 12:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.second = Math.floor(fractionResult);
          fractionResult = 1000 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 14:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          const fractionResult = 1000 * fractionPart;
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      default:
        throw new Error("Wrong input string for conversion");
    }
    const parserArray = parser.exec(dateTimeString);
    if (parserArray === null)
      throw new Error("Wrong input string for conversion");
    for (let j = 1;j < parserArray.length; j++) {
      switch (j) {
        case 1:
          this.year = parseInt(parserArray[j], 10);
          break;
        case 2:
          this.month = parseInt(parserArray[j], 10);
          break;
        case 3:
          this.day = parseInt(parserArray[j], 10);
          break;
        case 4:
          this.hour = parseInt(parserArray[j], 10) + hourDifference;
          break;
        case 5:
          this.minute = parseInt(parserArray[j], 10) + minuteDifference;
          break;
        case 6:
          this.second = parseInt(parserArray[j], 10);
          break;
        default:
          throw new Error("Wrong input string for conversion");
      }
    }
    if (isUTC === false) {
      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
      this.year = tempDate.getUTCFullYear();
      this.month = tempDate.getUTCMonth();
      this.day = tempDate.getUTCDay();
      this.hour = tempDate.getUTCHours();
      this.minute = tempDate.getUTCMinutes();
      this.second = tempDate.getUTCSeconds();
      this.millisecond = tempDate.getUTCMilliseconds();
    }
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = [];
      outputArray.push(padNumber(this.year, 4));
      outputArray.push(padNumber(this.month, 2));
      outputArray.push(padNumber(this.day, 2));
      outputArray.push(padNumber(this.hour, 2));
      outputArray.push(padNumber(this.minute, 2));
      outputArray.push(padNumber(this.second, 2));
      if (this.millisecond !== 0) {
        outputArray.push(".");
        outputArray.push(padNumber(this.millisecond, 3));
      }
      outputArray.push("Z");
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  toJSON() {
    return {
      ...super.toJSON(),
      millisecond: this.millisecond
    };
  }
}
_a$53 = GeneralizedTime3;
(() => {
  typeStore3.GeneralizedTime = _a$53;
})();
GeneralizedTime3.NAME = "GeneralizedTime";
var _a$43;

class DATE3 extends Utf8String3 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 31;
  }
}
_a$43 = DATE3;
(() => {
  typeStore3.DATE = _a$43;
})();
DATE3.NAME = "DATE";
var _a$33;

class TimeOfDay3 extends Utf8String3 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 32;
  }
}
_a$33 = TimeOfDay3;
(() => {
  typeStore3.TimeOfDay = _a$33;
})();
TimeOfDay3.NAME = "TimeOfDay";
var _a$23;

class DateTime3 extends Utf8String3 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 33;
  }
}
_a$23 = DateTime3;
(() => {
  typeStore3.DateTime = _a$23;
})();
DateTime3.NAME = "DateTime";
var _a$13;

class Duration3 extends Utf8String3 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 34;
  }
}
_a$13 = Duration3;
(() => {
  typeStore3.Duration = _a$13;
})();
Duration3.NAME = "Duration";
var _a3;

class TIME3 extends Utf8String3 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 14;
  }
}
_a3 = TIME3;
(() => {
  typeStore3.TIME = _a3;
})();
TIME3.NAME = "TIME";

class Any3 {
  constructor({ name: name3 = EMPTY_STRING3, optional = false } = {}) {
    this.name = name3;
    this.optional = optional;
  }
}

class Choice3 extends Any3 {
  constructor({ value = [], ...parameters } = {}) {
    super(parameters);
    this.value = value;
  }
}

class Repeated3 extends Any3 {
  constructor({ value = new Any3, local = false, ...parameters } = {}) {
    super(parameters);
    this.value = value;
    this.local = local;
  }
}

class RawData3 {
  get data() {
    return this.dataView.slice().buffer;
  }
  set data(value) {
    this.dataView = BufferSourceConverter.toUint8Array(value);
  }
  constructor({ data = EMPTY_VIEW3 } = {}) {
    this.dataView = BufferSourceConverter.toUint8Array(data);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const endLength = inputOffset + inputLength;
    this.dataView = BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
    return endLength;
  }
  toBER(_sizeOnly) {
    return this.dataView.slice().buffer;
  }
}
function compareSchema3(root, inputData, inputSchema) {
  if (inputSchema instanceof Choice3) {
    for (const element of inputSchema.value) {
      const result = compareSchema3(root, inputData, element);
      if (result.verified) {
        return {
          verified: true,
          result: root
        };
      }
    }
    {
      const _result = {
        verified: false,
        result: { error: "Wrong values for Choice type" }
      };
      if (inputSchema.hasOwnProperty(NAME3))
        _result.name = inputSchema.name;
      return _result;
    }
  }
  if (inputSchema instanceof Any3) {
    if (inputSchema.hasOwnProperty(NAME3))
      root[inputSchema.name] = inputData;
    return {
      verified: true,
      result: root
    };
  }
  if (root instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong root object" }
    };
  }
  if (inputData instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 data" }
    };
  }
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (ID_BLOCK3 in inputSchema === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (FROM_BER3 in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (TO_BER3 in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  const encodedId = inputSchema.idBlock.toBER(false);
  if (encodedId.byteLength === 0) {
    return {
      verified: false,
      result: { error: "Error encoding idBlock for ASN.1 schema" }
    };
  }
  const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
  if (decodedOffset === -1) {
    return {
      verified: false,
      result: { error: "Error decoding idBlock for ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS3) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER3) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED3) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
    return {
      verified: false,
      result: root
    };
  }
  if (!(IS_HEX_ONLY3 in inputSchema.idBlock)) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.isHexOnly) {
    if (VALUE_HEX_VIEW3 in inputSchema.idBlock === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    const schemaView = inputSchema.idBlock.valueHexView;
    const asn1View = inputData.idBlock.valueHexView;
    if (schemaView.length !== asn1View.length) {
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0;i < schemaView.length; i++) {
      if (schemaView[i] !== asn1View[1]) {
        return {
          verified: false,
          result: root
        };
      }
    }
  }
  if (inputSchema.name) {
    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING3);
    if (inputSchema.name)
      root[inputSchema.name] = inputData;
  }
  if (inputSchema instanceof typeStore3.Constructed) {
    let admission = 0;
    let result = {
      verified: false,
      result: { error: "Unknown error" }
    };
    let maxLength = inputSchema.valueBlock.value.length;
    if (maxLength > 0) {
      if (inputSchema.valueBlock.value[0] instanceof Repeated3) {
        maxLength = inputData.valueBlock.value.length;
      }
    }
    if (maxLength === 0) {
      return {
        verified: true,
        result: root
      };
    }
    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
      let _optional = true;
      for (let i = 0;i < inputSchema.valueBlock.value.length; i++)
        _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);
      if (_optional) {
        return {
          verified: true,
          result: root
        };
      }
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING3);
        if (inputSchema.name)
          delete root[inputSchema.name];
      }
      root.error = "Inconsistent object length";
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0;i < maxLength; i++) {
      if (i - admission >= inputData.valueBlock.value.length) {
        if (inputSchema.valueBlock.value[i].optional === false) {
          const _result = {
            verified: false,
            result: root
          };
          root.error = "Inconsistent length between ASN.1 data and schema";
          if (inputSchema.name) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING3);
            if (inputSchema.name) {
              delete root[inputSchema.name];
              _result.name = inputSchema.name;
            }
          }
          return _result;
        }
      } else {
        if (inputSchema.valueBlock.value[0] instanceof Repeated3) {
          result = compareSchema3(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[0].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING3);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
          if (NAME3 in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
            let arrayRoot = {};
            if (LOCAL3 in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local)
              arrayRoot = inputData;
            else
              arrayRoot = root;
            if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
              arrayRoot[inputSchema.valueBlock.value[0].name] = [];
            arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
          }
        } else {
          result = compareSchema3(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[i].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING3);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
        }
      }
    }
    if (result.verified === false) {
      const _result = {
        verified: false,
        result: root
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING3);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return {
      verified: true,
      result: root
    };
  }
  if (inputSchema.primitiveSchema && VALUE_HEX_VIEW3 in inputData.valueBlock) {
    const asn1 = localFromBER3(inputData.valueBlock.valueHexView);
    if (asn1.offset === -1) {
      const _result = {
        verified: false,
        result: asn1.result
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING3);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return compareSchema3(root, asn1.result, inputSchema.primitiveSchema);
  }
  return {
    verified: true,
    result: root
  };
}
function verifySchema3(inputBuffer, inputSchema) {
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema type" }
    };
  }
  const asn1 = localFromBER3(BufferSourceConverter.toUint8Array(inputBuffer));
  if (asn1.offset === -1) {
    return {
      verified: false,
      result: asn1.result
    };
  }
  return compareSchema3(asn1.result, asn1.result, inputSchema);
}

// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-schema/build/es2015/enums.js
var AsnTypeTypes3;
(function(AsnTypeTypes4) {
  AsnTypeTypes4[AsnTypeTypes4["Sequence"] = 0] = "Sequence";
  AsnTypeTypes4[AsnTypeTypes4["Set"] = 1] = "Set";
  AsnTypeTypes4[AsnTypeTypes4["Choice"] = 2] = "Choice";
})(AsnTypeTypes3 || (AsnTypeTypes3 = {}));
var AsnPropTypes3;
(function(AsnPropTypes4) {
  AsnPropTypes4[AsnPropTypes4["Any"] = 1] = "Any";
  AsnPropTypes4[AsnPropTypes4["Boolean"] = 2] = "Boolean";
  AsnPropTypes4[AsnPropTypes4["OctetString"] = 3] = "OctetString";
  AsnPropTypes4[AsnPropTypes4["BitString"] = 4] = "BitString";
  AsnPropTypes4[AsnPropTypes4["Integer"] = 5] = "Integer";
  AsnPropTypes4[AsnPropTypes4["Enumerated"] = 6] = "Enumerated";
  AsnPropTypes4[AsnPropTypes4["ObjectIdentifier"] = 7] = "ObjectIdentifier";
  AsnPropTypes4[AsnPropTypes4["Utf8String"] = 8] = "Utf8String";
  AsnPropTypes4[AsnPropTypes4["BmpString"] = 9] = "BmpString";
  AsnPropTypes4[AsnPropTypes4["UniversalString"] = 10] = "UniversalString";
  AsnPropTypes4[AsnPropTypes4["NumericString"] = 11] = "NumericString";
  AsnPropTypes4[AsnPropTypes4["PrintableString"] = 12] = "PrintableString";
  AsnPropTypes4[AsnPropTypes4["TeletexString"] = 13] = "TeletexString";
  AsnPropTypes4[AsnPropTypes4["VideotexString"] = 14] = "VideotexString";
  AsnPropTypes4[AsnPropTypes4["IA5String"] = 15] = "IA5String";
  AsnPropTypes4[AsnPropTypes4["GraphicString"] = 16] = "GraphicString";
  AsnPropTypes4[AsnPropTypes4["VisibleString"] = 17] = "VisibleString";
  AsnPropTypes4[AsnPropTypes4["GeneralString"] = 18] = "GeneralString";
  AsnPropTypes4[AsnPropTypes4["CharacterString"] = 19] = "CharacterString";
  AsnPropTypes4[AsnPropTypes4["UTCTime"] = 20] = "UTCTime";
  AsnPropTypes4[AsnPropTypes4["GeneralizedTime"] = 21] = "GeneralizedTime";
  AsnPropTypes4[AsnPropTypes4["DATE"] = 22] = "DATE";
  AsnPropTypes4[AsnPropTypes4["TimeOfDay"] = 23] = "TimeOfDay";
  AsnPropTypes4[AsnPropTypes4["DateTime"] = 24] = "DateTime";
  AsnPropTypes4[AsnPropTypes4["Duration"] = 25] = "Duration";
  AsnPropTypes4[AsnPropTypes4["TIME"] = 26] = "TIME";
  AsnPropTypes4[AsnPropTypes4["Null"] = 27] = "Null";
})(AsnPropTypes3 || (AsnPropTypes3 = {}));

// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-schema/build/es2015/types/bit_string.js
class BitString6 {
  constructor(params, unusedBits = 0) {
    this.unusedBits = 0;
    this.value = new ArrayBuffer(0);
    if (params) {
      if (typeof params === "number") {
        this.fromNumber(params);
      } else if (BufferSourceConverter.isBufferSource(params)) {
        this.unusedBits = unusedBits;
        this.value = BufferSourceConverter.toArrayBuffer(params);
      } else {
        throw TypeError("Unsupported type of 'params' argument for BitString");
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof BitString5)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 BitString");
    }
    this.unusedBits = asn.valueBlock.unusedBits;
    this.value = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new BitString5({ unusedBits: this.unusedBits, valueHex: this.value });
  }
  toSchema(name3) {
    return new BitString5({ name: name3 });
  }
  toNumber() {
    let res = "";
    const uintArray = new Uint8Array(this.value);
    for (const octet of uintArray) {
      res += octet.toString(2).padStart(8, "0");
    }
    res = res.split("").reverse().join("");
    if (this.unusedBits) {
      res = res.slice(this.unusedBits).padStart(this.unusedBits, "0");
    }
    return parseInt(res, 2);
  }
  fromNumber(value) {
    let bits = value.toString(2);
    const octetSize = bits.length + 7 >> 3;
    this.unusedBits = (octetSize << 3) - bits.length;
    const octets = new Uint8Array(octetSize);
    bits = bits.padStart(octetSize << 3, "0").split("").reverse().join("");
    let index = 0;
    while (index < octetSize) {
      octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);
      index++;
    }
    this.value = octets.buffer;
  }
}
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-schema/build/es2015/types/octet_string.js
class OctetString6 {
  get byteLength() {
    return this.buffer.byteLength;
  }
  get byteOffset() {
    return 0;
  }
  constructor(param) {
    if (typeof param === "number") {
      this.buffer = new ArrayBuffer(param);
    } else {
      if (BufferSourceConverter.isBufferSource(param)) {
        this.buffer = BufferSourceConverter.toArrayBuffer(param);
      } else if (Array.isArray(param)) {
        this.buffer = new Uint8Array(param);
      } else {
        this.buffer = new ArrayBuffer(0);
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof OctetString5)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString");
    }
    this.buffer = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new OctetString5({ valueHex: this.buffer });
  }
  toSchema(name3) {
    return new OctetString5({ name: name3 });
  }
}
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-schema/build/es2015/converters.js
var AsnAnyConverter3 = {
  fromASN: (value) => value instanceof Null3 ? null : value.valueBeforeDecodeView,
  toASN: (value) => {
    if (value === null) {
      return new Null3;
    }
    const schema = fromBER3(value);
    if (schema.result.error) {
      throw new Error(schema.result.error);
    }
    return schema.result;
  }
};
var AsnIntegerConverter3 = {
  fromASN: (value) => value.valueBlock.valueHexView.byteLength >= 4 ? value.valueBlock.toString() : value.valueBlock.valueDec,
  toASN: (value) => new Integer3({ value: +value })
};
var AsnEnumeratedConverter3 = {
  fromASN: (value) => value.valueBlock.valueDec,
  toASN: (value) => new Enumerated3({ value })
};
var AsnIntegerArrayBufferConverter3 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new Integer3({ valueHex: value })
};
var AsnBitStringConverter3 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new BitString5({ valueHex: value })
};
var AsnObjectIdentifierConverter3 = {
  fromASN: (value) => value.valueBlock.toString(),
  toASN: (value) => new ObjectIdentifier3({ value })
};
var AsnBooleanConverter3 = {
  fromASN: (value) => value.valueBlock.value,
  toASN: (value) => new Boolean4({ value })
};
var AsnOctetStringConverter3 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new OctetString5({ valueHex: value })
};
var AsnConstructedOctetStringConverter = {
  fromASN: (value) => new OctetString6(value.getValue()),
  toASN: (value) => value.toASN()
};
function createStringConverter3(Asn1Type) {
  return {
    fromASN: (value) => value.valueBlock.value,
    toASN: (value) => new Asn1Type({ value })
  };
}
var AsnUtf8StringConverter3 = createStringConverter3(Utf8String3);
var AsnBmpStringConverter3 = createStringConverter3(BmpString3);
var AsnUniversalStringConverter3 = createStringConverter3(UniversalString3);
var AsnNumericStringConverter3 = createStringConverter3(NumericString3);
var AsnPrintableStringConverter3 = createStringConverter3(PrintableString3);
var AsnTeletexStringConverter3 = createStringConverter3(TeletexString3);
var AsnVideotexStringConverter3 = createStringConverter3(VideotexString3);
var AsnIA5StringConverter3 = createStringConverter3(IA5String3);
var AsnGraphicStringConverter3 = createStringConverter3(GraphicString3);
var AsnVisibleStringConverter3 = createStringConverter3(VisibleString3);
var AsnGeneralStringConverter3 = createStringConverter3(GeneralString3);
var AsnCharacterStringConverter3 = createStringConverter3(CharacterString3);
var AsnUTCTimeConverter3 = {
  fromASN: (value) => value.toDate(),
  toASN: (value) => new UTCTime3({ valueDate: value })
};
var AsnGeneralizedTimeConverter3 = {
  fromASN: (value) => value.toDate(),
  toASN: (value) => new GeneralizedTime3({ valueDate: value })
};
var AsnNullConverter3 = {
  fromASN: () => null,
  toASN: () => {
    return new Null3;
  }
};
function defaultConverter3(type) {
  switch (type) {
    case AsnPropTypes3.Any:
      return AsnAnyConverter3;
    case AsnPropTypes3.BitString:
      return AsnBitStringConverter3;
    case AsnPropTypes3.BmpString:
      return AsnBmpStringConverter3;
    case AsnPropTypes3.Boolean:
      return AsnBooleanConverter3;
    case AsnPropTypes3.CharacterString:
      return AsnCharacterStringConverter3;
    case AsnPropTypes3.Enumerated:
      return AsnEnumeratedConverter3;
    case AsnPropTypes3.GeneralString:
      return AsnGeneralStringConverter3;
    case AsnPropTypes3.GeneralizedTime:
      return AsnGeneralizedTimeConverter3;
    case AsnPropTypes3.GraphicString:
      return AsnGraphicStringConverter3;
    case AsnPropTypes3.IA5String:
      return AsnIA5StringConverter3;
    case AsnPropTypes3.Integer:
      return AsnIntegerConverter3;
    case AsnPropTypes3.Null:
      return AsnNullConverter3;
    case AsnPropTypes3.NumericString:
      return AsnNumericStringConverter3;
    case AsnPropTypes3.ObjectIdentifier:
      return AsnObjectIdentifierConverter3;
    case AsnPropTypes3.OctetString:
      return AsnOctetStringConverter3;
    case AsnPropTypes3.PrintableString:
      return AsnPrintableStringConverter3;
    case AsnPropTypes3.TeletexString:
      return AsnTeletexStringConverter3;
    case AsnPropTypes3.UTCTime:
      return AsnUTCTimeConverter3;
    case AsnPropTypes3.UniversalString:
      return AsnUniversalStringConverter3;
    case AsnPropTypes3.Utf8String:
      return AsnUtf8StringConverter3;
    case AsnPropTypes3.VideotexString:
      return AsnVideotexStringConverter3;
    case AsnPropTypes3.VisibleString:
      return AsnVisibleStringConverter3;
    default:
      return null;
  }
}
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-schema/build/es2015/helper.js
function isConvertible3(target) {
  if (typeof target === "function" && target.prototype) {
    if (target.prototype.toASN && target.prototype.fromASN) {
      return true;
    } else {
      return isConvertible3(target.prototype);
    }
  } else {
    return !!(target && typeof target === "object" && ("toASN" in target) && ("fromASN" in target));
  }
}

// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-schema/build/es2015/schema.js
class AsnSchemaStorage3 {
  constructor() {
    this.items = new WeakMap;
  }
  has(target) {
    return this.items.has(target);
  }
  get(target, checkSchema = false) {
    const schema = this.items.get(target);
    if (!schema) {
      throw new Error(`Cannot get schema for '${target.prototype.constructor.name}' target`);
    }
    if (checkSchema && !schema.schema) {
      throw new Error(`Schema '${target.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);
    }
    return schema;
  }
  cache(target) {
    const schema = this.get(target);
    if (!schema.schema) {
      schema.schema = this.create(target, true);
    }
  }
  createDefault(target) {
    const schema = { type: AsnTypeTypes3.Sequence, items: {} };
    const parentSchema = this.findParentSchema(target);
    if (parentSchema) {
      Object.assign(schema, parentSchema);
      schema.items = Object.assign({}, schema.items, parentSchema.items);
    }
    return schema;
  }
  create(target, useNames) {
    const schema = this.items.get(target) || this.createDefault(target);
    const asn1Value = [];
    for (const key in schema.items) {
      const item = schema.items[key];
      const name3 = useNames ? key : "";
      let asn1Item;
      if (typeof item.type === "number") {
        const Asn1TypeName = AsnPropTypes3[item.type];
        const Asn1Type = exports_index_es4[Asn1TypeName];
        if (!Asn1Type) {
          throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
        }
        asn1Item = new Asn1Type({ name: name3 });
      } else if (isConvertible3(item.type)) {
        const instance = new item.type;
        asn1Item = instance.toSchema(name3);
      } else if (item.optional) {
        const itemSchema = this.get(item.type);
        if (itemSchema.type === AsnTypeTypes3.Choice) {
          asn1Item = new Any3({ name: name3 });
        } else {
          asn1Item = this.create(item.type, false);
          asn1Item.name = name3;
        }
      } else {
        asn1Item = new Any3({ name: name3 });
      }
      const optional = !!item.optional || item.defaultValue !== undefined;
      if (item.repeated) {
        asn1Item.name = "";
        const Container = item.repeated === "set" ? Set4 : Sequence3;
        asn1Item = new Container({
          name: "",
          value: [new Repeated3({ name: name3, value: asn1Item })]
        });
      }
      if (item.context !== null && item.context !== undefined) {
        if (item.implicit) {
          if (typeof item.type === "number" || isConvertible3(item.type)) {
            const Container = item.repeated ? Constructed3 : Primitive3;
            asn1Value.push(new Container({ name: name3, optional, idBlock: { tagClass: 3, tagNumber: item.context } }));
          } else {
            this.cache(item.type);
            const isRepeated = !!item.repeated;
            let value = !isRepeated ? this.get(item.type, true).schema : asn1Item;
            value = "valueBlock" in value ? value.valueBlock.value : value.value;
            asn1Value.push(new Constructed3({
              name: !isRepeated ? name3 : "",
              optional,
              idBlock: { tagClass: 3, tagNumber: item.context },
              value
            }));
          }
        } else {
          asn1Value.push(new Constructed3({
            optional,
            idBlock: { tagClass: 3, tagNumber: item.context },
            value: [asn1Item]
          }));
        }
      } else {
        asn1Item.optional = optional;
        asn1Value.push(asn1Item);
      }
    }
    switch (schema.type) {
      case AsnTypeTypes3.Sequence:
        return new Sequence3({ value: asn1Value, name: "" });
      case AsnTypeTypes3.Set:
        return new Set4({ value: asn1Value, name: "" });
      case AsnTypeTypes3.Choice:
        return new Choice3({ value: asn1Value, name: "" });
      default:
        throw new Error(`Unsupported ASN1 type in use`);
    }
  }
  set(target, schema) {
    this.items.set(target, schema);
    return this;
  }
  findParentSchema(target) {
    const parent = Object.getPrototypeOf(target);
    if (parent) {
      const schema = this.items.get(parent);
      return schema || this.findParentSchema(parent);
    }
    return null;
  }
}

// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-schema/build/es2015/storage.js
var schemaStorage3 = new AsnSchemaStorage3;

// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-schema/build/es2015/decorators.js
var AsnType3 = (options) => (target) => {
  let schema;
  if (!schemaStorage3.has(target)) {
    schema = schemaStorage3.createDefault(target);
    schemaStorage3.set(target, schema);
  } else {
    schema = schemaStorage3.get(target);
  }
  Object.assign(schema, options);
};
var AsnProp3 = (options) => (target, propertyKey) => {
  let schema;
  if (!schemaStorage3.has(target.constructor)) {
    schema = schemaStorage3.createDefault(target.constructor);
    schemaStorage3.set(target.constructor, schema);
  } else {
    schema = schemaStorage3.get(target.constructor);
  }
  const copyOptions = Object.assign({}, options);
  if (typeof copyOptions.type === "number" && !copyOptions.converter) {
    const defaultConverter4 = defaultConverter3(options.type);
    if (!defaultConverter4) {
      throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target.constructor.name}`);
    }
    copyOptions.converter = defaultConverter4;
  }
  copyOptions.raw = options.raw;
  schema.items[propertyKey] = copyOptions;
};
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-schema/build/es2015/objects.js
class AsnArray3 extends Array {
  constructor(items = []) {
    if (typeof items === "number") {
      super(items);
    } else {
      super();
      for (const item of items) {
        this.push(item);
      }
    }
  }
}
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/ip_converter.js
class IpConverter3 {
  static isIPv4(ip2) {
    return /^(\d{1,3}\.){3}\d{1,3}$/.test(ip2);
  }
  static parseIPv4(ip2) {
    const parts = ip2.split(".");
    if (parts.length !== 4) {
      throw new Error("Invalid IPv4 address");
    }
    return parts.map((part) => {
      const num = parseInt(part, 10);
      if (isNaN(num) || num < 0 || num > 255) {
        throw new Error("Invalid IPv4 address part");
      }
      return num;
    });
  }
  static parseIPv6(ip2) {
    const expandedIP = this.expandIPv6(ip2);
    const parts = expandedIP.split(":");
    if (parts.length !== 8) {
      throw new Error("Invalid IPv6 address");
    }
    return parts.reduce((bytes, part) => {
      const num = parseInt(part, 16);
      if (isNaN(num) || num < 0 || num > 65535) {
        throw new Error("Invalid IPv6 address part");
      }
      bytes.push(num >> 8 & 255);
      bytes.push(num & 255);
      return bytes;
    }, []);
  }
  static expandIPv6(ip2) {
    if (!ip2.includes("::")) {
      return ip2;
    }
    const parts = ip2.split("::");
    if (parts.length > 2) {
      throw new Error("Invalid IPv6 address");
    }
    const left = parts[0] ? parts[0].split(":") : [];
    const right = parts[1] ? parts[1].split(":") : [];
    const missing = 8 - (left.length + right.length);
    if (missing < 0) {
      throw new Error("Invalid IPv6 address");
    }
    return [...left, ...Array(missing).fill("0"), ...right].join(":");
  }
  static formatIPv6(bytes) {
    const parts = [];
    for (let i = 0;i < 16; i += 2) {
      parts.push((bytes[i] << 8 | bytes[i + 1]).toString(16));
    }
    return this.compressIPv6(parts.join(":"));
  }
  static compressIPv6(ip2) {
    const parts = ip2.split(":");
    let longestZeroStart = -1;
    let longestZeroLength = 0;
    let currentZeroStart = -1;
    let currentZeroLength = 0;
    for (let i = 0;i < parts.length; i++) {
      if (parts[i] === "0") {
        if (currentZeroStart === -1) {
          currentZeroStart = i;
        }
        currentZeroLength++;
      } else {
        if (currentZeroLength > longestZeroLength) {
          longestZeroStart = currentZeroStart;
          longestZeroLength = currentZeroLength;
        }
        currentZeroStart = -1;
        currentZeroLength = 0;
      }
    }
    if (currentZeroLength > longestZeroLength) {
      longestZeroStart = currentZeroStart;
      longestZeroLength = currentZeroLength;
    }
    if (longestZeroLength > 1) {
      const before = parts.slice(0, longestZeroStart).join(":");
      const after = parts.slice(longestZeroStart + longestZeroLength).join(":");
      return `${before}::${after}`;
    }
    return ip2;
  }
  static parseCIDR(text) {
    const [addr, prefixStr] = text.split("/");
    const prefix = parseInt(prefixStr, 10);
    if (this.isIPv4(addr)) {
      if (prefix < 0 || prefix > 32) {
        throw new Error("Invalid IPv4 prefix length");
      }
      return [this.parseIPv4(addr), prefix];
    } else {
      if (prefix < 0 || prefix > 128) {
        throw new Error("Invalid IPv6 prefix length");
      }
      return [this.parseIPv6(addr), prefix];
    }
  }
  static decodeIP(value) {
    if (value.length === 64 && parseInt(value, 16) === 0) {
      return "::/0";
    }
    if (value.length !== 16) {
      return value;
    }
    const mask = parseInt(value.slice(8), 16).toString(2).split("").reduce((a, k) => a + +k, 0);
    let ip2 = value.slice(0, 8).replace(/(.{2})/g, (match2) => `${parseInt(match2, 16)}.`);
    ip2 = ip2.slice(0, -1);
    return `${ip2}/${mask}`;
  }
  static toString(buf) {
    const uint8 = new Uint8Array(buf);
    if (uint8.length === 4) {
      return Array.from(uint8).join(".");
    }
    if (uint8.length === 16) {
      return this.formatIPv6(uint8);
    }
    if (uint8.length === 8 || uint8.length === 32) {
      const half = uint8.length / 2;
      const addrBytes = uint8.slice(0, half);
      const maskBytes = uint8.slice(half);
      const isAllZeros = uint8.every((byte) => byte === 0);
      if (isAllZeros) {
        return uint8.length === 8 ? "0.0.0.0/0" : "::/0";
      }
      const prefixLen = maskBytes.reduce((a, b) => a + (b.toString(2).match(/1/g) || []).length, 0);
      if (uint8.length === 8) {
        const addrStr = Array.from(addrBytes).join(".");
        return `${addrStr}/${prefixLen}`;
      } else {
        const addrStr = this.formatIPv6(addrBytes);
        return `${addrStr}/${prefixLen}`;
      }
    }
    return this.decodeIP(Convert.ToHex(buf));
  }
  static fromString(text) {
    if (text.includes("/")) {
      const [addr, prefix] = this.parseCIDR(text);
      const maskBytes = new Uint8Array(addr.length);
      let bitsLeft = prefix;
      for (let i = 0;i < maskBytes.length; i++) {
        if (bitsLeft >= 8) {
          maskBytes[i] = 255;
          bitsLeft -= 8;
        } else if (bitsLeft > 0) {
          maskBytes[i] = 255 << 8 - bitsLeft;
          bitsLeft = 0;
        }
      }
      const out = new Uint8Array(addr.length * 2);
      out.set(addr, 0);
      out.set(maskBytes, addr.length);
      return out.buffer;
    }
    const bytes = this.isIPv4(text) ? this.parseIPv4(text) : this.parseIPv6(text);
    return new Uint8Array(bytes).buffer;
  }
}

// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/name.js
var RelativeDistinguishedName_13;
var RDNSequence_13;
var Name_13;
var DirectoryString5 = class DirectoryString6 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.bmpString || this.printableString || this.teletexString || this.universalString || this.utf8String || "";
  }
};
__decorate([
  AsnProp3({ type: AsnPropTypes3.TeletexString })
], DirectoryString5.prototype, "teletexString", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.PrintableString })
], DirectoryString5.prototype, "printableString", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.UniversalString })
], DirectoryString5.prototype, "universalString", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.Utf8String })
], DirectoryString5.prototype, "utf8String", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.BmpString })
], DirectoryString5.prototype, "bmpString", undefined);
DirectoryString5 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], DirectoryString5);
var AttributeValue5 = class AttributeValue6 extends DirectoryString5 {
  constructor(params = {}) {
    super(params);
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || (this.anyValue ? Convert.ToHex(this.anyValue) : super.toString());
  }
};
__decorate([
  AsnProp3({ type: AsnPropTypes3.IA5String })
], AttributeValue5.prototype, "ia5String", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.Any })
], AttributeValue5.prototype, "anyValue", undefined);
AttributeValue5 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], AttributeValue5);
class AttributeTypeAndValue3 {
  constructor(params = {}) {
    this.type = "";
    this.value = new AttributeValue5;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.ObjectIdentifier })
], AttributeTypeAndValue3.prototype, "type", undefined);
__decorate([
  AsnProp3({ type: AttributeValue5 })
], AttributeTypeAndValue3.prototype, "value", undefined);
var RelativeDistinguishedName5 = RelativeDistinguishedName_13 = class RelativeDistinguishedName6 extends AsnArray3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RelativeDistinguishedName_13.prototype);
  }
};
RelativeDistinguishedName5 = RelativeDistinguishedName_13 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Set, itemType: AttributeTypeAndValue3 })
], RelativeDistinguishedName5);
var RDNSequence5 = RDNSequence_13 = class RDNSequence6 extends AsnArray3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RDNSequence_13.prototype);
  }
};
RDNSequence5 = RDNSequence_13 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence, itemType: RelativeDistinguishedName5 })
], RDNSequence5);
var Name5 = Name_13 = class Name6 extends RDNSequence5 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Name_13.prototype);
  }
};
Name5 = Name_13 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence })
], Name5);

// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/general_name.js
var AsnIpConverter3 = {
  fromASN: (value) => IpConverter3.toString(AsnOctetStringConverter3.fromASN(value)),
  toASN: (value) => AsnOctetStringConverter3.toASN(IpConverter3.fromString(value))
};

class OtherName3 {
  constructor(params = {}) {
    this.typeId = "";
    this.value = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.ObjectIdentifier })
], OtherName3.prototype, "typeId", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.Any, context: 0 })
], OtherName3.prototype, "value", undefined);

class EDIPartyName3 {
  constructor(params = {}) {
    this.partyName = new DirectoryString5;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: DirectoryString5, optional: true, context: 0, implicit: true })
], EDIPartyName3.prototype, "nameAssigner", undefined);
__decorate([
  AsnProp3({ type: DirectoryString5, context: 1, implicit: true })
], EDIPartyName3.prototype, "partyName", undefined);
var GeneralName5 = class GeneralName6 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp3({ type: OtherName3, context: 0, implicit: true })
], GeneralName5.prototype, "otherName", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.IA5String, context: 1, implicit: true })
], GeneralName5.prototype, "rfc822Name", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.IA5String, context: 2, implicit: true })
], GeneralName5.prototype, "dNSName", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.Any, context: 3, implicit: true })
], GeneralName5.prototype, "x400Address", undefined);
__decorate([
  AsnProp3({ type: Name5, context: 4, implicit: false })
], GeneralName5.prototype, "directoryName", undefined);
__decorate([
  AsnProp3({ type: EDIPartyName3, context: 5 })
], GeneralName5.prototype, "ediPartyName", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.IA5String, context: 6, implicit: true })
], GeneralName5.prototype, "uniformResourceIdentifier", undefined);
__decorate([
  AsnProp3({
    type: AsnPropTypes3.OctetString,
    context: 7,
    implicit: true,
    converter: AsnIpConverter3
  })
], GeneralName5.prototype, "iPAddress", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.ObjectIdentifier, context: 8, implicit: true })
], GeneralName5.prototype, "registeredID", undefined);
GeneralName5 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], GeneralName5);

// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js
var id_pkix3 = "1.3.6.1.5.5.7";
var id_pe3 = `${id_pkix3}.1`;
var id_qt3 = `${id_pkix3}.2`;
var id_kp3 = `${id_pkix3}.3`;
var id_ad3 = `${id_pkix3}.48`;
var id_qt_csp3 = `${id_qt3}.1`;
var id_qt_unotice3 = `${id_qt3}.2`;
var id_ad_ocsp3 = `${id_ad3}.1`;
var id_ad_caIssuers3 = `${id_ad3}.2`;
var id_ad_timeStamping3 = `${id_ad3}.3`;
var id_ad_caRepository3 = `${id_ad3}.5`;
var id_ce3 = "2.5.29";

// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_information_access.js
var AuthorityInfoAccessSyntax_13;
var id_pe_authorityInfoAccess3 = `${id_pe3}.1`;

class AccessDescription3 {
  constructor(params = {}) {
    this.accessMethod = "";
    this.accessLocation = new GeneralName5;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.ObjectIdentifier })
], AccessDescription3.prototype, "accessMethod", undefined);
__decorate([
  AsnProp3({ type: GeneralName5 })
], AccessDescription3.prototype, "accessLocation", undefined);
var AuthorityInfoAccessSyntax5 = AuthorityInfoAccessSyntax_13 = class AuthorityInfoAccessSyntax6 extends AsnArray3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, AuthorityInfoAccessSyntax_13.prototype);
  }
};
AuthorityInfoAccessSyntax5 = AuthorityInfoAccessSyntax_13 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence, itemType: AccessDescription3 })
], AuthorityInfoAccessSyntax5);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_key_identifier.js
var id_ce_authorityKeyIdentifier3 = `${id_ce3}.35`;

class KeyIdentifier3 extends OctetString6 {
}

class AuthorityKeyIdentifier3 {
  constructor(params = {}) {
    if (params) {
      Object.assign(this, params);
    }
  }
}
__decorate([
  AsnProp3({ type: KeyIdentifier3, context: 0, optional: true, implicit: true })
], AuthorityKeyIdentifier3.prototype, "keyIdentifier", undefined);
__decorate([
  AsnProp3({ type: GeneralName5, context: 1, optional: true, implicit: true, repeated: "sequence" })
], AuthorityKeyIdentifier3.prototype, "authorityCertIssuer", undefined);
__decorate([
  AsnProp3({
    type: AsnPropTypes3.Integer,
    context: 2,
    optional: true,
    implicit: true,
    converter: AsnIntegerArrayBufferConverter3
  })
], AuthorityKeyIdentifier3.prototype, "authorityCertSerialNumber", undefined);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/basic_constraints.js
var id_ce_basicConstraints3 = `${id_ce3}.19`;

class BasicConstraints3 {
  constructor(params = {}) {
    this.cA = false;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.Boolean, defaultValue: false })
], BasicConstraints3.prototype, "cA", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.Integer, optional: true })
], BasicConstraints3.prototype, "pathLenConstraint", undefined);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/general_names.js
var GeneralNames_13;
var GeneralNames5 = GeneralNames_13 = class GeneralNames6 extends AsnArray3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralNames_13.prototype);
  }
};
GeneralNames5 = GeneralNames_13 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence, itemType: GeneralName5 })
], GeneralNames5);

// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_issuer.js
var CertificateIssuer_13;
var id_ce_certificateIssuer3 = `${id_ce3}.29`;
var CertificateIssuer5 = CertificateIssuer_13 = class CertificateIssuer6 extends GeneralNames5 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificateIssuer_13.prototype);
  }
};
CertificateIssuer5 = CertificateIssuer_13 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence })
], CertificateIssuer5);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_policies.js
var CertificatePolicies_13;
var id_ce_certificatePolicies3 = `${id_ce3}.32`;
var id_ce_certificatePolicies_anyPolicy3 = `${id_ce_certificatePolicies3}.0`;
var DisplayText5 = class DisplayText6 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || this.visibleString || this.bmpString || this.utf8String || "";
  }
};
__decorate([
  AsnProp3({ type: AsnPropTypes3.IA5String })
], DisplayText5.prototype, "ia5String", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.VisibleString })
], DisplayText5.prototype, "visibleString", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.BmpString })
], DisplayText5.prototype, "bmpString", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.Utf8String })
], DisplayText5.prototype, "utf8String", undefined);
DisplayText5 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], DisplayText5);
class NoticeReference3 {
  constructor(params = {}) {
    this.organization = new DisplayText5;
    this.noticeNumbers = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: DisplayText5 })
], NoticeReference3.prototype, "organization", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.Integer, repeated: "sequence" })
], NoticeReference3.prototype, "noticeNumbers", undefined);

class UserNotice3 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: NoticeReference3, optional: true })
], UserNotice3.prototype, "noticeRef", undefined);
__decorate([
  AsnProp3({ type: DisplayText5, optional: true })
], UserNotice3.prototype, "explicitText", undefined);
var Qualifier5 = class Qualifier6 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp3({ type: AsnPropTypes3.IA5String })
], Qualifier5.prototype, "cPSuri", undefined);
__decorate([
  AsnProp3({ type: UserNotice3 })
], Qualifier5.prototype, "userNotice", undefined);
Qualifier5 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], Qualifier5);
class PolicyQualifierInfo3 {
  constructor(params = {}) {
    this.policyQualifierId = "";
    this.qualifier = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.ObjectIdentifier })
], PolicyQualifierInfo3.prototype, "policyQualifierId", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.Any })
], PolicyQualifierInfo3.prototype, "qualifier", undefined);

class PolicyInformation3 {
  constructor(params = {}) {
    this.policyIdentifier = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.ObjectIdentifier })
], PolicyInformation3.prototype, "policyIdentifier", undefined);
__decorate([
  AsnProp3({ type: PolicyQualifierInfo3, repeated: "sequence", optional: true })
], PolicyInformation3.prototype, "policyQualifiers", undefined);
var CertificatePolicies5 = CertificatePolicies_13 = class CertificatePolicies6 extends AsnArray3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificatePolicies_13.prototype);
  }
};
CertificatePolicies5 = CertificatePolicies_13 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence, itemType: PolicyInformation3 })
], CertificatePolicies5);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_number.js
var id_ce_cRLNumber3 = `${id_ce3}.20`;
var CRLNumber5 = class CRLNumber6 {
  constructor(value = 0) {
    this.value = value;
  }
};
__decorate([
  AsnProp3({ type: AsnPropTypes3.Integer })
], CRLNumber5.prototype, "value", undefined);
CRLNumber5 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], CRLNumber5);

// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_delta_indicator.js
var id_ce_deltaCRLIndicator3 = `${id_ce3}.27`;
var BaseCRLNumber5 = class BaseCRLNumber6 extends CRLNumber5 {
};
BaseCRLNumber5 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], BaseCRLNumber5);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_distribution_points.js
var CRLDistributionPoints_13;
var id_ce_cRLDistributionPoints3 = `${id_ce3}.31`;
var ReasonFlags3;
(function(ReasonFlags4) {
  ReasonFlags4[ReasonFlags4["unused"] = 1] = "unused";
  ReasonFlags4[ReasonFlags4["keyCompromise"] = 2] = "keyCompromise";
  ReasonFlags4[ReasonFlags4["cACompromise"] = 4] = "cACompromise";
  ReasonFlags4[ReasonFlags4["affiliationChanged"] = 8] = "affiliationChanged";
  ReasonFlags4[ReasonFlags4["superseded"] = 16] = "superseded";
  ReasonFlags4[ReasonFlags4["cessationOfOperation"] = 32] = "cessationOfOperation";
  ReasonFlags4[ReasonFlags4["certificateHold"] = 64] = "certificateHold";
  ReasonFlags4[ReasonFlags4["privilegeWithdrawn"] = 128] = "privilegeWithdrawn";
  ReasonFlags4[ReasonFlags4["aACompromise"] = 256] = "aACompromise";
})(ReasonFlags3 || (ReasonFlags3 = {}));

class Reason3 extends BitString6 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & ReasonFlags3.aACompromise) {
      res.push("aACompromise");
    }
    if (flags & ReasonFlags3.affiliationChanged) {
      res.push("affiliationChanged");
    }
    if (flags & ReasonFlags3.cACompromise) {
      res.push("cACompromise");
    }
    if (flags & ReasonFlags3.certificateHold) {
      res.push("certificateHold");
    }
    if (flags & ReasonFlags3.cessationOfOperation) {
      res.push("cessationOfOperation");
    }
    if (flags & ReasonFlags3.keyCompromise) {
      res.push("keyCompromise");
    }
    if (flags & ReasonFlags3.privilegeWithdrawn) {
      res.push("privilegeWithdrawn");
    }
    if (flags & ReasonFlags3.superseded) {
      res.push("superseded");
    }
    if (flags & ReasonFlags3.unused) {
      res.push("unused");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
}
var DistributionPointName5 = class DistributionPointName6 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp3({ type: GeneralName5, context: 0, repeated: "sequence", implicit: true })
], DistributionPointName5.prototype, "fullName", undefined);
__decorate([
  AsnProp3({ type: RelativeDistinguishedName5, context: 1, implicit: true })
], DistributionPointName5.prototype, "nameRelativeToCRLIssuer", undefined);
DistributionPointName5 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], DistributionPointName5);
class DistributionPoint3 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: DistributionPointName5, context: 0, optional: true })
], DistributionPoint3.prototype, "distributionPoint", undefined);
__decorate([
  AsnProp3({ type: Reason3, context: 1, optional: true, implicit: true })
], DistributionPoint3.prototype, "reasons", undefined);
__decorate([
  AsnProp3({ type: GeneralName5, context: 2, optional: true, repeated: "sequence", implicit: true })
], DistributionPoint3.prototype, "cRLIssuer", undefined);
var CRLDistributionPoints5 = CRLDistributionPoints_13 = class CRLDistributionPoints6 extends AsnArray3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CRLDistributionPoints_13.prototype);
  }
};
CRLDistributionPoints5 = CRLDistributionPoints_13 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence, itemType: DistributionPoint3 })
], CRLDistributionPoints5);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_freshest.js
var FreshestCRL_13;
var id_ce_freshestCRL3 = `${id_ce3}.46`;
var FreshestCRL5 = FreshestCRL_13 = class FreshestCRL6 extends CRLDistributionPoints5 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, FreshestCRL_13.prototype);
  }
};
FreshestCRL5 = FreshestCRL_13 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence, itemType: DistributionPoint3 })
], FreshestCRL5);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_issuing_distribution_point.js
var id_ce_issuingDistributionPoint3 = `${id_ce3}.28`;

class IssuingDistributionPoint3 {
  constructor(params = {}) {
    this.onlyContainsUserCerts = IssuingDistributionPoint3.ONLY;
    this.onlyContainsCACerts = IssuingDistributionPoint3.ONLY;
    this.indirectCRL = IssuingDistributionPoint3.ONLY;
    this.onlyContainsAttributeCerts = IssuingDistributionPoint3.ONLY;
    Object.assign(this, params);
  }
}
IssuingDistributionPoint3.ONLY = false;
__decorate([
  AsnProp3({ type: DistributionPointName5, context: 0, optional: true })
], IssuingDistributionPoint3.prototype, "distributionPoint", undefined);
__decorate([
  AsnProp3({
    type: AsnPropTypes3.Boolean,
    context: 1,
    defaultValue: IssuingDistributionPoint3.ONLY,
    implicit: true
  })
], IssuingDistributionPoint3.prototype, "onlyContainsUserCerts", undefined);
__decorate([
  AsnProp3({
    type: AsnPropTypes3.Boolean,
    context: 2,
    defaultValue: IssuingDistributionPoint3.ONLY,
    implicit: true
  })
], IssuingDistributionPoint3.prototype, "onlyContainsCACerts", undefined);
__decorate([
  AsnProp3({ type: Reason3, context: 3, optional: true, implicit: true })
], IssuingDistributionPoint3.prototype, "onlySomeReasons", undefined);
__decorate([
  AsnProp3({
    type: AsnPropTypes3.Boolean,
    context: 4,
    defaultValue: IssuingDistributionPoint3.ONLY,
    implicit: true
  })
], IssuingDistributionPoint3.prototype, "indirectCRL", undefined);
__decorate([
  AsnProp3({
    type: AsnPropTypes3.Boolean,
    context: 5,
    defaultValue: IssuingDistributionPoint3.ONLY,
    implicit: true
  })
], IssuingDistributionPoint3.prototype, "onlyContainsAttributeCerts", undefined);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_reason.js
var id_ce_cRLReasons3 = `${id_ce3}.21`;
var CRLReasons3;
(function(CRLReasons4) {
  CRLReasons4[CRLReasons4["unspecified"] = 0] = "unspecified";
  CRLReasons4[CRLReasons4["keyCompromise"] = 1] = "keyCompromise";
  CRLReasons4[CRLReasons4["cACompromise"] = 2] = "cACompromise";
  CRLReasons4[CRLReasons4["affiliationChanged"] = 3] = "affiliationChanged";
  CRLReasons4[CRLReasons4["superseded"] = 4] = "superseded";
  CRLReasons4[CRLReasons4["cessationOfOperation"] = 5] = "cessationOfOperation";
  CRLReasons4[CRLReasons4["certificateHold"] = 6] = "certificateHold";
  CRLReasons4[CRLReasons4["removeFromCRL"] = 8] = "removeFromCRL";
  CRLReasons4[CRLReasons4["privilegeWithdrawn"] = 9] = "privilegeWithdrawn";
  CRLReasons4[CRLReasons4["aACompromise"] = 10] = "aACompromise";
})(CRLReasons3 || (CRLReasons3 = {}));
var CRLReason5 = class CRLReason6 {
  constructor(reason = CRLReasons3.unspecified) {
    this.reason = CRLReasons3.unspecified;
    this.reason = reason;
  }
  toJSON() {
    return CRLReasons3[this.reason];
  }
  toString() {
    return this.toJSON();
  }
};
__decorate([
  AsnProp3({ type: AsnPropTypes3.Enumerated })
], CRLReason5.prototype, "reason", undefined);
CRLReason5 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], CRLReason5);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/extended_key_usage.js
var ExtendedKeyUsage_13;
var id_ce_extKeyUsage3 = `${id_ce3}.37`;
var ExtendedKeyUsage5 = ExtendedKeyUsage_13 = class ExtendedKeyUsage6 extends AsnArray3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, ExtendedKeyUsage_13.prototype);
  }
};
ExtendedKeyUsage5 = ExtendedKeyUsage_13 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence, itemType: AsnPropTypes3.ObjectIdentifier })
], ExtendedKeyUsage5);
var anyExtendedKeyUsage3 = `${id_ce_extKeyUsage3}.0`;
var id_kp_serverAuth3 = `${id_kp3}.1`;
var id_kp_clientAuth3 = `${id_kp3}.2`;
var id_kp_codeSigning3 = `${id_kp3}.3`;
var id_kp_emailProtection3 = `${id_kp3}.4`;
var id_kp_timeStamping3 = `${id_kp3}.8`;
var id_kp_OCSPSigning3 = `${id_kp3}.9`;
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/inhibit_any_policy.js
var id_ce_inhibitAnyPolicy3 = `${id_ce3}.54`;
var InhibitAnyPolicy5 = class InhibitAnyPolicy6 {
  constructor(value = new ArrayBuffer(0)) {
    this.value = value;
  }
};
__decorate([
  AsnProp3({ type: AsnPropTypes3.Integer, converter: AsnIntegerArrayBufferConverter3 })
], InhibitAnyPolicy5.prototype, "value", undefined);
InhibitAnyPolicy5 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], InhibitAnyPolicy5);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/invalidity_date.js
var id_ce_invalidityDate3 = `${id_ce3}.24`;
var InvalidityDate5 = class InvalidityDate6 {
  constructor(value) {
    this.value = new Date;
    if (value) {
      this.value = value;
    }
  }
};
__decorate([
  AsnProp3({ type: AsnPropTypes3.GeneralizedTime })
], InvalidityDate5.prototype, "value", undefined);
InvalidityDate5 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], InvalidityDate5);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/issuer_alternative_name.js
var IssueAlternativeName_13;
var id_ce_issuerAltName3 = `${id_ce3}.18`;
var IssueAlternativeName5 = IssueAlternativeName_13 = class IssueAlternativeName6 extends GeneralNames5 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, IssueAlternativeName_13.prototype);
  }
};
IssueAlternativeName5 = IssueAlternativeName_13 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence })
], IssueAlternativeName5);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/key_usage.js
var id_ce_keyUsage3 = `${id_ce3}.15`;
var KeyUsageFlags3;
(function(KeyUsageFlags4) {
  KeyUsageFlags4[KeyUsageFlags4["digitalSignature"] = 1] = "digitalSignature";
  KeyUsageFlags4[KeyUsageFlags4["nonRepudiation"] = 2] = "nonRepudiation";
  KeyUsageFlags4[KeyUsageFlags4["keyEncipherment"] = 4] = "keyEncipherment";
  KeyUsageFlags4[KeyUsageFlags4["dataEncipherment"] = 8] = "dataEncipherment";
  KeyUsageFlags4[KeyUsageFlags4["keyAgreement"] = 16] = "keyAgreement";
  KeyUsageFlags4[KeyUsageFlags4["keyCertSign"] = 32] = "keyCertSign";
  KeyUsageFlags4[KeyUsageFlags4["cRLSign"] = 64] = "cRLSign";
  KeyUsageFlags4[KeyUsageFlags4["encipherOnly"] = 128] = "encipherOnly";
  KeyUsageFlags4[KeyUsageFlags4["decipherOnly"] = 256] = "decipherOnly";
})(KeyUsageFlags3 || (KeyUsageFlags3 = {}));
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/name_constraints.js
var GeneralSubtrees_13;
var id_ce_nameConstraints3 = `${id_ce3}.30`;

class GeneralSubtree3 {
  constructor(params = {}) {
    this.base = new GeneralName5;
    this.minimum = 0;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: GeneralName5 })
], GeneralSubtree3.prototype, "base", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.Integer, context: 0, defaultValue: 0, implicit: true })
], GeneralSubtree3.prototype, "minimum", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.Integer, context: 1, optional: true, implicit: true })
], GeneralSubtree3.prototype, "maximum", undefined);
var GeneralSubtrees5 = GeneralSubtrees_13 = class GeneralSubtrees6 extends AsnArray3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralSubtrees_13.prototype);
  }
};
GeneralSubtrees5 = GeneralSubtrees_13 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence, itemType: GeneralSubtree3 })
], GeneralSubtrees5);
class NameConstraints3 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: GeneralSubtrees5, context: 0, optional: true, implicit: true })
], NameConstraints3.prototype, "permittedSubtrees", undefined);
__decorate([
  AsnProp3({ type: GeneralSubtrees5, context: 1, optional: true, implicit: true })
], NameConstraints3.prototype, "excludedSubtrees", undefined);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_constraints.js
var id_ce_policyConstraints3 = `${id_ce3}.36`;

class PolicyConstraints3 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({
    type: AsnPropTypes3.Integer,
    context: 0,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter3
  })
], PolicyConstraints3.prototype, "requireExplicitPolicy", undefined);
__decorate([
  AsnProp3({
    type: AsnPropTypes3.Integer,
    context: 1,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter3
  })
], PolicyConstraints3.prototype, "inhibitPolicyMapping", undefined);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_mappings.js
var PolicyMappings_13;
var id_ce_policyMappings3 = `${id_ce3}.33`;

class PolicyMapping3 {
  constructor(params = {}) {
    this.issuerDomainPolicy = "";
    this.subjectDomainPolicy = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.ObjectIdentifier })
], PolicyMapping3.prototype, "issuerDomainPolicy", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.ObjectIdentifier })
], PolicyMapping3.prototype, "subjectDomainPolicy", undefined);
var PolicyMappings5 = PolicyMappings_13 = class PolicyMappings6 extends AsnArray3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, PolicyMappings_13.prototype);
  }
};
PolicyMappings5 = PolicyMappings_13 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence, itemType: PolicyMapping3 })
], PolicyMappings5);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_alternative_name.js
var SubjectAlternativeName_13;
var id_ce_subjectAltName3 = `${id_ce3}.17`;
var SubjectAlternativeName5 = SubjectAlternativeName_13 = class SubjectAlternativeName6 extends GeneralNames5 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectAlternativeName_13.prototype);
  }
};
SubjectAlternativeName5 = SubjectAlternativeName_13 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence })
], SubjectAlternativeName5);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/attribute.js
class Attribute3 {
  constructor(params = {}) {
    this.type = "";
    this.values = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.ObjectIdentifier })
], Attribute3.prototype, "type", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.Any, repeated: "set" })
], Attribute3.prototype, "values", undefined);

// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_directory_attributes.js
var SubjectDirectoryAttributes_13;
var id_ce_subjectDirectoryAttributes3 = `${id_ce3}.9`;
var SubjectDirectoryAttributes5 = SubjectDirectoryAttributes_13 = class SubjectDirectoryAttributes6 extends AsnArray3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectDirectoryAttributes_13.prototype);
  }
};
SubjectDirectoryAttributes5 = SubjectDirectoryAttributes_13 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence, itemType: Attribute3 })
], SubjectDirectoryAttributes5);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_key_identifier.js
var id_ce_subjectKeyIdentifier3 = `${id_ce3}.14`;

class SubjectKeyIdentifier2 extends KeyIdentifier3 {
}
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/private_key_usage_period.js
var id_ce_privateKeyUsagePeriod3 = `${id_ce3}.16`;

class PrivateKeyUsagePeriod3 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.GeneralizedTime, context: 0, implicit: true, optional: true })
], PrivateKeyUsagePeriod3.prototype, "notBefore", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.GeneralizedTime, context: 1, implicit: true, optional: true })
], PrivateKeyUsagePeriod3.prototype, "notAfter", undefined);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/entrust_version_info.js
var EntrustInfoFlags3;
(function(EntrustInfoFlags4) {
  EntrustInfoFlags4[EntrustInfoFlags4["keyUpdateAllowed"] = 1] = "keyUpdateAllowed";
  EntrustInfoFlags4[EntrustInfoFlags4["newExtensions"] = 2] = "newExtensions";
  EntrustInfoFlags4[EntrustInfoFlags4["pKIXCertificate"] = 4] = "pKIXCertificate";
})(EntrustInfoFlags3 || (EntrustInfoFlags3 = {}));

class EntrustInfo3 extends BitString6 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & EntrustInfoFlags3.pKIXCertificate) {
      res.push("pKIXCertificate");
    }
    if (flags & EntrustInfoFlags3.newExtensions) {
      res.push("newExtensions");
    }
    if (flags & EntrustInfoFlags3.keyUpdateAllowed) {
      res.push("keyUpdateAllowed");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
}

class EntrustVersionInfo3 {
  constructor(params = {}) {
    this.entrustVers = "";
    this.entrustInfoFlags = new EntrustInfo3;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.GeneralString })
], EntrustVersionInfo3.prototype, "entrustVers", undefined);
__decorate([
  AsnProp3({ type: EntrustInfo3 })
], EntrustVersionInfo3.prototype, "entrustInfoFlags", undefined);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_info_access.js
var SubjectInfoAccessSyntax_13;
var id_pe_subjectInfoAccess3 = `${id_pe3}.11`;
var SubjectInfoAccessSyntax5 = SubjectInfoAccessSyntax_13 = class SubjectInfoAccessSyntax6 extends AsnArray3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectInfoAccessSyntax_13.prototype);
  }
};
SubjectInfoAccessSyntax5 = SubjectInfoAccessSyntax_13 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence, itemType: AccessDescription3 })
], SubjectInfoAccessSyntax5);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js
class AlgorithmIdentifier3 {
  constructor(params = {}) {
    this.algorithm = "";
    Object.assign(this, params);
  }
  isEqual(data) {
    return data instanceof AlgorithmIdentifier3 && data.algorithm == this.algorithm && (data.parameters && this.parameters && isEqual(data.parameters, this.parameters) || data.parameters === this.parameters);
  }
}
__decorate([
  AsnProp3({
    type: AsnPropTypes3.ObjectIdentifier
  })
], AlgorithmIdentifier3.prototype, "algorithm", undefined);
__decorate([
  AsnProp3({
    type: AsnPropTypes3.Any,
    optional: true
  })
], AlgorithmIdentifier3.prototype, "parameters", undefined);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/subject_public_key_info.js
class SubjectPublicKeyInfo3 {
  constructor(params = {}) {
    this.algorithm = new AlgorithmIdentifier3;
    this.subjectPublicKey = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AlgorithmIdentifier3 })
], SubjectPublicKeyInfo3.prototype, "algorithm", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.BitString })
], SubjectPublicKeyInfo3.prototype, "subjectPublicKey", undefined);

// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/time.js
var Time5 = class Time6 {
  constructor(time4) {
    if (time4) {
      if (typeof time4 === "string" || typeof time4 === "number" || time4 instanceof Date) {
        const date = new Date(time4);
        if (date.getUTCFullYear() > 2049) {
          this.generalTime = date;
        } else {
          this.utcTime = date;
        }
      } else {
        Object.assign(this, time4);
      }
    }
  }
  getTime() {
    const time4 = this.utcTime || this.generalTime;
    if (!time4) {
      throw new Error("Cannot get time from CHOICE object");
    }
    return time4;
  }
};
__decorate([
  AsnProp3({
    type: AsnPropTypes3.UTCTime
  })
], Time5.prototype, "utcTime", undefined);
__decorate([
  AsnProp3({
    type: AsnPropTypes3.GeneralizedTime
  })
], Time5.prototype, "generalTime", undefined);
Time5 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], Time5);

// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/validity.js
class Validity3 {
  constructor(params) {
    this.notBefore = new Time5(new Date);
    this.notAfter = new Time5(new Date);
    if (params) {
      this.notBefore = new Time5(params.notBefore);
      this.notAfter = new Time5(params.notAfter);
    }
  }
}
__decorate([
  AsnProp3({ type: Time5 })
], Validity3.prototype, "notBefore", undefined);
__decorate([
  AsnProp3({ type: Time5 })
], Validity3.prototype, "notAfter", undefined);

// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/extension.js
var Extensions_13;

class Extension3 {
  constructor(params = {}) {
    this.extnID = "";
    this.critical = Extension3.CRITICAL;
    this.extnValue = new OctetString6;
    Object.assign(this, params);
  }
}
Extension3.CRITICAL = false;
__decorate([
  AsnProp3({ type: AsnPropTypes3.ObjectIdentifier })
], Extension3.prototype, "extnID", undefined);
__decorate([
  AsnProp3({
    type: AsnPropTypes3.Boolean,
    defaultValue: Extension3.CRITICAL
  })
], Extension3.prototype, "critical", undefined);
__decorate([
  AsnProp3({ type: OctetString6 })
], Extension3.prototype, "extnValue", undefined);
var Extensions5 = Extensions_13 = class Extensions6 extends AsnArray3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Extensions_13.prototype);
  }
};
Extensions5 = Extensions_13 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence, itemType: Extension3 })
], Extensions5);

// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/types.js
var Version3;
(function(Version4) {
  Version4[Version4["v1"] = 0] = "v1";
  Version4[Version4["v2"] = 1] = "v2";
  Version4[Version4["v3"] = 2] = "v3";
})(Version3 || (Version3 = {}));

// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/tbs_certificate.js
class TBSCertificate3 {
  constructor(params = {}) {
    this.version = Version3.v1;
    this.serialNumber = new ArrayBuffer(0);
    this.signature = new AlgorithmIdentifier3;
    this.issuer = new Name5;
    this.validity = new Validity3;
    this.subject = new Name5;
    this.subjectPublicKeyInfo = new SubjectPublicKeyInfo3;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({
    type: AsnPropTypes3.Integer,
    context: 0,
    defaultValue: Version3.v1
  })
], TBSCertificate3.prototype, "version", undefined);
__decorate([
  AsnProp3({
    type: AsnPropTypes3.Integer,
    converter: AsnIntegerArrayBufferConverter3
  })
], TBSCertificate3.prototype, "serialNumber", undefined);
__decorate([
  AsnProp3({ type: AlgorithmIdentifier3 })
], TBSCertificate3.prototype, "signature", undefined);
__decorate([
  AsnProp3({ type: Name5 })
], TBSCertificate3.prototype, "issuer", undefined);
__decorate([
  AsnProp3({ type: Validity3 })
], TBSCertificate3.prototype, "validity", undefined);
__decorate([
  AsnProp3({ type: Name5 })
], TBSCertificate3.prototype, "subject", undefined);
__decorate([
  AsnProp3({ type: SubjectPublicKeyInfo3 })
], TBSCertificate3.prototype, "subjectPublicKeyInfo", undefined);
__decorate([
  AsnProp3({
    type: AsnPropTypes3.BitString,
    context: 1,
    implicit: true,
    optional: true
  })
], TBSCertificate3.prototype, "issuerUniqueID", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.BitString, context: 2, implicit: true, optional: true })
], TBSCertificate3.prototype, "subjectUniqueID", undefined);
__decorate([
  AsnProp3({ type: Extensions5, context: 3, optional: true })
], TBSCertificate3.prototype, "extensions", undefined);

// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/certificate.js
class Certificate3 {
  constructor(params = {}) {
    this.tbsCertificate = new TBSCertificate3;
    this.signatureAlgorithm = new AlgorithmIdentifier3;
    this.signatureValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: TBSCertificate3, raw: true })
], Certificate3.prototype, "tbsCertificate", undefined);
__decorate([
  AsnProp3({ type: AlgorithmIdentifier3 })
], Certificate3.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.BitString })
], Certificate3.prototype, "signatureValue", undefined);
// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/tbs_cert_list.js
class RevokedCertificate3 {
  constructor(params = {}) {
    this.userCertificate = new ArrayBuffer(0);
    this.revocationDate = new Time5;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.Integer, converter: AsnIntegerArrayBufferConverter3 })
], RevokedCertificate3.prototype, "userCertificate", undefined);
__decorate([
  AsnProp3({ type: Time5 })
], RevokedCertificate3.prototype, "revocationDate", undefined);
__decorate([
  AsnProp3({ type: Extension3, optional: true, repeated: "sequence" })
], RevokedCertificate3.prototype, "crlEntryExtensions", undefined);

class TBSCertList3 {
  constructor(params = {}) {
    this.signature = new AlgorithmIdentifier3;
    this.issuer = new Name5;
    this.thisUpdate = new Time5;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.Integer, optional: true })
], TBSCertList3.prototype, "version", undefined);
__decorate([
  AsnProp3({ type: AlgorithmIdentifier3 })
], TBSCertList3.prototype, "signature", undefined);
__decorate([
  AsnProp3({ type: Name5 })
], TBSCertList3.prototype, "issuer", undefined);
__decorate([
  AsnProp3({ type: Time5 })
], TBSCertList3.prototype, "thisUpdate", undefined);
__decorate([
  AsnProp3({ type: Time5, optional: true })
], TBSCertList3.prototype, "nextUpdate", undefined);
__decorate([
  AsnProp3({ type: RevokedCertificate3, repeated: "sequence", optional: true })
], TBSCertList3.prototype, "revokedCertificates", undefined);
__decorate([
  AsnProp3({ type: Extension3, optional: true, context: 0, repeated: "sequence" })
], TBSCertList3.prototype, "crlExtensions", undefined);

// node_modules/@peculiar/asn1-cms/node_modules/@peculiar/asn1-x509/build/es2015/certificate_list.js
class CertificateList3 {
  constructor(params = {}) {
    this.tbsCertList = new TBSCertList3;
    this.signatureAlgorithm = new AlgorithmIdentifier3;
    this.signature = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: TBSCertList3, raw: true })
], CertificateList3.prototype, "tbsCertList", undefined);
__decorate([
  AsnProp3({ type: AlgorithmIdentifier3 })
], CertificateList3.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.BitString })
], CertificateList3.prototype, "signature", undefined);
// node_modules/@peculiar/asn1-cms/build/es2015/issuer_and_serial_number.js
class IssuerAndSerialNumber {
  constructor(params = {}) {
    this.issuer = new Name5;
    this.serialNumber = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: Name5 })
], IssuerAndSerialNumber.prototype, "issuer", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.Integer, converter: AsnIntegerArrayBufferConverter3 })
], IssuerAndSerialNumber.prototype, "serialNumber", undefined);

// node_modules/@peculiar/asn1-cms/build/es2015/signer_identifier.js
var SignerIdentifier = class SignerIdentifier2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp3({ type: SubjectKeyIdentifier2, context: 0, implicit: true })
], SignerIdentifier.prototype, "subjectKeyIdentifier", undefined);
__decorate([
  AsnProp3({ type: IssuerAndSerialNumber })
], SignerIdentifier.prototype, "issuerAndSerialNumber", undefined);
SignerIdentifier = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], SignerIdentifier);

// node_modules/@peculiar/asn1-cms/build/es2015/types.js
var CMSVersion;
(function(CMSVersion2) {
  CMSVersion2[CMSVersion2["v0"] = 0] = "v0";
  CMSVersion2[CMSVersion2["v1"] = 1] = "v1";
  CMSVersion2[CMSVersion2["v2"] = 2] = "v2";
  CMSVersion2[CMSVersion2["v3"] = 3] = "v3";
  CMSVersion2[CMSVersion2["v4"] = 4] = "v4";
  CMSVersion2[CMSVersion2["v5"] = 5] = "v5";
})(CMSVersion || (CMSVersion = {}));
var DigestAlgorithmIdentifier = class DigestAlgorithmIdentifier2 extends AlgorithmIdentifier3 {
};
DigestAlgorithmIdentifier = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence })
], DigestAlgorithmIdentifier);
var SignatureAlgorithmIdentifier = class SignatureAlgorithmIdentifier2 extends AlgorithmIdentifier3 {
};
SignatureAlgorithmIdentifier = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence })
], SignatureAlgorithmIdentifier);
var KeyEncryptionAlgorithmIdentifier = class KeyEncryptionAlgorithmIdentifier2 extends AlgorithmIdentifier3 {
};
KeyEncryptionAlgorithmIdentifier = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence })
], KeyEncryptionAlgorithmIdentifier);
var ContentEncryptionAlgorithmIdentifier = class ContentEncryptionAlgorithmIdentifier2 extends AlgorithmIdentifier3 {
};
ContentEncryptionAlgorithmIdentifier = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence })
], ContentEncryptionAlgorithmIdentifier);
var MessageAuthenticationCodeAlgorithm = class MessageAuthenticationCodeAlgorithm2 extends AlgorithmIdentifier3 {
};
MessageAuthenticationCodeAlgorithm = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence })
], MessageAuthenticationCodeAlgorithm);
var KeyDerivationAlgorithmIdentifier = class KeyDerivationAlgorithmIdentifier2 extends AlgorithmIdentifier3 {
};
KeyDerivationAlgorithmIdentifier = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence })
], KeyDerivationAlgorithmIdentifier);

// node_modules/@peculiar/asn1-cms/build/es2015/attribute.js
class Attribute4 {
  constructor(params = {}) {
    this.attrType = "";
    this.attrValues = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.ObjectIdentifier })
], Attribute4.prototype, "attrType", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.Any, repeated: "set" })
], Attribute4.prototype, "attrValues", undefined);

// node_modules/@peculiar/asn1-cms/build/es2015/signer_info.js
var SignerInfos_1;

class SignerInfo {
  constructor(params = {}) {
    this.version = CMSVersion.v0;
    this.sid = new SignerIdentifier;
    this.digestAlgorithm = new DigestAlgorithmIdentifier;
    this.signatureAlgorithm = new SignatureAlgorithmIdentifier;
    this.signature = new OctetString6;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.Integer })
], SignerInfo.prototype, "version", undefined);
__decorate([
  AsnProp3({ type: SignerIdentifier })
], SignerInfo.prototype, "sid", undefined);
__decorate([
  AsnProp3({ type: DigestAlgorithmIdentifier })
], SignerInfo.prototype, "digestAlgorithm", undefined);
__decorate([
  AsnProp3({
    type: Attribute4,
    repeated: "set",
    context: 0,
    implicit: true,
    optional: true,
    raw: true
  })
], SignerInfo.prototype, "signedAttrs", undefined);
__decorate([
  AsnProp3({ type: SignatureAlgorithmIdentifier })
], SignerInfo.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp3({ type: OctetString6 })
], SignerInfo.prototype, "signature", undefined);
__decorate([
  AsnProp3({ type: Attribute4, repeated: "set", context: 1, implicit: true, optional: true })
], SignerInfo.prototype, "unsignedAttrs", undefined);
var SignerInfos = SignerInfos_1 = class SignerInfos2 extends AsnArray3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SignerInfos_1.prototype);
  }
};
SignerInfos = SignerInfos_1 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Set, itemType: SignerInfo })
], SignerInfos);

// node_modules/@peculiar/asn1-cms/build/es2015/attributes.js
var SigningTime = class SigningTime2 extends Time5 {
};
SigningTime = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], SigningTime);
var CounterSignature = class CounterSignature2 extends SignerInfo {
};
CounterSignature = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence })
], CounterSignature);
// node_modules/@peculiar/asn1-x509-attr/node_modules/asn1js/build/index.es.js
var exports_index_es5 = {};
__export(exports_index_es5, {
  verifySchema: () => verifySchema4,
  fromBER: () => fromBER4,
  compareSchema: () => compareSchema4,
  VisibleString: () => VisibleString4,
  ViewWriter: () => ViewWriter4,
  VideotexString: () => VideotexString4,
  ValueBlock: () => ValueBlock4,
  Utf8String: () => Utf8String4,
  UniversalString: () => UniversalString4,
  UTCTime: () => UTCTime4,
  TimeOfDay: () => TimeOfDay4,
  TeletexString: () => TeletexString4,
  TIME: () => TIME4,
  Set: () => Set5,
  Sequence: () => Sequence4,
  Repeated: () => Repeated4,
  RelativeObjectIdentifier: () => RelativeObjectIdentifier4,
  RawData: () => RawData4,
  PrintableString: () => PrintableString4,
  Primitive: () => Primitive4,
  OctetString: () => OctetString7,
  ObjectIdentifier: () => ObjectIdentifier4,
  NumericString: () => NumericString4,
  Null: () => Null4,
  Integer: () => Integer4,
  IA5String: () => IA5String4,
  HexBlock: () => HexBlock4,
  GraphicString: () => GraphicString4,
  GeneralizedTime: () => GeneralizedTime4,
  GeneralString: () => GeneralString4,
  Enumerated: () => Enumerated4,
  EndOfContent: () => EndOfContent4,
  Duration: () => Duration4,
  DateTime: () => DateTime4,
  DATE: () => DATE4,
  Constructed: () => Constructed4,
  Choice: () => Choice4,
  CharacterString: () => CharacterString4,
  Boolean: () => Boolean5,
  BmpString: () => BmpString4,
  BitString: () => BitString7,
  BaseStringBlock: () => BaseStringBlock4,
  BaseBlock: () => BaseBlock4,
  Any: () => Any4
});
/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
function assertBigInt4() {
  if (typeof BigInt === "undefined") {
    throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
  }
}
function concat4(buffers) {
  let outputLength = 0;
  let prevLength = 0;
  for (let i = 0;i < buffers.length; i++) {
    const buffer = buffers[i];
    outputLength += buffer.byteLength;
  }
  const retView = new Uint8Array(outputLength);
  for (let i = 0;i < buffers.length; i++) {
    const buffer = buffers[i];
    retView.set(new Uint8Array(buffer), prevLength);
    prevLength += buffer.byteLength;
  }
  return retView.buffer;
}
function checkBufferParams4(baseBlock, inputBuffer, inputOffset, inputLength) {
  if (!(inputBuffer instanceof Uint8Array)) {
    baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
    return false;
  }
  if (!inputBuffer.byteLength) {
    baseBlock.error = "Wrong parameter: inputBuffer has zero length";
    return false;
  }
  if (inputOffset < 0) {
    baseBlock.error = "Wrong parameter: inputOffset less than zero";
    return false;
  }
  if (inputLength < 0) {
    baseBlock.error = "Wrong parameter: inputLength less than zero";
    return false;
  }
  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
    baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
    return false;
  }
  return true;
}

class ViewWriter4 {
  constructor() {
    this.items = [];
  }
  write(buf) {
    this.items.push(buf);
  }
  final() {
    return concat4(this.items);
  }
}
var powers24 = [new Uint8Array([1])];
var digitsString4 = "0123456789";
var NAME4 = "name";
var VALUE_HEX_VIEW4 = "valueHexView";
var IS_HEX_ONLY4 = "isHexOnly";
var ID_BLOCK4 = "idBlock";
var TAG_CLASS4 = "tagClass";
var TAG_NUMBER4 = "tagNumber";
var IS_CONSTRUCTED4 = "isConstructed";
var FROM_BER4 = "fromBER";
var TO_BER4 = "toBER";
var LOCAL4 = "local";
var EMPTY_STRING4 = "";
var EMPTY_BUFFER4 = new ArrayBuffer(0);
var EMPTY_VIEW4 = new Uint8Array(0);
var END_OF_CONTENT_NAME4 = "EndOfContent";
var OCTET_STRING_NAME4 = "OCTET STRING";
var BIT_STRING_NAME4 = "BIT STRING";
function HexBlock4(BaseClass) {
  var _a4;
  return _a4 = class Some extends BaseClass {
    get valueHex() {
      return this.valueHexView.slice().buffer;
    }
    set valueHex(value) {
      this.valueHexView = new Uint8Array(value);
    }
    constructor(...args) {
      var _b;
      super(...args);
      const params = args[0] || {};
      this.isHexOnly = (_b = params.isHexOnly) !== null && _b !== undefined ? _b : false;
      this.valueHexView = params.valueHex ? BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW4;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      if (!checkBufferParams4(this, view, inputOffset, inputLength)) {
        return -1;
      }
      const endLength = inputOffset + inputLength;
      this.valueHexView = view.subarray(inputOffset, endLength);
      if (!this.valueHexView.length) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      }
      this.blockLength = inputLength;
      return endLength;
    }
    toBER(sizeOnly = false) {
      if (!this.isHexOnly) {
        this.error = "Flag 'isHexOnly' is not set, abort";
        return EMPTY_BUFFER4;
      }
      if (sizeOnly) {
        return new ArrayBuffer(this.valueHexView.byteLength);
      }
      return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        isHexOnly: this.isHexOnly,
        valueHex: Convert.ToHex(this.valueHexView)
      };
    }
  }, _a4.NAME = "hexBlock", _a4;
}

class LocalBaseBlock4 {
  static blockName() {
    return this.NAME;
  }
  get valueBeforeDecode() {
    return this.valueBeforeDecodeView.slice().buffer;
  }
  set valueBeforeDecode(value) {
    this.valueBeforeDecodeView = new Uint8Array(value);
  }
  constructor({ blockLength = 0, error = EMPTY_STRING4, warnings = [], valueBeforeDecode = EMPTY_VIEW4 } = {}) {
    this.blockLength = blockLength;
    this.error = error;
    this.warnings = warnings;
    this.valueBeforeDecodeView = BufferSourceConverter.toUint8Array(valueBeforeDecode);
  }
  toJSON() {
    return {
      blockName: this.constructor.NAME,
      blockLength: this.blockLength,
      error: this.error,
      warnings: this.warnings,
      valueBeforeDecode: Convert.ToHex(this.valueBeforeDecodeView)
    };
  }
}
LocalBaseBlock4.NAME = "baseBlock";

class ValueBlock4 extends LocalBaseBlock4 {
  fromBER(_inputBuffer, _inputOffset, _inputLength) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
  toBER(_sizeOnly, _writer) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
}
ValueBlock4.NAME = "valueBlock";

class LocalIdentificationBlock4 extends HexBlock4(LocalBaseBlock4) {
  constructor({ idBlock = {} } = {}) {
    var _a4, _b, _c, _d;
    super();
    if (idBlock) {
      this.isHexOnly = (_a4 = idBlock.isHexOnly) !== null && _a4 !== undefined ? _a4 : false;
      this.valueHexView = idBlock.valueHex ? BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW4;
      this.tagClass = (_b = idBlock.tagClass) !== null && _b !== undefined ? _b : -1;
      this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== undefined ? _c : -1;
      this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== undefined ? _d : false;
    } else {
      this.tagClass = -1;
      this.tagNumber = -1;
      this.isConstructed = false;
    }
  }
  toBER(sizeOnly = false) {
    let firstOctet = 0;
    switch (this.tagClass) {
      case 1:
        firstOctet |= 0;
        break;
      case 2:
        firstOctet |= 64;
        break;
      case 3:
        firstOctet |= 128;
        break;
      case 4:
        firstOctet |= 192;
        break;
      default:
        this.error = "Unknown tag class";
        return EMPTY_BUFFER4;
    }
    if (this.isConstructed)
      firstOctet |= 32;
    if (this.tagNumber < 31 && !this.isHexOnly) {
      const retView2 = new Uint8Array(1);
      if (!sizeOnly) {
        let number = this.tagNumber;
        number &= 31;
        firstOctet |= number;
        retView2[0] = firstOctet;
      }
      return retView2.buffer;
    }
    if (!this.isHexOnly) {
      const encodedBuf = utilToBase(this.tagNumber, 7);
      const encodedView = new Uint8Array(encodedBuf);
      const size = encodedBuf.byteLength;
      const retView2 = new Uint8Array(size + 1);
      retView2[0] = firstOctet | 31;
      if (!sizeOnly) {
        for (let i = 0;i < size - 1; i++)
          retView2[i + 1] = encodedView[i] | 128;
        retView2[size] = encodedView[size - 1];
      }
      return retView2.buffer;
    }
    const retView = new Uint8Array(this.valueHexView.byteLength + 1);
    retView[0] = firstOctet | 31;
    if (!sizeOnly) {
      const curView = this.valueHexView;
      for (let i = 0;i < curView.length - 1; i++)
        retView[i + 1] = curView[i] | 128;
      retView[this.valueHexView.byteLength] = curView[curView.length - 1];
    }
    return retView.buffer;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams4(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    const tagClassMask = intBuffer[0] & 192;
    switch (tagClassMask) {
      case 0:
        this.tagClass = 1;
        break;
      case 64:
        this.tagClass = 2;
        break;
      case 128:
        this.tagClass = 3;
        break;
      case 192:
        this.tagClass = 4;
        break;
      default:
        this.error = "Unknown tag class";
        return -1;
    }
    this.isConstructed = (intBuffer[0] & 32) === 32;
    this.isHexOnly = false;
    const tagNumberMask = intBuffer[0] & 31;
    if (tagNumberMask !== 31) {
      this.tagNumber = tagNumberMask;
      this.blockLength = 1;
    } else {
      let count = 1;
      let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
      let tagNumberBufferMaxLength = 255;
      while (intBuffer[count] & 128) {
        intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
        count++;
        if (count >= intBuffer.length) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (count === tagNumberBufferMaxLength) {
          tagNumberBufferMaxLength += 255;
          const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);
          for (let i = 0;i < intTagNumberBuffer.length; i++)
            tempBufferView2[i] = intTagNumberBuffer[i];
          intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
        }
      }
      this.blockLength = count + 1;
      intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
      const tempBufferView = new Uint8Array(count);
      for (let i = 0;i < count; i++)
        tempBufferView[i] = intTagNumberBuffer[i];
      intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
      intTagNumberBuffer.set(tempBufferView);
      if (this.blockLength <= 9)
        this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
      else {
        this.isHexOnly = true;
        this.warnings.push("Tag too long, represented as hex-coded");
      }
    }
    if (this.tagClass === 1 && this.isConstructed) {
      switch (this.tagNumber) {
        case 1:
        case 2:
        case 5:
        case 6:
        case 9:
        case 13:
        case 14:
        case 23:
        case 24:
        case 31:
        case 32:
        case 33:
        case 34:
          this.error = "Constructed encoding used for primitive type";
          return -1;
      }
    }
    return inputOffset + this.blockLength;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      tagClass: this.tagClass,
      tagNumber: this.tagNumber,
      isConstructed: this.isConstructed
    };
  }
}
LocalIdentificationBlock4.NAME = "identificationBlock";

class LocalLengthBlock4 extends LocalBaseBlock4 {
  constructor({ lenBlock = {} } = {}) {
    var _a4, _b, _c;
    super();
    this.isIndefiniteForm = (_a4 = lenBlock.isIndefiniteForm) !== null && _a4 !== undefined ? _a4 : false;
    this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== undefined ? _b : false;
    this.length = (_c = lenBlock.length) !== null && _c !== undefined ? _c : 0;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams4(this, view, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    if (intBuffer[0] === 255) {
      this.error = "Length block 0xFF is reserved by standard";
      return -1;
    }
    this.isIndefiniteForm = intBuffer[0] === 128;
    if (this.isIndefiniteForm) {
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    this.longFormUsed = !!(intBuffer[0] & 128);
    if (this.longFormUsed === false) {
      this.length = intBuffer[0];
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    const count = intBuffer[0] & 127;
    if (count > 8) {
      this.error = "Too big integer";
      return -1;
    }
    if (count + 1 > intBuffer.length) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    const lenOffset = inputOffset + 1;
    const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
    if (lengthBufferView[count - 1] === 0)
      this.warnings.push("Needlessly long encoded length");
    this.length = utilFromBase(lengthBufferView, 8);
    if (this.longFormUsed && this.length <= 127)
      this.warnings.push("Unnecessary usage of long length form");
    this.blockLength = count + 1;
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly = false) {
    let retBuf;
    let retView;
    if (this.length > 127)
      this.longFormUsed = true;
    if (this.isIndefiniteForm) {
      retBuf = new ArrayBuffer(1);
      if (sizeOnly === false) {
        retView = new Uint8Array(retBuf);
        retView[0] = 128;
      }
      return retBuf;
    }
    if (this.longFormUsed) {
      const encodedBuf = utilToBase(this.length, 8);
      if (encodedBuf.byteLength > 127) {
        this.error = "Too big length";
        return EMPTY_BUFFER4;
      }
      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
      if (sizeOnly)
        return retBuf;
      const encodedView = new Uint8Array(encodedBuf);
      retView = new Uint8Array(retBuf);
      retView[0] = encodedBuf.byteLength | 128;
      for (let i = 0;i < encodedBuf.byteLength; i++)
        retView[i + 1] = encodedView[i];
      return retBuf;
    }
    retBuf = new ArrayBuffer(1);
    if (sizeOnly === false) {
      retView = new Uint8Array(retBuf);
      retView[0] = this.length;
    }
    return retBuf;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      longFormUsed: this.longFormUsed,
      length: this.length
    };
  }
}
LocalLengthBlock4.NAME = "lengthBlock";
var typeStore4 = {};

class BaseBlock4 extends LocalBaseBlock4 {
  constructor({ name: name4 = EMPTY_STRING4, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType) {
    super(parameters);
    this.name = name4;
    this.optional = optional;
    if (primitiveSchema) {
      this.primitiveSchema = primitiveSchema;
    }
    this.idBlock = new LocalIdentificationBlock4(parameters);
    this.lenBlock = new LocalLengthBlock4(parameters);
    this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock4(parameters);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter4;
    if (!writer) {
      prepareIndefiniteForm4(this);
    }
    const idBlockBuf = this.idBlock.toBER(sizeOnly);
    _writer.write(idBlockBuf);
    if (this.lenBlock.isIndefiniteForm) {
      _writer.write(new Uint8Array([128]).buffer);
      this.valueBlock.toBER(sizeOnly, _writer);
      _writer.write(new ArrayBuffer(2));
    } else {
      const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
      this.lenBlock.length = valueBlockBuf.byteLength;
      const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
      _writer.write(lenBlockBuf);
      _writer.write(valueBlockBuf);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER4;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      idBlock: this.idBlock.toJSON(),
      lenBlock: this.lenBlock.toJSON(),
      valueBlock: this.valueBlock.toJSON(),
      name: this.name,
      optional: this.optional
    };
    if (this.primitiveSchema)
      object.primitiveSchema = this.primitiveSchema.toJSON();
    return object;
  }
  toString(encoding = "ascii") {
    if (encoding === "ascii") {
      return this.onAsciiEncoding();
    }
    return Convert.ToHex(this.toBER());
  }
  onAsciiEncoding() {
    const name4 = this.constructor.NAME;
    const value = Convert.ToHex(this.valueBlock.valueBeforeDecodeView);
    return `${name4} : ${value}`;
  }
  isEqual(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof this.constructor)) {
      return false;
    }
    const thisRaw = this.toBER();
    const otherRaw = other.toBER();
    return isEqualBuffer(thisRaw, otherRaw);
  }
}
BaseBlock4.NAME = "BaseBlock";
function prepareIndefiniteForm4(baseBlock) {
  var _a4;
  if (baseBlock instanceof typeStore4.Constructed) {
    for (const value of baseBlock.valueBlock.value) {
      if (prepareIndefiniteForm4(value)) {
        baseBlock.lenBlock.isIndefiniteForm = true;
      }
    }
  }
  return !!((_a4 = baseBlock.lenBlock) === null || _a4 === undefined ? undefined : _a4.isIndefiniteForm);
}

class BaseStringBlock4 extends BaseBlock4 {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  constructor({ value = EMPTY_STRING4, ...parameters } = {}, stringValueBlockType) {
    super(parameters, stringValueBlockType);
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    this.fromBuffer(this.valueBlock.valueHexView);
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
  }
}
BaseStringBlock4.NAME = "BaseStringBlock";

class LocalPrimitiveValueBlock4 extends HexBlock4(ValueBlock4) {
  constructor({ isHexOnly = true, ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = isHexOnly;
  }
}
LocalPrimitiveValueBlock4.NAME = "PrimitiveValueBlock";
var _a$w4;

class Primitive4 extends BaseBlock4 {
  constructor(parameters = {}) {
    super(parameters, LocalPrimitiveValueBlock4);
    this.idBlock.isConstructed = false;
  }
}
_a$w4 = Primitive4;
(() => {
  typeStore4.Primitive = _a$w4;
})();
Primitive4.NAME = "PRIMITIVE";
function localChangeType4(inputObject, newType) {
  if (inputObject instanceof newType) {
    return inputObject;
  }
  const newObject = new newType;
  newObject.idBlock = inputObject.idBlock;
  newObject.lenBlock = inputObject.lenBlock;
  newObject.warnings = inputObject.warnings;
  newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
  return newObject;
}
function localFromBER4(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
  const incomingOffset = inputOffset;
  let returnObject = new BaseBlock4({}, ValueBlock4);
  const baseBlock = new LocalBaseBlock4;
  if (!checkBufferParams4(baseBlock, inputBuffer, inputOffset, inputLength)) {
    returnObject.error = baseBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
  if (!intBuffer.length) {
    returnObject.error = "Zero buffer length";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.idBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.idBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.idBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.idBlock.blockLength;
  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.lenBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.lenBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.lenBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.lenBlock.blockLength;
  if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
    returnObject.error = "Indefinite length form used for primitive encoding form";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let newASN1Type = BaseBlock4;
  switch (returnObject.idBlock.tagClass) {
    case 1:
      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
        returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
        return {
          offset: -1,
          result: returnObject
        };
      }
      switch (returnObject.idBlock.tagNumber) {
        case 0:
          if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
            returnObject.error = "Type [UNIVERSAL 0] is reserved";
            return {
              offset: -1,
              result: returnObject
            };
          }
          newASN1Type = typeStore4.EndOfContent;
          break;
        case 1:
          newASN1Type = typeStore4.Boolean;
          break;
        case 2:
          newASN1Type = typeStore4.Integer;
          break;
        case 3:
          newASN1Type = typeStore4.BitString;
          break;
        case 4:
          newASN1Type = typeStore4.OctetString;
          break;
        case 5:
          newASN1Type = typeStore4.Null;
          break;
        case 6:
          newASN1Type = typeStore4.ObjectIdentifier;
          break;
        case 10:
          newASN1Type = typeStore4.Enumerated;
          break;
        case 12:
          newASN1Type = typeStore4.Utf8String;
          break;
        case 13:
          newASN1Type = typeStore4.RelativeObjectIdentifier;
          break;
        case 14:
          newASN1Type = typeStore4.TIME;
          break;
        case 15:
          returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
          return {
            offset: -1,
            result: returnObject
          };
        case 16:
          newASN1Type = typeStore4.Sequence;
          break;
        case 17:
          newASN1Type = typeStore4.Set;
          break;
        case 18:
          newASN1Type = typeStore4.NumericString;
          break;
        case 19:
          newASN1Type = typeStore4.PrintableString;
          break;
        case 20:
          newASN1Type = typeStore4.TeletexString;
          break;
        case 21:
          newASN1Type = typeStore4.VideotexString;
          break;
        case 22:
          newASN1Type = typeStore4.IA5String;
          break;
        case 23:
          newASN1Type = typeStore4.UTCTime;
          break;
        case 24:
          newASN1Type = typeStore4.GeneralizedTime;
          break;
        case 25:
          newASN1Type = typeStore4.GraphicString;
          break;
        case 26:
          newASN1Type = typeStore4.VisibleString;
          break;
        case 27:
          newASN1Type = typeStore4.GeneralString;
          break;
        case 28:
          newASN1Type = typeStore4.UniversalString;
          break;
        case 29:
          newASN1Type = typeStore4.CharacterString;
          break;
        case 30:
          newASN1Type = typeStore4.BmpString;
          break;
        case 31:
          newASN1Type = typeStore4.DATE;
          break;
        case 32:
          newASN1Type = typeStore4.TimeOfDay;
          break;
        case 33:
          newASN1Type = typeStore4.DateTime;
          break;
        case 34:
          newASN1Type = typeStore4.Duration;
          break;
        default: {
          const newObject = returnObject.idBlock.isConstructed ? new typeStore4.Constructed : new typeStore4.Primitive;
          newObject.idBlock = returnObject.idBlock;
          newObject.lenBlock = returnObject.lenBlock;
          newObject.warnings = returnObject.warnings;
          returnObject = newObject;
        }
      }
      break;
    case 2:
    case 3:
    case 4:
    default: {
      newASN1Type = returnObject.idBlock.isConstructed ? typeStore4.Constructed : typeStore4.Primitive;
    }
  }
  returnObject = localChangeType4(returnObject, newASN1Type);
  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
  returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
  return {
    offset: resultOffset,
    result: returnObject
  };
}
function fromBER4(inputBuffer) {
  if (!inputBuffer.byteLength) {
    const result = new BaseBlock4({}, ValueBlock4);
    result.error = "Input buffer has zero length";
    return {
      offset: -1,
      result
    };
  }
  return localFromBER4(BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
}
function checkLen4(indefiniteLength, length) {
  if (indefiniteLength) {
    return 1;
  }
  return length;
}

class LocalConstructedValueBlock4 extends ValueBlock4 {
  constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {
    super(parameters);
    this.value = value;
    this.isIndefiniteForm = isIndefiniteForm;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams4(this, view, inputOffset, inputLength)) {
      return -1;
    }
    this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
    if (this.valueBeforeDecodeView.length === 0) {
      this.warnings.push("Zero buffer length");
      return inputOffset;
    }
    let currentOffset = inputOffset;
    while (checkLen4(this.isIndefiniteForm, inputLength) > 0) {
      const returnObject = localFromBER4(view, currentOffset, inputLength);
      if (returnObject.offset === -1) {
        this.error = returnObject.result.error;
        this.warnings.concat(returnObject.result.warnings);
        return -1;
      }
      currentOffset = returnObject.offset;
      this.blockLength += returnObject.result.blockLength;
      inputLength -= returnObject.result.blockLength;
      this.value.push(returnObject.result);
      if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME4) {
        break;
      }
    }
    if (this.isIndefiniteForm) {
      if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME4) {
        this.value.pop();
      } else {
        this.warnings.push("No EndOfContent block encoded");
      }
    }
    return currentOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter4;
    for (let i = 0;i < this.value.length; i++) {
      this.value[i].toBER(sizeOnly, _writer);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER4;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      value: []
    };
    for (const value of this.value) {
      object.value.push(value.toJSON());
    }
    return object;
  }
}
LocalConstructedValueBlock4.NAME = "ConstructedValueBlock";
var _a$v4;

class Constructed4 extends BaseBlock4 {
  constructor(parameters = {}) {
    super(parameters, LocalConstructedValueBlock4);
    this.idBlock.isConstructed = true;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    const values = [];
    for (const value of this.valueBlock.value) {
      values.push(value.toString("ascii").split(`
`).map((o) => `  ${o}`).join(`
`));
    }
    const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
    return values.length ? `${blockName} :
${values.join(`
`)}` : `${blockName} :`;
  }
}
_a$v4 = Constructed4;
(() => {
  typeStore4.Constructed = _a$v4;
})();
Constructed4.NAME = "CONSTRUCTED";

class LocalEndOfContentValueBlock4 extends ValueBlock4 {
  fromBER(inputBuffer, inputOffset, _inputLength) {
    return inputOffset;
  }
  toBER(_sizeOnly) {
    return EMPTY_BUFFER4;
  }
}
LocalEndOfContentValueBlock4.override = "EndOfContentValueBlock";
var _a$u4;

class EndOfContent4 extends BaseBlock4 {
  constructor(parameters = {}) {
    super(parameters, LocalEndOfContentValueBlock4);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 0;
  }
}
_a$u4 = EndOfContent4;
(() => {
  typeStore4.EndOfContent = _a$u4;
})();
EndOfContent4.NAME = END_OF_CONTENT_NAME4;
var _a$t4;

class Null4 extends BaseBlock4 {
  constructor(parameters = {}) {
    super(parameters, ValueBlock4);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 5;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (this.lenBlock.length > 0)
      this.warnings.push("Non-zero length of value block for Null type");
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    this.blockLength += inputLength;
    if (inputOffset + inputLength > inputBuffer.byteLength) {
      this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
      return -1;
    }
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    const retBuf = new ArrayBuffer(2);
    if (!sizeOnly) {
      const retView = new Uint8Array(retBuf);
      retView[0] = 5;
      retView[1] = 0;
    }
    if (writer) {
      writer.write(retBuf);
    }
    return retBuf;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME}`;
  }
}
_a$t4 = Null4;
(() => {
  typeStore4.Null = _a$t4;
})();
Null4.NAME = "NULL";

class LocalBooleanValueBlock4 extends HexBlock4(ValueBlock4) {
  get value() {
    for (const octet of this.valueHexView) {
      if (octet > 0) {
        return true;
      }
    }
    return false;
  }
  set value(value) {
    this.valueHexView[0] = value ? 255 : 0;
  }
  constructor({ value, ...parameters } = {}) {
    super(parameters);
    if (parameters.valueHex) {
      this.valueHexView = BufferSourceConverter.toUint8Array(parameters.valueHex);
    } else {
      this.valueHexView = new Uint8Array(1);
    }
    if (value) {
      this.value = value;
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams4(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (inputLength > 1)
      this.warnings.push("Boolean value encoded in more then 1 octet");
    this.isHexOnly = true;
    utilDecodeTC.call(this);
    this.blockLength = inputLength;
    return inputOffset + inputLength;
  }
  toBER() {
    return this.valueHexView.slice();
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalBooleanValueBlock4.NAME = "BooleanValueBlock";
var _a$s4;

class Boolean5 extends BaseBlock4 {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  constructor(parameters = {}) {
    super(parameters, LocalBooleanValueBlock4);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 1;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.getValue}`;
  }
}
_a$s4 = Boolean5;
(() => {
  typeStore4.Boolean = _a$s4;
})();
Boolean5.NAME = "BOOLEAN";

class LocalOctetStringValueBlock4 extends HexBlock4(LocalConstructedValueBlock4) {
  constructor({ isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.isConstructed = isConstructed;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = 0;
    if (this.isConstructed) {
      this.isHexOnly = false;
      resultOffset = LocalConstructedValueBlock4.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (let i = 0;i < this.value.length; i++) {
        const currentBlockName = this.value[i].constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME4) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== OCTET_STRING_NAME4) {
          this.error = "OCTET STRING may consists of OCTET STRINGs only";
          return -1;
        }
      }
    } else {
      this.isHexOnly = true;
      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
      this.blockLength = inputLength;
    }
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed)
      return LocalConstructedValueBlock4.prototype.toBER.call(this, sizeOnly, writer);
    return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isConstructed: this.isConstructed
    };
  }
}
LocalOctetStringValueBlock4.NAME = "OctetStringValueBlock";
var _a$r4;

class OctetString7 extends BaseBlock4 {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b, _c;
    (_b = parameters.isConstructed) !== null && _b !== undefined || (parameters.isConstructed = !!((_c = parameters.value) === null || _c === undefined ? undefined : _c.length));
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalOctetStringValueBlock4);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 4;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    if (inputLength === 0) {
      if (this.idBlock.error.length === 0)
        this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0)
        this.blockLength += this.lenBlock.blockLength;
      return inputOffset;
    }
    if (!this.valueBlock.isConstructed) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      const buf = view.subarray(inputOffset, inputOffset + inputLength);
      try {
        if (buf.byteLength) {
          const asn = localFromBER4(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength) {
            this.valueBlock.value = [asn.result];
          }
        }
      } catch {}
    }
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed4.prototype.onAsciiEncoding.call(this);
    }
    const name4 = this.constructor.NAME;
    const value = Convert.ToHex(this.valueBlock.valueHexView);
    return `${name4} : ${value}`;
  }
  getValue() {
    if (!this.idBlock.isConstructed) {
      return this.valueBlock.valueHexView.slice().buffer;
    }
    const array = [];
    for (const content of this.valueBlock.value) {
      if (content instanceof _a$r4) {
        array.push(content.valueBlock.valueHexView);
      }
    }
    return BufferSourceConverter.concat(array);
  }
}
_a$r4 = OctetString7;
(() => {
  typeStore4.OctetString = _a$r4;
})();
OctetString7.NAME = OCTET_STRING_NAME4;

class LocalBitStringValueBlock4 extends HexBlock4(LocalConstructedValueBlock4) {
  constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.unusedBits = unusedBits;
    this.isConstructed = isConstructed;
    this.blockLength = this.valueHexView.byteLength;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    let resultOffset = -1;
    if (this.isConstructed) {
      resultOffset = LocalConstructedValueBlock4.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (const value of this.value) {
        const currentBlockName = value.constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME4) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== BIT_STRING_NAME4) {
          this.error = "BIT STRING may consists of BIT STRINGs only";
          return -1;
        }
        const valueBlock = value.valueBlock;
        if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
          this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
          return -1;
        }
        this.unusedBits = valueBlock.unusedBits;
      }
      return resultOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams4(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.unusedBits = intBuffer[0];
    if (this.unusedBits > 7) {
      this.error = "Unused bits for BitString must be in range 0-7";
      return -1;
    }
    if (!this.unusedBits) {
      const buf = intBuffer.subarray(1);
      try {
        if (buf.byteLength) {
          const asn = localFromBER4(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength - 1) {
            this.value = [asn.result];
          }
        }
      } catch {}
    }
    this.valueHexView = intBuffer.subarray(1);
    this.blockLength = intBuffer.length;
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed) {
      return LocalConstructedValueBlock4.prototype.toBER.call(this, sizeOnly, writer);
    }
    if (sizeOnly) {
      return new ArrayBuffer(this.valueHexView.byteLength + 1);
    }
    if (!this.valueHexView.byteLength) {
      return EMPTY_BUFFER4;
    }
    const retView = new Uint8Array(this.valueHexView.length + 1);
    retView[0] = this.unusedBits;
    retView.set(this.valueHexView, 1);
    return retView.buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      unusedBits: this.unusedBits,
      isConstructed: this.isConstructed
    };
  }
}
LocalBitStringValueBlock4.NAME = "BitStringValueBlock";
var _a$q4;

class BitString7 extends BaseBlock4 {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b, _c;
    (_b = parameters.isConstructed) !== null && _b !== undefined || (parameters.isConstructed = !!((_c = parameters.value) === null || _c === undefined ? undefined : _c.length));
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalBitStringValueBlock4);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 3;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed4.prototype.onAsciiEncoding.call(this);
    } else {
      const bits = [];
      const valueHex = this.valueBlock.valueHexView;
      for (const byte of valueHex) {
        bits.push(byte.toString(2).padStart(8, "0"));
      }
      const bitsStr = bits.join("");
      const name4 = this.constructor.NAME;
      const value = bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits);
      return `${name4} : ${value}`;
    }
  }
}
_a$q4 = BitString7;
(() => {
  typeStore4.BitString = _a$q4;
})();
BitString7.NAME = BIT_STRING_NAME4;
var _a$p4;
function viewAdd4(first, second) {
  const c = new Uint8Array([0]);
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  let firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value = 0;
  const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
  let counter = 0;
  for (let i = max;i >= 0; i--, counter++) {
    switch (true) {
      case counter < secondViewCopy.length:
        value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
        break;
      default:
        value = firstViewCopy[firstViewCopyLength - counter] + c[0];
    }
    c[0] = value / 10;
    switch (true) {
      case counter >= firstViewCopy.length:
        firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
        break;
      default:
        firstViewCopy[firstViewCopyLength - counter] = value % 10;
    }
  }
  if (c[0] > 0)
    firstViewCopy = utilConcatView(c, firstViewCopy);
  return firstViewCopy;
}
function power24(n) {
  if (n >= powers24.length) {
    for (let p = powers24.length;p <= n; p++) {
      const c = new Uint8Array([0]);
      let digits = powers24[p - 1].slice(0);
      for (let i = digits.length - 1;i >= 0; i--) {
        const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
        c[0] = newValue[0] / 10;
        digits[i] = newValue[0] % 10;
      }
      if (c[0] > 0)
        digits = utilConcatView(c, digits);
      powers24.push(digits);
    }
  }
  return powers24[n];
}
function viewSub4(first, second) {
  let b = 0;
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  const firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value;
  let counter = 0;
  for (let i = secondViewCopyLength;i >= 0; i--, counter++) {
    value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
    switch (true) {
      case value < 0:
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
        break;
      default:
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
    }
  }
  if (b > 0) {
    for (let i = firstViewCopyLength - secondViewCopyLength + 1;i >= 0; i--, counter++) {
      value = firstViewCopy[firstViewCopyLength - counter] - b;
      if (value < 0) {
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
      } else {
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
        break;
      }
    }
  }
  return firstViewCopy.slice();
}

class LocalIntegerValueBlock4 extends HexBlock4(ValueBlock4) {
  setValueHex() {
    if (this.valueHexView.length >= 4) {
      this.warnings.push("Too big Integer for decoding, hex only");
      this.isHexOnly = true;
      this._valueDec = 0;
    } else {
      this.isHexOnly = false;
      if (this.valueHexView.length > 0) {
        this._valueDec = utilDecodeTC.call(this);
      }
    }
  }
  constructor({ value, ...parameters } = {}) {
    super(parameters);
    this._valueDec = 0;
    if (parameters.valueHex) {
      this.setValueHex();
    }
    if (value !== undefined) {
      this.valueDec = value;
    }
  }
  set valueDec(v) {
    this._valueDec = v;
    this.isHexOnly = false;
    this.valueHexView = new Uint8Array(utilEncodeTC(v));
  }
  get valueDec() {
    return this._valueDec;
  }
  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
    if (offset === -1)
      return offset;
    const view = this.valueHexView;
    if (view[0] === 0 && (view[1] & 128) !== 0) {
      this.valueHexView = view.subarray(1);
    } else {
      if (expectedLength !== 0) {
        if (view.length < expectedLength) {
          if (expectedLength - view.length > 1)
            expectedLength = view.length + 1;
          this.valueHexView = view.subarray(expectedLength - view.length);
        }
      }
    }
    return offset;
  }
  toDER(sizeOnly = false) {
    const view = this.valueHexView;
    switch (true) {
      case (view[0] & 128) !== 0:
        {
          const updatedView = new Uint8Array(this.valueHexView.length + 1);
          updatedView[0] = 0;
          updatedView.set(view, 1);
          this.valueHexView = updatedView;
        }
        break;
      case (view[0] === 0 && (view[1] & 128) === 0):
        {
          this.valueHexView = this.valueHexView.subarray(1);
        }
        break;
    }
    return this.toBER(sizeOnly);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
    if (resultOffset === -1) {
      return resultOffset;
    }
    this.setValueHex();
    return resultOffset;
  }
  toBER(sizeOnly) {
    return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
  toString() {
    const firstBit = this.valueHexView.length * 8 - 1;
    let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
    let bitNumber = 0;
    let currentByte;
    const asn1View = this.valueHexView;
    let result = "";
    let flag = false;
    for (let byteNumber = asn1View.byteLength - 1;byteNumber >= 0; byteNumber--) {
      currentByte = asn1View[byteNumber];
      for (let i = 0;i < 8; i++) {
        if ((currentByte & 1) === 1) {
          switch (bitNumber) {
            case firstBit:
              digits = viewSub4(power24(bitNumber), digits);
              result = "-";
              break;
            default:
              digits = viewAdd4(digits, power24(bitNumber));
          }
        }
        bitNumber++;
        currentByte >>= 1;
      }
    }
    for (let i = 0;i < digits.length; i++) {
      if (digits[i])
        flag = true;
      if (flag)
        result += digitsString4.charAt(digits[i]);
    }
    if (flag === false)
      result += digitsString4.charAt(0);
    return result;
  }
}
_a$p4 = LocalIntegerValueBlock4;
LocalIntegerValueBlock4.NAME = "IntegerValueBlock";
(() => {
  Object.defineProperty(_a$p4.prototype, "valueHex", {
    set: function(v) {
      this.valueHexView = new Uint8Array(v);
      this.setValueHex();
    },
    get: function() {
      return this.valueHexView.slice().buffer;
    }
  });
})();
var _a$o4;

class Integer4 extends BaseBlock4 {
  constructor(parameters = {}) {
    super(parameters, LocalIntegerValueBlock4);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 2;
  }
  toBigInt() {
    assertBigInt4();
    return BigInt(this.valueBlock.toString());
  }
  static fromBigInt(value) {
    assertBigInt4();
    const bigIntValue = BigInt(value);
    const writer = new ViewWriter4;
    const hex = bigIntValue.toString(16).replace(/^-/, "");
    const view = new Uint8Array(Convert.FromHex(hex));
    if (bigIntValue < 0) {
      const first = new Uint8Array(view.length + (view[0] & 128 ? 1 : 0));
      first[0] |= 128;
      const firstInt = BigInt(`0x${Convert.ToHex(first)}`);
      const secondInt = firstInt + bigIntValue;
      const second = BufferSourceConverter.toUint8Array(Convert.FromHex(secondInt.toString(16)));
      second[0] |= 128;
      writer.write(second);
    } else {
      if (view[0] & 128) {
        writer.write(new Uint8Array([0]));
      }
      writer.write(view);
    }
    const res = new _a$o4({ valueHex: writer.final() });
    return res;
  }
  convertToDER() {
    const integer = new _a$o4({ valueHex: this.valueBlock.valueHexView });
    integer.valueBlock.toDER();
    return integer;
  }
  convertFromDER() {
    return new _a$o4({
      valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
    });
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
  }
}
_a$o4 = Integer4;
(() => {
  typeStore4.Integer = _a$o4;
})();
Integer4.NAME = "INTEGER";
var _a$n4;

class Enumerated4 extends Integer4 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 10;
  }
}
_a$n4 = Enumerated4;
(() => {
  typeStore4.Enumerated = _a$n4;
})();
Enumerated4.NAME = "ENUMERATED";

class LocalSidValueBlock4 extends HexBlock4(ValueBlock4) {
  constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
    this.isFirstSid = isFirstSid;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams4(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0;i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0;i < this.blockLength; i++) {
      tempView[i] = this.valueHexView[i];
    }
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  set valueBigInt(value) {
    assertBigInt4();
    let bits = BigInt(value).toString(2);
    while (bits.length % 7) {
      bits = "0" + bits;
    }
    const bytes = new Uint8Array(bits.length / 7);
    for (let i = 0;i < bytes.length; i++) {
      bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 128 : 0);
    }
    this.fromBER(bytes.buffer, 0, bytes.length);
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0;i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER4;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0;i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      if (this.isFirstSid) {
        let sidValue = this.valueDec;
        if (this.valueDec <= 39)
          result = "0.";
        else {
          if (this.valueDec <= 79) {
            result = "1.";
            sidValue -= 40;
          } else {
            result = "2.";
            sidValue -= 80;
          }
        }
        result += sidValue.toString();
      } else
        result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec,
      isFirstSid: this.isFirstSid
    };
  }
}
LocalSidValueBlock4.NAME = "sidBlock";

class LocalObjectIdentifierValueBlock4 extends ValueBlock4 {
  constructor({ value = EMPTY_STRING4, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalSidValueBlock4;
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      if (this.value.length === 0)
        sidBlock.isFirstSid = true;
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly) {
    const retBuffers = [];
    for (let i = 0;i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER4;
      }
      retBuffers.push(valueBuf);
    }
    return concat4(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    let flag = false;
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      if (flag) {
        const sidBlock = this.value[0];
        let plus = 0;
        switch (sidBlock.valueDec) {
          case 0:
            break;
          case 1:
            plus = 40;
            break;
          case 2:
            plus = 80;
            break;
          default:
            this.value = [];
            return;
        }
        const parsedSID = parseInt(sid, 10);
        if (isNaN(parsedSID))
          return;
        sidBlock.valueDec = parsedSID + plus;
        flag = false;
      } else {
        const sidBlock = new LocalSidValueBlock4;
        if (sid > Number.MAX_SAFE_INTEGER) {
          assertBigInt4();
          const sidValue = BigInt(sid);
          sidBlock.valueBigInt = sidValue;
        } else {
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec))
            return;
        }
        if (!this.value.length) {
          sidBlock.isFirstSid = true;
          flag = true;
        }
        this.value.push(sidBlock);
      }
    } while (pos2 !== -1);
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0;i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        if (this.value[i].isFirstSid)
          result = `2.{${sidStr} - 80}`;
        else
          result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0;i < this.value.length; i++) {
      object.sidArray.push(this.value[i].toJSON());
    }
    return object;
  }
}
LocalObjectIdentifierValueBlock4.NAME = "ObjectIdentifierValueBlock";
var _a$m4;

class ObjectIdentifier4 extends BaseBlock4 {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  constructor(parameters = {}) {
    super(parameters, LocalObjectIdentifierValueBlock4);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 6;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$m4 = ObjectIdentifier4;
(() => {
  typeStore4.ObjectIdentifier = _a$m4;
})();
ObjectIdentifier4.NAME = "OBJECT IDENTIFIER";

class LocalRelativeSidValueBlock4 extends HexBlock4(LocalBaseBlock4) {
  constructor({ valueDec = 0, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (inputLength === 0)
      return inputOffset;
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams4(this, inputView, inputOffset, inputLength))
      return -1;
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0;i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0;i < this.blockLength; i++)
      tempView[i] = this.valueHexView[i];
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0;i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER4;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0;i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView.buffer;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
}
LocalRelativeSidValueBlock4.NAME = "relativeSidBlock";

class LocalRelativeObjectIdentifierValueBlock4 extends ValueBlock4 {
  constructor({ value = EMPTY_STRING4, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalRelativeSidValueBlock4;
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly, _writer) {
    const retBuffers = [];
    for (let i = 0;i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER4;
      }
      retBuffers.push(valueBuf);
    }
    return concat4(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      const sidBlock = new LocalRelativeSidValueBlock4;
      sidBlock.valueDec = parseInt(sid, 10);
      if (isNaN(sidBlock.valueDec))
        return true;
      this.value.push(sidBlock);
    } while (pos2 !== -1);
    return true;
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0;i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0;i < this.value.length; i++)
      object.sidArray.push(this.value[i].toJSON());
    return object;
  }
}
LocalRelativeObjectIdentifierValueBlock4.NAME = "RelativeObjectIdentifierValueBlock";
var _a$l4;

class RelativeObjectIdentifier4 extends BaseBlock4 {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  constructor(parameters = {}) {
    super(parameters, LocalRelativeObjectIdentifierValueBlock4);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 13;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$l4 = RelativeObjectIdentifier4;
(() => {
  typeStore4.RelativeObjectIdentifier = _a$l4;
})();
RelativeObjectIdentifier4.NAME = "RelativeObjectIdentifier";
var _a$k4;

class Sequence4 extends Constructed4 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 16;
  }
}
_a$k4 = Sequence4;
(() => {
  typeStore4.Sequence = _a$k4;
})();
Sequence4.NAME = "SEQUENCE";
var _a$j4;

class Set5 extends Constructed4 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 17;
  }
}
_a$j4 = Set5;
(() => {
  typeStore4.Set = _a$j4;
})();
Set5.NAME = "SET";

class LocalStringValueBlock4 extends HexBlock4(ValueBlock4) {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = true;
    this.value = EMPTY_STRING4;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalStringValueBlock4.NAME = "StringValueBlock";

class LocalSimpleStringValueBlock4 extends LocalStringValueBlock4 {
}
LocalSimpleStringValueBlock4.NAME = "SimpleStringValueBlock";

class LocalSimpleStringBlock4 extends BaseStringBlock4 {
  constructor({ ...parameters } = {}) {
    super(parameters, LocalSimpleStringValueBlock4);
  }
  fromBuffer(inputBuffer) {
    this.valueBlock.value = String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer));
  }
  fromString(inputString) {
    const strLen = inputString.length;
    const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
    for (let i = 0;i < strLen; i++)
      view[i] = inputString.charCodeAt(i);
    this.valueBlock.value = inputString;
  }
}
LocalSimpleStringBlock4.NAME = "SIMPLE STRING";

class LocalUtf8StringValueBlock4 extends LocalSimpleStringBlock4 {
  fromBuffer(inputBuffer) {
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
    try {
      this.valueBlock.value = Convert.ToUtf8String(inputBuffer);
    } catch (ex) {
      this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
      this.valueBlock.value = Convert.ToBinary(inputBuffer);
    }
  }
  fromString(inputString) {
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf8String(inputString));
    this.valueBlock.value = inputString;
  }
}
LocalUtf8StringValueBlock4.NAME = "Utf8StringValueBlock";
var _a$i4;

class Utf8String4 extends LocalUtf8StringValueBlock4 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 12;
  }
}
_a$i4 = Utf8String4;
(() => {
  typeStore4.Utf8String = _a$i4;
})();
Utf8String4.NAME = "UTF8String";

class LocalBmpStringValueBlock4 extends LocalSimpleStringBlock4 {
  fromBuffer(inputBuffer) {
    this.valueBlock.value = Convert.ToUtf16String(inputBuffer);
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
  }
  fromString(inputString) {
    this.valueBlock.value = inputString;
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf16String(inputString));
  }
}
LocalBmpStringValueBlock4.NAME = "BmpStringValueBlock";
var _a$h4;

class BmpString4 extends LocalBmpStringValueBlock4 {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 30;
  }
}
_a$h4 = BmpString4;
(() => {
  typeStore4.BmpString = _a$h4;
})();
BmpString4.NAME = "BMPString";

class LocalUniversalStringValueBlock4 extends LocalSimpleStringBlock4 {
  fromBuffer(inputBuffer) {
    const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
    const valueView = new Uint8Array(copyBuffer);
    for (let i = 0;i < valueView.length; i += 4) {
      valueView[i] = valueView[i + 3];
      valueView[i + 1] = valueView[i + 2];
      valueView[i + 2] = 0;
      valueView[i + 3] = 0;
    }
    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
  }
  fromString(inputString) {
    const strLength = inputString.length;
    const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
    for (let i = 0;i < strLength; i++) {
      const codeBuf = utilToBase(inputString.charCodeAt(i), 8);
      const codeView = new Uint8Array(codeBuf);
      if (codeView.length > 4)
        continue;
      const dif = 4 - codeView.length;
      for (let j = codeView.length - 1;j >= 0; j--)
        valueHexView[i * 4 + j + dif] = codeView[j];
    }
    this.valueBlock.value = inputString;
  }
}
LocalUniversalStringValueBlock4.NAME = "UniversalStringValueBlock";
var _a$g4;

class UniversalString4 extends LocalUniversalStringValueBlock4 {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 28;
  }
}
_a$g4 = UniversalString4;
(() => {
  typeStore4.UniversalString = _a$g4;
})();
UniversalString4.NAME = "UniversalString";
var _a$f4;

class NumericString4 extends LocalSimpleStringBlock4 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 18;
  }
}
_a$f4 = NumericString4;
(() => {
  typeStore4.NumericString = _a$f4;
})();
NumericString4.NAME = "NumericString";
var _a$e4;

class PrintableString4 extends LocalSimpleStringBlock4 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 19;
  }
}
_a$e4 = PrintableString4;
(() => {
  typeStore4.PrintableString = _a$e4;
})();
PrintableString4.NAME = "PrintableString";
var _a$d4;

class TeletexString4 extends LocalSimpleStringBlock4 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 20;
  }
}
_a$d4 = TeletexString4;
(() => {
  typeStore4.TeletexString = _a$d4;
})();
TeletexString4.NAME = "TeletexString";
var _a$c4;

class VideotexString4 extends LocalSimpleStringBlock4 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 21;
  }
}
_a$c4 = VideotexString4;
(() => {
  typeStore4.VideotexString = _a$c4;
})();
VideotexString4.NAME = "VideotexString";
var _a$b4;

class IA5String4 extends LocalSimpleStringBlock4 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 22;
  }
}
_a$b4 = IA5String4;
(() => {
  typeStore4.IA5String = _a$b4;
})();
IA5String4.NAME = "IA5String";
var _a$a4;

class GraphicString4 extends LocalSimpleStringBlock4 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 25;
  }
}
_a$a4 = GraphicString4;
(() => {
  typeStore4.GraphicString = _a$a4;
})();
GraphicString4.NAME = "GraphicString";
var _a$94;

class VisibleString4 extends LocalSimpleStringBlock4 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 26;
  }
}
_a$94 = VisibleString4;
(() => {
  typeStore4.VisibleString = _a$94;
})();
VisibleString4.NAME = "VisibleString";
var _a$84;

class GeneralString4 extends LocalSimpleStringBlock4 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 27;
  }
}
_a$84 = GeneralString4;
(() => {
  typeStore4.GeneralString = _a$84;
})();
GeneralString4.NAME = "GeneralString";
var _a$74;

class CharacterString4 extends LocalSimpleStringBlock4 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 29;
  }
}
_a$74 = CharacterString4;
(() => {
  typeStore4.CharacterString = _a$74;
})();
CharacterString4.NAME = "CharacterString";
var _a$64;

class UTCTime4 extends VisibleString4 {
  constructor({ value, valueDate, ...parameters } = {}) {
    super(parameters);
    this.year = 0;
    this.month = 0;
    this.day = 0;
    this.hour = 0;
    this.minute = 0;
    this.second = 0;
    if (value) {
      this.fromString(value);
      this.valueBlock.valueHexView = new Uint8Array(value.length);
      for (let i = 0;i < value.length; i++)
        this.valueBlock.valueHexView[i] = value.charCodeAt(i);
    }
    if (valueDate) {
      this.fromDate(valueDate);
      this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
    }
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 23;
  }
  fromBuffer(inputBuffer) {
    this.fromString(String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer)));
  }
  toBuffer() {
    const str = this.toString();
    const buffer = new ArrayBuffer(str.length);
    const view = new Uint8Array(buffer);
    for (let i = 0;i < str.length; i++)
      view[i] = str.charCodeAt(i);
    return buffer;
  }
  fromDate(inputDate) {
    this.year = inputDate.getUTCFullYear();
    this.month = inputDate.getUTCMonth() + 1;
    this.day = inputDate.getUTCDate();
    this.hour = inputDate.getUTCHours();
    this.minute = inputDate.getUTCMinutes();
    this.second = inputDate.getUTCSeconds();
  }
  toDate() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
  }
  fromString(inputString) {
    const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
    const parserArray = parser.exec(inputString);
    if (parserArray === null) {
      this.error = "Wrong input string for conversion";
      return;
    }
    const year = parseInt(parserArray[1], 10);
    if (year >= 50)
      this.year = 1900 + year;
    else
      this.year = 2000 + year;
    this.month = parseInt(parserArray[2], 10);
    this.day = parseInt(parserArray[3], 10);
    this.hour = parseInt(parserArray[4], 10);
    this.minute = parseInt(parserArray[5], 10);
    this.second = parseInt(parserArray[6], 10);
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = new Array(7);
      outputArray[0] = padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);
      outputArray[1] = padNumber(this.month, 2);
      outputArray[2] = padNumber(this.day, 2);
      outputArray[3] = padNumber(this.hour, 2);
      outputArray[4] = padNumber(this.minute, 2);
      outputArray[5] = padNumber(this.second, 2);
      outputArray[6] = "Z";
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second
    };
  }
}
_a$64 = UTCTime4;
(() => {
  typeStore4.UTCTime = _a$64;
})();
UTCTime4.NAME = "UTCTime";
var _a$54;

class GeneralizedTime4 extends UTCTime4 {
  constructor(parameters = {}) {
    var _b;
    super(parameters);
    (_b = this.millisecond) !== null && _b !== undefined || (this.millisecond = 0);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 24;
  }
  fromDate(inputDate) {
    super.fromDate(inputDate);
    this.millisecond = inputDate.getUTCMilliseconds();
  }
  toDate() {
    const utcDate = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond);
    return new Date(utcDate);
  }
  fromString(inputString) {
    let isUTC = false;
    let timeString = "";
    let dateTimeString = "";
    let fractionPart = 0;
    let parser;
    let hourDifference = 0;
    let minuteDifference = 0;
    if (inputString[inputString.length - 1] === "Z") {
      timeString = inputString.substring(0, inputString.length - 1);
      isUTC = true;
    } else {
      const number = new Number(inputString[inputString.length - 1]);
      if (isNaN(number.valueOf()))
        throw new Error("Wrong input string for conversion");
      timeString = inputString;
    }
    if (isUTC) {
      if (timeString.indexOf("+") !== -1)
        throw new Error("Wrong input string for conversion");
      if (timeString.indexOf("-") !== -1)
        throw new Error("Wrong input string for conversion");
    } else {
      let multiplier = 1;
      let differencePosition = timeString.indexOf("+");
      let differenceString = "";
      if (differencePosition === -1) {
        differencePosition = timeString.indexOf("-");
        multiplier = -1;
      }
      if (differencePosition !== -1) {
        differenceString = timeString.substring(differencePosition + 1);
        timeString = timeString.substring(0, differencePosition);
        if (differenceString.length !== 2 && differenceString.length !== 4)
          throw new Error("Wrong input string for conversion");
        let number = parseInt(differenceString.substring(0, 2), 10);
        if (isNaN(number.valueOf()))
          throw new Error("Wrong input string for conversion");
        hourDifference = multiplier * number;
        if (differenceString.length === 4) {
          number = parseInt(differenceString.substring(2, 4), 10);
          if (isNaN(number.valueOf()))
            throw new Error("Wrong input string for conversion");
          minuteDifference = multiplier * number;
        }
      }
    }
    let fractionPointPosition = timeString.indexOf(".");
    if (fractionPointPosition === -1)
      fractionPointPosition = timeString.indexOf(",");
    if (fractionPointPosition !== -1) {
      const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
      if (isNaN(fractionPartCheck.valueOf()))
        throw new Error("Wrong input string for conversion");
      fractionPart = fractionPartCheck.valueOf();
      dateTimeString = timeString.substring(0, fractionPointPosition);
    } else
      dateTimeString = timeString;
    switch (true) {
      case dateTimeString.length === 8:
        parser = /(\d{4})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1)
          throw new Error("Wrong input string for conversion");
        break;
      case dateTimeString.length === 10:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.minute = Math.floor(fractionResult);
          fractionResult = 60 * (fractionResult - this.minute);
          this.second = Math.floor(fractionResult);
          fractionResult = 1000 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 12:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.second = Math.floor(fractionResult);
          fractionResult = 1000 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 14:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          const fractionResult = 1000 * fractionPart;
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      default:
        throw new Error("Wrong input string for conversion");
    }
    const parserArray = parser.exec(dateTimeString);
    if (parserArray === null)
      throw new Error("Wrong input string for conversion");
    for (let j = 1;j < parserArray.length; j++) {
      switch (j) {
        case 1:
          this.year = parseInt(parserArray[j], 10);
          break;
        case 2:
          this.month = parseInt(parserArray[j], 10);
          break;
        case 3:
          this.day = parseInt(parserArray[j], 10);
          break;
        case 4:
          this.hour = parseInt(parserArray[j], 10) + hourDifference;
          break;
        case 5:
          this.minute = parseInt(parserArray[j], 10) + minuteDifference;
          break;
        case 6:
          this.second = parseInt(parserArray[j], 10);
          break;
        default:
          throw new Error("Wrong input string for conversion");
      }
    }
    if (isUTC === false) {
      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
      this.year = tempDate.getUTCFullYear();
      this.month = tempDate.getUTCMonth();
      this.day = tempDate.getUTCDay();
      this.hour = tempDate.getUTCHours();
      this.minute = tempDate.getUTCMinutes();
      this.second = tempDate.getUTCSeconds();
      this.millisecond = tempDate.getUTCMilliseconds();
    }
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = [];
      outputArray.push(padNumber(this.year, 4));
      outputArray.push(padNumber(this.month, 2));
      outputArray.push(padNumber(this.day, 2));
      outputArray.push(padNumber(this.hour, 2));
      outputArray.push(padNumber(this.minute, 2));
      outputArray.push(padNumber(this.second, 2));
      if (this.millisecond !== 0) {
        outputArray.push(".");
        outputArray.push(padNumber(this.millisecond, 3));
      }
      outputArray.push("Z");
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  toJSON() {
    return {
      ...super.toJSON(),
      millisecond: this.millisecond
    };
  }
}
_a$54 = GeneralizedTime4;
(() => {
  typeStore4.GeneralizedTime = _a$54;
})();
GeneralizedTime4.NAME = "GeneralizedTime";
var _a$44;

class DATE4 extends Utf8String4 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 31;
  }
}
_a$44 = DATE4;
(() => {
  typeStore4.DATE = _a$44;
})();
DATE4.NAME = "DATE";
var _a$34;

class TimeOfDay4 extends Utf8String4 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 32;
  }
}
_a$34 = TimeOfDay4;
(() => {
  typeStore4.TimeOfDay = _a$34;
})();
TimeOfDay4.NAME = "TimeOfDay";
var _a$24;

class DateTime4 extends Utf8String4 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 33;
  }
}
_a$24 = DateTime4;
(() => {
  typeStore4.DateTime = _a$24;
})();
DateTime4.NAME = "DateTime";
var _a$14;

class Duration4 extends Utf8String4 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 34;
  }
}
_a$14 = Duration4;
(() => {
  typeStore4.Duration = _a$14;
})();
Duration4.NAME = "Duration";
var _a4;

class TIME4 extends Utf8String4 {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 14;
  }
}
_a4 = TIME4;
(() => {
  typeStore4.TIME = _a4;
})();
TIME4.NAME = "TIME";

class Any4 {
  constructor({ name: name4 = EMPTY_STRING4, optional = false } = {}) {
    this.name = name4;
    this.optional = optional;
  }
}

class Choice4 extends Any4 {
  constructor({ value = [], ...parameters } = {}) {
    super(parameters);
    this.value = value;
  }
}

class Repeated4 extends Any4 {
  constructor({ value = new Any4, local = false, ...parameters } = {}) {
    super(parameters);
    this.value = value;
    this.local = local;
  }
}

class RawData4 {
  get data() {
    return this.dataView.slice().buffer;
  }
  set data(value) {
    this.dataView = BufferSourceConverter.toUint8Array(value);
  }
  constructor({ data = EMPTY_VIEW4 } = {}) {
    this.dataView = BufferSourceConverter.toUint8Array(data);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const endLength = inputOffset + inputLength;
    this.dataView = BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
    return endLength;
  }
  toBER(_sizeOnly) {
    return this.dataView.slice().buffer;
  }
}
function compareSchema4(root, inputData, inputSchema) {
  if (inputSchema instanceof Choice4) {
    for (const element of inputSchema.value) {
      const result = compareSchema4(root, inputData, element);
      if (result.verified) {
        return {
          verified: true,
          result: root
        };
      }
    }
    {
      const _result = {
        verified: false,
        result: { error: "Wrong values for Choice type" }
      };
      if (inputSchema.hasOwnProperty(NAME4))
        _result.name = inputSchema.name;
      return _result;
    }
  }
  if (inputSchema instanceof Any4) {
    if (inputSchema.hasOwnProperty(NAME4))
      root[inputSchema.name] = inputData;
    return {
      verified: true,
      result: root
    };
  }
  if (root instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong root object" }
    };
  }
  if (inputData instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 data" }
    };
  }
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (ID_BLOCK4 in inputSchema === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (FROM_BER4 in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (TO_BER4 in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  const encodedId = inputSchema.idBlock.toBER(false);
  if (encodedId.byteLength === 0) {
    return {
      verified: false,
      result: { error: "Error encoding idBlock for ASN.1 schema" }
    };
  }
  const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
  if (decodedOffset === -1) {
    return {
      verified: false,
      result: { error: "Error decoding idBlock for ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS4) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER4) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED4) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
    return {
      verified: false,
      result: root
    };
  }
  if (!(IS_HEX_ONLY4 in inputSchema.idBlock)) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.isHexOnly) {
    if (VALUE_HEX_VIEW4 in inputSchema.idBlock === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    const schemaView = inputSchema.idBlock.valueHexView;
    const asn1View = inputData.idBlock.valueHexView;
    if (schemaView.length !== asn1View.length) {
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0;i < schemaView.length; i++) {
      if (schemaView[i] !== asn1View[1]) {
        return {
          verified: false,
          result: root
        };
      }
    }
  }
  if (inputSchema.name) {
    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING4);
    if (inputSchema.name)
      root[inputSchema.name] = inputData;
  }
  if (inputSchema instanceof typeStore4.Constructed) {
    let admission = 0;
    let result = {
      verified: false,
      result: { error: "Unknown error" }
    };
    let maxLength = inputSchema.valueBlock.value.length;
    if (maxLength > 0) {
      if (inputSchema.valueBlock.value[0] instanceof Repeated4) {
        maxLength = inputData.valueBlock.value.length;
      }
    }
    if (maxLength === 0) {
      return {
        verified: true,
        result: root
      };
    }
    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
      let _optional = true;
      for (let i = 0;i < inputSchema.valueBlock.value.length; i++)
        _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);
      if (_optional) {
        return {
          verified: true,
          result: root
        };
      }
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING4);
        if (inputSchema.name)
          delete root[inputSchema.name];
      }
      root.error = "Inconsistent object length";
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0;i < maxLength; i++) {
      if (i - admission >= inputData.valueBlock.value.length) {
        if (inputSchema.valueBlock.value[i].optional === false) {
          const _result = {
            verified: false,
            result: root
          };
          root.error = "Inconsistent length between ASN.1 data and schema";
          if (inputSchema.name) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING4);
            if (inputSchema.name) {
              delete root[inputSchema.name];
              _result.name = inputSchema.name;
            }
          }
          return _result;
        }
      } else {
        if (inputSchema.valueBlock.value[0] instanceof Repeated4) {
          result = compareSchema4(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[0].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING4);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
          if (NAME4 in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
            let arrayRoot = {};
            if (LOCAL4 in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local)
              arrayRoot = inputData;
            else
              arrayRoot = root;
            if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
              arrayRoot[inputSchema.valueBlock.value[0].name] = [];
            arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
          }
        } else {
          result = compareSchema4(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[i].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING4);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
        }
      }
    }
    if (result.verified === false) {
      const _result = {
        verified: false,
        result: root
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING4);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return {
      verified: true,
      result: root
    };
  }
  if (inputSchema.primitiveSchema && VALUE_HEX_VIEW4 in inputData.valueBlock) {
    const asn1 = localFromBER4(inputData.valueBlock.valueHexView);
    if (asn1.offset === -1) {
      const _result = {
        verified: false,
        result: asn1.result
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING4);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return compareSchema4(root, asn1.result, inputSchema.primitiveSchema);
  }
  return {
    verified: true,
    result: root
  };
}
function verifySchema4(inputBuffer, inputSchema) {
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema type" }
    };
  }
  const asn1 = localFromBER4(BufferSourceConverter.toUint8Array(inputBuffer));
  if (asn1.offset === -1) {
    return {
      verified: false,
      result: asn1.result
    };
  }
  return compareSchema4(asn1.result, asn1.result, inputSchema);
}

// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-schema/build/es2015/enums.js
var AsnTypeTypes4;
(function(AsnTypeTypes5) {
  AsnTypeTypes5[AsnTypeTypes5["Sequence"] = 0] = "Sequence";
  AsnTypeTypes5[AsnTypeTypes5["Set"] = 1] = "Set";
  AsnTypeTypes5[AsnTypeTypes5["Choice"] = 2] = "Choice";
})(AsnTypeTypes4 || (AsnTypeTypes4 = {}));
var AsnPropTypes4;
(function(AsnPropTypes5) {
  AsnPropTypes5[AsnPropTypes5["Any"] = 1] = "Any";
  AsnPropTypes5[AsnPropTypes5["Boolean"] = 2] = "Boolean";
  AsnPropTypes5[AsnPropTypes5["OctetString"] = 3] = "OctetString";
  AsnPropTypes5[AsnPropTypes5["BitString"] = 4] = "BitString";
  AsnPropTypes5[AsnPropTypes5["Integer"] = 5] = "Integer";
  AsnPropTypes5[AsnPropTypes5["Enumerated"] = 6] = "Enumerated";
  AsnPropTypes5[AsnPropTypes5["ObjectIdentifier"] = 7] = "ObjectIdentifier";
  AsnPropTypes5[AsnPropTypes5["Utf8String"] = 8] = "Utf8String";
  AsnPropTypes5[AsnPropTypes5["BmpString"] = 9] = "BmpString";
  AsnPropTypes5[AsnPropTypes5["UniversalString"] = 10] = "UniversalString";
  AsnPropTypes5[AsnPropTypes5["NumericString"] = 11] = "NumericString";
  AsnPropTypes5[AsnPropTypes5["PrintableString"] = 12] = "PrintableString";
  AsnPropTypes5[AsnPropTypes5["TeletexString"] = 13] = "TeletexString";
  AsnPropTypes5[AsnPropTypes5["VideotexString"] = 14] = "VideotexString";
  AsnPropTypes5[AsnPropTypes5["IA5String"] = 15] = "IA5String";
  AsnPropTypes5[AsnPropTypes5["GraphicString"] = 16] = "GraphicString";
  AsnPropTypes5[AsnPropTypes5["VisibleString"] = 17] = "VisibleString";
  AsnPropTypes5[AsnPropTypes5["GeneralString"] = 18] = "GeneralString";
  AsnPropTypes5[AsnPropTypes5["CharacterString"] = 19] = "CharacterString";
  AsnPropTypes5[AsnPropTypes5["UTCTime"] = 20] = "UTCTime";
  AsnPropTypes5[AsnPropTypes5["GeneralizedTime"] = 21] = "GeneralizedTime";
  AsnPropTypes5[AsnPropTypes5["DATE"] = 22] = "DATE";
  AsnPropTypes5[AsnPropTypes5["TimeOfDay"] = 23] = "TimeOfDay";
  AsnPropTypes5[AsnPropTypes5["DateTime"] = 24] = "DateTime";
  AsnPropTypes5[AsnPropTypes5["Duration"] = 25] = "Duration";
  AsnPropTypes5[AsnPropTypes5["TIME"] = 26] = "TIME";
  AsnPropTypes5[AsnPropTypes5["Null"] = 27] = "Null";
})(AsnPropTypes4 || (AsnPropTypes4 = {}));

// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-schema/build/es2015/types/bit_string.js
class BitString8 {
  constructor(params, unusedBits = 0) {
    this.unusedBits = 0;
    this.value = new ArrayBuffer(0);
    if (params) {
      if (typeof params === "number") {
        this.fromNumber(params);
      } else if (BufferSourceConverter.isBufferSource(params)) {
        this.unusedBits = unusedBits;
        this.value = BufferSourceConverter.toArrayBuffer(params);
      } else {
        throw TypeError("Unsupported type of 'params' argument for BitString");
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof BitString7)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 BitString");
    }
    this.unusedBits = asn.valueBlock.unusedBits;
    this.value = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new BitString7({ unusedBits: this.unusedBits, valueHex: this.value });
  }
  toSchema(name4) {
    return new BitString7({ name: name4 });
  }
  toNumber() {
    let res = "";
    const uintArray = new Uint8Array(this.value);
    for (const octet of uintArray) {
      res += octet.toString(2).padStart(8, "0");
    }
    res = res.split("").reverse().join("");
    if (this.unusedBits) {
      res = res.slice(this.unusedBits).padStart(this.unusedBits, "0");
    }
    return parseInt(res, 2);
  }
  fromNumber(value) {
    let bits = value.toString(2);
    const octetSize = bits.length + 7 >> 3;
    this.unusedBits = (octetSize << 3) - bits.length;
    const octets = new Uint8Array(octetSize);
    bits = bits.padStart(octetSize << 3, "0").split("").reverse().join("");
    let index = 0;
    while (index < octetSize) {
      octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);
      index++;
    }
    this.value = octets.buffer;
  }
}
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-schema/build/es2015/types/octet_string.js
class OctetString8 {
  get byteLength() {
    return this.buffer.byteLength;
  }
  get byteOffset() {
    return 0;
  }
  constructor(param) {
    if (typeof param === "number") {
      this.buffer = new ArrayBuffer(param);
    } else {
      if (BufferSourceConverter.isBufferSource(param)) {
        this.buffer = BufferSourceConverter.toArrayBuffer(param);
      } else if (Array.isArray(param)) {
        this.buffer = new Uint8Array(param);
      } else {
        this.buffer = new ArrayBuffer(0);
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof OctetString7)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString");
    }
    this.buffer = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new OctetString7({ valueHex: this.buffer });
  }
  toSchema(name4) {
    return new OctetString7({ name: name4 });
  }
}
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-schema/build/es2015/converters.js
var AsnAnyConverter4 = {
  fromASN: (value) => value instanceof Null4 ? null : value.valueBeforeDecodeView,
  toASN: (value) => {
    if (value === null) {
      return new Null4;
    }
    const schema = fromBER4(value);
    if (schema.result.error) {
      throw new Error(schema.result.error);
    }
    return schema.result;
  }
};
var AsnIntegerConverter4 = {
  fromASN: (value) => value.valueBlock.valueHexView.byteLength >= 4 ? value.valueBlock.toString() : value.valueBlock.valueDec,
  toASN: (value) => new Integer4({ value: +value })
};
var AsnEnumeratedConverter4 = {
  fromASN: (value) => value.valueBlock.valueDec,
  toASN: (value) => new Enumerated4({ value })
};
var AsnIntegerArrayBufferConverter4 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new Integer4({ valueHex: value })
};
var AsnBitStringConverter4 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new BitString7({ valueHex: value })
};
var AsnObjectIdentifierConverter4 = {
  fromASN: (value) => value.valueBlock.toString(),
  toASN: (value) => new ObjectIdentifier4({ value })
};
var AsnBooleanConverter4 = {
  fromASN: (value) => value.valueBlock.value,
  toASN: (value) => new Boolean5({ value })
};
var AsnOctetStringConverter4 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new OctetString7({ valueHex: value })
};
function createStringConverter4(Asn1Type) {
  return {
    fromASN: (value) => value.valueBlock.value,
    toASN: (value) => new Asn1Type({ value })
  };
}
var AsnUtf8StringConverter4 = createStringConverter4(Utf8String4);
var AsnBmpStringConverter4 = createStringConverter4(BmpString4);
var AsnUniversalStringConverter4 = createStringConverter4(UniversalString4);
var AsnNumericStringConverter4 = createStringConverter4(NumericString4);
var AsnPrintableStringConverter4 = createStringConverter4(PrintableString4);
var AsnTeletexStringConverter4 = createStringConverter4(TeletexString4);
var AsnVideotexStringConverter4 = createStringConverter4(VideotexString4);
var AsnIA5StringConverter4 = createStringConverter4(IA5String4);
var AsnGraphicStringConverter4 = createStringConverter4(GraphicString4);
var AsnVisibleStringConverter4 = createStringConverter4(VisibleString4);
var AsnGeneralStringConverter4 = createStringConverter4(GeneralString4);
var AsnCharacterStringConverter4 = createStringConverter4(CharacterString4);
var AsnUTCTimeConverter4 = {
  fromASN: (value) => value.toDate(),
  toASN: (value) => new UTCTime4({ valueDate: value })
};
var AsnGeneralizedTimeConverter4 = {
  fromASN: (value) => value.toDate(),
  toASN: (value) => new GeneralizedTime4({ valueDate: value })
};
var AsnNullConverter4 = {
  fromASN: () => null,
  toASN: () => {
    return new Null4;
  }
};
function defaultConverter4(type) {
  switch (type) {
    case AsnPropTypes4.Any:
      return AsnAnyConverter4;
    case AsnPropTypes4.BitString:
      return AsnBitStringConverter4;
    case AsnPropTypes4.BmpString:
      return AsnBmpStringConverter4;
    case AsnPropTypes4.Boolean:
      return AsnBooleanConverter4;
    case AsnPropTypes4.CharacterString:
      return AsnCharacterStringConverter4;
    case AsnPropTypes4.Enumerated:
      return AsnEnumeratedConverter4;
    case AsnPropTypes4.GeneralString:
      return AsnGeneralStringConverter4;
    case AsnPropTypes4.GeneralizedTime:
      return AsnGeneralizedTimeConverter4;
    case AsnPropTypes4.GraphicString:
      return AsnGraphicStringConverter4;
    case AsnPropTypes4.IA5String:
      return AsnIA5StringConverter4;
    case AsnPropTypes4.Integer:
      return AsnIntegerConverter4;
    case AsnPropTypes4.Null:
      return AsnNullConverter4;
    case AsnPropTypes4.NumericString:
      return AsnNumericStringConverter4;
    case AsnPropTypes4.ObjectIdentifier:
      return AsnObjectIdentifierConverter4;
    case AsnPropTypes4.OctetString:
      return AsnOctetStringConverter4;
    case AsnPropTypes4.PrintableString:
      return AsnPrintableStringConverter4;
    case AsnPropTypes4.TeletexString:
      return AsnTeletexStringConverter4;
    case AsnPropTypes4.UTCTime:
      return AsnUTCTimeConverter4;
    case AsnPropTypes4.UniversalString:
      return AsnUniversalStringConverter4;
    case AsnPropTypes4.Utf8String:
      return AsnUtf8StringConverter4;
    case AsnPropTypes4.VideotexString:
      return AsnVideotexStringConverter4;
    case AsnPropTypes4.VisibleString:
      return AsnVisibleStringConverter4;
    default:
      return null;
  }
}
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-schema/build/es2015/helper.js
function isConvertible4(target) {
  if (typeof target === "function" && target.prototype) {
    if (target.prototype.toASN && target.prototype.fromASN) {
      return true;
    } else {
      return isConvertible4(target.prototype);
    }
  } else {
    return !!(target && typeof target === "object" && ("toASN" in target) && ("fromASN" in target));
  }
}

// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-schema/build/es2015/schema.js
class AsnSchemaStorage4 {
  constructor() {
    this.items = new WeakMap;
  }
  has(target) {
    return this.items.has(target);
  }
  get(target, checkSchema = false) {
    const schema = this.items.get(target);
    if (!schema) {
      throw new Error(`Cannot get schema for '${target.prototype.constructor.name}' target`);
    }
    if (checkSchema && !schema.schema) {
      throw new Error(`Schema '${target.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);
    }
    return schema;
  }
  cache(target) {
    const schema = this.get(target);
    if (!schema.schema) {
      schema.schema = this.create(target, true);
    }
  }
  createDefault(target) {
    const schema = { type: AsnTypeTypes4.Sequence, items: {} };
    const parentSchema = this.findParentSchema(target);
    if (parentSchema) {
      Object.assign(schema, parentSchema);
      schema.items = Object.assign({}, schema.items, parentSchema.items);
    }
    return schema;
  }
  create(target, useNames) {
    const schema = this.items.get(target) || this.createDefault(target);
    const asn1Value = [];
    for (const key in schema.items) {
      const item = schema.items[key];
      const name4 = useNames ? key : "";
      let asn1Item;
      if (typeof item.type === "number") {
        const Asn1TypeName = AsnPropTypes4[item.type];
        const Asn1Type = exports_index_es5[Asn1TypeName];
        if (!Asn1Type) {
          throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
        }
        asn1Item = new Asn1Type({ name: name4 });
      } else if (isConvertible4(item.type)) {
        const instance = new item.type;
        asn1Item = instance.toSchema(name4);
      } else if (item.optional) {
        const itemSchema = this.get(item.type);
        if (itemSchema.type === AsnTypeTypes4.Choice) {
          asn1Item = new Any4({ name: name4 });
        } else {
          asn1Item = this.create(item.type, false);
          asn1Item.name = name4;
        }
      } else {
        asn1Item = new Any4({ name: name4 });
      }
      const optional = !!item.optional || item.defaultValue !== undefined;
      if (item.repeated) {
        asn1Item.name = "";
        const Container = item.repeated === "set" ? Set5 : Sequence4;
        asn1Item = new Container({
          name: "",
          value: [new Repeated4({ name: name4, value: asn1Item })]
        });
      }
      if (item.context !== null && item.context !== undefined) {
        if (item.implicit) {
          if (typeof item.type === "number" || isConvertible4(item.type)) {
            const Container = item.repeated ? Constructed4 : Primitive4;
            asn1Value.push(new Container({ name: name4, optional, idBlock: { tagClass: 3, tagNumber: item.context } }));
          } else {
            this.cache(item.type);
            const isRepeated = !!item.repeated;
            let value = !isRepeated ? this.get(item.type, true).schema : asn1Item;
            value = "valueBlock" in value ? value.valueBlock.value : value.value;
            asn1Value.push(new Constructed4({
              name: !isRepeated ? name4 : "",
              optional,
              idBlock: { tagClass: 3, tagNumber: item.context },
              value
            }));
          }
        } else {
          asn1Value.push(new Constructed4({
            optional,
            idBlock: { tagClass: 3, tagNumber: item.context },
            value: [asn1Item]
          }));
        }
      } else {
        asn1Item.optional = optional;
        asn1Value.push(asn1Item);
      }
    }
    switch (schema.type) {
      case AsnTypeTypes4.Sequence:
        return new Sequence4({ value: asn1Value, name: "" });
      case AsnTypeTypes4.Set:
        return new Set5({ value: asn1Value, name: "" });
      case AsnTypeTypes4.Choice:
        return new Choice4({ value: asn1Value, name: "" });
      default:
        throw new Error(`Unsupported ASN1 type in use`);
    }
  }
  set(target, schema) {
    this.items.set(target, schema);
    return this;
  }
  findParentSchema(target) {
    const parent = Object.getPrototypeOf(target);
    if (parent) {
      const schema = this.items.get(parent);
      return schema || this.findParentSchema(parent);
    }
    return null;
  }
}

// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-schema/build/es2015/storage.js
var schemaStorage4 = new AsnSchemaStorage4;

// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-schema/build/es2015/decorators.js
var AsnType4 = (options) => (target) => {
  let schema;
  if (!schemaStorage4.has(target)) {
    schema = schemaStorage4.createDefault(target);
    schemaStorage4.set(target, schema);
  } else {
    schema = schemaStorage4.get(target);
  }
  Object.assign(schema, options);
};
var AsnProp4 = (options) => (target, propertyKey) => {
  let schema;
  if (!schemaStorage4.has(target.constructor)) {
    schema = schemaStorage4.createDefault(target.constructor);
    schemaStorage4.set(target.constructor, schema);
  } else {
    schema = schemaStorage4.get(target.constructor);
  }
  const copyOptions = Object.assign({}, options);
  if (typeof copyOptions.type === "number" && !copyOptions.converter) {
    const defaultConverter5 = defaultConverter4(options.type);
    if (!defaultConverter5) {
      throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target.constructor.name}`);
    }
    copyOptions.converter = defaultConverter5;
  }
  copyOptions.raw = options.raw;
  schema.items[propertyKey] = copyOptions;
};
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-schema/build/es2015/objects.js
class AsnArray4 extends Array {
  constructor(items = []) {
    if (typeof items === "number") {
      super(items);
    } else {
      super();
      for (const item of items) {
        this.push(item);
      }
    }
  }
}
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/ip_converter.js
class IpConverter4 {
  static isIPv4(ip2) {
    return /^(\d{1,3}\.){3}\d{1,3}$/.test(ip2);
  }
  static parseIPv4(ip2) {
    const parts = ip2.split(".");
    if (parts.length !== 4) {
      throw new Error("Invalid IPv4 address");
    }
    return parts.map((part) => {
      const num = parseInt(part, 10);
      if (isNaN(num) || num < 0 || num > 255) {
        throw new Error("Invalid IPv4 address part");
      }
      return num;
    });
  }
  static parseIPv6(ip2) {
    const expandedIP = this.expandIPv6(ip2);
    const parts = expandedIP.split(":");
    if (parts.length !== 8) {
      throw new Error("Invalid IPv6 address");
    }
    return parts.reduce((bytes, part) => {
      const num = parseInt(part, 16);
      if (isNaN(num) || num < 0 || num > 65535) {
        throw new Error("Invalid IPv6 address part");
      }
      bytes.push(num >> 8 & 255);
      bytes.push(num & 255);
      return bytes;
    }, []);
  }
  static expandIPv6(ip2) {
    if (!ip2.includes("::")) {
      return ip2;
    }
    const parts = ip2.split("::");
    if (parts.length > 2) {
      throw new Error("Invalid IPv6 address");
    }
    const left = parts[0] ? parts[0].split(":") : [];
    const right = parts[1] ? parts[1].split(":") : [];
    const missing = 8 - (left.length + right.length);
    if (missing < 0) {
      throw new Error("Invalid IPv6 address");
    }
    return [...left, ...Array(missing).fill("0"), ...right].join(":");
  }
  static formatIPv6(bytes) {
    const parts = [];
    for (let i = 0;i < 16; i += 2) {
      parts.push((bytes[i] << 8 | bytes[i + 1]).toString(16));
    }
    return this.compressIPv6(parts.join(":"));
  }
  static compressIPv6(ip2) {
    const parts = ip2.split(":");
    let longestZeroStart = -1;
    let longestZeroLength = 0;
    let currentZeroStart = -1;
    let currentZeroLength = 0;
    for (let i = 0;i < parts.length; i++) {
      if (parts[i] === "0") {
        if (currentZeroStart === -1) {
          currentZeroStart = i;
        }
        currentZeroLength++;
      } else {
        if (currentZeroLength > longestZeroLength) {
          longestZeroStart = currentZeroStart;
          longestZeroLength = currentZeroLength;
        }
        currentZeroStart = -1;
        currentZeroLength = 0;
      }
    }
    if (currentZeroLength > longestZeroLength) {
      longestZeroStart = currentZeroStart;
      longestZeroLength = currentZeroLength;
    }
    if (longestZeroLength > 1) {
      const before = parts.slice(0, longestZeroStart).join(":");
      const after = parts.slice(longestZeroStart + longestZeroLength).join(":");
      return `${before}::${after}`;
    }
    return ip2;
  }
  static parseCIDR(text) {
    const [addr, prefixStr] = text.split("/");
    const prefix = parseInt(prefixStr, 10);
    if (this.isIPv4(addr)) {
      if (prefix < 0 || prefix > 32) {
        throw new Error("Invalid IPv4 prefix length");
      }
      return [this.parseIPv4(addr), prefix];
    } else {
      if (prefix < 0 || prefix > 128) {
        throw new Error("Invalid IPv6 prefix length");
      }
      return [this.parseIPv6(addr), prefix];
    }
  }
  static decodeIP(value) {
    if (value.length === 64 && parseInt(value, 16) === 0) {
      return "::/0";
    }
    if (value.length !== 16) {
      return value;
    }
    const mask = parseInt(value.slice(8), 16).toString(2).split("").reduce((a, k) => a + +k, 0);
    let ip2 = value.slice(0, 8).replace(/(.{2})/g, (match2) => `${parseInt(match2, 16)}.`);
    ip2 = ip2.slice(0, -1);
    return `${ip2}/${mask}`;
  }
  static toString(buf) {
    const uint8 = new Uint8Array(buf);
    if (uint8.length === 4) {
      return Array.from(uint8).join(".");
    }
    if (uint8.length === 16) {
      return this.formatIPv6(uint8);
    }
    if (uint8.length === 8 || uint8.length === 32) {
      const half = uint8.length / 2;
      const addrBytes = uint8.slice(0, half);
      const maskBytes = uint8.slice(half);
      const isAllZeros = uint8.every((byte) => byte === 0);
      if (isAllZeros) {
        return uint8.length === 8 ? "0.0.0.0/0" : "::/0";
      }
      const prefixLen = maskBytes.reduce((a, b) => a + (b.toString(2).match(/1/g) || []).length, 0);
      if (uint8.length === 8) {
        const addrStr = Array.from(addrBytes).join(".");
        return `${addrStr}/${prefixLen}`;
      } else {
        const addrStr = this.formatIPv6(addrBytes);
        return `${addrStr}/${prefixLen}`;
      }
    }
    return this.decodeIP(Convert.ToHex(buf));
  }
  static fromString(text) {
    if (text.includes("/")) {
      const [addr, prefix] = this.parseCIDR(text);
      const maskBytes = new Uint8Array(addr.length);
      let bitsLeft = prefix;
      for (let i = 0;i < maskBytes.length; i++) {
        if (bitsLeft >= 8) {
          maskBytes[i] = 255;
          bitsLeft -= 8;
        } else if (bitsLeft > 0) {
          maskBytes[i] = 255 << 8 - bitsLeft;
          bitsLeft = 0;
        }
      }
      const out = new Uint8Array(addr.length * 2);
      out.set(addr, 0);
      out.set(maskBytes, addr.length);
      return out.buffer;
    }
    const bytes = this.isIPv4(text) ? this.parseIPv4(text) : this.parseIPv6(text);
    return new Uint8Array(bytes).buffer;
  }
}

// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/name.js
var RelativeDistinguishedName_14;
var RDNSequence_14;
var Name_14;
var DirectoryString7 = class DirectoryString8 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.bmpString || this.printableString || this.teletexString || this.universalString || this.utf8String || "";
  }
};
__decorate([
  AsnProp4({ type: AsnPropTypes4.TeletexString })
], DirectoryString7.prototype, "teletexString", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.PrintableString })
], DirectoryString7.prototype, "printableString", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.UniversalString })
], DirectoryString7.prototype, "universalString", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.Utf8String })
], DirectoryString7.prototype, "utf8String", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.BmpString })
], DirectoryString7.prototype, "bmpString", undefined);
DirectoryString7 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Choice })
], DirectoryString7);
var AttributeValue7 = class AttributeValue8 extends DirectoryString7 {
  constructor(params = {}) {
    super(params);
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || (this.anyValue ? Convert.ToHex(this.anyValue) : super.toString());
  }
};
__decorate([
  AsnProp4({ type: AsnPropTypes4.IA5String })
], AttributeValue7.prototype, "ia5String", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.Any })
], AttributeValue7.prototype, "anyValue", undefined);
AttributeValue7 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Choice })
], AttributeValue7);
class AttributeTypeAndValue4 {
  constructor(params = {}) {
    this.type = "";
    this.value = new AttributeValue7;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AsnPropTypes4.ObjectIdentifier })
], AttributeTypeAndValue4.prototype, "type", undefined);
__decorate([
  AsnProp4({ type: AttributeValue7 })
], AttributeTypeAndValue4.prototype, "value", undefined);
var RelativeDistinguishedName7 = RelativeDistinguishedName_14 = class RelativeDistinguishedName8 extends AsnArray4 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RelativeDistinguishedName_14.prototype);
  }
};
RelativeDistinguishedName7 = RelativeDistinguishedName_14 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Set, itemType: AttributeTypeAndValue4 })
], RelativeDistinguishedName7);
var RDNSequence7 = RDNSequence_14 = class RDNSequence8 extends AsnArray4 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RDNSequence_14.prototype);
  }
};
RDNSequence7 = RDNSequence_14 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Sequence, itemType: RelativeDistinguishedName7 })
], RDNSequence7);
var Name7 = Name_14 = class Name8 extends RDNSequence7 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Name_14.prototype);
  }
};
Name7 = Name_14 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Sequence })
], Name7);

// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/general_name.js
var AsnIpConverter4 = {
  fromASN: (value) => IpConverter4.toString(AsnOctetStringConverter4.fromASN(value)),
  toASN: (value) => AsnOctetStringConverter4.toASN(IpConverter4.fromString(value))
};

class OtherName4 {
  constructor(params = {}) {
    this.typeId = "";
    this.value = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AsnPropTypes4.ObjectIdentifier })
], OtherName4.prototype, "typeId", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.Any, context: 0 })
], OtherName4.prototype, "value", undefined);

class EDIPartyName4 {
  constructor(params = {}) {
    this.partyName = new DirectoryString7;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: DirectoryString7, optional: true, context: 0, implicit: true })
], EDIPartyName4.prototype, "nameAssigner", undefined);
__decorate([
  AsnProp4({ type: DirectoryString7, context: 1, implicit: true })
], EDIPartyName4.prototype, "partyName", undefined);
var GeneralName7 = class GeneralName8 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp4({ type: OtherName4, context: 0, implicit: true })
], GeneralName7.prototype, "otherName", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.IA5String, context: 1, implicit: true })
], GeneralName7.prototype, "rfc822Name", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.IA5String, context: 2, implicit: true })
], GeneralName7.prototype, "dNSName", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.Any, context: 3, implicit: true })
], GeneralName7.prototype, "x400Address", undefined);
__decorate([
  AsnProp4({ type: Name7, context: 4, implicit: false })
], GeneralName7.prototype, "directoryName", undefined);
__decorate([
  AsnProp4({ type: EDIPartyName4, context: 5 })
], GeneralName7.prototype, "ediPartyName", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.IA5String, context: 6, implicit: true })
], GeneralName7.prototype, "uniformResourceIdentifier", undefined);
__decorate([
  AsnProp4({
    type: AsnPropTypes4.OctetString,
    context: 7,
    implicit: true,
    converter: AsnIpConverter4
  })
], GeneralName7.prototype, "iPAddress", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.ObjectIdentifier, context: 8, implicit: true })
], GeneralName7.prototype, "registeredID", undefined);
GeneralName7 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Choice })
], GeneralName7);

// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js
var id_pkix4 = "1.3.6.1.5.5.7";
var id_pe4 = `${id_pkix4}.1`;
var id_qt4 = `${id_pkix4}.2`;
var id_kp4 = `${id_pkix4}.3`;
var id_ad4 = `${id_pkix4}.48`;
var id_qt_csp4 = `${id_qt4}.1`;
var id_qt_unotice4 = `${id_qt4}.2`;
var id_ad_ocsp4 = `${id_ad4}.1`;
var id_ad_caIssuers4 = `${id_ad4}.2`;
var id_ad_timeStamping4 = `${id_ad4}.3`;
var id_ad_caRepository4 = `${id_ad4}.5`;
var id_ce4 = "2.5.29";

// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_information_access.js
var AuthorityInfoAccessSyntax_14;
var id_pe_authorityInfoAccess4 = `${id_pe4}.1`;

class AccessDescription4 {
  constructor(params = {}) {
    this.accessMethod = "";
    this.accessLocation = new GeneralName7;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AsnPropTypes4.ObjectIdentifier })
], AccessDescription4.prototype, "accessMethod", undefined);
__decorate([
  AsnProp4({ type: GeneralName7 })
], AccessDescription4.prototype, "accessLocation", undefined);
var AuthorityInfoAccessSyntax7 = AuthorityInfoAccessSyntax_14 = class AuthorityInfoAccessSyntax8 extends AsnArray4 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, AuthorityInfoAccessSyntax_14.prototype);
  }
};
AuthorityInfoAccessSyntax7 = AuthorityInfoAccessSyntax_14 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Sequence, itemType: AccessDescription4 })
], AuthorityInfoAccessSyntax7);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_key_identifier.js
var id_ce_authorityKeyIdentifier4 = `${id_ce4}.35`;

class KeyIdentifier4 extends OctetString8 {
}

class AuthorityKeyIdentifier4 {
  constructor(params = {}) {
    if (params) {
      Object.assign(this, params);
    }
  }
}
__decorate([
  AsnProp4({ type: KeyIdentifier4, context: 0, optional: true, implicit: true })
], AuthorityKeyIdentifier4.prototype, "keyIdentifier", undefined);
__decorate([
  AsnProp4({ type: GeneralName7, context: 1, optional: true, implicit: true, repeated: "sequence" })
], AuthorityKeyIdentifier4.prototype, "authorityCertIssuer", undefined);
__decorate([
  AsnProp4({
    type: AsnPropTypes4.Integer,
    context: 2,
    optional: true,
    implicit: true,
    converter: AsnIntegerArrayBufferConverter4
  })
], AuthorityKeyIdentifier4.prototype, "authorityCertSerialNumber", undefined);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/basic_constraints.js
var id_ce_basicConstraints4 = `${id_ce4}.19`;

class BasicConstraints4 {
  constructor(params = {}) {
    this.cA = false;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AsnPropTypes4.Boolean, defaultValue: false })
], BasicConstraints4.prototype, "cA", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.Integer, optional: true })
], BasicConstraints4.prototype, "pathLenConstraint", undefined);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/general_names.js
var GeneralNames_14;
var GeneralNames7 = GeneralNames_14 = class GeneralNames8 extends AsnArray4 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralNames_14.prototype);
  }
};
GeneralNames7 = GeneralNames_14 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Sequence, itemType: GeneralName7 })
], GeneralNames7);

// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_issuer.js
var CertificateIssuer_14;
var id_ce_certificateIssuer4 = `${id_ce4}.29`;
var CertificateIssuer7 = CertificateIssuer_14 = class CertificateIssuer8 extends GeneralNames7 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificateIssuer_14.prototype);
  }
};
CertificateIssuer7 = CertificateIssuer_14 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Sequence })
], CertificateIssuer7);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_policies.js
var CertificatePolicies_14;
var id_ce_certificatePolicies4 = `${id_ce4}.32`;
var id_ce_certificatePolicies_anyPolicy4 = `${id_ce_certificatePolicies4}.0`;
var DisplayText7 = class DisplayText8 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || this.visibleString || this.bmpString || this.utf8String || "";
  }
};
__decorate([
  AsnProp4({ type: AsnPropTypes4.IA5String })
], DisplayText7.prototype, "ia5String", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.VisibleString })
], DisplayText7.prototype, "visibleString", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.BmpString })
], DisplayText7.prototype, "bmpString", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.Utf8String })
], DisplayText7.prototype, "utf8String", undefined);
DisplayText7 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Choice })
], DisplayText7);
class NoticeReference4 {
  constructor(params = {}) {
    this.organization = new DisplayText7;
    this.noticeNumbers = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: DisplayText7 })
], NoticeReference4.prototype, "organization", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.Integer, repeated: "sequence" })
], NoticeReference4.prototype, "noticeNumbers", undefined);

class UserNotice4 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: NoticeReference4, optional: true })
], UserNotice4.prototype, "noticeRef", undefined);
__decorate([
  AsnProp4({ type: DisplayText7, optional: true })
], UserNotice4.prototype, "explicitText", undefined);
var Qualifier7 = class Qualifier8 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp4({ type: AsnPropTypes4.IA5String })
], Qualifier7.prototype, "cPSuri", undefined);
__decorate([
  AsnProp4({ type: UserNotice4 })
], Qualifier7.prototype, "userNotice", undefined);
Qualifier7 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Choice })
], Qualifier7);
class PolicyQualifierInfo4 {
  constructor(params = {}) {
    this.policyQualifierId = "";
    this.qualifier = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AsnPropTypes4.ObjectIdentifier })
], PolicyQualifierInfo4.prototype, "policyQualifierId", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.Any })
], PolicyQualifierInfo4.prototype, "qualifier", undefined);

class PolicyInformation4 {
  constructor(params = {}) {
    this.policyIdentifier = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AsnPropTypes4.ObjectIdentifier })
], PolicyInformation4.prototype, "policyIdentifier", undefined);
__decorate([
  AsnProp4({ type: PolicyQualifierInfo4, repeated: "sequence", optional: true })
], PolicyInformation4.prototype, "policyQualifiers", undefined);
var CertificatePolicies7 = CertificatePolicies_14 = class CertificatePolicies8 extends AsnArray4 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificatePolicies_14.prototype);
  }
};
CertificatePolicies7 = CertificatePolicies_14 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Sequence, itemType: PolicyInformation4 })
], CertificatePolicies7);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_number.js
var id_ce_cRLNumber4 = `${id_ce4}.20`;
var CRLNumber7 = class CRLNumber8 {
  constructor(value = 0) {
    this.value = value;
  }
};
__decorate([
  AsnProp4({ type: AsnPropTypes4.Integer })
], CRLNumber7.prototype, "value", undefined);
CRLNumber7 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Choice })
], CRLNumber7);

// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_delta_indicator.js
var id_ce_deltaCRLIndicator4 = `${id_ce4}.27`;
var BaseCRLNumber7 = class BaseCRLNumber8 extends CRLNumber7 {
};
BaseCRLNumber7 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Choice })
], BaseCRLNumber7);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_distribution_points.js
var CRLDistributionPoints_14;
var id_ce_cRLDistributionPoints4 = `${id_ce4}.31`;
var ReasonFlags4;
(function(ReasonFlags5) {
  ReasonFlags5[ReasonFlags5["unused"] = 1] = "unused";
  ReasonFlags5[ReasonFlags5["keyCompromise"] = 2] = "keyCompromise";
  ReasonFlags5[ReasonFlags5["cACompromise"] = 4] = "cACompromise";
  ReasonFlags5[ReasonFlags5["affiliationChanged"] = 8] = "affiliationChanged";
  ReasonFlags5[ReasonFlags5["superseded"] = 16] = "superseded";
  ReasonFlags5[ReasonFlags5["cessationOfOperation"] = 32] = "cessationOfOperation";
  ReasonFlags5[ReasonFlags5["certificateHold"] = 64] = "certificateHold";
  ReasonFlags5[ReasonFlags5["privilegeWithdrawn"] = 128] = "privilegeWithdrawn";
  ReasonFlags5[ReasonFlags5["aACompromise"] = 256] = "aACompromise";
})(ReasonFlags4 || (ReasonFlags4 = {}));

class Reason4 extends BitString8 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & ReasonFlags4.aACompromise) {
      res.push("aACompromise");
    }
    if (flags & ReasonFlags4.affiliationChanged) {
      res.push("affiliationChanged");
    }
    if (flags & ReasonFlags4.cACompromise) {
      res.push("cACompromise");
    }
    if (flags & ReasonFlags4.certificateHold) {
      res.push("certificateHold");
    }
    if (flags & ReasonFlags4.cessationOfOperation) {
      res.push("cessationOfOperation");
    }
    if (flags & ReasonFlags4.keyCompromise) {
      res.push("keyCompromise");
    }
    if (flags & ReasonFlags4.privilegeWithdrawn) {
      res.push("privilegeWithdrawn");
    }
    if (flags & ReasonFlags4.superseded) {
      res.push("superseded");
    }
    if (flags & ReasonFlags4.unused) {
      res.push("unused");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
}
var DistributionPointName7 = class DistributionPointName8 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp4({ type: GeneralName7, context: 0, repeated: "sequence", implicit: true })
], DistributionPointName7.prototype, "fullName", undefined);
__decorate([
  AsnProp4({ type: RelativeDistinguishedName7, context: 1, implicit: true })
], DistributionPointName7.prototype, "nameRelativeToCRLIssuer", undefined);
DistributionPointName7 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Choice })
], DistributionPointName7);
class DistributionPoint4 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: DistributionPointName7, context: 0, optional: true })
], DistributionPoint4.prototype, "distributionPoint", undefined);
__decorate([
  AsnProp4({ type: Reason4, context: 1, optional: true, implicit: true })
], DistributionPoint4.prototype, "reasons", undefined);
__decorate([
  AsnProp4({ type: GeneralName7, context: 2, optional: true, repeated: "sequence", implicit: true })
], DistributionPoint4.prototype, "cRLIssuer", undefined);
var CRLDistributionPoints7 = CRLDistributionPoints_14 = class CRLDistributionPoints8 extends AsnArray4 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CRLDistributionPoints_14.prototype);
  }
};
CRLDistributionPoints7 = CRLDistributionPoints_14 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Sequence, itemType: DistributionPoint4 })
], CRLDistributionPoints7);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_freshest.js
var FreshestCRL_14;
var id_ce_freshestCRL4 = `${id_ce4}.46`;
var FreshestCRL7 = FreshestCRL_14 = class FreshestCRL8 extends CRLDistributionPoints7 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, FreshestCRL_14.prototype);
  }
};
FreshestCRL7 = FreshestCRL_14 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Sequence, itemType: DistributionPoint4 })
], FreshestCRL7);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_issuing_distribution_point.js
var id_ce_issuingDistributionPoint4 = `${id_ce4}.28`;

class IssuingDistributionPoint4 {
  constructor(params = {}) {
    this.onlyContainsUserCerts = IssuingDistributionPoint4.ONLY;
    this.onlyContainsCACerts = IssuingDistributionPoint4.ONLY;
    this.indirectCRL = IssuingDistributionPoint4.ONLY;
    this.onlyContainsAttributeCerts = IssuingDistributionPoint4.ONLY;
    Object.assign(this, params);
  }
}
IssuingDistributionPoint4.ONLY = false;
__decorate([
  AsnProp4({ type: DistributionPointName7, context: 0, optional: true })
], IssuingDistributionPoint4.prototype, "distributionPoint", undefined);
__decorate([
  AsnProp4({
    type: AsnPropTypes4.Boolean,
    context: 1,
    defaultValue: IssuingDistributionPoint4.ONLY,
    implicit: true
  })
], IssuingDistributionPoint4.prototype, "onlyContainsUserCerts", undefined);
__decorate([
  AsnProp4({
    type: AsnPropTypes4.Boolean,
    context: 2,
    defaultValue: IssuingDistributionPoint4.ONLY,
    implicit: true
  })
], IssuingDistributionPoint4.prototype, "onlyContainsCACerts", undefined);
__decorate([
  AsnProp4({ type: Reason4, context: 3, optional: true, implicit: true })
], IssuingDistributionPoint4.prototype, "onlySomeReasons", undefined);
__decorate([
  AsnProp4({
    type: AsnPropTypes4.Boolean,
    context: 4,
    defaultValue: IssuingDistributionPoint4.ONLY,
    implicit: true
  })
], IssuingDistributionPoint4.prototype, "indirectCRL", undefined);
__decorate([
  AsnProp4({
    type: AsnPropTypes4.Boolean,
    context: 5,
    defaultValue: IssuingDistributionPoint4.ONLY,
    implicit: true
  })
], IssuingDistributionPoint4.prototype, "onlyContainsAttributeCerts", undefined);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_reason.js
var id_ce_cRLReasons4 = `${id_ce4}.21`;
var CRLReasons4;
(function(CRLReasons5) {
  CRLReasons5[CRLReasons5["unspecified"] = 0] = "unspecified";
  CRLReasons5[CRLReasons5["keyCompromise"] = 1] = "keyCompromise";
  CRLReasons5[CRLReasons5["cACompromise"] = 2] = "cACompromise";
  CRLReasons5[CRLReasons5["affiliationChanged"] = 3] = "affiliationChanged";
  CRLReasons5[CRLReasons5["superseded"] = 4] = "superseded";
  CRLReasons5[CRLReasons5["cessationOfOperation"] = 5] = "cessationOfOperation";
  CRLReasons5[CRLReasons5["certificateHold"] = 6] = "certificateHold";
  CRLReasons5[CRLReasons5["removeFromCRL"] = 8] = "removeFromCRL";
  CRLReasons5[CRLReasons5["privilegeWithdrawn"] = 9] = "privilegeWithdrawn";
  CRLReasons5[CRLReasons5["aACompromise"] = 10] = "aACompromise";
})(CRLReasons4 || (CRLReasons4 = {}));
var CRLReason7 = class CRLReason8 {
  constructor(reason = CRLReasons4.unspecified) {
    this.reason = CRLReasons4.unspecified;
    this.reason = reason;
  }
  toJSON() {
    return CRLReasons4[this.reason];
  }
  toString() {
    return this.toJSON();
  }
};
__decorate([
  AsnProp4({ type: AsnPropTypes4.Enumerated })
], CRLReason7.prototype, "reason", undefined);
CRLReason7 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Choice })
], CRLReason7);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/extended_key_usage.js
var ExtendedKeyUsage_14;
var id_ce_extKeyUsage4 = `${id_ce4}.37`;
var ExtendedKeyUsage7 = ExtendedKeyUsage_14 = class ExtendedKeyUsage8 extends AsnArray4 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, ExtendedKeyUsage_14.prototype);
  }
};
ExtendedKeyUsage7 = ExtendedKeyUsage_14 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Sequence, itemType: AsnPropTypes4.ObjectIdentifier })
], ExtendedKeyUsage7);
var anyExtendedKeyUsage4 = `${id_ce_extKeyUsage4}.0`;
var id_kp_serverAuth4 = `${id_kp4}.1`;
var id_kp_clientAuth4 = `${id_kp4}.2`;
var id_kp_codeSigning4 = `${id_kp4}.3`;
var id_kp_emailProtection4 = `${id_kp4}.4`;
var id_kp_timeStamping4 = `${id_kp4}.8`;
var id_kp_OCSPSigning4 = `${id_kp4}.9`;
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/inhibit_any_policy.js
var id_ce_inhibitAnyPolicy4 = `${id_ce4}.54`;
var InhibitAnyPolicy7 = class InhibitAnyPolicy8 {
  constructor(value = new ArrayBuffer(0)) {
    this.value = value;
  }
};
__decorate([
  AsnProp4({ type: AsnPropTypes4.Integer, converter: AsnIntegerArrayBufferConverter4 })
], InhibitAnyPolicy7.prototype, "value", undefined);
InhibitAnyPolicy7 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Choice })
], InhibitAnyPolicy7);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/invalidity_date.js
var id_ce_invalidityDate4 = `${id_ce4}.24`;
var InvalidityDate7 = class InvalidityDate8 {
  constructor(value) {
    this.value = new Date;
    if (value) {
      this.value = value;
    }
  }
};
__decorate([
  AsnProp4({ type: AsnPropTypes4.GeneralizedTime })
], InvalidityDate7.prototype, "value", undefined);
InvalidityDate7 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Choice })
], InvalidityDate7);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/issuer_alternative_name.js
var IssueAlternativeName_14;
var id_ce_issuerAltName4 = `${id_ce4}.18`;
var IssueAlternativeName7 = IssueAlternativeName_14 = class IssueAlternativeName8 extends GeneralNames7 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, IssueAlternativeName_14.prototype);
  }
};
IssueAlternativeName7 = IssueAlternativeName_14 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Sequence })
], IssueAlternativeName7);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/key_usage.js
var id_ce_keyUsage4 = `${id_ce4}.15`;
var KeyUsageFlags4;
(function(KeyUsageFlags5) {
  KeyUsageFlags5[KeyUsageFlags5["digitalSignature"] = 1] = "digitalSignature";
  KeyUsageFlags5[KeyUsageFlags5["nonRepudiation"] = 2] = "nonRepudiation";
  KeyUsageFlags5[KeyUsageFlags5["keyEncipherment"] = 4] = "keyEncipherment";
  KeyUsageFlags5[KeyUsageFlags5["dataEncipherment"] = 8] = "dataEncipherment";
  KeyUsageFlags5[KeyUsageFlags5["keyAgreement"] = 16] = "keyAgreement";
  KeyUsageFlags5[KeyUsageFlags5["keyCertSign"] = 32] = "keyCertSign";
  KeyUsageFlags5[KeyUsageFlags5["cRLSign"] = 64] = "cRLSign";
  KeyUsageFlags5[KeyUsageFlags5["encipherOnly"] = 128] = "encipherOnly";
  KeyUsageFlags5[KeyUsageFlags5["decipherOnly"] = 256] = "decipherOnly";
})(KeyUsageFlags4 || (KeyUsageFlags4 = {}));
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/name_constraints.js
var GeneralSubtrees_14;
var id_ce_nameConstraints4 = `${id_ce4}.30`;

class GeneralSubtree4 {
  constructor(params = {}) {
    this.base = new GeneralName7;
    this.minimum = 0;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: GeneralName7 })
], GeneralSubtree4.prototype, "base", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.Integer, context: 0, defaultValue: 0, implicit: true })
], GeneralSubtree4.prototype, "minimum", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.Integer, context: 1, optional: true, implicit: true })
], GeneralSubtree4.prototype, "maximum", undefined);
var GeneralSubtrees7 = GeneralSubtrees_14 = class GeneralSubtrees8 extends AsnArray4 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralSubtrees_14.prototype);
  }
};
GeneralSubtrees7 = GeneralSubtrees_14 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Sequence, itemType: GeneralSubtree4 })
], GeneralSubtrees7);
class NameConstraints4 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: GeneralSubtrees7, context: 0, optional: true, implicit: true })
], NameConstraints4.prototype, "permittedSubtrees", undefined);
__decorate([
  AsnProp4({ type: GeneralSubtrees7, context: 1, optional: true, implicit: true })
], NameConstraints4.prototype, "excludedSubtrees", undefined);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_constraints.js
var id_ce_policyConstraints4 = `${id_ce4}.36`;

class PolicyConstraints4 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({
    type: AsnPropTypes4.Integer,
    context: 0,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter4
  })
], PolicyConstraints4.prototype, "requireExplicitPolicy", undefined);
__decorate([
  AsnProp4({
    type: AsnPropTypes4.Integer,
    context: 1,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter4
  })
], PolicyConstraints4.prototype, "inhibitPolicyMapping", undefined);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_mappings.js
var PolicyMappings_14;
var id_ce_policyMappings4 = `${id_ce4}.33`;

class PolicyMapping4 {
  constructor(params = {}) {
    this.issuerDomainPolicy = "";
    this.subjectDomainPolicy = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AsnPropTypes4.ObjectIdentifier })
], PolicyMapping4.prototype, "issuerDomainPolicy", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.ObjectIdentifier })
], PolicyMapping4.prototype, "subjectDomainPolicy", undefined);
var PolicyMappings7 = PolicyMappings_14 = class PolicyMappings8 extends AsnArray4 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, PolicyMappings_14.prototype);
  }
};
PolicyMappings7 = PolicyMappings_14 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Sequence, itemType: PolicyMapping4 })
], PolicyMappings7);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_alternative_name.js
var SubjectAlternativeName_14;
var id_ce_subjectAltName4 = `${id_ce4}.17`;
var SubjectAlternativeName7 = SubjectAlternativeName_14 = class SubjectAlternativeName8 extends GeneralNames7 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectAlternativeName_14.prototype);
  }
};
SubjectAlternativeName7 = SubjectAlternativeName_14 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Sequence })
], SubjectAlternativeName7);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/attribute.js
class Attribute5 {
  constructor(params = {}) {
    this.type = "";
    this.values = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AsnPropTypes4.ObjectIdentifier })
], Attribute5.prototype, "type", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.Any, repeated: "set" })
], Attribute5.prototype, "values", undefined);

// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_directory_attributes.js
var SubjectDirectoryAttributes_14;
var id_ce_subjectDirectoryAttributes4 = `${id_ce4}.9`;
var SubjectDirectoryAttributes7 = SubjectDirectoryAttributes_14 = class SubjectDirectoryAttributes8 extends AsnArray4 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectDirectoryAttributes_14.prototype);
  }
};
SubjectDirectoryAttributes7 = SubjectDirectoryAttributes_14 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Sequence, itemType: Attribute5 })
], SubjectDirectoryAttributes7);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_key_identifier.js
var id_ce_subjectKeyIdentifier4 = `${id_ce4}.14`;
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/private_key_usage_period.js
var id_ce_privateKeyUsagePeriod4 = `${id_ce4}.16`;

class PrivateKeyUsagePeriod4 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AsnPropTypes4.GeneralizedTime, context: 0, implicit: true, optional: true })
], PrivateKeyUsagePeriod4.prototype, "notBefore", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.GeneralizedTime, context: 1, implicit: true, optional: true })
], PrivateKeyUsagePeriod4.prototype, "notAfter", undefined);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/entrust_version_info.js
var EntrustInfoFlags4;
(function(EntrustInfoFlags5) {
  EntrustInfoFlags5[EntrustInfoFlags5["keyUpdateAllowed"] = 1] = "keyUpdateAllowed";
  EntrustInfoFlags5[EntrustInfoFlags5["newExtensions"] = 2] = "newExtensions";
  EntrustInfoFlags5[EntrustInfoFlags5["pKIXCertificate"] = 4] = "pKIXCertificate";
})(EntrustInfoFlags4 || (EntrustInfoFlags4 = {}));

class EntrustInfo4 extends BitString8 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & EntrustInfoFlags4.pKIXCertificate) {
      res.push("pKIXCertificate");
    }
    if (flags & EntrustInfoFlags4.newExtensions) {
      res.push("newExtensions");
    }
    if (flags & EntrustInfoFlags4.keyUpdateAllowed) {
      res.push("keyUpdateAllowed");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
}

class EntrustVersionInfo4 {
  constructor(params = {}) {
    this.entrustVers = "";
    this.entrustInfoFlags = new EntrustInfo4;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AsnPropTypes4.GeneralString })
], EntrustVersionInfo4.prototype, "entrustVers", undefined);
__decorate([
  AsnProp4({ type: EntrustInfo4 })
], EntrustVersionInfo4.prototype, "entrustInfoFlags", undefined);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_info_access.js
var SubjectInfoAccessSyntax_14;
var id_pe_subjectInfoAccess4 = `${id_pe4}.11`;
var SubjectInfoAccessSyntax7 = SubjectInfoAccessSyntax_14 = class SubjectInfoAccessSyntax8 extends AsnArray4 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectInfoAccessSyntax_14.prototype);
  }
};
SubjectInfoAccessSyntax7 = SubjectInfoAccessSyntax_14 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Sequence, itemType: AccessDescription4 })
], SubjectInfoAccessSyntax7);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js
class AlgorithmIdentifier4 {
  constructor(params = {}) {
    this.algorithm = "";
    Object.assign(this, params);
  }
  isEqual(data) {
    return data instanceof AlgorithmIdentifier4 && data.algorithm == this.algorithm && (data.parameters && this.parameters && isEqual(data.parameters, this.parameters) || data.parameters === this.parameters);
  }
}
__decorate([
  AsnProp4({
    type: AsnPropTypes4.ObjectIdentifier
  })
], AlgorithmIdentifier4.prototype, "algorithm", undefined);
__decorate([
  AsnProp4({
    type: AsnPropTypes4.Any,
    optional: true
  })
], AlgorithmIdentifier4.prototype, "parameters", undefined);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/subject_public_key_info.js
class SubjectPublicKeyInfo4 {
  constructor(params = {}) {
    this.algorithm = new AlgorithmIdentifier4;
    this.subjectPublicKey = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AlgorithmIdentifier4 })
], SubjectPublicKeyInfo4.prototype, "algorithm", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.BitString })
], SubjectPublicKeyInfo4.prototype, "subjectPublicKey", undefined);

// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/time.js
var Time7 = class Time8 {
  constructor(time5) {
    if (time5) {
      if (typeof time5 === "string" || typeof time5 === "number" || time5 instanceof Date) {
        const date = new Date(time5);
        if (date.getUTCFullYear() > 2049) {
          this.generalTime = date;
        } else {
          this.utcTime = date;
        }
      } else {
        Object.assign(this, time5);
      }
    }
  }
  getTime() {
    const time5 = this.utcTime || this.generalTime;
    if (!time5) {
      throw new Error("Cannot get time from CHOICE object");
    }
    return time5;
  }
};
__decorate([
  AsnProp4({
    type: AsnPropTypes4.UTCTime
  })
], Time7.prototype, "utcTime", undefined);
__decorate([
  AsnProp4({
    type: AsnPropTypes4.GeneralizedTime
  })
], Time7.prototype, "generalTime", undefined);
Time7 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Choice })
], Time7);

// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/validity.js
class Validity4 {
  constructor(params) {
    this.notBefore = new Time7(new Date);
    this.notAfter = new Time7(new Date);
    if (params) {
      this.notBefore = new Time7(params.notBefore);
      this.notAfter = new Time7(params.notAfter);
    }
  }
}
__decorate([
  AsnProp4({ type: Time7 })
], Validity4.prototype, "notBefore", undefined);
__decorate([
  AsnProp4({ type: Time7 })
], Validity4.prototype, "notAfter", undefined);

// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/extension.js
var Extensions_14;

class Extension4 {
  constructor(params = {}) {
    this.extnID = "";
    this.critical = Extension4.CRITICAL;
    this.extnValue = new OctetString8;
    Object.assign(this, params);
  }
}
Extension4.CRITICAL = false;
__decorate([
  AsnProp4({ type: AsnPropTypes4.ObjectIdentifier })
], Extension4.prototype, "extnID", undefined);
__decorate([
  AsnProp4({
    type: AsnPropTypes4.Boolean,
    defaultValue: Extension4.CRITICAL
  })
], Extension4.prototype, "critical", undefined);
__decorate([
  AsnProp4({ type: OctetString8 })
], Extension4.prototype, "extnValue", undefined);
var Extensions7 = Extensions_14 = class Extensions8 extends AsnArray4 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Extensions_14.prototype);
  }
};
Extensions7 = Extensions_14 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Sequence, itemType: Extension4 })
], Extensions7);

// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/types.js
var Version4;
(function(Version5) {
  Version5[Version5["v1"] = 0] = "v1";
  Version5[Version5["v2"] = 1] = "v2";
  Version5[Version5["v3"] = 2] = "v3";
})(Version4 || (Version4 = {}));

// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/tbs_certificate.js
class TBSCertificate4 {
  constructor(params = {}) {
    this.version = Version4.v1;
    this.serialNumber = new ArrayBuffer(0);
    this.signature = new AlgorithmIdentifier4;
    this.issuer = new Name7;
    this.validity = new Validity4;
    this.subject = new Name7;
    this.subjectPublicKeyInfo = new SubjectPublicKeyInfo4;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({
    type: AsnPropTypes4.Integer,
    context: 0,
    defaultValue: Version4.v1
  })
], TBSCertificate4.prototype, "version", undefined);
__decorate([
  AsnProp4({
    type: AsnPropTypes4.Integer,
    converter: AsnIntegerArrayBufferConverter4
  })
], TBSCertificate4.prototype, "serialNumber", undefined);
__decorate([
  AsnProp4({ type: AlgorithmIdentifier4 })
], TBSCertificate4.prototype, "signature", undefined);
__decorate([
  AsnProp4({ type: Name7 })
], TBSCertificate4.prototype, "issuer", undefined);
__decorate([
  AsnProp4({ type: Validity4 })
], TBSCertificate4.prototype, "validity", undefined);
__decorate([
  AsnProp4({ type: Name7 })
], TBSCertificate4.prototype, "subject", undefined);
__decorate([
  AsnProp4({ type: SubjectPublicKeyInfo4 })
], TBSCertificate4.prototype, "subjectPublicKeyInfo", undefined);
__decorate([
  AsnProp4({
    type: AsnPropTypes4.BitString,
    context: 1,
    implicit: true,
    optional: true
  })
], TBSCertificate4.prototype, "issuerUniqueID", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.BitString, context: 2, implicit: true, optional: true })
], TBSCertificate4.prototype, "subjectUniqueID", undefined);
__decorate([
  AsnProp4({ type: Extensions7, context: 3, optional: true })
], TBSCertificate4.prototype, "extensions", undefined);

// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/certificate.js
class Certificate4 {
  constructor(params = {}) {
    this.tbsCertificate = new TBSCertificate4;
    this.signatureAlgorithm = new AlgorithmIdentifier4;
    this.signatureValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: TBSCertificate4, raw: true })
], Certificate4.prototype, "tbsCertificate", undefined);
__decorate([
  AsnProp4({ type: AlgorithmIdentifier4 })
], Certificate4.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.BitString })
], Certificate4.prototype, "signatureValue", undefined);
// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/tbs_cert_list.js
class RevokedCertificate4 {
  constructor(params = {}) {
    this.userCertificate = new ArrayBuffer(0);
    this.revocationDate = new Time7;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AsnPropTypes4.Integer, converter: AsnIntegerArrayBufferConverter4 })
], RevokedCertificate4.prototype, "userCertificate", undefined);
__decorate([
  AsnProp4({ type: Time7 })
], RevokedCertificate4.prototype, "revocationDate", undefined);
__decorate([
  AsnProp4({ type: Extension4, optional: true, repeated: "sequence" })
], RevokedCertificate4.prototype, "crlEntryExtensions", undefined);

class TBSCertList4 {
  constructor(params = {}) {
    this.signature = new AlgorithmIdentifier4;
    this.issuer = new Name7;
    this.thisUpdate = new Time7;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AsnPropTypes4.Integer, optional: true })
], TBSCertList4.prototype, "version", undefined);
__decorate([
  AsnProp4({ type: AlgorithmIdentifier4 })
], TBSCertList4.prototype, "signature", undefined);
__decorate([
  AsnProp4({ type: Name7 })
], TBSCertList4.prototype, "issuer", undefined);
__decorate([
  AsnProp4({ type: Time7 })
], TBSCertList4.prototype, "thisUpdate", undefined);
__decorate([
  AsnProp4({ type: Time7, optional: true })
], TBSCertList4.prototype, "nextUpdate", undefined);
__decorate([
  AsnProp4({ type: RevokedCertificate4, repeated: "sequence", optional: true })
], TBSCertList4.prototype, "revokedCertificates", undefined);
__decorate([
  AsnProp4({ type: Extension4, optional: true, context: 0, repeated: "sequence" })
], TBSCertList4.prototype, "crlExtensions", undefined);

// node_modules/@peculiar/asn1-x509-attr/node_modules/@peculiar/asn1-x509/build/es2015/certificate_list.js
class CertificateList4 {
  constructor(params = {}) {
    this.tbsCertList = new TBSCertList4;
    this.signatureAlgorithm = new AlgorithmIdentifier4;
    this.signature = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: TBSCertList4, raw: true })
], CertificateList4.prototype, "tbsCertList", undefined);
__decorate([
  AsnProp4({ type: AlgorithmIdentifier4 })
], CertificateList4.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.BitString })
], CertificateList4.prototype, "signature", undefined);
// node_modules/@peculiar/asn1-x509-attr/build/es2015/aa_clear_attrs.js
class ACClearAttrs {
  constructor(params = {}) {
    this.acIssuer = new GeneralName7;
    this.acSerial = 0;
    this.attrs = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: GeneralName7 })
], ACClearAttrs.prototype, "acIssuer", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.Integer })
], ACClearAttrs.prototype, "acSerial", undefined);
__decorate([
  AsnProp4({ type: Attribute5, repeated: "sequence" })
], ACClearAttrs.prototype, "attrs", undefined);
// node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_spec.js
var AttrSpec_1;
var AttrSpec = AttrSpec_1 = class AttrSpec2 extends AsnArray4 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, AttrSpec_1.prototype);
  }
};
AttrSpec = AttrSpec_1 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Sequence, itemType: AsnPropTypes4.ObjectIdentifier })
], AttrSpec);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/aa_controls.js
class AAControls {
  constructor(params = {}) {
    this.permitUnSpecified = true;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AsnPropTypes4.Integer, optional: true })
], AAControls.prototype, "pathLenConstraint", undefined);
__decorate([
  AsnProp4({ type: AttrSpec, implicit: true, context: 0, optional: true })
], AAControls.prototype, "permittedAttrs", undefined);
__decorate([
  AsnProp4({ type: AttrSpec, implicit: true, context: 1, optional: true })
], AAControls.prototype, "excludedAttrs", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.Boolean, defaultValue: true })
], AAControls.prototype, "permitUnSpecified", undefined);
// node_modules/@peculiar/asn1-x509-attr/build/es2015/issuer_serial.js
class IssuerSerial {
  constructor(params = {}) {
    this.issuer = new GeneralNames7;
    this.serial = new ArrayBuffer(0);
    this.issuerUID = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: GeneralNames7 })
], IssuerSerial.prototype, "issuer", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.Integer, converter: AsnIntegerArrayBufferConverter4 })
], IssuerSerial.prototype, "serial", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.BitString, optional: true })
], IssuerSerial.prototype, "issuerUID", undefined);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/object_digest_info.js
var DigestedObjectType;
(function(DigestedObjectType2) {
  DigestedObjectType2[DigestedObjectType2["publicKey"] = 0] = "publicKey";
  DigestedObjectType2[DigestedObjectType2["publicKeyCert"] = 1] = "publicKeyCert";
  DigestedObjectType2[DigestedObjectType2["otherObjectTypes"] = 2] = "otherObjectTypes";
})(DigestedObjectType || (DigestedObjectType = {}));

class ObjectDigestInfo {
  constructor(params = {}) {
    this.digestedObjectType = DigestedObjectType.publicKey;
    this.digestAlgorithm = new AlgorithmIdentifier4;
    this.objectDigest = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AsnPropTypes4.Enumerated })
], ObjectDigestInfo.prototype, "digestedObjectType", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.ObjectIdentifier, optional: true })
], ObjectDigestInfo.prototype, "otherObjectTypeID", undefined);
__decorate([
  AsnProp4({ type: AlgorithmIdentifier4 })
], ObjectDigestInfo.prototype, "digestAlgorithm", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.BitString })
], ObjectDigestInfo.prototype, "objectDigest", undefined);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/v2_form.js
class V2Form {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: GeneralNames7, optional: true })
], V2Form.prototype, "issuerName", undefined);
__decorate([
  AsnProp4({ type: IssuerSerial, context: 0, implicit: true, optional: true })
], V2Form.prototype, "baseCertificateID", undefined);
__decorate([
  AsnProp4({ type: ObjectDigestInfo, context: 1, implicit: true, optional: true })
], V2Form.prototype, "objectDigestInfo", undefined);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_cert_issuer.js
var AttCertIssuer = class AttCertIssuer2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp4({ type: GeneralName7, repeated: "sequence" })
], AttCertIssuer.prototype, "v1Form", undefined);
__decorate([
  AsnProp4({ type: V2Form, context: 0, implicit: true })
], AttCertIssuer.prototype, "v2Form", undefined);
AttCertIssuer = __decorate([
  AsnType4({ type: AsnTypeTypes4.Choice })
], AttCertIssuer);
// node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_cert_validity_period.js
class AttCertValidityPeriod {
  constructor(params = {}) {
    this.notBeforeTime = new Date;
    this.notAfterTime = new Date;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AsnPropTypes4.GeneralizedTime })
], AttCertValidityPeriod.prototype, "notBeforeTime", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.GeneralizedTime })
], AttCertValidityPeriod.prototype, "notAfterTime", undefined);
// node_modules/@peculiar/asn1-x509-attr/build/es2015/holder.js
class Holder {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: IssuerSerial, implicit: true, context: 0, optional: true })
], Holder.prototype, "baseCertificateID", undefined);
__decorate([
  AsnProp4({ type: GeneralNames7, implicit: true, context: 1, optional: true })
], Holder.prototype, "entityName", undefined);
__decorate([
  AsnProp4({ type: ObjectDigestInfo, implicit: true, context: 2, optional: true })
], Holder.prototype, "objectDigestInfo", undefined);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/attribute_certificate_info.js
var AttCertVersion;
(function(AttCertVersion2) {
  AttCertVersion2[AttCertVersion2["v2"] = 1] = "v2";
})(AttCertVersion || (AttCertVersion = {}));

class AttributeCertificateInfo {
  constructor(params = {}) {
    this.version = AttCertVersion.v2;
    this.holder = new Holder;
    this.issuer = new AttCertIssuer;
    this.signature = new AlgorithmIdentifier4;
    this.serialNumber = new ArrayBuffer(0);
    this.attrCertValidityPeriod = new AttCertValidityPeriod;
    this.attributes = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AsnPropTypes4.Integer })
], AttributeCertificateInfo.prototype, "version", undefined);
__decorate([
  AsnProp4({ type: Holder })
], AttributeCertificateInfo.prototype, "holder", undefined);
__decorate([
  AsnProp4({ type: AttCertIssuer })
], AttributeCertificateInfo.prototype, "issuer", undefined);
__decorate([
  AsnProp4({ type: AlgorithmIdentifier4 })
], AttributeCertificateInfo.prototype, "signature", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.Integer, converter: AsnIntegerArrayBufferConverter4 })
], AttributeCertificateInfo.prototype, "serialNumber", undefined);
__decorate([
  AsnProp4({ type: AttCertValidityPeriod })
], AttributeCertificateInfo.prototype, "attrCertValidityPeriod", undefined);
__decorate([
  AsnProp4({ type: Attribute5, repeated: "sequence" })
], AttributeCertificateInfo.prototype, "attributes", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.BitString, optional: true })
], AttributeCertificateInfo.prototype, "issuerUniqueID", undefined);
__decorate([
  AsnProp4({ type: Extensions7, optional: true })
], AttributeCertificateInfo.prototype, "extensions", undefined);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/attribute_certificate.js
class AttributeCertificate {
  constructor(params = {}) {
    this.acinfo = new AttributeCertificateInfo;
    this.signatureAlgorithm = new AlgorithmIdentifier4;
    this.signatureValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AttributeCertificateInfo })
], AttributeCertificate.prototype, "acinfo", undefined);
__decorate([
  AsnProp4({ type: AlgorithmIdentifier4 })
], AttributeCertificate.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.BitString })
], AttributeCertificate.prototype, "signatureValue", undefined);
// node_modules/@peculiar/asn1-x509-attr/build/es2015/class_list.js
var ClassListFlags;
(function(ClassListFlags2) {
  ClassListFlags2[ClassListFlags2["unmarked"] = 1] = "unmarked";
  ClassListFlags2[ClassListFlags2["unclassified"] = 2] = "unclassified";
  ClassListFlags2[ClassListFlags2["restricted"] = 4] = "restricted";
  ClassListFlags2[ClassListFlags2["confidential"] = 8] = "confidential";
  ClassListFlags2[ClassListFlags2["secret"] = 16] = "secret";
  ClassListFlags2[ClassListFlags2["topSecret"] = 32] = "topSecret";
})(ClassListFlags || (ClassListFlags = {}));

class ClassList extends BitString8 {
}
// node_modules/@peculiar/asn1-x509-attr/build/es2015/security_category.js
class SecurityCategory {
  constructor(params = {}) {
    this.type = "";
    this.value = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AsnPropTypes4.ObjectIdentifier, implicit: true, context: 0 })
], SecurityCategory.prototype, "type", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.Any, implicit: true, context: 1 })
], SecurityCategory.prototype, "value", undefined);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/clearance.js
class Clearance {
  constructor(params = {}) {
    this.policyId = "";
    this.classList = new ClassList(ClassListFlags.unclassified);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: AsnPropTypes4.ObjectIdentifier })
], Clearance.prototype, "policyId", undefined);
__decorate([
  AsnProp4({ type: ClassList, defaultValue: new ClassList(ClassListFlags.unclassified) })
], Clearance.prototype, "classList", undefined);
__decorate([
  AsnProp4({ type: SecurityCategory, repeated: "set" })
], Clearance.prototype, "securityCategories", undefined);
// node_modules/@peculiar/asn1-x509-attr/build/es2015/ietf_attr_syntax.js
class IetfAttrSyntaxValueChoices {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: OctetString8 })
], IetfAttrSyntaxValueChoices.prototype, "cotets", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.ObjectIdentifier })
], IetfAttrSyntaxValueChoices.prototype, "oid", undefined);
__decorate([
  AsnProp4({ type: AsnPropTypes4.Utf8String })
], IetfAttrSyntaxValueChoices.prototype, "string", undefined);

class IetfAttrSyntax {
  constructor(params = {}) {
    this.values = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: GeneralNames7, implicit: true, context: 0, optional: true })
], IetfAttrSyntax.prototype, "policyAuthority", undefined);
__decorate([
  AsnProp4({ type: IetfAttrSyntaxValueChoices, repeated: "sequence" })
], IetfAttrSyntax.prototype, "values", undefined);
// node_modules/@peculiar/asn1-x509-attr/build/es2015/object_identifiers.js
var id_pe_ac_auditIdentity = `${id_pe4}.4`;
var id_pe_aaControls = `${id_pe4}.6`;
var id_pe_ac_proxying = `${id_pe4}.10`;
var id_ce_targetInformation = `${id_ce4}.55`;
var id_aca = `${id_pkix4}.10`;
var id_aca_authenticationInfo = `${id_aca}.1`;
var id_aca_accessIdentity = `${id_aca}.2`;
var id_aca_chargingIdentity = `${id_aca}.3`;
var id_aca_group = `${id_aca}.4`;
var id_aca_encAttrs = `${id_aca}.6`;
var id_at = "2.5.4";
var id_at_role = `${id_at}.72`;
// node_modules/@peculiar/asn1-x509-attr/build/es2015/target.js
var Targets_1;

class TargetCert {
  constructor(params = {}) {
    this.targetCertificate = new IssuerSerial;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: IssuerSerial })
], TargetCert.prototype, "targetCertificate", undefined);
__decorate([
  AsnProp4({ type: GeneralName7, optional: true })
], TargetCert.prototype, "targetName", undefined);
__decorate([
  AsnProp4({ type: ObjectDigestInfo, optional: true })
], TargetCert.prototype, "certDigestInfo", undefined);
var Target = class Target2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp4({ type: GeneralName7, context: 0, implicit: true })
], Target.prototype, "targetName", undefined);
__decorate([
  AsnProp4({ type: GeneralName7, context: 1, implicit: true })
], Target.prototype, "targetGroup", undefined);
__decorate([
  AsnProp4({ type: TargetCert, context: 2, implicit: true })
], Target.prototype, "targetCert", undefined);
Target = __decorate([
  AsnType4({ type: AsnTypeTypes4.Choice })
], Target);
var Targets = Targets_1 = class Targets2 extends AsnArray4 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Targets_1.prototype);
  }
};
Targets = Targets_1 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Sequence, itemType: Target })
], Targets);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/proxy_info.js
var ProxyInfo_1;
var ProxyInfo = ProxyInfo_1 = class ProxyInfo2 extends AsnArray4 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, ProxyInfo_1.prototype);
  }
};
ProxyInfo = ProxyInfo_1 = __decorate([
  AsnType4({ type: AsnTypeTypes4.Sequence, itemType: Targets })
], ProxyInfo);
// node_modules/@peculiar/asn1-x509-attr/build/es2015/role_syntax.js
class RoleSyntax {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: GeneralNames7, implicit: true, context: 0, optional: true })
], RoleSyntax.prototype, "roleAuthority", undefined);
__decorate([
  AsnProp4({ type: GeneralName7, implicit: true, context: 1 })
], RoleSyntax.prototype, "roleName", undefined);
// node_modules/@peculiar/asn1-x509-attr/build/es2015/svce_auth_info.js
class SvceAuthInfo {
  constructor(params = {}) {
    this.service = new GeneralName7;
    this.ident = new GeneralName7;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp4({ type: GeneralName7 })
], SvceAuthInfo.prototype, "service", undefined);
__decorate([
  AsnProp4({ type: GeneralName7 })
], SvceAuthInfo.prototype, "ident", undefined);
__decorate([
  AsnProp4({ type: OctetString8, optional: true })
], SvceAuthInfo.prototype, "authInfo", undefined);
// node_modules/@peculiar/asn1-cms/build/es2015/certificate_choices.js
var CertificateSet_1;

class OtherCertificateFormat {
  constructor(params = {}) {
    this.otherCertFormat = "";
    this.otherCert = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.ObjectIdentifier })
], OtherCertificateFormat.prototype, "otherCertFormat", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.Any })
], OtherCertificateFormat.prototype, "otherCert", undefined);
var CertificateChoices = class CertificateChoices2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp3({ type: Certificate3 })
], CertificateChoices.prototype, "certificate", undefined);
__decorate([
  AsnProp3({ type: AttributeCertificate, context: 2, implicit: true })
], CertificateChoices.prototype, "v2AttrCert", undefined);
__decorate([
  AsnProp3({ type: OtherCertificateFormat, context: 3, implicit: true })
], CertificateChoices.prototype, "other", undefined);
CertificateChoices = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], CertificateChoices);
var CertificateSet = CertificateSet_1 = class CertificateSet2 extends AsnArray3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificateSet_1.prototype);
  }
};
CertificateSet = CertificateSet_1 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Set, itemType: CertificateChoices })
], CertificateSet);
// node_modules/@peculiar/asn1-cms/build/es2015/content_info.js
class ContentInfo {
  constructor(params = {}) {
    this.contentType = "";
    this.content = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.ObjectIdentifier })
], ContentInfo.prototype, "contentType", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.Any, context: 0 })
], ContentInfo.prototype, "content", undefined);
// node_modules/@peculiar/asn1-cms/build/es2015/encapsulated_content_info.js
var EncapsulatedContent = class EncapsulatedContent2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp3({ type: OctetString6 })
], EncapsulatedContent.prototype, "single", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.Any })
], EncapsulatedContent.prototype, "any", undefined);
EncapsulatedContent = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], EncapsulatedContent);
class EncapsulatedContentInfo {
  constructor(params = {}) {
    this.eContentType = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.ObjectIdentifier })
], EncapsulatedContentInfo.prototype, "eContentType", undefined);
__decorate([
  AsnProp3({ type: EncapsulatedContent, context: 0, optional: true })
], EncapsulatedContentInfo.prototype, "eContent", undefined);
// node_modules/@peculiar/asn1-cms/build/es2015/encrypted_content_info.js
var EncryptedContent = class EncryptedContent2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp3({ type: OctetString6, context: 0, implicit: true, optional: true })
], EncryptedContent.prototype, "value", undefined);
__decorate([
  AsnProp3({
    type: OctetString6,
    converter: AsnConstructedOctetStringConverter,
    context: 0,
    implicit: true,
    optional: true,
    repeated: "sequence"
  })
], EncryptedContent.prototype, "constructedValue", undefined);
EncryptedContent = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], EncryptedContent);
class EncryptedContentInfo {
  constructor(params = {}) {
    this.contentType = "";
    this.contentEncryptionAlgorithm = new ContentEncryptionAlgorithmIdentifier;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.ObjectIdentifier })
], EncryptedContentInfo.prototype, "contentType", undefined);
__decorate([
  AsnProp3({ type: ContentEncryptionAlgorithmIdentifier })
], EncryptedContentInfo.prototype, "contentEncryptionAlgorithm", undefined);
__decorate([
  AsnProp3({ type: EncryptedContent, optional: true })
], EncryptedContentInfo.prototype, "encryptedContent", undefined);
// node_modules/@peculiar/asn1-cms/build/es2015/other_key_attribute.js
class OtherKeyAttribute {
  constructor(params = {}) {
    this.keyAttrId = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.ObjectIdentifier })
], OtherKeyAttribute.prototype, "keyAttrId", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.Any, optional: true })
], OtherKeyAttribute.prototype, "keyAttr", undefined);

// node_modules/@peculiar/asn1-cms/build/es2015/key_agree_recipient_info.js
var RecipientEncryptedKeys_1;

class RecipientKeyIdentifier {
  constructor(params = {}) {
    this.subjectKeyIdentifier = new SubjectKeyIdentifier2;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: SubjectKeyIdentifier2 })
], RecipientKeyIdentifier.prototype, "subjectKeyIdentifier", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.GeneralizedTime, optional: true })
], RecipientKeyIdentifier.prototype, "date", undefined);
__decorate([
  AsnProp3({ type: OtherKeyAttribute, optional: true })
], RecipientKeyIdentifier.prototype, "other", undefined);
var KeyAgreeRecipientIdentifier = class KeyAgreeRecipientIdentifier2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp3({ type: RecipientKeyIdentifier, context: 0, implicit: true, optional: true })
], KeyAgreeRecipientIdentifier.prototype, "rKeyId", undefined);
__decorate([
  AsnProp3({ type: IssuerAndSerialNumber, optional: true })
], KeyAgreeRecipientIdentifier.prototype, "issuerAndSerialNumber", undefined);
KeyAgreeRecipientIdentifier = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], KeyAgreeRecipientIdentifier);
class RecipientEncryptedKey {
  constructor(params = {}) {
    this.rid = new KeyAgreeRecipientIdentifier;
    this.encryptedKey = new OctetString6;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: KeyAgreeRecipientIdentifier })
], RecipientEncryptedKey.prototype, "rid", undefined);
__decorate([
  AsnProp3({ type: OctetString6 })
], RecipientEncryptedKey.prototype, "encryptedKey", undefined);
var RecipientEncryptedKeys = RecipientEncryptedKeys_1 = class RecipientEncryptedKeys2 extends AsnArray3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RecipientEncryptedKeys_1.prototype);
  }
};
RecipientEncryptedKeys = RecipientEncryptedKeys_1 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Sequence, itemType: RecipientEncryptedKey })
], RecipientEncryptedKeys);
class OriginatorPublicKey {
  constructor(params = {}) {
    this.algorithm = new AlgorithmIdentifier3;
    this.publicKey = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AlgorithmIdentifier3 })
], OriginatorPublicKey.prototype, "algorithm", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.BitString })
], OriginatorPublicKey.prototype, "publicKey", undefined);
var OriginatorIdentifierOrKey = class OriginatorIdentifierOrKey2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp3({ type: SubjectKeyIdentifier2, context: 0, implicit: true, optional: true })
], OriginatorIdentifierOrKey.prototype, "subjectKeyIdentifier", undefined);
__decorate([
  AsnProp3({ type: OriginatorPublicKey, context: 1, implicit: true, optional: true })
], OriginatorIdentifierOrKey.prototype, "originatorKey", undefined);
__decorate([
  AsnProp3({ type: IssuerAndSerialNumber, optional: true })
], OriginatorIdentifierOrKey.prototype, "issuerAndSerialNumber", undefined);
OriginatorIdentifierOrKey = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], OriginatorIdentifierOrKey);
class KeyAgreeRecipientInfo {
  constructor(params = {}) {
    this.version = CMSVersion.v3;
    this.originator = new OriginatorIdentifierOrKey;
    this.keyEncryptionAlgorithm = new KeyEncryptionAlgorithmIdentifier;
    this.recipientEncryptedKeys = new RecipientEncryptedKeys;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.Integer })
], KeyAgreeRecipientInfo.prototype, "version", undefined);
__decorate([
  AsnProp3({ type: OriginatorIdentifierOrKey, context: 0 })
], KeyAgreeRecipientInfo.prototype, "originator", undefined);
__decorate([
  AsnProp3({ type: OctetString6, context: 1, optional: true })
], KeyAgreeRecipientInfo.prototype, "ukm", undefined);
__decorate([
  AsnProp3({ type: KeyEncryptionAlgorithmIdentifier })
], KeyAgreeRecipientInfo.prototype, "keyEncryptionAlgorithm", undefined);
__decorate([
  AsnProp3({ type: RecipientEncryptedKeys })
], KeyAgreeRecipientInfo.prototype, "recipientEncryptedKeys", undefined);

// node_modules/@peculiar/asn1-cms/build/es2015/key_trans_recipient_info.js
var RecipientIdentifier = class RecipientIdentifier2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp3({ type: SubjectKeyIdentifier2, context: 0, implicit: true })
], RecipientIdentifier.prototype, "subjectKeyIdentifier", undefined);
__decorate([
  AsnProp3({ type: IssuerAndSerialNumber })
], RecipientIdentifier.prototype, "issuerAndSerialNumber", undefined);
RecipientIdentifier = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], RecipientIdentifier);
class KeyTransRecipientInfo {
  constructor(params = {}) {
    this.version = CMSVersion.v0;
    this.rid = new RecipientIdentifier;
    this.keyEncryptionAlgorithm = new KeyEncryptionAlgorithmIdentifier;
    this.encryptedKey = new OctetString6;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.Integer })
], KeyTransRecipientInfo.prototype, "version", undefined);
__decorate([
  AsnProp3({ type: RecipientIdentifier })
], KeyTransRecipientInfo.prototype, "rid", undefined);
__decorate([
  AsnProp3({ type: KeyEncryptionAlgorithmIdentifier })
], KeyTransRecipientInfo.prototype, "keyEncryptionAlgorithm", undefined);
__decorate([
  AsnProp3({ type: OctetString6 })
], KeyTransRecipientInfo.prototype, "encryptedKey", undefined);

// node_modules/@peculiar/asn1-cms/build/es2015/kek_recipient_info.js
class KEKIdentifier {
  constructor(params = {}) {
    this.keyIdentifier = new OctetString6;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: OctetString6 })
], KEKIdentifier.prototype, "keyIdentifier", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.GeneralizedTime, optional: true })
], KEKIdentifier.prototype, "date", undefined);
__decorate([
  AsnProp3({ type: OtherKeyAttribute, optional: true })
], KEKIdentifier.prototype, "other", undefined);

class KEKRecipientInfo {
  constructor(params = {}) {
    this.version = CMSVersion.v4;
    this.kekid = new KEKIdentifier;
    this.keyEncryptionAlgorithm = new KeyEncryptionAlgorithmIdentifier;
    this.encryptedKey = new OctetString6;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.Integer })
], KEKRecipientInfo.prototype, "version", undefined);
__decorate([
  AsnProp3({ type: KEKIdentifier })
], KEKRecipientInfo.prototype, "kekid", undefined);
__decorate([
  AsnProp3({ type: KeyEncryptionAlgorithmIdentifier })
], KEKRecipientInfo.prototype, "keyEncryptionAlgorithm", undefined);
__decorate([
  AsnProp3({ type: OctetString6 })
], KEKRecipientInfo.prototype, "encryptedKey", undefined);

// node_modules/@peculiar/asn1-cms/build/es2015/password_recipient_info.js
class PasswordRecipientInfo {
  constructor(params = {}) {
    this.version = CMSVersion.v0;
    this.keyEncryptionAlgorithm = new KeyEncryptionAlgorithmIdentifier;
    this.encryptedKey = new OctetString6;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.Integer })
], PasswordRecipientInfo.prototype, "version", undefined);
__decorate([
  AsnProp3({ type: KeyDerivationAlgorithmIdentifier, context: 0, optional: true })
], PasswordRecipientInfo.prototype, "keyDerivationAlgorithm", undefined);
__decorate([
  AsnProp3({ type: KeyEncryptionAlgorithmIdentifier })
], PasswordRecipientInfo.prototype, "keyEncryptionAlgorithm", undefined);
__decorate([
  AsnProp3({ type: OctetString6 })
], PasswordRecipientInfo.prototype, "encryptedKey", undefined);

// node_modules/@peculiar/asn1-cms/build/es2015/recipient_info.js
class OtherRecipientInfo {
  constructor(params = {}) {
    this.oriType = "";
    this.oriValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.ObjectIdentifier })
], OtherRecipientInfo.prototype, "oriType", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.Any })
], OtherRecipientInfo.prototype, "oriValue", undefined);
var RecipientInfo = class RecipientInfo2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp3({ type: KeyTransRecipientInfo, optional: true })
], RecipientInfo.prototype, "ktri", undefined);
__decorate([
  AsnProp3({ type: KeyAgreeRecipientInfo, context: 1, implicit: true, optional: true })
], RecipientInfo.prototype, "kari", undefined);
__decorate([
  AsnProp3({ type: KEKRecipientInfo, context: 2, implicit: true, optional: true })
], RecipientInfo.prototype, "kekri", undefined);
__decorate([
  AsnProp3({ type: PasswordRecipientInfo, context: 3, implicit: true, optional: true })
], RecipientInfo.prototype, "pwri", undefined);
__decorate([
  AsnProp3({ type: OtherRecipientInfo, context: 4, implicit: true, optional: true })
], RecipientInfo.prototype, "ori", undefined);
RecipientInfo = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], RecipientInfo);

// node_modules/@peculiar/asn1-cms/build/es2015/recipient_infos.js
var RecipientInfos_1;
var RecipientInfos = RecipientInfos_1 = class RecipientInfos2 extends AsnArray3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RecipientInfos_1.prototype);
  }
};
RecipientInfos = RecipientInfos_1 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Set, itemType: RecipientInfo })
], RecipientInfos);

// node_modules/@peculiar/asn1-cms/build/es2015/revocation_info_choice.js
var RevocationInfoChoices_1;
var id_ri = `${id_pkix3}.16`;
var id_ri_ocsp_response = `${id_ri}.2`;
var id_ri_scvp = `${id_ri}.4`;

class OtherRevocationInfoFormat {
  constructor(params = {}) {
    this.otherRevInfoFormat = "";
    this.otherRevInfo = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.ObjectIdentifier })
], OtherRevocationInfoFormat.prototype, "otherRevInfoFormat", undefined);
__decorate([
  AsnProp3({ type: AsnPropTypes3.Any })
], OtherRevocationInfoFormat.prototype, "otherRevInfo", undefined);
var RevocationInfoChoice = class RevocationInfoChoice2 {
  constructor(params = {}) {
    this.other = new OtherRevocationInfoFormat;
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp3({ type: OtherRevocationInfoFormat, context: 1, implicit: true })
], RevocationInfoChoice.prototype, "other", undefined);
RevocationInfoChoice = __decorate([
  AsnType3({ type: AsnTypeTypes3.Choice })
], RevocationInfoChoice);
var RevocationInfoChoices = RevocationInfoChoices_1 = class RevocationInfoChoices2 extends AsnArray3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RevocationInfoChoices_1.prototype);
  }
};
RevocationInfoChoices = RevocationInfoChoices_1 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Set, itemType: RevocationInfoChoice })
], RevocationInfoChoices);

// node_modules/@peculiar/asn1-cms/build/es2015/originator_info.js
class OriginatorInfo {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: CertificateSet, context: 0, implicit: true, optional: true })
], OriginatorInfo.prototype, "certs", undefined);
__decorate([
  AsnProp3({ type: RevocationInfoChoices, context: 1, implicit: true, optional: true })
], OriginatorInfo.prototype, "crls", undefined);

// node_modules/@peculiar/asn1-cms/build/es2015/enveloped_data.js
var UnprotectedAttributes_1;
var UnprotectedAttributes = UnprotectedAttributes_1 = class UnprotectedAttributes2 extends AsnArray3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, UnprotectedAttributes_1.prototype);
  }
};
UnprotectedAttributes = UnprotectedAttributes_1 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Set, itemType: Attribute4 })
], UnprotectedAttributes);
class EnvelopedData {
  constructor(params = {}) {
    this.version = CMSVersion.v0;
    this.recipientInfos = new RecipientInfos;
    this.encryptedContentInfo = new EncryptedContentInfo;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.Integer })
], EnvelopedData.prototype, "version", undefined);
__decorate([
  AsnProp3({ type: OriginatorInfo, context: 0, implicit: true, optional: true })
], EnvelopedData.prototype, "originatorInfo", undefined);
__decorate([
  AsnProp3({ type: RecipientInfos })
], EnvelopedData.prototype, "recipientInfos", undefined);
__decorate([
  AsnProp3({ type: EncryptedContentInfo })
], EnvelopedData.prototype, "encryptedContentInfo", undefined);
__decorate([
  AsnProp3({ type: UnprotectedAttributes, context: 1, implicit: true, optional: true })
], EnvelopedData.prototype, "unprotectedAttrs", undefined);
// node_modules/@peculiar/asn1-cms/build/es2015/object_identifiers.js
var id_signedData = "1.2.840.113549.1.7.2";
// node_modules/@peculiar/asn1-cms/build/es2015/signed_data.js
var DigestAlgorithmIdentifiers_1;
var DigestAlgorithmIdentifiers = DigestAlgorithmIdentifiers_1 = class DigestAlgorithmIdentifiers2 extends AsnArray3 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, DigestAlgorithmIdentifiers_1.prototype);
  }
};
DigestAlgorithmIdentifiers = DigestAlgorithmIdentifiers_1 = __decorate([
  AsnType3({ type: AsnTypeTypes3.Set, itemType: DigestAlgorithmIdentifier })
], DigestAlgorithmIdentifiers);
class SignedData {
  constructor(params = {}) {
    this.version = CMSVersion.v0;
    this.digestAlgorithms = new DigestAlgorithmIdentifiers;
    this.encapContentInfo = new EncapsulatedContentInfo;
    this.signerInfos = new SignerInfos;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp3({ type: AsnPropTypes3.Integer })
], SignedData.prototype, "version", undefined);
__decorate([
  AsnProp3({ type: DigestAlgorithmIdentifiers })
], SignedData.prototype, "digestAlgorithms", undefined);
__decorate([
  AsnProp3({ type: EncapsulatedContentInfo })
], SignedData.prototype, "encapContentInfo", undefined);
__decorate([
  AsnProp3({ type: CertificateSet, context: 0, implicit: true, optional: true })
], SignedData.prototype, "certificates", undefined);
__decorate([
  AsnProp3({ type: RevocationInfoChoices, context: 1, implicit: true, optional: true })
], SignedData.prototype, "crls", undefined);
__decorate([
  AsnProp3({ type: SignerInfos })
], SignedData.prototype, "signerInfos", undefined);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-ecc/build/es2015/object_identifiers.js
var id_ecPublicKey = "1.2.840.10045.2.1";
var id_ecdsaWithSHA1 = "1.2.840.10045.4.1";
var id_ecdsaWithSHA224 = "1.2.840.10045.4.3.1";
var id_ecdsaWithSHA256 = "1.2.840.10045.4.3.2";
var id_ecdsaWithSHA384 = "1.2.840.10045.4.3.3";
var id_ecdsaWithSHA512 = "1.2.840.10045.4.3.4";
var id_secp256r1 = "1.2.840.10045.3.1.7";
var id_secp384r1 = "1.3.132.0.34";
var id_secp521r1 = "1.3.132.0.35";

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-ecc/build/es2015/algorithms.js
function create(algorithm2) {
  return new AlgorithmIdentifier2({ algorithm: algorithm2 });
}
var ecdsaWithSHA1 = create(id_ecdsaWithSHA1);
var ecdsaWithSHA224 = create(id_ecdsaWithSHA224);
var ecdsaWithSHA256 = create(id_ecdsaWithSHA256);
var ecdsaWithSHA384 = create(id_ecdsaWithSHA384);
var ecdsaWithSHA512 = create(id_ecdsaWithSHA512);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-ecc/build/es2015/rfc3279.js
var FieldID = class FieldID2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp2({ type: AsnPropTypes2.ObjectIdentifier })
], FieldID.prototype, "fieldType", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Any })
], FieldID.prototype, "parameters", undefined);
FieldID = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence })
], FieldID);
class ECPoint extends OctetString4 {
}
var Curve = class Curve2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp2({ type: AsnPropTypes2.OctetString })
], Curve.prototype, "a", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.OctetString })
], Curve.prototype, "b", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.BitString, optional: true })
], Curve.prototype, "seed", undefined);
Curve = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence })
], Curve);
var ECPVer;
(function(ECPVer2) {
  ECPVer2[ECPVer2["ecpVer1"] = 1] = "ecpVer1";
})(ECPVer || (ECPVer = {}));
var SpecifiedECDomain = class SpecifiedECDomain2 {
  constructor(params = {}) {
    this.version = ECPVer.ecpVer1;
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer })
], SpecifiedECDomain.prototype, "version", undefined);
__decorate([
  AsnProp2({ type: FieldID })
], SpecifiedECDomain.prototype, "fieldID", undefined);
__decorate([
  AsnProp2({ type: Curve })
], SpecifiedECDomain.prototype, "curve", undefined);
__decorate([
  AsnProp2({ type: ECPoint })
], SpecifiedECDomain.prototype, "base", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, converter: AsnIntegerArrayBufferConverter2 })
], SpecifiedECDomain.prototype, "order", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, optional: true })
], SpecifiedECDomain.prototype, "cofactor", undefined);
SpecifiedECDomain = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence })
], SpecifiedECDomain);

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-ecc/build/es2015/ec_parameters.js
var ECParameters = class ECParameters2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp2({ type: AsnPropTypes2.ObjectIdentifier })
], ECParameters.prototype, "namedCurve", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Null })
], ECParameters.prototype, "implicitCurve", undefined);
__decorate([
  AsnProp2({ type: SpecifiedECDomain })
], ECParameters.prototype, "specifiedCurve", undefined);
ECParameters = __decorate([
  AsnType2({ type: AsnTypeTypes2.Choice })
], ECParameters);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-ecc/build/es2015/ec_private_key.js
class ECPrivateKey {
  constructor(params = {}) {
    this.version = 1;
    this.privateKey = new OctetString4;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer })
], ECPrivateKey.prototype, "version", undefined);
__decorate([
  AsnProp2({ type: OctetString4 })
], ECPrivateKey.prototype, "privateKey", undefined);
__decorate([
  AsnProp2({ type: ECParameters, context: 0, optional: true })
], ECPrivateKey.prototype, "parameters", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.BitString, context: 1, optional: true })
], ECPrivateKey.prototype, "publicKey", undefined);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-ecc/build/es2015/ec_signature_value.js
class ECDSASigValue {
  constructor(params = {}) {
    this.r = new ArrayBuffer(0);
    this.s = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, converter: AsnIntegerArrayBufferConverter2 })
], ECDSASigValue.prototype, "r", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, converter: AsnIntegerArrayBufferConverter2 })
], ECDSASigValue.prototype, "s", undefined);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-rsa/build/es2015/object_identifiers.js
var id_pkcs_1 = "1.2.840.113549.1.1";
var id_rsaEncryption = `${id_pkcs_1}.1`;
var id_RSAES_OAEP = `${id_pkcs_1}.7`;
var id_pSpecified = `${id_pkcs_1}.9`;
var id_RSASSA_PSS = `${id_pkcs_1}.10`;
var id_md2WithRSAEncryption = `${id_pkcs_1}.2`;
var id_md5WithRSAEncryption = `${id_pkcs_1}.4`;
var id_sha1WithRSAEncryption = `${id_pkcs_1}.5`;
var id_sha224WithRSAEncryption = `${id_pkcs_1}.14`;
var id_sha256WithRSAEncryption = `${id_pkcs_1}.11`;
var id_sha384WithRSAEncryption = `${id_pkcs_1}.12`;
var id_sha512WithRSAEncryption = `${id_pkcs_1}.13`;
var id_sha512_224WithRSAEncryption = `${id_pkcs_1}.15`;
var id_sha512_256WithRSAEncryption = `${id_pkcs_1}.16`;
var id_sha1 = "1.3.14.3.2.26";
var id_sha224 = "2.16.840.1.101.3.4.2.4";
var id_sha256 = "2.16.840.1.101.3.4.2.1";
var id_sha384 = "2.16.840.1.101.3.4.2.2";
var id_sha512 = "2.16.840.1.101.3.4.2.3";
var id_sha512_224 = "2.16.840.1.101.3.4.2.5";
var id_sha512_256 = "2.16.840.1.101.3.4.2.6";
var id_md2 = "1.2.840.113549.2.2";
var id_md5 = "1.2.840.113549.2.5";
var id_mgf1 = `${id_pkcs_1}.8`;

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-rsa/build/es2015/algorithms.js
function create2(algorithm2) {
  return new AlgorithmIdentifier2({ algorithm: algorithm2, parameters: null });
}
var md2 = create2(id_md2);
var md4 = create2(id_md5);
var sha1 = create2(id_sha1);
var sha224 = create2(id_sha224);
var sha256 = create2(id_sha256);
var sha384 = create2(id_sha384);
var sha512 = create2(id_sha512);
var sha512_224 = create2(id_sha512_224);
var sha512_256 = create2(id_sha512_256);
var mgf1SHA1 = new AlgorithmIdentifier2({
  algorithm: id_mgf1,
  parameters: AsnConvert2.serialize(sha1)
});
var pSpecifiedEmpty = new AlgorithmIdentifier2({
  algorithm: id_pSpecified,
  parameters: AsnConvert2.serialize(AsnOctetStringConverter2.toASN(new Uint8Array([
    218,
    57,
    163,
    238,
    94,
    107,
    75,
    13,
    50,
    85,
    191,
    239,
    149,
    96,
    24,
    144,
    175,
    216,
    7,
    9
  ]).buffer))
});
var rsaEncryption = create2(id_rsaEncryption);
var md2WithRSAEncryption = create2(id_md2WithRSAEncryption);
var md5WithRSAEncryption = create2(id_md5WithRSAEncryption);
var sha1WithRSAEncryption = create2(id_sha1WithRSAEncryption);
var sha224WithRSAEncryption = create2(id_sha512_224WithRSAEncryption);
var sha256WithRSAEncryption = create2(id_sha512_256WithRSAEncryption);
var sha384WithRSAEncryption = create2(id_sha384WithRSAEncryption);
var sha512WithRSAEncryption = create2(id_sha512WithRSAEncryption);
var sha512_224WithRSAEncryption = create2(id_sha512_224WithRSAEncryption);
var sha512_256WithRSAEncryption = create2(id_sha512_256WithRSAEncryption);

// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsaes_oaep.js
class RsaEsOaepParams {
  constructor(params = {}) {
    this.hashAlgorithm = new AlgorithmIdentifier2(sha1);
    this.maskGenAlgorithm = new AlgorithmIdentifier2({
      algorithm: id_mgf1,
      parameters: AsnConvert2.serialize(sha1)
    });
    this.pSourceAlgorithm = new AlgorithmIdentifier2(pSpecifiedEmpty);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AlgorithmIdentifier2, context: 0, defaultValue: sha1 })
], RsaEsOaepParams.prototype, "hashAlgorithm", undefined);
__decorate([
  AsnProp2({ type: AlgorithmIdentifier2, context: 1, defaultValue: mgf1SHA1 })
], RsaEsOaepParams.prototype, "maskGenAlgorithm", undefined);
__decorate([
  AsnProp2({ type: AlgorithmIdentifier2, context: 2, defaultValue: pSpecifiedEmpty })
], RsaEsOaepParams.prototype, "pSourceAlgorithm", undefined);
var RSAES_OAEP = new AlgorithmIdentifier2({
  algorithm: id_RSAES_OAEP,
  parameters: AsnConvert2.serialize(new RsaEsOaepParams)
});
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pss.js
class RsaSaPssParams {
  constructor(params = {}) {
    this.hashAlgorithm = new AlgorithmIdentifier2(sha1);
    this.maskGenAlgorithm = new AlgorithmIdentifier2({
      algorithm: id_mgf1,
      parameters: AsnConvert2.serialize(sha1)
    });
    this.saltLength = 20;
    this.trailerField = 1;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AlgorithmIdentifier2, context: 0, defaultValue: sha1 })
], RsaSaPssParams.prototype, "hashAlgorithm", undefined);
__decorate([
  AsnProp2({ type: AlgorithmIdentifier2, context: 1, defaultValue: mgf1SHA1 })
], RsaSaPssParams.prototype, "maskGenAlgorithm", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, context: 2, defaultValue: 20 })
], RsaSaPssParams.prototype, "saltLength", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, context: 3, defaultValue: 1 })
], RsaSaPssParams.prototype, "trailerField", undefined);
var RSASSA_PSS = new AlgorithmIdentifier2({
  algorithm: id_RSASSA_PSS,
  parameters: AsnConvert2.serialize(new RsaSaPssParams)
});
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pkcs1_v1_5.js
class DigestInfo {
  constructor(params = {}) {
    this.digestAlgorithm = new AlgorithmIdentifier2;
    this.digest = new OctetString4;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AlgorithmIdentifier2 })
], DigestInfo.prototype, "digestAlgorithm", undefined);
__decorate([
  AsnProp2({ type: OctetString4 })
], DigestInfo.prototype, "digest", undefined);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-rsa/build/es2015/other_prime_info.js
var OtherPrimeInfos_1;

class OtherPrimeInfo {
  constructor(params = {}) {
    this.prime = new ArrayBuffer(0);
    this.exponent = new ArrayBuffer(0);
    this.coefficient = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, converter: AsnIntegerArrayBufferConverter2 })
], OtherPrimeInfo.prototype, "prime", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, converter: AsnIntegerArrayBufferConverter2 })
], OtherPrimeInfo.prototype, "exponent", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, converter: AsnIntegerArrayBufferConverter2 })
], OtherPrimeInfo.prototype, "coefficient", undefined);
var OtherPrimeInfos = OtherPrimeInfos_1 = class OtherPrimeInfos2 extends AsnArray2 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, OtherPrimeInfos_1.prototype);
  }
};
OtherPrimeInfos = OtherPrimeInfos_1 = __decorate([
  AsnType2({ type: AsnTypeTypes2.Sequence, itemType: OtherPrimeInfo })
], OtherPrimeInfos);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-rsa/build/es2015/rsa_private_key.js
class RSAPrivateKey {
  constructor(params = {}) {
    this.version = 0;
    this.modulus = new ArrayBuffer(0);
    this.publicExponent = new ArrayBuffer(0);
    this.privateExponent = new ArrayBuffer(0);
    this.prime1 = new ArrayBuffer(0);
    this.prime2 = new ArrayBuffer(0);
    this.exponent1 = new ArrayBuffer(0);
    this.exponent2 = new ArrayBuffer(0);
    this.coefficient = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer })
], RSAPrivateKey.prototype, "version", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, converter: AsnIntegerArrayBufferConverter2 })
], RSAPrivateKey.prototype, "modulus", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, converter: AsnIntegerArrayBufferConverter2 })
], RSAPrivateKey.prototype, "publicExponent", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, converter: AsnIntegerArrayBufferConverter2 })
], RSAPrivateKey.prototype, "privateExponent", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, converter: AsnIntegerArrayBufferConverter2 })
], RSAPrivateKey.prototype, "prime1", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, converter: AsnIntegerArrayBufferConverter2 })
], RSAPrivateKey.prototype, "prime2", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, converter: AsnIntegerArrayBufferConverter2 })
], RSAPrivateKey.prototype, "exponent1", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, converter: AsnIntegerArrayBufferConverter2 })
], RSAPrivateKey.prototype, "exponent2", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, converter: AsnIntegerArrayBufferConverter2 })
], RSAPrivateKey.prototype, "coefficient", undefined);
__decorate([
  AsnProp2({ type: OtherPrimeInfos, optional: true })
], RSAPrivateKey.prototype, "otherPrimeInfos", undefined);
// node_modules/@peculiar/x509/node_modules/@peculiar/asn1-rsa/build/es2015/rsa_public_key.js
class RSAPublicKey {
  constructor(params = {}) {
    this.modulus = new ArrayBuffer(0);
    this.publicExponent = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, converter: AsnIntegerArrayBufferConverter2 })
], RSAPublicKey.prototype, "modulus", undefined);
__decorate([
  AsnProp2({ type: AsnPropTypes2.Integer, converter: AsnIntegerArrayBufferConverter2 })
], RSAPublicKey.prototype, "publicExponent", undefined);
// node_modules/tsyringe/dist/esm5/types/lifecycle.js
var Lifecycle;
(function(Lifecycle2) {
  Lifecycle2[Lifecycle2["Transient"] = 0] = "Transient";
  Lifecycle2[Lifecycle2["Singleton"] = 1] = "Singleton";
  Lifecycle2[Lifecycle2["ResolutionScoped"] = 2] = "ResolutionScoped";
  Lifecycle2[Lifecycle2["ContainerScoped"] = 3] = "ContainerScoped";
})(Lifecycle || (Lifecycle = {}));
var lifecycle_default = Lifecycle;
// node_modules/tsyringe/node_modules/tslib/modules/index.js
var import_tslib195 = __toESM(require_tslib2(), 1);
var {
  __extends: __extends2,
  __assign: __assign2,
  __rest: __rest2,
  __decorate: __decorate2,
  __param: __param2,
  __metadata: __metadata2,
  __awaiter: __awaiter2,
  __generator: __generator2,
  __exportStar: __exportStar2,
  __createBinding: __createBinding2,
  __values: __values2,
  __read: __read2,
  __spread: __spread2,
  __spreadArrays: __spreadArrays2,
  __await: __await2,
  __asyncGenerator: __asyncGenerator2,
  __asyncDelegator: __asyncDelegator2,
  __asyncValues: __asyncValues2,
  __makeTemplateObject: __makeTemplateObject2,
  __importStar: __importStar2,
  __importDefault: __importDefault2,
  __classPrivateFieldGet: __classPrivateFieldGet2,
  __classPrivateFieldSet: __classPrivateFieldSet2
} = import_tslib195.default;

// node_modules/tsyringe/dist/esm5/reflection-helpers.js
var INJECTION_TOKEN_METADATA_KEY = "injectionTokens";
function getParamInfo(target2) {
  var params = Reflect.getMetadata("design:paramtypes", target2) || [];
  var injectionTokens = Reflect.getOwnMetadata(INJECTION_TOKEN_METADATA_KEY, target2) || {};
  Object.keys(injectionTokens).forEach(function(key) {
    params[+key] = injectionTokens[key];
  });
  return params;
}

// node_modules/tsyringe/dist/esm5/providers/class-provider.js
function isClassProvider(provider) {
  return !!provider.useClass;
}
// node_modules/tsyringe/dist/esm5/providers/factory-provider.js
function isFactoryProvider(provider) {
  return !!provider.useFactory;
}
// node_modules/tsyringe/dist/esm5/lazy-helpers.js
var DelayedConstructor = function() {
  function DelayedConstructor2(wrap) {
    this.wrap = wrap;
    this.reflectMethods = [
      "get",
      "getPrototypeOf",
      "setPrototypeOf",
      "getOwnPropertyDescriptor",
      "defineProperty",
      "has",
      "set",
      "deleteProperty",
      "apply",
      "construct",
      "ownKeys"
    ];
  }
  DelayedConstructor2.prototype.createProxy = function(createObject) {
    var _this = this;
    var target2 = {};
    var init = false;
    var value;
    var delayedObject = function() {
      if (!init) {
        value = createObject(_this.wrap());
        init = true;
      }
      return value;
    };
    return new Proxy(target2, this.createHandler(delayedObject));
  };
  DelayedConstructor2.prototype.createHandler = function(delayedObject) {
    var handler = {};
    var install = function(name5) {
      handler[name5] = function() {
        var args = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        args[0] = delayedObject();
        var method = Reflect[name5];
        return method.apply(undefined, __spread2(args));
      };
    };
    this.reflectMethods.forEach(install);
    return handler;
  };
  return DelayedConstructor2;
}();

// node_modules/tsyringe/dist/esm5/providers/injection-token.js
function isNormalToken(token) {
  return typeof token === "string" || typeof token === "symbol";
}
function isTokenDescriptor(descriptor) {
  return typeof descriptor === "object" && "token" in descriptor && "multiple" in descriptor;
}
function isTransformDescriptor(descriptor) {
  return typeof descriptor === "object" && "token" in descriptor && "transform" in descriptor;
}
function isConstructorToken(token) {
  return typeof token === "function" || token instanceof DelayedConstructor;
}
// node_modules/tsyringe/dist/esm5/providers/token-provider.js
function isTokenProvider(provider) {
  return !!provider.useToken;
}
// node_modules/tsyringe/dist/esm5/providers/value-provider.js
function isValueProvider(provider) {
  return provider.useValue != null;
}
// node_modules/tsyringe/dist/esm5/providers/provider.js
function isProvider(provider) {
  return isClassProvider(provider) || isValueProvider(provider) || isTokenProvider(provider) || isFactoryProvider(provider);
}

// node_modules/tsyringe/dist/esm5/registry-base.js
var RegistryBase = function() {
  function RegistryBase2() {
    this._registryMap = new Map;
  }
  RegistryBase2.prototype.entries = function() {
    return this._registryMap.entries();
  };
  RegistryBase2.prototype.getAll = function(key) {
    this.ensure(key);
    return this._registryMap.get(key);
  };
  RegistryBase2.prototype.get = function(key) {
    this.ensure(key);
    var value = this._registryMap.get(key);
    return value[value.length - 1] || null;
  };
  RegistryBase2.prototype.set = function(key, value) {
    this.ensure(key);
    this._registryMap.get(key).push(value);
  };
  RegistryBase2.prototype.setAll = function(key, value) {
    this._registryMap.set(key, value);
  };
  RegistryBase2.prototype.has = function(key) {
    this.ensure(key);
    return this._registryMap.get(key).length > 0;
  };
  RegistryBase2.prototype.clear = function() {
    this._registryMap.clear();
  };
  RegistryBase2.prototype.ensure = function(key) {
    if (!this._registryMap.has(key)) {
      this._registryMap.set(key, []);
    }
  };
  return RegistryBase2;
}();
var registry_base_default = RegistryBase;

// node_modules/tsyringe/dist/esm5/registry.js
var Registry = function(_super) {
  __extends2(Registry2, _super);
  function Registry2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return Registry2;
}(registry_base_default);
var registry_default = Registry;

// node_modules/tsyringe/dist/esm5/resolution-context.js
var ResolutionContext = function() {
  function ResolutionContext2() {
    this.scopedResolutions = new Map;
  }
  return ResolutionContext2;
}();
var resolution_context_default = ResolutionContext;

// node_modules/tsyringe/dist/esm5/error-helpers.js
function formatDependency(params, idx) {
  if (params === null) {
    return "at position #" + idx;
  }
  var argName = params.split(",")[idx].trim();
  return '"' + argName + '" at position #' + idx;
}
function composeErrorMessage(msg, e, indent) {
  if (indent === undefined) {
    indent = "    ";
  }
  return __spread2([msg], e.message.split(`
`).map(function(l) {
    return indent + l;
  })).join(`
`);
}
function formatErrorCtor(ctor, paramIdx, error) {
  var _a5 = __read2(ctor.toString().match(/constructor\(([\w, ]+)\)/) || [], 2), _b = _a5[1], params = _b === undefined ? null : _b;
  var dep = formatDependency(params, paramIdx);
  return composeErrorMessage("Cannot inject the dependency " + dep + ' of "' + ctor.name + '" constructor. Reason:', error);
}

// node_modules/tsyringe/dist/esm5/types/disposable.js
function isDisposable(value) {
  if (typeof value.dispose !== "function")
    return false;
  var disposeFun = value.dispose;
  if (disposeFun.length > 0) {
    return false;
  }
  return true;
}

// node_modules/tsyringe/dist/esm5/interceptors.js
var PreResolutionInterceptors = function(_super) {
  __extends2(PreResolutionInterceptors2, _super);
  function PreResolutionInterceptors2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return PreResolutionInterceptors2;
}(registry_base_default);
var PostResolutionInterceptors = function(_super) {
  __extends2(PostResolutionInterceptors2, _super);
  function PostResolutionInterceptors2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return PostResolutionInterceptors2;
}(registry_base_default);
var Interceptors = function() {
  function Interceptors2() {
    this.preResolution = new PreResolutionInterceptors;
    this.postResolution = new PostResolutionInterceptors;
  }
  return Interceptors2;
}();
var interceptors_default = Interceptors;

// node_modules/tsyringe/dist/esm5/dependency-container.js
var typeInfo = new Map;
var InternalDependencyContainer = function() {
  function InternalDependencyContainer2(parent) {
    this.parent = parent;
    this._registry = new registry_default;
    this.interceptors = new interceptors_default;
    this.disposed = false;
    this.disposables = new Set;
  }
  InternalDependencyContainer2.prototype.register = function(token, providerOrConstructor, options) {
    if (options === undefined) {
      options = { lifecycle: lifecycle_default.Transient };
    }
    this.ensureNotDisposed();
    var provider;
    if (!isProvider(providerOrConstructor)) {
      provider = { useClass: providerOrConstructor };
    } else {
      provider = providerOrConstructor;
    }
    if (isTokenProvider(provider)) {
      var path2 = [token];
      var tokenProvider = provider;
      while (tokenProvider != null) {
        var currentToken = tokenProvider.useToken;
        if (path2.includes(currentToken)) {
          throw new Error("Token registration cycle detected! " + __spread2(path2, [currentToken]).join(" -> "));
        }
        path2.push(currentToken);
        var registration = this._registry.get(currentToken);
        if (registration && isTokenProvider(registration.provider)) {
          tokenProvider = registration.provider;
        } else {
          tokenProvider = null;
        }
      }
    }
    if (options.lifecycle === lifecycle_default.Singleton || options.lifecycle == lifecycle_default.ContainerScoped || options.lifecycle == lifecycle_default.ResolutionScoped) {
      if (isValueProvider(provider) || isFactoryProvider(provider)) {
        throw new Error('Cannot use lifecycle "' + lifecycle_default[options.lifecycle] + '" with ValueProviders or FactoryProviders');
      }
    }
    this._registry.set(token, { provider, options });
    return this;
  };
  InternalDependencyContainer2.prototype.registerType = function(from, to) {
    this.ensureNotDisposed();
    if (isNormalToken(to)) {
      return this.register(from, {
        useToken: to
      });
    }
    return this.register(from, {
      useClass: to
    });
  };
  InternalDependencyContainer2.prototype.registerInstance = function(token, instance) {
    this.ensureNotDisposed();
    return this.register(token, {
      useValue: instance
    });
  };
  InternalDependencyContainer2.prototype.registerSingleton = function(from, to) {
    this.ensureNotDisposed();
    if (isNormalToken(from)) {
      if (isNormalToken(to)) {
        return this.register(from, {
          useToken: to
        }, { lifecycle: lifecycle_default.Singleton });
      } else if (to) {
        return this.register(from, {
          useClass: to
        }, { lifecycle: lifecycle_default.Singleton });
      }
      throw new Error('Cannot register a type name as a singleton without a "to" token');
    }
    var useClass = from;
    if (to && !isNormalToken(to)) {
      useClass = to;
    }
    return this.register(from, {
      useClass
    }, { lifecycle: lifecycle_default.Singleton });
  };
  InternalDependencyContainer2.prototype.resolve = function(token, context, isOptional) {
    if (context === undefined) {
      context = new resolution_context_default;
    }
    if (isOptional === undefined) {
      isOptional = false;
    }
    this.ensureNotDisposed();
    var registration = this.getRegistration(token);
    if (!registration && isNormalToken(token)) {
      if (isOptional) {
        return;
      }
      throw new Error('Attempted to resolve unregistered dependency token: "' + token.toString() + '"');
    }
    this.executePreResolutionInterceptor(token, "Single");
    if (registration) {
      var result = this.resolveRegistration(registration, context);
      this.executePostResolutionInterceptor(token, result, "Single");
      return result;
    }
    if (isConstructorToken(token)) {
      var result = this.construct(token, context);
      this.executePostResolutionInterceptor(token, result, "Single");
      return result;
    }
    throw new Error("Attempted to construct an undefined constructor. Could mean a circular dependency problem. Try using `delay` function.");
  };
  InternalDependencyContainer2.prototype.executePreResolutionInterceptor = function(token, resolutionType) {
    var e_1, _a5;
    if (this.interceptors.preResolution.has(token)) {
      var remainingInterceptors = [];
      try {
        for (var _b = __values2(this.interceptors.preResolution.getAll(token)), _c = _b.next();!_c.done; _c = _b.next()) {
          var interceptor = _c.value;
          if (interceptor.options.frequency != "Once") {
            remainingInterceptors.push(interceptor);
          }
          interceptor.callback(token, resolutionType);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a5 = _b.return))
            _a5.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      this.interceptors.preResolution.setAll(token, remainingInterceptors);
    }
  };
  InternalDependencyContainer2.prototype.executePostResolutionInterceptor = function(token, result, resolutionType) {
    var e_2, _a5;
    if (this.interceptors.postResolution.has(token)) {
      var remainingInterceptors = [];
      try {
        for (var _b = __values2(this.interceptors.postResolution.getAll(token)), _c = _b.next();!_c.done; _c = _b.next()) {
          var interceptor = _c.value;
          if (interceptor.options.frequency != "Once") {
            remainingInterceptors.push(interceptor);
          }
          interceptor.callback(token, result, resolutionType);
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a5 = _b.return))
            _a5.call(_b);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      this.interceptors.postResolution.setAll(token, remainingInterceptors);
    }
  };
  InternalDependencyContainer2.prototype.resolveRegistration = function(registration, context) {
    this.ensureNotDisposed();
    if (registration.options.lifecycle === lifecycle_default.ResolutionScoped && context.scopedResolutions.has(registration)) {
      return context.scopedResolutions.get(registration);
    }
    var isSingleton = registration.options.lifecycle === lifecycle_default.Singleton;
    var isContainerScoped = registration.options.lifecycle === lifecycle_default.ContainerScoped;
    var returnInstance = isSingleton || isContainerScoped;
    var resolved;
    if (isValueProvider(registration.provider)) {
      resolved = registration.provider.useValue;
    } else if (isTokenProvider(registration.provider)) {
      resolved = returnInstance ? registration.instance || (registration.instance = this.resolve(registration.provider.useToken, context)) : this.resolve(registration.provider.useToken, context);
    } else if (isClassProvider(registration.provider)) {
      resolved = returnInstance ? registration.instance || (registration.instance = this.construct(registration.provider.useClass, context)) : this.construct(registration.provider.useClass, context);
    } else if (isFactoryProvider(registration.provider)) {
      resolved = registration.provider.useFactory(this);
    } else {
      resolved = this.construct(registration.provider, context);
    }
    if (registration.options.lifecycle === lifecycle_default.ResolutionScoped) {
      context.scopedResolutions.set(registration, resolved);
    }
    return resolved;
  };
  InternalDependencyContainer2.prototype.resolveAll = function(token, context, isOptional) {
    var _this = this;
    if (context === undefined) {
      context = new resolution_context_default;
    }
    if (isOptional === undefined) {
      isOptional = false;
    }
    this.ensureNotDisposed();
    var registrations = this.getAllRegistrations(token);
    if (!registrations && isNormalToken(token)) {
      if (isOptional) {
        return [];
      }
      throw new Error('Attempted to resolve unregistered dependency token: "' + token.toString() + '"');
    }
    this.executePreResolutionInterceptor(token, "All");
    if (registrations) {
      var result_1 = registrations.map(function(item) {
        return _this.resolveRegistration(item, context);
      });
      this.executePostResolutionInterceptor(token, result_1, "All");
      return result_1;
    }
    var result = [this.construct(token, context)];
    this.executePostResolutionInterceptor(token, result, "All");
    return result;
  };
  InternalDependencyContainer2.prototype.isRegistered = function(token, recursive) {
    if (recursive === undefined) {
      recursive = false;
    }
    this.ensureNotDisposed();
    return this._registry.has(token) || recursive && (this.parent || false) && this.parent.isRegistered(token, true);
  };
  InternalDependencyContainer2.prototype.reset = function() {
    this.ensureNotDisposed();
    this._registry.clear();
    this.interceptors.preResolution.clear();
    this.interceptors.postResolution.clear();
  };
  InternalDependencyContainer2.prototype.clearInstances = function() {
    var e_3, _a5;
    this.ensureNotDisposed();
    try {
      for (var _b = __values2(this._registry.entries()), _c = _b.next();!_c.done; _c = _b.next()) {
        var _d = __read2(_c.value, 2), token = _d[0], registrations = _d[1];
        this._registry.setAll(token, registrations.filter(function(registration) {
          return !isValueProvider(registration.provider);
        }).map(function(registration) {
          registration.instance = undefined;
          return registration;
        }));
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a5 = _b.return))
          _a5.call(_b);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
  };
  InternalDependencyContainer2.prototype.createChildContainer = function() {
    var e_4, _a5;
    this.ensureNotDisposed();
    var childContainer = new InternalDependencyContainer2(this);
    try {
      for (var _b = __values2(this._registry.entries()), _c = _b.next();!_c.done; _c = _b.next()) {
        var _d = __read2(_c.value, 2), token = _d[0], registrations = _d[1];
        if (registrations.some(function(_a6) {
          var options = _a6.options;
          return options.lifecycle === lifecycle_default.ContainerScoped;
        })) {
          childContainer._registry.setAll(token, registrations.map(function(registration) {
            if (registration.options.lifecycle === lifecycle_default.ContainerScoped) {
              return {
                provider: registration.provider,
                options: registration.options
              };
            }
            return registration;
          }));
        }
      }
    } catch (e_4_1) {
      e_4 = { error: e_4_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a5 = _b.return))
          _a5.call(_b);
      } finally {
        if (e_4)
          throw e_4.error;
      }
    }
    return childContainer;
  };
  InternalDependencyContainer2.prototype.beforeResolution = function(token, callback, options) {
    if (options === undefined) {
      options = { frequency: "Always" };
    }
    this.interceptors.preResolution.set(token, {
      callback,
      options
    });
  };
  InternalDependencyContainer2.prototype.afterResolution = function(token, callback, options) {
    if (options === undefined) {
      options = { frequency: "Always" };
    }
    this.interceptors.postResolution.set(token, {
      callback,
      options
    });
  };
  InternalDependencyContainer2.prototype.dispose = function() {
    return __awaiter2(this, undefined, undefined, function() {
      var promises;
      return __generator2(this, function(_a5) {
        switch (_a5.label) {
          case 0:
            this.disposed = true;
            promises = [];
            this.disposables.forEach(function(disposable) {
              var maybePromise = disposable.dispose();
              if (maybePromise) {
                promises.push(maybePromise);
              }
            });
            return [4, Promise.all(promises)];
          case 1:
            _a5.sent();
            return [2];
        }
      });
    });
  };
  InternalDependencyContainer2.prototype.getRegistration = function(token) {
    if (this.isRegistered(token)) {
      return this._registry.get(token);
    }
    if (this.parent) {
      return this.parent.getRegistration(token);
    }
    return null;
  };
  InternalDependencyContainer2.prototype.getAllRegistrations = function(token) {
    if (this.isRegistered(token)) {
      return this._registry.getAll(token);
    }
    if (this.parent) {
      return this.parent.getAllRegistrations(token);
    }
    return null;
  };
  InternalDependencyContainer2.prototype.construct = function(ctor, context) {
    var _this = this;
    if (ctor instanceof DelayedConstructor) {
      return ctor.createProxy(function(target2) {
        return _this.resolve(target2, context);
      });
    }
    var instance = function() {
      var paramInfo = typeInfo.get(ctor);
      if (!paramInfo || paramInfo.length === 0) {
        if (ctor.length === 0) {
          return new ctor;
        } else {
          throw new Error('TypeInfo not known for "' + ctor.name + '"');
        }
      }
      var params = paramInfo.map(_this.resolveParams(context, ctor));
      return new (ctor.bind.apply(ctor, __spread2([undefined], params)));
    }();
    if (isDisposable(instance)) {
      this.disposables.add(instance);
    }
    return instance;
  };
  InternalDependencyContainer2.prototype.resolveParams = function(context, ctor) {
    var _this = this;
    return function(param, idx) {
      var _a5, _b, _c;
      try {
        if (isTokenDescriptor(param)) {
          if (isTransformDescriptor(param)) {
            return param.multiple ? (_a5 = _this.resolve(param.transform)).transform.apply(_a5, __spread2([_this.resolveAll(param.token, new resolution_context_default, param.isOptional)], param.transformArgs)) : (_b = _this.resolve(param.transform)).transform.apply(_b, __spread2([_this.resolve(param.token, context, param.isOptional)], param.transformArgs));
          } else {
            return param.multiple ? _this.resolveAll(param.token, new resolution_context_default, param.isOptional) : _this.resolve(param.token, context, param.isOptional);
          }
        } else if (isTransformDescriptor(param)) {
          return (_c = _this.resolve(param.transform, context)).transform.apply(_c, __spread2([_this.resolve(param.token, context)], param.transformArgs));
        }
        return _this.resolve(param, context);
      } catch (e) {
        throw new Error(formatErrorCtor(ctor, idx, e));
      }
    };
  };
  InternalDependencyContainer2.prototype.ensureNotDisposed = function() {
    if (this.disposed) {
      throw new Error("This container has been disposed, you cannot interact with a disposed container");
    }
  };
  return InternalDependencyContainer2;
}();
var instance = new InternalDependencyContainer;
// node_modules/tsyringe/dist/esm5/decorators/injectable.js
function injectable(options) {
  return function(target2) {
    typeInfo.set(target2, getParamInfo(target2));
    if (options && options.token) {
      if (!Array.isArray(options.token)) {
        instance.register(options.token, target2);
      } else {
        options.token.forEach(function(token) {
          instance.register(token, target2);
        });
      }
    }
  };
}
var injectable_default = injectable;
// node_modules/tsyringe/dist/esm5/index.js
if (typeof Reflect === "undefined" || !Reflect.getMetadata) {
  throw new Error(`tsyringe requires a reflect polyfill. Please add 'import "reflect-metadata"' to the top of your entry point.`);
}

// node_modules/@peculiar/asn1-pkcs9/node_modules/asn1js/build/index.es.js
var exports_index_es6 = {};
__export(exports_index_es6, {
  verifySchema: () => verifySchema5,
  fromBER: () => fromBER5,
  compareSchema: () => compareSchema5,
  VisibleString: () => VisibleString5,
  ViewWriter: () => ViewWriter5,
  VideotexString: () => VideotexString5,
  ValueBlock: () => ValueBlock5,
  Utf8String: () => Utf8String5,
  UniversalString: () => UniversalString5,
  UTCTime: () => UTCTime5,
  TimeOfDay: () => TimeOfDay5,
  TeletexString: () => TeletexString5,
  TIME: () => TIME5,
  Set: () => Set6,
  Sequence: () => Sequence5,
  Repeated: () => Repeated5,
  RelativeObjectIdentifier: () => RelativeObjectIdentifier5,
  RawData: () => RawData5,
  PrintableString: () => PrintableString5,
  Primitive: () => Primitive5,
  OctetString: () => OctetString9,
  ObjectIdentifier: () => ObjectIdentifier5,
  NumericString: () => NumericString5,
  Null: () => Null5,
  Integer: () => Integer5,
  IA5String: () => IA5String5,
  HexBlock: () => HexBlock5,
  GraphicString: () => GraphicString5,
  GeneralizedTime: () => GeneralizedTime5,
  GeneralString: () => GeneralString5,
  Enumerated: () => Enumerated5,
  EndOfContent: () => EndOfContent5,
  Duration: () => Duration5,
  DateTime: () => DateTime5,
  DATE: () => DATE5,
  Constructed: () => Constructed5,
  Choice: () => Choice5,
  CharacterString: () => CharacterString5,
  Boolean: () => Boolean6,
  BmpString: () => BmpString5,
  BitString: () => BitString9,
  BaseStringBlock: () => BaseStringBlock5,
  BaseBlock: () => BaseBlock5,
  Any: () => Any5
});
/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
function assertBigInt5() {
  if (typeof BigInt === "undefined") {
    throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
  }
}
function concat5(buffers) {
  let outputLength = 0;
  let prevLength = 0;
  for (let i = 0;i < buffers.length; i++) {
    const buffer = buffers[i];
    outputLength += buffer.byteLength;
  }
  const retView = new Uint8Array(outputLength);
  for (let i = 0;i < buffers.length; i++) {
    const buffer = buffers[i];
    retView.set(new Uint8Array(buffer), prevLength);
    prevLength += buffer.byteLength;
  }
  return retView.buffer;
}
function checkBufferParams5(baseBlock, inputBuffer, inputOffset, inputLength) {
  if (!(inputBuffer instanceof Uint8Array)) {
    baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
    return false;
  }
  if (!inputBuffer.byteLength) {
    baseBlock.error = "Wrong parameter: inputBuffer has zero length";
    return false;
  }
  if (inputOffset < 0) {
    baseBlock.error = "Wrong parameter: inputOffset less than zero";
    return false;
  }
  if (inputLength < 0) {
    baseBlock.error = "Wrong parameter: inputLength less than zero";
    return false;
  }
  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
    baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
    return false;
  }
  return true;
}

class ViewWriter5 {
  constructor() {
    this.items = [];
  }
  write(buf) {
    this.items.push(buf);
  }
  final() {
    return concat5(this.items);
  }
}
var powers25 = [new Uint8Array([1])];
var digitsString5 = "0123456789";
var NAME5 = "name";
var VALUE_HEX_VIEW5 = "valueHexView";
var IS_HEX_ONLY5 = "isHexOnly";
var ID_BLOCK5 = "idBlock";
var TAG_CLASS5 = "tagClass";
var TAG_NUMBER5 = "tagNumber";
var IS_CONSTRUCTED5 = "isConstructed";
var FROM_BER5 = "fromBER";
var TO_BER5 = "toBER";
var LOCAL5 = "local";
var EMPTY_STRING5 = "";
var EMPTY_BUFFER5 = new ArrayBuffer(0);
var EMPTY_VIEW5 = new Uint8Array(0);
var END_OF_CONTENT_NAME5 = "EndOfContent";
var OCTET_STRING_NAME5 = "OCTET STRING";
var BIT_STRING_NAME5 = "BIT STRING";
function HexBlock5(BaseClass) {
  var _a5;
  return _a5 = class Some extends BaseClass {
    get valueHex() {
      return this.valueHexView.slice().buffer;
    }
    set valueHex(value) {
      this.valueHexView = new Uint8Array(value);
    }
    constructor(...args) {
      var _b;
      super(...args);
      const params = args[0] || {};
      this.isHexOnly = (_b = params.isHexOnly) !== null && _b !== undefined ? _b : false;
      this.valueHexView = params.valueHex ? BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW5;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      if (!checkBufferParams5(this, view, inputOffset, inputLength)) {
        return -1;
      }
      const endLength = inputOffset + inputLength;
      this.valueHexView = view.subarray(inputOffset, endLength);
      if (!this.valueHexView.length) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      }
      this.blockLength = inputLength;
      return endLength;
    }
    toBER(sizeOnly = false) {
      if (!this.isHexOnly) {
        this.error = "Flag 'isHexOnly' is not set, abort";
        return EMPTY_BUFFER5;
      }
      if (sizeOnly) {
        return new ArrayBuffer(this.valueHexView.byteLength);
      }
      return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        isHexOnly: this.isHexOnly,
        valueHex: Convert.ToHex(this.valueHexView)
      };
    }
  }, _a5.NAME = "hexBlock", _a5;
}

class LocalBaseBlock5 {
  static blockName() {
    return this.NAME;
  }
  get valueBeforeDecode() {
    return this.valueBeforeDecodeView.slice().buffer;
  }
  set valueBeforeDecode(value) {
    this.valueBeforeDecodeView = new Uint8Array(value);
  }
  constructor({ blockLength = 0, error = EMPTY_STRING5, warnings = [], valueBeforeDecode = EMPTY_VIEW5 } = {}) {
    this.blockLength = blockLength;
    this.error = error;
    this.warnings = warnings;
    this.valueBeforeDecodeView = BufferSourceConverter.toUint8Array(valueBeforeDecode);
  }
  toJSON() {
    return {
      blockName: this.constructor.NAME,
      blockLength: this.blockLength,
      error: this.error,
      warnings: this.warnings,
      valueBeforeDecode: Convert.ToHex(this.valueBeforeDecodeView)
    };
  }
}
LocalBaseBlock5.NAME = "baseBlock";

class ValueBlock5 extends LocalBaseBlock5 {
  fromBER(_inputBuffer, _inputOffset, _inputLength) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
  toBER(_sizeOnly, _writer) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
}
ValueBlock5.NAME = "valueBlock";

class LocalIdentificationBlock5 extends HexBlock5(LocalBaseBlock5) {
  constructor({ idBlock = {} } = {}) {
    var _a5, _b, _c, _d;
    super();
    if (idBlock) {
      this.isHexOnly = (_a5 = idBlock.isHexOnly) !== null && _a5 !== undefined ? _a5 : false;
      this.valueHexView = idBlock.valueHex ? BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW5;
      this.tagClass = (_b = idBlock.tagClass) !== null && _b !== undefined ? _b : -1;
      this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== undefined ? _c : -1;
      this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== undefined ? _d : false;
    } else {
      this.tagClass = -1;
      this.tagNumber = -1;
      this.isConstructed = false;
    }
  }
  toBER(sizeOnly = false) {
    let firstOctet = 0;
    switch (this.tagClass) {
      case 1:
        firstOctet |= 0;
        break;
      case 2:
        firstOctet |= 64;
        break;
      case 3:
        firstOctet |= 128;
        break;
      case 4:
        firstOctet |= 192;
        break;
      default:
        this.error = "Unknown tag class";
        return EMPTY_BUFFER5;
    }
    if (this.isConstructed)
      firstOctet |= 32;
    if (this.tagNumber < 31 && !this.isHexOnly) {
      const retView2 = new Uint8Array(1);
      if (!sizeOnly) {
        let number = this.tagNumber;
        number &= 31;
        firstOctet |= number;
        retView2[0] = firstOctet;
      }
      return retView2.buffer;
    }
    if (!this.isHexOnly) {
      const encodedBuf = utilToBase(this.tagNumber, 7);
      const encodedView = new Uint8Array(encodedBuf);
      const size = encodedBuf.byteLength;
      const retView2 = new Uint8Array(size + 1);
      retView2[0] = firstOctet | 31;
      if (!sizeOnly) {
        for (let i = 0;i < size - 1; i++)
          retView2[i + 1] = encodedView[i] | 128;
        retView2[size] = encodedView[size - 1];
      }
      return retView2.buffer;
    }
    const retView = new Uint8Array(this.valueHexView.byteLength + 1);
    retView[0] = firstOctet | 31;
    if (!sizeOnly) {
      const curView = this.valueHexView;
      for (let i = 0;i < curView.length - 1; i++)
        retView[i + 1] = curView[i] | 128;
      retView[this.valueHexView.byteLength] = curView[curView.length - 1];
    }
    return retView.buffer;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams5(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    const tagClassMask = intBuffer[0] & 192;
    switch (tagClassMask) {
      case 0:
        this.tagClass = 1;
        break;
      case 64:
        this.tagClass = 2;
        break;
      case 128:
        this.tagClass = 3;
        break;
      case 192:
        this.tagClass = 4;
        break;
      default:
        this.error = "Unknown tag class";
        return -1;
    }
    this.isConstructed = (intBuffer[0] & 32) === 32;
    this.isHexOnly = false;
    const tagNumberMask = intBuffer[0] & 31;
    if (tagNumberMask !== 31) {
      this.tagNumber = tagNumberMask;
      this.blockLength = 1;
    } else {
      let count = 1;
      let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
      let tagNumberBufferMaxLength = 255;
      while (intBuffer[count] & 128) {
        intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
        count++;
        if (count >= intBuffer.length) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (count === tagNumberBufferMaxLength) {
          tagNumberBufferMaxLength += 255;
          const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);
          for (let i = 0;i < intTagNumberBuffer.length; i++)
            tempBufferView2[i] = intTagNumberBuffer[i];
          intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
        }
      }
      this.blockLength = count + 1;
      intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
      const tempBufferView = new Uint8Array(count);
      for (let i = 0;i < count; i++)
        tempBufferView[i] = intTagNumberBuffer[i];
      intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
      intTagNumberBuffer.set(tempBufferView);
      if (this.blockLength <= 9)
        this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
      else {
        this.isHexOnly = true;
        this.warnings.push("Tag too long, represented as hex-coded");
      }
    }
    if (this.tagClass === 1 && this.isConstructed) {
      switch (this.tagNumber) {
        case 1:
        case 2:
        case 5:
        case 6:
        case 9:
        case 13:
        case 14:
        case 23:
        case 24:
        case 31:
        case 32:
        case 33:
        case 34:
          this.error = "Constructed encoding used for primitive type";
          return -1;
      }
    }
    return inputOffset + this.blockLength;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      tagClass: this.tagClass,
      tagNumber: this.tagNumber,
      isConstructed: this.isConstructed
    };
  }
}
LocalIdentificationBlock5.NAME = "identificationBlock";

class LocalLengthBlock5 extends LocalBaseBlock5 {
  constructor({ lenBlock = {} } = {}) {
    var _a5, _b, _c;
    super();
    this.isIndefiniteForm = (_a5 = lenBlock.isIndefiniteForm) !== null && _a5 !== undefined ? _a5 : false;
    this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== undefined ? _b : false;
    this.length = (_c = lenBlock.length) !== null && _c !== undefined ? _c : 0;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams5(this, view, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    if (intBuffer[0] === 255) {
      this.error = "Length block 0xFF is reserved by standard";
      return -1;
    }
    this.isIndefiniteForm = intBuffer[0] === 128;
    if (this.isIndefiniteForm) {
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    this.longFormUsed = !!(intBuffer[0] & 128);
    if (this.longFormUsed === false) {
      this.length = intBuffer[0];
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    const count = intBuffer[0] & 127;
    if (count > 8) {
      this.error = "Too big integer";
      return -1;
    }
    if (count + 1 > intBuffer.length) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    const lenOffset = inputOffset + 1;
    const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
    if (lengthBufferView[count - 1] === 0)
      this.warnings.push("Needlessly long encoded length");
    this.length = utilFromBase(lengthBufferView, 8);
    if (this.longFormUsed && this.length <= 127)
      this.warnings.push("Unnecessary usage of long length form");
    this.blockLength = count + 1;
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly = false) {
    let retBuf;
    let retView;
    if (this.length > 127)
      this.longFormUsed = true;
    if (this.isIndefiniteForm) {
      retBuf = new ArrayBuffer(1);
      if (sizeOnly === false) {
        retView = new Uint8Array(retBuf);
        retView[0] = 128;
      }
      return retBuf;
    }
    if (this.longFormUsed) {
      const encodedBuf = utilToBase(this.length, 8);
      if (encodedBuf.byteLength > 127) {
        this.error = "Too big length";
        return EMPTY_BUFFER5;
      }
      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
      if (sizeOnly)
        return retBuf;
      const encodedView = new Uint8Array(encodedBuf);
      retView = new Uint8Array(retBuf);
      retView[0] = encodedBuf.byteLength | 128;
      for (let i = 0;i < encodedBuf.byteLength; i++)
        retView[i + 1] = encodedView[i];
      return retBuf;
    }
    retBuf = new ArrayBuffer(1);
    if (sizeOnly === false) {
      retView = new Uint8Array(retBuf);
      retView[0] = this.length;
    }
    return retBuf;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      longFormUsed: this.longFormUsed,
      length: this.length
    };
  }
}
LocalLengthBlock5.NAME = "lengthBlock";
var typeStore5 = {};

class BaseBlock5 extends LocalBaseBlock5 {
  constructor({ name: name5 = EMPTY_STRING5, optional = false, primitiveSchema, ...parameters2 } = {}, valueBlockType) {
    super(parameters2);
    this.name = name5;
    this.optional = optional;
    if (primitiveSchema) {
      this.primitiveSchema = primitiveSchema;
    }
    this.idBlock = new LocalIdentificationBlock5(parameters2);
    this.lenBlock = new LocalLengthBlock5(parameters2);
    this.valueBlock = valueBlockType ? new valueBlockType(parameters2) : new ValueBlock5(parameters2);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter5;
    if (!writer) {
      prepareIndefiniteForm5(this);
    }
    const idBlockBuf = this.idBlock.toBER(sizeOnly);
    _writer.write(idBlockBuf);
    if (this.lenBlock.isIndefiniteForm) {
      _writer.write(new Uint8Array([128]).buffer);
      this.valueBlock.toBER(sizeOnly, _writer);
      _writer.write(new ArrayBuffer(2));
    } else {
      const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
      this.lenBlock.length = valueBlockBuf.byteLength;
      const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
      _writer.write(lenBlockBuf);
      _writer.write(valueBlockBuf);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER5;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      idBlock: this.idBlock.toJSON(),
      lenBlock: this.lenBlock.toJSON(),
      valueBlock: this.valueBlock.toJSON(),
      name: this.name,
      optional: this.optional
    };
    if (this.primitiveSchema)
      object.primitiveSchema = this.primitiveSchema.toJSON();
    return object;
  }
  toString(encoding = "ascii") {
    if (encoding === "ascii") {
      return this.onAsciiEncoding();
    }
    return Convert.ToHex(this.toBER());
  }
  onAsciiEncoding() {
    const name5 = this.constructor.NAME;
    const value = Convert.ToHex(this.valueBlock.valueBeforeDecodeView);
    return `${name5} : ${value}`;
  }
  isEqual(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof this.constructor)) {
      return false;
    }
    const thisRaw = this.toBER();
    const otherRaw = other.toBER();
    return isEqualBuffer(thisRaw, otherRaw);
  }
}
BaseBlock5.NAME = "BaseBlock";
function prepareIndefiniteForm5(baseBlock) {
  var _a5;
  if (baseBlock instanceof typeStore5.Constructed) {
    for (const value of baseBlock.valueBlock.value) {
      if (prepareIndefiniteForm5(value)) {
        baseBlock.lenBlock.isIndefiniteForm = true;
      }
    }
  }
  return !!((_a5 = baseBlock.lenBlock) === null || _a5 === undefined ? undefined : _a5.isIndefiniteForm);
}

class BaseStringBlock5 extends BaseBlock5 {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  constructor({ value = EMPTY_STRING5, ...parameters2 } = {}, stringValueBlockType) {
    super(parameters2, stringValueBlockType);
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    this.fromBuffer(this.valueBlock.valueHexView);
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
  }
}
BaseStringBlock5.NAME = "BaseStringBlock";

class LocalPrimitiveValueBlock5 extends HexBlock5(ValueBlock5) {
  constructor({ isHexOnly = true, ...parameters2 } = {}) {
    super(parameters2);
    this.isHexOnly = isHexOnly;
  }
}
LocalPrimitiveValueBlock5.NAME = "PrimitiveValueBlock";
var _a$w5;

class Primitive5 extends BaseBlock5 {
  constructor(parameters2 = {}) {
    super(parameters2, LocalPrimitiveValueBlock5);
    this.idBlock.isConstructed = false;
  }
}
_a$w5 = Primitive5;
(() => {
  typeStore5.Primitive = _a$w5;
})();
Primitive5.NAME = "PRIMITIVE";
function localChangeType5(inputObject, newType) {
  if (inputObject instanceof newType) {
    return inputObject;
  }
  const newObject = new newType;
  newObject.idBlock = inputObject.idBlock;
  newObject.lenBlock = inputObject.lenBlock;
  newObject.warnings = inputObject.warnings;
  newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
  return newObject;
}
function localFromBER5(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
  const incomingOffset = inputOffset;
  let returnObject = new BaseBlock5({}, ValueBlock5);
  const baseBlock = new LocalBaseBlock5;
  if (!checkBufferParams5(baseBlock, inputBuffer, inputOffset, inputLength)) {
    returnObject.error = baseBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
  if (!intBuffer.length) {
    returnObject.error = "Zero buffer length";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.idBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.idBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.idBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.idBlock.blockLength;
  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.lenBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.lenBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.lenBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.lenBlock.blockLength;
  if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
    returnObject.error = "Indefinite length form used for primitive encoding form";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let newASN1Type = BaseBlock5;
  switch (returnObject.idBlock.tagClass) {
    case 1:
      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
        returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
        return {
          offset: -1,
          result: returnObject
        };
      }
      switch (returnObject.idBlock.tagNumber) {
        case 0:
          if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
            returnObject.error = "Type [UNIVERSAL 0] is reserved";
            return {
              offset: -1,
              result: returnObject
            };
          }
          newASN1Type = typeStore5.EndOfContent;
          break;
        case 1:
          newASN1Type = typeStore5.Boolean;
          break;
        case 2:
          newASN1Type = typeStore5.Integer;
          break;
        case 3:
          newASN1Type = typeStore5.BitString;
          break;
        case 4:
          newASN1Type = typeStore5.OctetString;
          break;
        case 5:
          newASN1Type = typeStore5.Null;
          break;
        case 6:
          newASN1Type = typeStore5.ObjectIdentifier;
          break;
        case 10:
          newASN1Type = typeStore5.Enumerated;
          break;
        case 12:
          newASN1Type = typeStore5.Utf8String;
          break;
        case 13:
          newASN1Type = typeStore5.RelativeObjectIdentifier;
          break;
        case 14:
          newASN1Type = typeStore5.TIME;
          break;
        case 15:
          returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
          return {
            offset: -1,
            result: returnObject
          };
        case 16:
          newASN1Type = typeStore5.Sequence;
          break;
        case 17:
          newASN1Type = typeStore5.Set;
          break;
        case 18:
          newASN1Type = typeStore5.NumericString;
          break;
        case 19:
          newASN1Type = typeStore5.PrintableString;
          break;
        case 20:
          newASN1Type = typeStore5.TeletexString;
          break;
        case 21:
          newASN1Type = typeStore5.VideotexString;
          break;
        case 22:
          newASN1Type = typeStore5.IA5String;
          break;
        case 23:
          newASN1Type = typeStore5.UTCTime;
          break;
        case 24:
          newASN1Type = typeStore5.GeneralizedTime;
          break;
        case 25:
          newASN1Type = typeStore5.GraphicString;
          break;
        case 26:
          newASN1Type = typeStore5.VisibleString;
          break;
        case 27:
          newASN1Type = typeStore5.GeneralString;
          break;
        case 28:
          newASN1Type = typeStore5.UniversalString;
          break;
        case 29:
          newASN1Type = typeStore5.CharacterString;
          break;
        case 30:
          newASN1Type = typeStore5.BmpString;
          break;
        case 31:
          newASN1Type = typeStore5.DATE;
          break;
        case 32:
          newASN1Type = typeStore5.TimeOfDay;
          break;
        case 33:
          newASN1Type = typeStore5.DateTime;
          break;
        case 34:
          newASN1Type = typeStore5.Duration;
          break;
        default: {
          const newObject = returnObject.idBlock.isConstructed ? new typeStore5.Constructed : new typeStore5.Primitive;
          newObject.idBlock = returnObject.idBlock;
          newObject.lenBlock = returnObject.lenBlock;
          newObject.warnings = returnObject.warnings;
          returnObject = newObject;
        }
      }
      break;
    case 2:
    case 3:
    case 4:
    default: {
      newASN1Type = returnObject.idBlock.isConstructed ? typeStore5.Constructed : typeStore5.Primitive;
    }
  }
  returnObject = localChangeType5(returnObject, newASN1Type);
  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
  returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
  return {
    offset: resultOffset,
    result: returnObject
  };
}
function fromBER5(inputBuffer) {
  if (!inputBuffer.byteLength) {
    const result = new BaseBlock5({}, ValueBlock5);
    result.error = "Input buffer has zero length";
    return {
      offset: -1,
      result
    };
  }
  return localFromBER5(BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
}
function checkLen5(indefiniteLength, length) {
  if (indefiniteLength) {
    return 1;
  }
  return length;
}

class LocalConstructedValueBlock5 extends ValueBlock5 {
  constructor({ value = [], isIndefiniteForm = false, ...parameters2 } = {}) {
    super(parameters2);
    this.value = value;
    this.isIndefiniteForm = isIndefiniteForm;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams5(this, view, inputOffset, inputLength)) {
      return -1;
    }
    this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
    if (this.valueBeforeDecodeView.length === 0) {
      this.warnings.push("Zero buffer length");
      return inputOffset;
    }
    let currentOffset = inputOffset;
    while (checkLen5(this.isIndefiniteForm, inputLength) > 0) {
      const returnObject = localFromBER5(view, currentOffset, inputLength);
      if (returnObject.offset === -1) {
        this.error = returnObject.result.error;
        this.warnings.concat(returnObject.result.warnings);
        return -1;
      }
      currentOffset = returnObject.offset;
      this.blockLength += returnObject.result.blockLength;
      inputLength -= returnObject.result.blockLength;
      this.value.push(returnObject.result);
      if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME5) {
        break;
      }
    }
    if (this.isIndefiniteForm) {
      if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME5) {
        this.value.pop();
      } else {
        this.warnings.push("No EndOfContent block encoded");
      }
    }
    return currentOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter5;
    for (let i = 0;i < this.value.length; i++) {
      this.value[i].toBER(sizeOnly, _writer);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER5;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      value: []
    };
    for (const value of this.value) {
      object.value.push(value.toJSON());
    }
    return object;
  }
}
LocalConstructedValueBlock5.NAME = "ConstructedValueBlock";
var _a$v5;

class Constructed5 extends BaseBlock5 {
  constructor(parameters2 = {}) {
    super(parameters2, LocalConstructedValueBlock5);
    this.idBlock.isConstructed = true;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    const values = [];
    for (const value of this.valueBlock.value) {
      values.push(value.toString("ascii").split(`
`).map((o) => `  ${o}`).join(`
`));
    }
    const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
    return values.length ? `${blockName} :
${values.join(`
`)}` : `${blockName} :`;
  }
}
_a$v5 = Constructed5;
(() => {
  typeStore5.Constructed = _a$v5;
})();
Constructed5.NAME = "CONSTRUCTED";

class LocalEndOfContentValueBlock5 extends ValueBlock5 {
  fromBER(inputBuffer, inputOffset, _inputLength) {
    return inputOffset;
  }
  toBER(_sizeOnly) {
    return EMPTY_BUFFER5;
  }
}
LocalEndOfContentValueBlock5.override = "EndOfContentValueBlock";
var _a$u5;

class EndOfContent5 extends BaseBlock5 {
  constructor(parameters2 = {}) {
    super(parameters2, LocalEndOfContentValueBlock5);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 0;
  }
}
_a$u5 = EndOfContent5;
(() => {
  typeStore5.EndOfContent = _a$u5;
})();
EndOfContent5.NAME = END_OF_CONTENT_NAME5;
var _a$t5;

class Null5 extends BaseBlock5 {
  constructor(parameters2 = {}) {
    super(parameters2, ValueBlock5);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 5;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (this.lenBlock.length > 0)
      this.warnings.push("Non-zero length of value block for Null type");
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    this.blockLength += inputLength;
    if (inputOffset + inputLength > inputBuffer.byteLength) {
      this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
      return -1;
    }
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    const retBuf = new ArrayBuffer(2);
    if (!sizeOnly) {
      const retView = new Uint8Array(retBuf);
      retView[0] = 5;
      retView[1] = 0;
    }
    if (writer) {
      writer.write(retBuf);
    }
    return retBuf;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME}`;
  }
}
_a$t5 = Null5;
(() => {
  typeStore5.Null = _a$t5;
})();
Null5.NAME = "NULL";

class LocalBooleanValueBlock5 extends HexBlock5(ValueBlock5) {
  get value() {
    for (const octet of this.valueHexView) {
      if (octet > 0) {
        return true;
      }
    }
    return false;
  }
  set value(value) {
    this.valueHexView[0] = value ? 255 : 0;
  }
  constructor({ value, ...parameters2 } = {}) {
    super(parameters2);
    if (parameters2.valueHex) {
      this.valueHexView = BufferSourceConverter.toUint8Array(parameters2.valueHex);
    } else {
      this.valueHexView = new Uint8Array(1);
    }
    if (value) {
      this.value = value;
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams5(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (inputLength > 1)
      this.warnings.push("Boolean value encoded in more then 1 octet");
    this.isHexOnly = true;
    utilDecodeTC.call(this);
    this.blockLength = inputLength;
    return inputOffset + inputLength;
  }
  toBER() {
    return this.valueHexView.slice();
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalBooleanValueBlock5.NAME = "BooleanValueBlock";
var _a$s5;

class Boolean6 extends BaseBlock5 {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  constructor(parameters2 = {}) {
    super(parameters2, LocalBooleanValueBlock5);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 1;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.getValue}`;
  }
}
_a$s5 = Boolean6;
(() => {
  typeStore5.Boolean = _a$s5;
})();
Boolean6.NAME = "BOOLEAN";

class LocalOctetStringValueBlock5 extends HexBlock5(LocalConstructedValueBlock5) {
  constructor({ isConstructed = false, ...parameters2 } = {}) {
    super(parameters2);
    this.isConstructed = isConstructed;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = 0;
    if (this.isConstructed) {
      this.isHexOnly = false;
      resultOffset = LocalConstructedValueBlock5.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (let i = 0;i < this.value.length; i++) {
        const currentBlockName = this.value[i].constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME5) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== OCTET_STRING_NAME5) {
          this.error = "OCTET STRING may consists of OCTET STRINGs only";
          return -1;
        }
      }
    } else {
      this.isHexOnly = true;
      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
      this.blockLength = inputLength;
    }
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed)
      return LocalConstructedValueBlock5.prototype.toBER.call(this, sizeOnly, writer);
    return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isConstructed: this.isConstructed
    };
  }
}
LocalOctetStringValueBlock5.NAME = "OctetStringValueBlock";
var _a$r5;

class OctetString9 extends BaseBlock5 {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters2 } = {}) {
    var _b, _c;
    (_b = parameters2.isConstructed) !== null && _b !== undefined || (parameters2.isConstructed = !!((_c = parameters2.value) === null || _c === undefined ? undefined : _c.length));
    super({
      idBlock: {
        isConstructed: parameters2.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters2.isIndefiniteForm
      },
      ...parameters2
    }, LocalOctetStringValueBlock5);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 4;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    if (inputLength === 0) {
      if (this.idBlock.error.length === 0)
        this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0)
        this.blockLength += this.lenBlock.blockLength;
      return inputOffset;
    }
    if (!this.valueBlock.isConstructed) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      const buf = view.subarray(inputOffset, inputOffset + inputLength);
      try {
        if (buf.byteLength) {
          const asn = localFromBER5(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength) {
            this.valueBlock.value = [asn.result];
          }
        }
      } catch {}
    }
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed5.prototype.onAsciiEncoding.call(this);
    }
    const name5 = this.constructor.NAME;
    const value = Convert.ToHex(this.valueBlock.valueHexView);
    return `${name5} : ${value}`;
  }
  getValue() {
    if (!this.idBlock.isConstructed) {
      return this.valueBlock.valueHexView.slice().buffer;
    }
    const array = [];
    for (const content of this.valueBlock.value) {
      if (content instanceof _a$r5) {
        array.push(content.valueBlock.valueHexView);
      }
    }
    return BufferSourceConverter.concat(array);
  }
}
_a$r5 = OctetString9;
(() => {
  typeStore5.OctetString = _a$r5;
})();
OctetString9.NAME = OCTET_STRING_NAME5;

class LocalBitStringValueBlock5 extends HexBlock5(LocalConstructedValueBlock5) {
  constructor({ unusedBits = 0, isConstructed = false, ...parameters2 } = {}) {
    super(parameters2);
    this.unusedBits = unusedBits;
    this.isConstructed = isConstructed;
    this.blockLength = this.valueHexView.byteLength;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    let resultOffset = -1;
    if (this.isConstructed) {
      resultOffset = LocalConstructedValueBlock5.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (const value of this.value) {
        const currentBlockName = value.constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME5) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== BIT_STRING_NAME5) {
          this.error = "BIT STRING may consists of BIT STRINGs only";
          return -1;
        }
        const valueBlock = value.valueBlock;
        if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
          this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
          return -1;
        }
        this.unusedBits = valueBlock.unusedBits;
      }
      return resultOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams5(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.unusedBits = intBuffer[0];
    if (this.unusedBits > 7) {
      this.error = "Unused bits for BitString must be in range 0-7";
      return -1;
    }
    if (!this.unusedBits) {
      const buf = intBuffer.subarray(1);
      try {
        if (buf.byteLength) {
          const asn = localFromBER5(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength - 1) {
            this.value = [asn.result];
          }
        }
      } catch {}
    }
    this.valueHexView = intBuffer.subarray(1);
    this.blockLength = intBuffer.length;
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed) {
      return LocalConstructedValueBlock5.prototype.toBER.call(this, sizeOnly, writer);
    }
    if (sizeOnly) {
      return new ArrayBuffer(this.valueHexView.byteLength + 1);
    }
    if (!this.valueHexView.byteLength) {
      return EMPTY_BUFFER5;
    }
    const retView = new Uint8Array(this.valueHexView.length + 1);
    retView[0] = this.unusedBits;
    retView.set(this.valueHexView, 1);
    return retView.buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      unusedBits: this.unusedBits,
      isConstructed: this.isConstructed
    };
  }
}
LocalBitStringValueBlock5.NAME = "BitStringValueBlock";
var _a$q5;

class BitString9 extends BaseBlock5 {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters2 } = {}) {
    var _b, _c;
    (_b = parameters2.isConstructed) !== null && _b !== undefined || (parameters2.isConstructed = !!((_c = parameters2.value) === null || _c === undefined ? undefined : _c.length));
    super({
      idBlock: {
        isConstructed: parameters2.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters2.isIndefiniteForm
      },
      ...parameters2
    }, LocalBitStringValueBlock5);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 3;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed5.prototype.onAsciiEncoding.call(this);
    } else {
      const bits = [];
      const valueHex = this.valueBlock.valueHexView;
      for (const byte of valueHex) {
        bits.push(byte.toString(2).padStart(8, "0"));
      }
      const bitsStr = bits.join("");
      const name5 = this.constructor.NAME;
      const value = bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits);
      return `${name5} : ${value}`;
    }
  }
}
_a$q5 = BitString9;
(() => {
  typeStore5.BitString = _a$q5;
})();
BitString9.NAME = BIT_STRING_NAME5;
var _a$p5;
function viewAdd5(first, second) {
  const c = new Uint8Array([0]);
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  let firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value = 0;
  const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
  let counter = 0;
  for (let i = max;i >= 0; i--, counter++) {
    switch (true) {
      case counter < secondViewCopy.length:
        value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
        break;
      default:
        value = firstViewCopy[firstViewCopyLength - counter] + c[0];
    }
    c[0] = value / 10;
    switch (true) {
      case counter >= firstViewCopy.length:
        firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
        break;
      default:
        firstViewCopy[firstViewCopyLength - counter] = value % 10;
    }
  }
  if (c[0] > 0)
    firstViewCopy = utilConcatView(c, firstViewCopy);
  return firstViewCopy;
}
function power25(n) {
  if (n >= powers25.length) {
    for (let p = powers25.length;p <= n; p++) {
      const c = new Uint8Array([0]);
      let digits = powers25[p - 1].slice(0);
      for (let i = digits.length - 1;i >= 0; i--) {
        const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
        c[0] = newValue[0] / 10;
        digits[i] = newValue[0] % 10;
      }
      if (c[0] > 0)
        digits = utilConcatView(c, digits);
      powers25.push(digits);
    }
  }
  return powers25[n];
}
function viewSub5(first, second) {
  let b = 0;
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  const firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value;
  let counter = 0;
  for (let i = secondViewCopyLength;i >= 0; i--, counter++) {
    value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
    switch (true) {
      case value < 0:
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
        break;
      default:
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
    }
  }
  if (b > 0) {
    for (let i = firstViewCopyLength - secondViewCopyLength + 1;i >= 0; i--, counter++) {
      value = firstViewCopy[firstViewCopyLength - counter] - b;
      if (value < 0) {
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
      } else {
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
        break;
      }
    }
  }
  return firstViewCopy.slice();
}

class LocalIntegerValueBlock5 extends HexBlock5(ValueBlock5) {
  setValueHex() {
    if (this.valueHexView.length >= 4) {
      this.warnings.push("Too big Integer for decoding, hex only");
      this.isHexOnly = true;
      this._valueDec = 0;
    } else {
      this.isHexOnly = false;
      if (this.valueHexView.length > 0) {
        this._valueDec = utilDecodeTC.call(this);
      }
    }
  }
  constructor({ value, ...parameters2 } = {}) {
    super(parameters2);
    this._valueDec = 0;
    if (parameters2.valueHex) {
      this.setValueHex();
    }
    if (value !== undefined) {
      this.valueDec = value;
    }
  }
  set valueDec(v) {
    this._valueDec = v;
    this.isHexOnly = false;
    this.valueHexView = new Uint8Array(utilEncodeTC(v));
  }
  get valueDec() {
    return this._valueDec;
  }
  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
    if (offset === -1)
      return offset;
    const view = this.valueHexView;
    if (view[0] === 0 && (view[1] & 128) !== 0) {
      this.valueHexView = view.subarray(1);
    } else {
      if (expectedLength !== 0) {
        if (view.length < expectedLength) {
          if (expectedLength - view.length > 1)
            expectedLength = view.length + 1;
          this.valueHexView = view.subarray(expectedLength - view.length);
        }
      }
    }
    return offset;
  }
  toDER(sizeOnly = false) {
    const view = this.valueHexView;
    switch (true) {
      case (view[0] & 128) !== 0:
        {
          const updatedView = new Uint8Array(this.valueHexView.length + 1);
          updatedView[0] = 0;
          updatedView.set(view, 1);
          this.valueHexView = updatedView;
        }
        break;
      case (view[0] === 0 && (view[1] & 128) === 0):
        {
          this.valueHexView = this.valueHexView.subarray(1);
        }
        break;
    }
    return this.toBER(sizeOnly);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
    if (resultOffset === -1) {
      return resultOffset;
    }
    this.setValueHex();
    return resultOffset;
  }
  toBER(sizeOnly) {
    return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
  toString() {
    const firstBit = this.valueHexView.length * 8 - 1;
    let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
    let bitNumber = 0;
    let currentByte;
    const asn1View = this.valueHexView;
    let result = "";
    let flag = false;
    for (let byteNumber = asn1View.byteLength - 1;byteNumber >= 0; byteNumber--) {
      currentByte = asn1View[byteNumber];
      for (let i = 0;i < 8; i++) {
        if ((currentByte & 1) === 1) {
          switch (bitNumber) {
            case firstBit:
              digits = viewSub5(power25(bitNumber), digits);
              result = "-";
              break;
            default:
              digits = viewAdd5(digits, power25(bitNumber));
          }
        }
        bitNumber++;
        currentByte >>= 1;
      }
    }
    for (let i = 0;i < digits.length; i++) {
      if (digits[i])
        flag = true;
      if (flag)
        result += digitsString5.charAt(digits[i]);
    }
    if (flag === false)
      result += digitsString5.charAt(0);
    return result;
  }
}
_a$p5 = LocalIntegerValueBlock5;
LocalIntegerValueBlock5.NAME = "IntegerValueBlock";
(() => {
  Object.defineProperty(_a$p5.prototype, "valueHex", {
    set: function(v) {
      this.valueHexView = new Uint8Array(v);
      this.setValueHex();
    },
    get: function() {
      return this.valueHexView.slice().buffer;
    }
  });
})();
var _a$o5;

class Integer5 extends BaseBlock5 {
  constructor(parameters2 = {}) {
    super(parameters2, LocalIntegerValueBlock5);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 2;
  }
  toBigInt() {
    assertBigInt5();
    return BigInt(this.valueBlock.toString());
  }
  static fromBigInt(value) {
    assertBigInt5();
    const bigIntValue = BigInt(value);
    const writer = new ViewWriter5;
    const hex = bigIntValue.toString(16).replace(/^-/, "");
    const view = new Uint8Array(Convert.FromHex(hex));
    if (bigIntValue < 0) {
      const first = new Uint8Array(view.length + (view[0] & 128 ? 1 : 0));
      first[0] |= 128;
      const firstInt = BigInt(`0x${Convert.ToHex(first)}`);
      const secondInt = firstInt + bigIntValue;
      const second = BufferSourceConverter.toUint8Array(Convert.FromHex(secondInt.toString(16)));
      second[0] |= 128;
      writer.write(second);
    } else {
      if (view[0] & 128) {
        writer.write(new Uint8Array([0]));
      }
      writer.write(view);
    }
    const res = new _a$o5({ valueHex: writer.final() });
    return res;
  }
  convertToDER() {
    const integer = new _a$o5({ valueHex: this.valueBlock.valueHexView });
    integer.valueBlock.toDER();
    return integer;
  }
  convertFromDER() {
    return new _a$o5({
      valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
    });
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
  }
}
_a$o5 = Integer5;
(() => {
  typeStore5.Integer = _a$o5;
})();
Integer5.NAME = "INTEGER";
var _a$n5;

class Enumerated5 extends Integer5 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 10;
  }
}
_a$n5 = Enumerated5;
(() => {
  typeStore5.Enumerated = _a$n5;
})();
Enumerated5.NAME = "ENUMERATED";

class LocalSidValueBlock5 extends HexBlock5(ValueBlock5) {
  constructor({ valueDec = -1, isFirstSid = false, ...parameters2 } = {}) {
    super(parameters2);
    this.valueDec = valueDec;
    this.isFirstSid = isFirstSid;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams5(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0;i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0;i < this.blockLength; i++) {
      tempView[i] = this.valueHexView[i];
    }
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  set valueBigInt(value) {
    assertBigInt5();
    let bits = BigInt(value).toString(2);
    while (bits.length % 7) {
      bits = "0" + bits;
    }
    const bytes = new Uint8Array(bits.length / 7);
    for (let i = 0;i < bytes.length; i++) {
      bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 128 : 0);
    }
    this.fromBER(bytes.buffer, 0, bytes.length);
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0;i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER5;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0;i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      if (this.isFirstSid) {
        let sidValue = this.valueDec;
        if (this.valueDec <= 39)
          result = "0.";
        else {
          if (this.valueDec <= 79) {
            result = "1.";
            sidValue -= 40;
          } else {
            result = "2.";
            sidValue -= 80;
          }
        }
        result += sidValue.toString();
      } else
        result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec,
      isFirstSid: this.isFirstSid
    };
  }
}
LocalSidValueBlock5.NAME = "sidBlock";

class LocalObjectIdentifierValueBlock5 extends ValueBlock5 {
  constructor({ value = EMPTY_STRING5, ...parameters2 } = {}) {
    super(parameters2);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalSidValueBlock5;
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      if (this.value.length === 0)
        sidBlock.isFirstSid = true;
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly) {
    const retBuffers = [];
    for (let i = 0;i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER5;
      }
      retBuffers.push(valueBuf);
    }
    return concat5(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    let flag = false;
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      if (flag) {
        const sidBlock = this.value[0];
        let plus = 0;
        switch (sidBlock.valueDec) {
          case 0:
            break;
          case 1:
            plus = 40;
            break;
          case 2:
            plus = 80;
            break;
          default:
            this.value = [];
            return;
        }
        const parsedSID = parseInt(sid, 10);
        if (isNaN(parsedSID))
          return;
        sidBlock.valueDec = parsedSID + plus;
        flag = false;
      } else {
        const sidBlock = new LocalSidValueBlock5;
        if (sid > Number.MAX_SAFE_INTEGER) {
          assertBigInt5();
          const sidValue = BigInt(sid);
          sidBlock.valueBigInt = sidValue;
        } else {
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec))
            return;
        }
        if (!this.value.length) {
          sidBlock.isFirstSid = true;
          flag = true;
        }
        this.value.push(sidBlock);
      }
    } while (pos2 !== -1);
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0;i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        if (this.value[i].isFirstSid)
          result = `2.{${sidStr} - 80}`;
        else
          result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0;i < this.value.length; i++) {
      object.sidArray.push(this.value[i].toJSON());
    }
    return object;
  }
}
LocalObjectIdentifierValueBlock5.NAME = "ObjectIdentifierValueBlock";
var _a$m5;

class ObjectIdentifier5 extends BaseBlock5 {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  constructor(parameters2 = {}) {
    super(parameters2, LocalObjectIdentifierValueBlock5);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 6;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$m5 = ObjectIdentifier5;
(() => {
  typeStore5.ObjectIdentifier = _a$m5;
})();
ObjectIdentifier5.NAME = "OBJECT IDENTIFIER";

class LocalRelativeSidValueBlock5 extends HexBlock5(LocalBaseBlock5) {
  constructor({ valueDec = 0, ...parameters2 } = {}) {
    super(parameters2);
    this.valueDec = valueDec;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (inputLength === 0)
      return inputOffset;
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams5(this, inputView, inputOffset, inputLength))
      return -1;
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0;i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0;i < this.blockLength; i++)
      tempView[i] = this.valueHexView[i];
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0;i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER5;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0;i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView.buffer;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
}
LocalRelativeSidValueBlock5.NAME = "relativeSidBlock";

class LocalRelativeObjectIdentifierValueBlock5 extends ValueBlock5 {
  constructor({ value = EMPTY_STRING5, ...parameters2 } = {}) {
    super(parameters2);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalRelativeSidValueBlock5;
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly, _writer) {
    const retBuffers = [];
    for (let i = 0;i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER5;
      }
      retBuffers.push(valueBuf);
    }
    return concat5(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      const sidBlock = new LocalRelativeSidValueBlock5;
      sidBlock.valueDec = parseInt(sid, 10);
      if (isNaN(sidBlock.valueDec))
        return true;
      this.value.push(sidBlock);
    } while (pos2 !== -1);
    return true;
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0;i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0;i < this.value.length; i++)
      object.sidArray.push(this.value[i].toJSON());
    return object;
  }
}
LocalRelativeObjectIdentifierValueBlock5.NAME = "RelativeObjectIdentifierValueBlock";
var _a$l5;

class RelativeObjectIdentifier5 extends BaseBlock5 {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  constructor(parameters2 = {}) {
    super(parameters2, LocalRelativeObjectIdentifierValueBlock5);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 13;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$l5 = RelativeObjectIdentifier5;
(() => {
  typeStore5.RelativeObjectIdentifier = _a$l5;
})();
RelativeObjectIdentifier5.NAME = "RelativeObjectIdentifier";
var _a$k5;

class Sequence5 extends Constructed5 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 16;
  }
}
_a$k5 = Sequence5;
(() => {
  typeStore5.Sequence = _a$k5;
})();
Sequence5.NAME = "SEQUENCE";
var _a$j5;

class Set6 extends Constructed5 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 17;
  }
}
_a$j5 = Set6;
(() => {
  typeStore5.Set = _a$j5;
})();
Set6.NAME = "SET";

class LocalStringValueBlock5 extends HexBlock5(ValueBlock5) {
  constructor({ ...parameters2 } = {}) {
    super(parameters2);
    this.isHexOnly = true;
    this.value = EMPTY_STRING5;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalStringValueBlock5.NAME = "StringValueBlock";

class LocalSimpleStringValueBlock5 extends LocalStringValueBlock5 {
}
LocalSimpleStringValueBlock5.NAME = "SimpleStringValueBlock";

class LocalSimpleStringBlock5 extends BaseStringBlock5 {
  constructor({ ...parameters2 } = {}) {
    super(parameters2, LocalSimpleStringValueBlock5);
  }
  fromBuffer(inputBuffer) {
    this.valueBlock.value = String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer));
  }
  fromString(inputString) {
    const strLen = inputString.length;
    const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
    for (let i = 0;i < strLen; i++)
      view[i] = inputString.charCodeAt(i);
    this.valueBlock.value = inputString;
  }
}
LocalSimpleStringBlock5.NAME = "SIMPLE STRING";

class LocalUtf8StringValueBlock5 extends LocalSimpleStringBlock5 {
  fromBuffer(inputBuffer) {
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
    try {
      this.valueBlock.value = Convert.ToUtf8String(inputBuffer);
    } catch (ex) {
      this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
      this.valueBlock.value = Convert.ToBinary(inputBuffer);
    }
  }
  fromString(inputString) {
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf8String(inputString));
    this.valueBlock.value = inputString;
  }
}
LocalUtf8StringValueBlock5.NAME = "Utf8StringValueBlock";
var _a$i5;

class Utf8String5 extends LocalUtf8StringValueBlock5 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 12;
  }
}
_a$i5 = Utf8String5;
(() => {
  typeStore5.Utf8String = _a$i5;
})();
Utf8String5.NAME = "UTF8String";

class LocalBmpStringValueBlock5 extends LocalSimpleStringBlock5 {
  fromBuffer(inputBuffer) {
    this.valueBlock.value = Convert.ToUtf16String(inputBuffer);
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
  }
  fromString(inputString) {
    this.valueBlock.value = inputString;
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf16String(inputString));
  }
}
LocalBmpStringValueBlock5.NAME = "BmpStringValueBlock";
var _a$h5;

class BmpString5 extends LocalBmpStringValueBlock5 {
  constructor({ ...parameters2 } = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 30;
  }
}
_a$h5 = BmpString5;
(() => {
  typeStore5.BmpString = _a$h5;
})();
BmpString5.NAME = "BMPString";

class LocalUniversalStringValueBlock5 extends LocalSimpleStringBlock5 {
  fromBuffer(inputBuffer) {
    const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
    const valueView = new Uint8Array(copyBuffer);
    for (let i = 0;i < valueView.length; i += 4) {
      valueView[i] = valueView[i + 3];
      valueView[i + 1] = valueView[i + 2];
      valueView[i + 2] = 0;
      valueView[i + 3] = 0;
    }
    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
  }
  fromString(inputString) {
    const strLength = inputString.length;
    const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
    for (let i = 0;i < strLength; i++) {
      const codeBuf = utilToBase(inputString.charCodeAt(i), 8);
      const codeView = new Uint8Array(codeBuf);
      if (codeView.length > 4)
        continue;
      const dif = 4 - codeView.length;
      for (let j = codeView.length - 1;j >= 0; j--)
        valueHexView[i * 4 + j + dif] = codeView[j];
    }
    this.valueBlock.value = inputString;
  }
}
LocalUniversalStringValueBlock5.NAME = "UniversalStringValueBlock";
var _a$g5;

class UniversalString5 extends LocalUniversalStringValueBlock5 {
  constructor({ ...parameters2 } = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 28;
  }
}
_a$g5 = UniversalString5;
(() => {
  typeStore5.UniversalString = _a$g5;
})();
UniversalString5.NAME = "UniversalString";
var _a$f5;

class NumericString5 extends LocalSimpleStringBlock5 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 18;
  }
}
_a$f5 = NumericString5;
(() => {
  typeStore5.NumericString = _a$f5;
})();
NumericString5.NAME = "NumericString";
var _a$e5;

class PrintableString5 extends LocalSimpleStringBlock5 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 19;
  }
}
_a$e5 = PrintableString5;
(() => {
  typeStore5.PrintableString = _a$e5;
})();
PrintableString5.NAME = "PrintableString";
var _a$d5;

class TeletexString5 extends LocalSimpleStringBlock5 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 20;
  }
}
_a$d5 = TeletexString5;
(() => {
  typeStore5.TeletexString = _a$d5;
})();
TeletexString5.NAME = "TeletexString";
var _a$c5;

class VideotexString5 extends LocalSimpleStringBlock5 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 21;
  }
}
_a$c5 = VideotexString5;
(() => {
  typeStore5.VideotexString = _a$c5;
})();
VideotexString5.NAME = "VideotexString";
var _a$b5;

class IA5String5 extends LocalSimpleStringBlock5 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 22;
  }
}
_a$b5 = IA5String5;
(() => {
  typeStore5.IA5String = _a$b5;
})();
IA5String5.NAME = "IA5String";
var _a$a5;

class GraphicString5 extends LocalSimpleStringBlock5 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 25;
  }
}
_a$a5 = GraphicString5;
(() => {
  typeStore5.GraphicString = _a$a5;
})();
GraphicString5.NAME = "GraphicString";
var _a$95;

class VisibleString5 extends LocalSimpleStringBlock5 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 26;
  }
}
_a$95 = VisibleString5;
(() => {
  typeStore5.VisibleString = _a$95;
})();
VisibleString5.NAME = "VisibleString";
var _a$85;

class GeneralString5 extends LocalSimpleStringBlock5 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 27;
  }
}
_a$85 = GeneralString5;
(() => {
  typeStore5.GeneralString = _a$85;
})();
GeneralString5.NAME = "GeneralString";
var _a$75;

class CharacterString5 extends LocalSimpleStringBlock5 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 29;
  }
}
_a$75 = CharacterString5;
(() => {
  typeStore5.CharacterString = _a$75;
})();
CharacterString5.NAME = "CharacterString";
var _a$65;

class UTCTime5 extends VisibleString5 {
  constructor({ value, valueDate, ...parameters2 } = {}) {
    super(parameters2);
    this.year = 0;
    this.month = 0;
    this.day = 0;
    this.hour = 0;
    this.minute = 0;
    this.second = 0;
    if (value) {
      this.fromString(value);
      this.valueBlock.valueHexView = new Uint8Array(value.length);
      for (let i = 0;i < value.length; i++)
        this.valueBlock.valueHexView[i] = value.charCodeAt(i);
    }
    if (valueDate) {
      this.fromDate(valueDate);
      this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
    }
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 23;
  }
  fromBuffer(inputBuffer) {
    this.fromString(String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer)));
  }
  toBuffer() {
    const str = this.toString();
    const buffer = new ArrayBuffer(str.length);
    const view = new Uint8Array(buffer);
    for (let i = 0;i < str.length; i++)
      view[i] = str.charCodeAt(i);
    return buffer;
  }
  fromDate(inputDate) {
    this.year = inputDate.getUTCFullYear();
    this.month = inputDate.getUTCMonth() + 1;
    this.day = inputDate.getUTCDate();
    this.hour = inputDate.getUTCHours();
    this.minute = inputDate.getUTCMinutes();
    this.second = inputDate.getUTCSeconds();
  }
  toDate() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
  }
  fromString(inputString) {
    const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
    const parserArray = parser.exec(inputString);
    if (parserArray === null) {
      this.error = "Wrong input string for conversion";
      return;
    }
    const year = parseInt(parserArray[1], 10);
    if (year >= 50)
      this.year = 1900 + year;
    else
      this.year = 2000 + year;
    this.month = parseInt(parserArray[2], 10);
    this.day = parseInt(parserArray[3], 10);
    this.hour = parseInt(parserArray[4], 10);
    this.minute = parseInt(parserArray[5], 10);
    this.second = parseInt(parserArray[6], 10);
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = new Array(7);
      outputArray[0] = padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);
      outputArray[1] = padNumber(this.month, 2);
      outputArray[2] = padNumber(this.day, 2);
      outputArray[3] = padNumber(this.hour, 2);
      outputArray[4] = padNumber(this.minute, 2);
      outputArray[5] = padNumber(this.second, 2);
      outputArray[6] = "Z";
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second
    };
  }
}
_a$65 = UTCTime5;
(() => {
  typeStore5.UTCTime = _a$65;
})();
UTCTime5.NAME = "UTCTime";
var _a$55;

class GeneralizedTime5 extends UTCTime5 {
  constructor(parameters2 = {}) {
    var _b;
    super(parameters2);
    (_b = this.millisecond) !== null && _b !== undefined || (this.millisecond = 0);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 24;
  }
  fromDate(inputDate) {
    super.fromDate(inputDate);
    this.millisecond = inputDate.getUTCMilliseconds();
  }
  toDate() {
    const utcDate = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond);
    return new Date(utcDate);
  }
  fromString(inputString) {
    let isUTC = false;
    let timeString = "";
    let dateTimeString = "";
    let fractionPart = 0;
    let parser;
    let hourDifference = 0;
    let minuteDifference = 0;
    if (inputString[inputString.length - 1] === "Z") {
      timeString = inputString.substring(0, inputString.length - 1);
      isUTC = true;
    } else {
      const number = new Number(inputString[inputString.length - 1]);
      if (isNaN(number.valueOf()))
        throw new Error("Wrong input string for conversion");
      timeString = inputString;
    }
    if (isUTC) {
      if (timeString.indexOf("+") !== -1)
        throw new Error("Wrong input string for conversion");
      if (timeString.indexOf("-") !== -1)
        throw new Error("Wrong input string for conversion");
    } else {
      let multiplier = 1;
      let differencePosition = timeString.indexOf("+");
      let differenceString = "";
      if (differencePosition === -1) {
        differencePosition = timeString.indexOf("-");
        multiplier = -1;
      }
      if (differencePosition !== -1) {
        differenceString = timeString.substring(differencePosition + 1);
        timeString = timeString.substring(0, differencePosition);
        if (differenceString.length !== 2 && differenceString.length !== 4)
          throw new Error("Wrong input string for conversion");
        let number = parseInt(differenceString.substring(0, 2), 10);
        if (isNaN(number.valueOf()))
          throw new Error("Wrong input string for conversion");
        hourDifference = multiplier * number;
        if (differenceString.length === 4) {
          number = parseInt(differenceString.substring(2, 4), 10);
          if (isNaN(number.valueOf()))
            throw new Error("Wrong input string for conversion");
          minuteDifference = multiplier * number;
        }
      }
    }
    let fractionPointPosition = timeString.indexOf(".");
    if (fractionPointPosition === -1)
      fractionPointPosition = timeString.indexOf(",");
    if (fractionPointPosition !== -1) {
      const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
      if (isNaN(fractionPartCheck.valueOf()))
        throw new Error("Wrong input string for conversion");
      fractionPart = fractionPartCheck.valueOf();
      dateTimeString = timeString.substring(0, fractionPointPosition);
    } else
      dateTimeString = timeString;
    switch (true) {
      case dateTimeString.length === 8:
        parser = /(\d{4})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1)
          throw new Error("Wrong input string for conversion");
        break;
      case dateTimeString.length === 10:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.minute = Math.floor(fractionResult);
          fractionResult = 60 * (fractionResult - this.minute);
          this.second = Math.floor(fractionResult);
          fractionResult = 1000 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 12:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.second = Math.floor(fractionResult);
          fractionResult = 1000 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 14:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          const fractionResult = 1000 * fractionPart;
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      default:
        throw new Error("Wrong input string for conversion");
    }
    const parserArray = parser.exec(dateTimeString);
    if (parserArray === null)
      throw new Error("Wrong input string for conversion");
    for (let j = 1;j < parserArray.length; j++) {
      switch (j) {
        case 1:
          this.year = parseInt(parserArray[j], 10);
          break;
        case 2:
          this.month = parseInt(parserArray[j], 10);
          break;
        case 3:
          this.day = parseInt(parserArray[j], 10);
          break;
        case 4:
          this.hour = parseInt(parserArray[j], 10) + hourDifference;
          break;
        case 5:
          this.minute = parseInt(parserArray[j], 10) + minuteDifference;
          break;
        case 6:
          this.second = parseInt(parserArray[j], 10);
          break;
        default:
          throw new Error("Wrong input string for conversion");
      }
    }
    if (isUTC === false) {
      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
      this.year = tempDate.getUTCFullYear();
      this.month = tempDate.getUTCMonth();
      this.day = tempDate.getUTCDay();
      this.hour = tempDate.getUTCHours();
      this.minute = tempDate.getUTCMinutes();
      this.second = tempDate.getUTCSeconds();
      this.millisecond = tempDate.getUTCMilliseconds();
    }
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = [];
      outputArray.push(padNumber(this.year, 4));
      outputArray.push(padNumber(this.month, 2));
      outputArray.push(padNumber(this.day, 2));
      outputArray.push(padNumber(this.hour, 2));
      outputArray.push(padNumber(this.minute, 2));
      outputArray.push(padNumber(this.second, 2));
      if (this.millisecond !== 0) {
        outputArray.push(".");
        outputArray.push(padNumber(this.millisecond, 3));
      }
      outputArray.push("Z");
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  toJSON() {
    return {
      ...super.toJSON(),
      millisecond: this.millisecond
    };
  }
}
_a$55 = GeneralizedTime5;
(() => {
  typeStore5.GeneralizedTime = _a$55;
})();
GeneralizedTime5.NAME = "GeneralizedTime";
var _a$45;

class DATE5 extends Utf8String5 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 31;
  }
}
_a$45 = DATE5;
(() => {
  typeStore5.DATE = _a$45;
})();
DATE5.NAME = "DATE";
var _a$35;

class TimeOfDay5 extends Utf8String5 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 32;
  }
}
_a$35 = TimeOfDay5;
(() => {
  typeStore5.TimeOfDay = _a$35;
})();
TimeOfDay5.NAME = "TimeOfDay";
var _a$25;

class DateTime5 extends Utf8String5 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 33;
  }
}
_a$25 = DateTime5;
(() => {
  typeStore5.DateTime = _a$25;
})();
DateTime5.NAME = "DateTime";
var _a$15;

class Duration5 extends Utf8String5 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 34;
  }
}
_a$15 = Duration5;
(() => {
  typeStore5.Duration = _a$15;
})();
Duration5.NAME = "Duration";
var _a5;

class TIME5 extends Utf8String5 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 14;
  }
}
_a5 = TIME5;
(() => {
  typeStore5.TIME = _a5;
})();
TIME5.NAME = "TIME";

class Any5 {
  constructor({ name: name5 = EMPTY_STRING5, optional = false } = {}) {
    this.name = name5;
    this.optional = optional;
  }
}

class Choice5 extends Any5 {
  constructor({ value = [], ...parameters2 } = {}) {
    super(parameters2);
    this.value = value;
  }
}

class Repeated5 extends Any5 {
  constructor({ value = new Any5, local = false, ...parameters2 } = {}) {
    super(parameters2);
    this.value = value;
    this.local = local;
  }
}

class RawData5 {
  get data() {
    return this.dataView.slice().buffer;
  }
  set data(value) {
    this.dataView = BufferSourceConverter.toUint8Array(value);
  }
  constructor({ data = EMPTY_VIEW5 } = {}) {
    this.dataView = BufferSourceConverter.toUint8Array(data);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const endLength = inputOffset + inputLength;
    this.dataView = BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
    return endLength;
  }
  toBER(_sizeOnly) {
    return this.dataView.slice().buffer;
  }
}
function compareSchema5(root, inputData, inputSchema) {
  if (inputSchema instanceof Choice5) {
    for (const element of inputSchema.value) {
      const result = compareSchema5(root, inputData, element);
      if (result.verified) {
        return {
          verified: true,
          result: root
        };
      }
    }
    {
      const _result = {
        verified: false,
        result: { error: "Wrong values for Choice type" }
      };
      if (inputSchema.hasOwnProperty(NAME5))
        _result.name = inputSchema.name;
      return _result;
    }
  }
  if (inputSchema instanceof Any5) {
    if (inputSchema.hasOwnProperty(NAME5))
      root[inputSchema.name] = inputData;
    return {
      verified: true,
      result: root
    };
  }
  if (root instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong root object" }
    };
  }
  if (inputData instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 data" }
    };
  }
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (ID_BLOCK5 in inputSchema === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (FROM_BER5 in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (TO_BER5 in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  const encodedId = inputSchema.idBlock.toBER(false);
  if (encodedId.byteLength === 0) {
    return {
      verified: false,
      result: { error: "Error encoding idBlock for ASN.1 schema" }
    };
  }
  const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
  if (decodedOffset === -1) {
    return {
      verified: false,
      result: { error: "Error decoding idBlock for ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS5) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER5) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED5) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
    return {
      verified: false,
      result: root
    };
  }
  if (!(IS_HEX_ONLY5 in inputSchema.idBlock)) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.isHexOnly) {
    if (VALUE_HEX_VIEW5 in inputSchema.idBlock === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    const schemaView = inputSchema.idBlock.valueHexView;
    const asn1View = inputData.idBlock.valueHexView;
    if (schemaView.length !== asn1View.length) {
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0;i < schemaView.length; i++) {
      if (schemaView[i] !== asn1View[1]) {
        return {
          verified: false,
          result: root
        };
      }
    }
  }
  if (inputSchema.name) {
    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING5);
    if (inputSchema.name)
      root[inputSchema.name] = inputData;
  }
  if (inputSchema instanceof typeStore5.Constructed) {
    let admission = 0;
    let result = {
      verified: false,
      result: { error: "Unknown error" }
    };
    let maxLength = inputSchema.valueBlock.value.length;
    if (maxLength > 0) {
      if (inputSchema.valueBlock.value[0] instanceof Repeated5) {
        maxLength = inputData.valueBlock.value.length;
      }
    }
    if (maxLength === 0) {
      return {
        verified: true,
        result: root
      };
    }
    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
      let _optional = true;
      for (let i = 0;i < inputSchema.valueBlock.value.length; i++)
        _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);
      if (_optional) {
        return {
          verified: true,
          result: root
        };
      }
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING5);
        if (inputSchema.name)
          delete root[inputSchema.name];
      }
      root.error = "Inconsistent object length";
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0;i < maxLength; i++) {
      if (i - admission >= inputData.valueBlock.value.length) {
        if (inputSchema.valueBlock.value[i].optional === false) {
          const _result = {
            verified: false,
            result: root
          };
          root.error = "Inconsistent length between ASN.1 data and schema";
          if (inputSchema.name) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING5);
            if (inputSchema.name) {
              delete root[inputSchema.name];
              _result.name = inputSchema.name;
            }
          }
          return _result;
        }
      } else {
        if (inputSchema.valueBlock.value[0] instanceof Repeated5) {
          result = compareSchema5(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[0].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING5);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
          if (NAME5 in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
            let arrayRoot = {};
            if (LOCAL5 in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local)
              arrayRoot = inputData;
            else
              arrayRoot = root;
            if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
              arrayRoot[inputSchema.valueBlock.value[0].name] = [];
            arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
          }
        } else {
          result = compareSchema5(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[i].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING5);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
        }
      }
    }
    if (result.verified === false) {
      const _result = {
        verified: false,
        result: root
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING5);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return {
      verified: true,
      result: root
    };
  }
  if (inputSchema.primitiveSchema && VALUE_HEX_VIEW5 in inputData.valueBlock) {
    const asn1 = localFromBER5(inputData.valueBlock.valueHexView);
    if (asn1.offset === -1) {
      const _result = {
        verified: false,
        result: asn1.result
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING5);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return compareSchema5(root, asn1.result, inputSchema.primitiveSchema);
  }
  return {
    verified: true,
    result: root
  };
}
function verifySchema5(inputBuffer, inputSchema) {
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema type" }
    };
  }
  const asn1 = localFromBER5(BufferSourceConverter.toUint8Array(inputBuffer));
  if (asn1.offset === -1) {
    return {
      verified: false,
      result: asn1.result
    };
  }
  return compareSchema5(asn1.result, asn1.result, inputSchema);
}

// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-schema/build/es2015/enums.js
var AsnTypeTypes5;
(function(AsnTypeTypes6) {
  AsnTypeTypes6[AsnTypeTypes6["Sequence"] = 0] = "Sequence";
  AsnTypeTypes6[AsnTypeTypes6["Set"] = 1] = "Set";
  AsnTypeTypes6[AsnTypeTypes6["Choice"] = 2] = "Choice";
})(AsnTypeTypes5 || (AsnTypeTypes5 = {}));
var AsnPropTypes5;
(function(AsnPropTypes6) {
  AsnPropTypes6[AsnPropTypes6["Any"] = 1] = "Any";
  AsnPropTypes6[AsnPropTypes6["Boolean"] = 2] = "Boolean";
  AsnPropTypes6[AsnPropTypes6["OctetString"] = 3] = "OctetString";
  AsnPropTypes6[AsnPropTypes6["BitString"] = 4] = "BitString";
  AsnPropTypes6[AsnPropTypes6["Integer"] = 5] = "Integer";
  AsnPropTypes6[AsnPropTypes6["Enumerated"] = 6] = "Enumerated";
  AsnPropTypes6[AsnPropTypes6["ObjectIdentifier"] = 7] = "ObjectIdentifier";
  AsnPropTypes6[AsnPropTypes6["Utf8String"] = 8] = "Utf8String";
  AsnPropTypes6[AsnPropTypes6["BmpString"] = 9] = "BmpString";
  AsnPropTypes6[AsnPropTypes6["UniversalString"] = 10] = "UniversalString";
  AsnPropTypes6[AsnPropTypes6["NumericString"] = 11] = "NumericString";
  AsnPropTypes6[AsnPropTypes6["PrintableString"] = 12] = "PrintableString";
  AsnPropTypes6[AsnPropTypes6["TeletexString"] = 13] = "TeletexString";
  AsnPropTypes6[AsnPropTypes6["VideotexString"] = 14] = "VideotexString";
  AsnPropTypes6[AsnPropTypes6["IA5String"] = 15] = "IA5String";
  AsnPropTypes6[AsnPropTypes6["GraphicString"] = 16] = "GraphicString";
  AsnPropTypes6[AsnPropTypes6["VisibleString"] = 17] = "VisibleString";
  AsnPropTypes6[AsnPropTypes6["GeneralString"] = 18] = "GeneralString";
  AsnPropTypes6[AsnPropTypes6["CharacterString"] = 19] = "CharacterString";
  AsnPropTypes6[AsnPropTypes6["UTCTime"] = 20] = "UTCTime";
  AsnPropTypes6[AsnPropTypes6["GeneralizedTime"] = 21] = "GeneralizedTime";
  AsnPropTypes6[AsnPropTypes6["DATE"] = 22] = "DATE";
  AsnPropTypes6[AsnPropTypes6["TimeOfDay"] = 23] = "TimeOfDay";
  AsnPropTypes6[AsnPropTypes6["DateTime"] = 24] = "DateTime";
  AsnPropTypes6[AsnPropTypes6["Duration"] = 25] = "Duration";
  AsnPropTypes6[AsnPropTypes6["TIME"] = 26] = "TIME";
  AsnPropTypes6[AsnPropTypes6["Null"] = 27] = "Null";
})(AsnPropTypes5 || (AsnPropTypes5 = {}));

// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-schema/build/es2015/types/bit_string.js
class BitString10 {
  constructor(params, unusedBits = 0) {
    this.unusedBits = 0;
    this.value = new ArrayBuffer(0);
    if (params) {
      if (typeof params === "number") {
        this.fromNumber(params);
      } else if (BufferSourceConverter.isBufferSource(params)) {
        this.unusedBits = unusedBits;
        this.value = BufferSourceConverter.toArrayBuffer(params);
      } else {
        throw TypeError("Unsupported type of 'params' argument for BitString");
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof BitString9)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 BitString");
    }
    this.unusedBits = asn.valueBlock.unusedBits;
    this.value = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new BitString9({ unusedBits: this.unusedBits, valueHex: this.value });
  }
  toSchema(name5) {
    return new BitString9({ name: name5 });
  }
  toNumber() {
    let res = "";
    const uintArray = new Uint8Array(this.value);
    for (const octet of uintArray) {
      res += octet.toString(2).padStart(8, "0");
    }
    res = res.split("").reverse().join("");
    if (this.unusedBits) {
      res = res.slice(this.unusedBits).padStart(this.unusedBits, "0");
    }
    return parseInt(res, 2);
  }
  fromNumber(value) {
    let bits = value.toString(2);
    const octetSize = bits.length + 7 >> 3;
    this.unusedBits = (octetSize << 3) - bits.length;
    const octets = new Uint8Array(octetSize);
    bits = bits.padStart(octetSize << 3, "0").split("").reverse().join("");
    let index = 0;
    while (index < octetSize) {
      octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);
      index++;
    }
    this.value = octets.buffer;
  }
}
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-schema/build/es2015/types/octet_string.js
class OctetString10 {
  get byteLength() {
    return this.buffer.byteLength;
  }
  get byteOffset() {
    return 0;
  }
  constructor(param) {
    if (typeof param === "number") {
      this.buffer = new ArrayBuffer(param);
    } else {
      if (BufferSourceConverter.isBufferSource(param)) {
        this.buffer = BufferSourceConverter.toArrayBuffer(param);
      } else if (Array.isArray(param)) {
        this.buffer = new Uint8Array(param);
      } else {
        this.buffer = new ArrayBuffer(0);
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof OctetString9)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString");
    }
    this.buffer = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new OctetString9({ valueHex: this.buffer });
  }
  toSchema(name5) {
    return new OctetString9({ name: name5 });
  }
}
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-schema/build/es2015/converters.js
var AsnAnyConverter5 = {
  fromASN: (value) => value instanceof Null5 ? null : value.valueBeforeDecodeView,
  toASN: (value) => {
    if (value === null) {
      return new Null5;
    }
    const schema = fromBER5(value);
    if (schema.result.error) {
      throw new Error(schema.result.error);
    }
    return schema.result;
  }
};
var AsnIntegerConverter5 = {
  fromASN: (value) => value.valueBlock.valueHexView.byteLength >= 4 ? value.valueBlock.toString() : value.valueBlock.valueDec,
  toASN: (value) => new Integer5({ value: +value })
};
var AsnEnumeratedConverter5 = {
  fromASN: (value) => value.valueBlock.valueDec,
  toASN: (value) => new Enumerated5({ value })
};
var AsnIntegerArrayBufferConverter5 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new Integer5({ valueHex: value })
};
var AsnBitStringConverter5 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new BitString9({ valueHex: value })
};
var AsnObjectIdentifierConverter5 = {
  fromASN: (value) => value.valueBlock.toString(),
  toASN: (value) => new ObjectIdentifier5({ value })
};
var AsnBooleanConverter5 = {
  fromASN: (value) => value.valueBlock.value,
  toASN: (value) => new Boolean6({ value })
};
var AsnOctetStringConverter5 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new OctetString9({ valueHex: value })
};
function createStringConverter5(Asn1Type) {
  return {
    fromASN: (value) => value.valueBlock.value,
    toASN: (value) => new Asn1Type({ value })
  };
}
var AsnUtf8StringConverter5 = createStringConverter5(Utf8String5);
var AsnBmpStringConverter5 = createStringConverter5(BmpString5);
var AsnUniversalStringConverter5 = createStringConverter5(UniversalString5);
var AsnNumericStringConverter5 = createStringConverter5(NumericString5);
var AsnPrintableStringConverter5 = createStringConverter5(PrintableString5);
var AsnTeletexStringConverter5 = createStringConverter5(TeletexString5);
var AsnVideotexStringConverter5 = createStringConverter5(VideotexString5);
var AsnIA5StringConverter5 = createStringConverter5(IA5String5);
var AsnGraphicStringConverter5 = createStringConverter5(GraphicString5);
var AsnVisibleStringConverter5 = createStringConverter5(VisibleString5);
var AsnGeneralStringConverter5 = createStringConverter5(GeneralString5);
var AsnCharacterStringConverter5 = createStringConverter5(CharacterString5);
var AsnUTCTimeConverter5 = {
  fromASN: (value) => value.toDate(),
  toASN: (value) => new UTCTime5({ valueDate: value })
};
var AsnGeneralizedTimeConverter5 = {
  fromASN: (value) => value.toDate(),
  toASN: (value) => new GeneralizedTime5({ valueDate: value })
};
var AsnNullConverter5 = {
  fromASN: () => null,
  toASN: () => {
    return new Null5;
  }
};
function defaultConverter5(type) {
  switch (type) {
    case AsnPropTypes5.Any:
      return AsnAnyConverter5;
    case AsnPropTypes5.BitString:
      return AsnBitStringConverter5;
    case AsnPropTypes5.BmpString:
      return AsnBmpStringConverter5;
    case AsnPropTypes5.Boolean:
      return AsnBooleanConverter5;
    case AsnPropTypes5.CharacterString:
      return AsnCharacterStringConverter5;
    case AsnPropTypes5.Enumerated:
      return AsnEnumeratedConverter5;
    case AsnPropTypes5.GeneralString:
      return AsnGeneralStringConverter5;
    case AsnPropTypes5.GeneralizedTime:
      return AsnGeneralizedTimeConverter5;
    case AsnPropTypes5.GraphicString:
      return AsnGraphicStringConverter5;
    case AsnPropTypes5.IA5String:
      return AsnIA5StringConverter5;
    case AsnPropTypes5.Integer:
      return AsnIntegerConverter5;
    case AsnPropTypes5.Null:
      return AsnNullConverter5;
    case AsnPropTypes5.NumericString:
      return AsnNumericStringConverter5;
    case AsnPropTypes5.ObjectIdentifier:
      return AsnObjectIdentifierConverter5;
    case AsnPropTypes5.OctetString:
      return AsnOctetStringConverter5;
    case AsnPropTypes5.PrintableString:
      return AsnPrintableStringConverter5;
    case AsnPropTypes5.TeletexString:
      return AsnTeletexStringConverter5;
    case AsnPropTypes5.UTCTime:
      return AsnUTCTimeConverter5;
    case AsnPropTypes5.UniversalString:
      return AsnUniversalStringConverter5;
    case AsnPropTypes5.Utf8String:
      return AsnUtf8StringConverter5;
    case AsnPropTypes5.VideotexString:
      return AsnVideotexStringConverter5;
    case AsnPropTypes5.VisibleString:
      return AsnVisibleStringConverter5;
    default:
      return null;
  }
}
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-schema/build/es2015/helper.js
function isConvertible5(target2) {
  if (typeof target2 === "function" && target2.prototype) {
    if (target2.prototype.toASN && target2.prototype.fromASN) {
      return true;
    } else {
      return isConvertible5(target2.prototype);
    }
  } else {
    return !!(target2 && typeof target2 === "object" && ("toASN" in target2) && ("fromASN" in target2));
  }
}

// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-schema/build/es2015/schema.js
class AsnSchemaStorage5 {
  constructor() {
    this.items = new WeakMap;
  }
  has(target2) {
    return this.items.has(target2);
  }
  get(target2, checkSchema = false) {
    const schema = this.items.get(target2);
    if (!schema) {
      throw new Error(`Cannot get schema for '${target2.prototype.constructor.name}' target`);
    }
    if (checkSchema && !schema.schema) {
      throw new Error(`Schema '${target2.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);
    }
    return schema;
  }
  cache(target2) {
    const schema = this.get(target2);
    if (!schema.schema) {
      schema.schema = this.create(target2, true);
    }
  }
  createDefault(target2) {
    const schema = { type: AsnTypeTypes5.Sequence, items: {} };
    const parentSchema = this.findParentSchema(target2);
    if (parentSchema) {
      Object.assign(schema, parentSchema);
      schema.items = Object.assign({}, schema.items, parentSchema.items);
    }
    return schema;
  }
  create(target2, useNames) {
    const schema = this.items.get(target2) || this.createDefault(target2);
    const asn1Value = [];
    for (const key in schema.items) {
      const item = schema.items[key];
      const name5 = useNames ? key : "";
      let asn1Item;
      if (typeof item.type === "number") {
        const Asn1TypeName = AsnPropTypes5[item.type];
        const Asn1Type = exports_index_es6[Asn1TypeName];
        if (!Asn1Type) {
          throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
        }
        asn1Item = new Asn1Type({ name: name5 });
      } else if (isConvertible5(item.type)) {
        const instance2 = new item.type;
        asn1Item = instance2.toSchema(name5);
      } else if (item.optional) {
        const itemSchema = this.get(item.type);
        if (itemSchema.type === AsnTypeTypes5.Choice) {
          asn1Item = new Any5({ name: name5 });
        } else {
          asn1Item = this.create(item.type, false);
          asn1Item.name = name5;
        }
      } else {
        asn1Item = new Any5({ name: name5 });
      }
      const optional = !!item.optional || item.defaultValue !== undefined;
      if (item.repeated) {
        asn1Item.name = "";
        const Container = item.repeated === "set" ? Set6 : Sequence5;
        asn1Item = new Container({
          name: "",
          value: [new Repeated5({ name: name5, value: asn1Item })]
        });
      }
      if (item.context !== null && item.context !== undefined) {
        if (item.implicit) {
          if (typeof item.type === "number" || isConvertible5(item.type)) {
            const Container = item.repeated ? Constructed5 : Primitive5;
            asn1Value.push(new Container({ name: name5, optional, idBlock: { tagClass: 3, tagNumber: item.context } }));
          } else {
            this.cache(item.type);
            const isRepeated = !!item.repeated;
            let value = !isRepeated ? this.get(item.type, true).schema : asn1Item;
            value = "valueBlock" in value ? value.valueBlock.value : value.value;
            asn1Value.push(new Constructed5({
              name: !isRepeated ? name5 : "",
              optional,
              idBlock: { tagClass: 3, tagNumber: item.context },
              value
            }));
          }
        } else {
          asn1Value.push(new Constructed5({
            optional,
            idBlock: { tagClass: 3, tagNumber: item.context },
            value: [asn1Item]
          }));
        }
      } else {
        asn1Item.optional = optional;
        asn1Value.push(asn1Item);
      }
    }
    switch (schema.type) {
      case AsnTypeTypes5.Sequence:
        return new Sequence5({ value: asn1Value, name: "" });
      case AsnTypeTypes5.Set:
        return new Set6({ value: asn1Value, name: "" });
      case AsnTypeTypes5.Choice:
        return new Choice5({ value: asn1Value, name: "" });
      default:
        throw new Error(`Unsupported ASN1 type in use`);
    }
  }
  set(target2, schema) {
    this.items.set(target2, schema);
    return this;
  }
  findParentSchema(target2) {
    const parent = Object.getPrototypeOf(target2);
    if (parent) {
      const schema = this.items.get(parent);
      return schema || this.findParentSchema(parent);
    }
    return null;
  }
}

// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-schema/build/es2015/storage.js
var schemaStorage5 = new AsnSchemaStorage5;

// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-schema/build/es2015/decorators.js
var AsnType5 = (options) => (target2) => {
  let schema;
  if (!schemaStorage5.has(target2)) {
    schema = schemaStorage5.createDefault(target2);
    schemaStorage5.set(target2, schema);
  } else {
    schema = schemaStorage5.get(target2);
  }
  Object.assign(schema, options);
};
var AsnProp5 = (options) => (target2, propertyKey) => {
  let schema;
  if (!schemaStorage5.has(target2.constructor)) {
    schema = schemaStorage5.createDefault(target2.constructor);
    schemaStorage5.set(target2.constructor, schema);
  } else {
    schema = schemaStorage5.get(target2.constructor);
  }
  const copyOptions = Object.assign({}, options);
  if (typeof copyOptions.type === "number" && !copyOptions.converter) {
    const defaultConverter6 = defaultConverter5(options.type);
    if (!defaultConverter6) {
      throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target2.constructor.name}`);
    }
    copyOptions.converter = defaultConverter6;
  }
  copyOptions.raw = options.raw;
  schema.items[propertyKey] = copyOptions;
};
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-schema/build/es2015/objects.js
class AsnArray5 extends Array {
  constructor(items = []) {
    if (typeof items === "number") {
      super(items);
    } else {
      super();
      for (const item of items) {
        this.push(item);
      }
    }
  }
}
// node_modules/@peculiar/asn1-pfx/node_modules/asn1js/build/index.es.js
var exports_index_es7 = {};
__export(exports_index_es7, {
  verifySchema: () => verifySchema6,
  fromBER: () => fromBER6,
  compareSchema: () => compareSchema6,
  VisibleString: () => VisibleString6,
  ViewWriter: () => ViewWriter6,
  VideotexString: () => VideotexString6,
  ValueBlock: () => ValueBlock6,
  Utf8String: () => Utf8String6,
  UniversalString: () => UniversalString6,
  UTCTime: () => UTCTime6,
  TimeOfDay: () => TimeOfDay6,
  TeletexString: () => TeletexString6,
  TIME: () => TIME6,
  Set: () => Set7,
  Sequence: () => Sequence6,
  Repeated: () => Repeated6,
  RelativeObjectIdentifier: () => RelativeObjectIdentifier6,
  RawData: () => RawData6,
  PrintableString: () => PrintableString6,
  Primitive: () => Primitive6,
  OctetString: () => OctetString11,
  ObjectIdentifier: () => ObjectIdentifier6,
  NumericString: () => NumericString6,
  Null: () => Null6,
  Integer: () => Integer6,
  IA5String: () => IA5String6,
  HexBlock: () => HexBlock6,
  GraphicString: () => GraphicString6,
  GeneralizedTime: () => GeneralizedTime6,
  GeneralString: () => GeneralString6,
  Enumerated: () => Enumerated6,
  EndOfContent: () => EndOfContent6,
  Duration: () => Duration6,
  DateTime: () => DateTime6,
  DATE: () => DATE6,
  Constructed: () => Constructed6,
  Choice: () => Choice6,
  CharacterString: () => CharacterString6,
  Boolean: () => Boolean7,
  BmpString: () => BmpString6,
  BitString: () => BitString11,
  BaseStringBlock: () => BaseStringBlock6,
  BaseBlock: () => BaseBlock6,
  Any: () => Any6
});
/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
function assertBigInt6() {
  if (typeof BigInt === "undefined") {
    throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
  }
}
function concat6(buffers) {
  let outputLength = 0;
  let prevLength = 0;
  for (let i = 0;i < buffers.length; i++) {
    const buffer = buffers[i];
    outputLength += buffer.byteLength;
  }
  const retView = new Uint8Array(outputLength);
  for (let i = 0;i < buffers.length; i++) {
    const buffer = buffers[i];
    retView.set(new Uint8Array(buffer), prevLength);
    prevLength += buffer.byteLength;
  }
  return retView.buffer;
}
function checkBufferParams6(baseBlock, inputBuffer, inputOffset, inputLength) {
  if (!(inputBuffer instanceof Uint8Array)) {
    baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
    return false;
  }
  if (!inputBuffer.byteLength) {
    baseBlock.error = "Wrong parameter: inputBuffer has zero length";
    return false;
  }
  if (inputOffset < 0) {
    baseBlock.error = "Wrong parameter: inputOffset less than zero";
    return false;
  }
  if (inputLength < 0) {
    baseBlock.error = "Wrong parameter: inputLength less than zero";
    return false;
  }
  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
    baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
    return false;
  }
  return true;
}

class ViewWriter6 {
  constructor() {
    this.items = [];
  }
  write(buf) {
    this.items.push(buf);
  }
  final() {
    return concat6(this.items);
  }
}
var powers26 = [new Uint8Array([1])];
var digitsString6 = "0123456789";
var NAME6 = "name";
var VALUE_HEX_VIEW6 = "valueHexView";
var IS_HEX_ONLY6 = "isHexOnly";
var ID_BLOCK6 = "idBlock";
var TAG_CLASS6 = "tagClass";
var TAG_NUMBER6 = "tagNumber";
var IS_CONSTRUCTED6 = "isConstructed";
var FROM_BER6 = "fromBER";
var TO_BER6 = "toBER";
var LOCAL6 = "local";
var EMPTY_STRING6 = "";
var EMPTY_BUFFER6 = new ArrayBuffer(0);
var EMPTY_VIEW6 = new Uint8Array(0);
var END_OF_CONTENT_NAME6 = "EndOfContent";
var OCTET_STRING_NAME6 = "OCTET STRING";
var BIT_STRING_NAME6 = "BIT STRING";
function HexBlock6(BaseClass) {
  var _a6;
  return _a6 = class Some extends BaseClass {
    get valueHex() {
      return this.valueHexView.slice().buffer;
    }
    set valueHex(value) {
      this.valueHexView = new Uint8Array(value);
    }
    constructor(...args) {
      var _b;
      super(...args);
      const params = args[0] || {};
      this.isHexOnly = (_b = params.isHexOnly) !== null && _b !== undefined ? _b : false;
      this.valueHexView = params.valueHex ? BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW6;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      if (!checkBufferParams6(this, view, inputOffset, inputLength)) {
        return -1;
      }
      const endLength = inputOffset + inputLength;
      this.valueHexView = view.subarray(inputOffset, endLength);
      if (!this.valueHexView.length) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      }
      this.blockLength = inputLength;
      return endLength;
    }
    toBER(sizeOnly = false) {
      if (!this.isHexOnly) {
        this.error = "Flag 'isHexOnly' is not set, abort";
        return EMPTY_BUFFER6;
      }
      if (sizeOnly) {
        return new ArrayBuffer(this.valueHexView.byteLength);
      }
      return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        isHexOnly: this.isHexOnly,
        valueHex: Convert.ToHex(this.valueHexView)
      };
    }
  }, _a6.NAME = "hexBlock", _a6;
}

class LocalBaseBlock6 {
  static blockName() {
    return this.NAME;
  }
  get valueBeforeDecode() {
    return this.valueBeforeDecodeView.slice().buffer;
  }
  set valueBeforeDecode(value) {
    this.valueBeforeDecodeView = new Uint8Array(value);
  }
  constructor({ blockLength = 0, error = EMPTY_STRING6, warnings = [], valueBeforeDecode = EMPTY_VIEW6 } = {}) {
    this.blockLength = blockLength;
    this.error = error;
    this.warnings = warnings;
    this.valueBeforeDecodeView = BufferSourceConverter.toUint8Array(valueBeforeDecode);
  }
  toJSON() {
    return {
      blockName: this.constructor.NAME,
      blockLength: this.blockLength,
      error: this.error,
      warnings: this.warnings,
      valueBeforeDecode: Convert.ToHex(this.valueBeforeDecodeView)
    };
  }
}
LocalBaseBlock6.NAME = "baseBlock";

class ValueBlock6 extends LocalBaseBlock6 {
  fromBER(_inputBuffer, _inputOffset, _inputLength) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
  toBER(_sizeOnly, _writer) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
}
ValueBlock6.NAME = "valueBlock";

class LocalIdentificationBlock6 extends HexBlock6(LocalBaseBlock6) {
  constructor({ idBlock = {} } = {}) {
    var _a6, _b, _c, _d;
    super();
    if (idBlock) {
      this.isHexOnly = (_a6 = idBlock.isHexOnly) !== null && _a6 !== undefined ? _a6 : false;
      this.valueHexView = idBlock.valueHex ? BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW6;
      this.tagClass = (_b = idBlock.tagClass) !== null && _b !== undefined ? _b : -1;
      this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== undefined ? _c : -1;
      this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== undefined ? _d : false;
    } else {
      this.tagClass = -1;
      this.tagNumber = -1;
      this.isConstructed = false;
    }
  }
  toBER(sizeOnly = false) {
    let firstOctet = 0;
    switch (this.tagClass) {
      case 1:
        firstOctet |= 0;
        break;
      case 2:
        firstOctet |= 64;
        break;
      case 3:
        firstOctet |= 128;
        break;
      case 4:
        firstOctet |= 192;
        break;
      default:
        this.error = "Unknown tag class";
        return EMPTY_BUFFER6;
    }
    if (this.isConstructed)
      firstOctet |= 32;
    if (this.tagNumber < 31 && !this.isHexOnly) {
      const retView2 = new Uint8Array(1);
      if (!sizeOnly) {
        let number = this.tagNumber;
        number &= 31;
        firstOctet |= number;
        retView2[0] = firstOctet;
      }
      return retView2.buffer;
    }
    if (!this.isHexOnly) {
      const encodedBuf = utilToBase(this.tagNumber, 7);
      const encodedView = new Uint8Array(encodedBuf);
      const size = encodedBuf.byteLength;
      const retView2 = new Uint8Array(size + 1);
      retView2[0] = firstOctet | 31;
      if (!sizeOnly) {
        for (let i = 0;i < size - 1; i++)
          retView2[i + 1] = encodedView[i] | 128;
        retView2[size] = encodedView[size - 1];
      }
      return retView2.buffer;
    }
    const retView = new Uint8Array(this.valueHexView.byteLength + 1);
    retView[0] = firstOctet | 31;
    if (!sizeOnly) {
      const curView = this.valueHexView;
      for (let i = 0;i < curView.length - 1; i++)
        retView[i + 1] = curView[i] | 128;
      retView[this.valueHexView.byteLength] = curView[curView.length - 1];
    }
    return retView.buffer;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams6(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    const tagClassMask = intBuffer[0] & 192;
    switch (tagClassMask) {
      case 0:
        this.tagClass = 1;
        break;
      case 64:
        this.tagClass = 2;
        break;
      case 128:
        this.tagClass = 3;
        break;
      case 192:
        this.tagClass = 4;
        break;
      default:
        this.error = "Unknown tag class";
        return -1;
    }
    this.isConstructed = (intBuffer[0] & 32) === 32;
    this.isHexOnly = false;
    const tagNumberMask = intBuffer[0] & 31;
    if (tagNumberMask !== 31) {
      this.tagNumber = tagNumberMask;
      this.blockLength = 1;
    } else {
      let count = 1;
      let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
      let tagNumberBufferMaxLength = 255;
      while (intBuffer[count] & 128) {
        intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
        count++;
        if (count >= intBuffer.length) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (count === tagNumberBufferMaxLength) {
          tagNumberBufferMaxLength += 255;
          const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);
          for (let i = 0;i < intTagNumberBuffer.length; i++)
            tempBufferView2[i] = intTagNumberBuffer[i];
          intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
        }
      }
      this.blockLength = count + 1;
      intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
      const tempBufferView = new Uint8Array(count);
      for (let i = 0;i < count; i++)
        tempBufferView[i] = intTagNumberBuffer[i];
      intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
      intTagNumberBuffer.set(tempBufferView);
      if (this.blockLength <= 9)
        this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
      else {
        this.isHexOnly = true;
        this.warnings.push("Tag too long, represented as hex-coded");
      }
    }
    if (this.tagClass === 1 && this.isConstructed) {
      switch (this.tagNumber) {
        case 1:
        case 2:
        case 5:
        case 6:
        case 9:
        case 13:
        case 14:
        case 23:
        case 24:
        case 31:
        case 32:
        case 33:
        case 34:
          this.error = "Constructed encoding used for primitive type";
          return -1;
      }
    }
    return inputOffset + this.blockLength;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      tagClass: this.tagClass,
      tagNumber: this.tagNumber,
      isConstructed: this.isConstructed
    };
  }
}
LocalIdentificationBlock6.NAME = "identificationBlock";

class LocalLengthBlock6 extends LocalBaseBlock6 {
  constructor({ lenBlock = {} } = {}) {
    var _a6, _b, _c;
    super();
    this.isIndefiniteForm = (_a6 = lenBlock.isIndefiniteForm) !== null && _a6 !== undefined ? _a6 : false;
    this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== undefined ? _b : false;
    this.length = (_c = lenBlock.length) !== null && _c !== undefined ? _c : 0;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams6(this, view, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    if (intBuffer[0] === 255) {
      this.error = "Length block 0xFF is reserved by standard";
      return -1;
    }
    this.isIndefiniteForm = intBuffer[0] === 128;
    if (this.isIndefiniteForm) {
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    this.longFormUsed = !!(intBuffer[0] & 128);
    if (this.longFormUsed === false) {
      this.length = intBuffer[0];
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    const count = intBuffer[0] & 127;
    if (count > 8) {
      this.error = "Too big integer";
      return -1;
    }
    if (count + 1 > intBuffer.length) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    const lenOffset = inputOffset + 1;
    const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
    if (lengthBufferView[count - 1] === 0)
      this.warnings.push("Needlessly long encoded length");
    this.length = utilFromBase(lengthBufferView, 8);
    if (this.longFormUsed && this.length <= 127)
      this.warnings.push("Unnecessary usage of long length form");
    this.blockLength = count + 1;
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly = false) {
    let retBuf;
    let retView;
    if (this.length > 127)
      this.longFormUsed = true;
    if (this.isIndefiniteForm) {
      retBuf = new ArrayBuffer(1);
      if (sizeOnly === false) {
        retView = new Uint8Array(retBuf);
        retView[0] = 128;
      }
      return retBuf;
    }
    if (this.longFormUsed) {
      const encodedBuf = utilToBase(this.length, 8);
      if (encodedBuf.byteLength > 127) {
        this.error = "Too big length";
        return EMPTY_BUFFER6;
      }
      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
      if (sizeOnly)
        return retBuf;
      const encodedView = new Uint8Array(encodedBuf);
      retView = new Uint8Array(retBuf);
      retView[0] = encodedBuf.byteLength | 128;
      for (let i = 0;i < encodedBuf.byteLength; i++)
        retView[i + 1] = encodedView[i];
      return retBuf;
    }
    retBuf = new ArrayBuffer(1);
    if (sizeOnly === false) {
      retView = new Uint8Array(retBuf);
      retView[0] = this.length;
    }
    return retBuf;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      longFormUsed: this.longFormUsed,
      length: this.length
    };
  }
}
LocalLengthBlock6.NAME = "lengthBlock";
var typeStore6 = {};

class BaseBlock6 extends LocalBaseBlock6 {
  constructor({ name: name5 = EMPTY_STRING6, optional = false, primitiveSchema, ...parameters2 } = {}, valueBlockType) {
    super(parameters2);
    this.name = name5;
    this.optional = optional;
    if (primitiveSchema) {
      this.primitiveSchema = primitiveSchema;
    }
    this.idBlock = new LocalIdentificationBlock6(parameters2);
    this.lenBlock = new LocalLengthBlock6(parameters2);
    this.valueBlock = valueBlockType ? new valueBlockType(parameters2) : new ValueBlock6(parameters2);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter6;
    if (!writer) {
      prepareIndefiniteForm6(this);
    }
    const idBlockBuf = this.idBlock.toBER(sizeOnly);
    _writer.write(idBlockBuf);
    if (this.lenBlock.isIndefiniteForm) {
      _writer.write(new Uint8Array([128]).buffer);
      this.valueBlock.toBER(sizeOnly, _writer);
      _writer.write(new ArrayBuffer(2));
    } else {
      const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
      this.lenBlock.length = valueBlockBuf.byteLength;
      const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
      _writer.write(lenBlockBuf);
      _writer.write(valueBlockBuf);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER6;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      idBlock: this.idBlock.toJSON(),
      lenBlock: this.lenBlock.toJSON(),
      valueBlock: this.valueBlock.toJSON(),
      name: this.name,
      optional: this.optional
    };
    if (this.primitiveSchema)
      object.primitiveSchema = this.primitiveSchema.toJSON();
    return object;
  }
  toString(encoding = "ascii") {
    if (encoding === "ascii") {
      return this.onAsciiEncoding();
    }
    return Convert.ToHex(this.toBER());
  }
  onAsciiEncoding() {
    const name5 = this.constructor.NAME;
    const value = Convert.ToHex(this.valueBlock.valueBeforeDecodeView);
    return `${name5} : ${value}`;
  }
  isEqual(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof this.constructor)) {
      return false;
    }
    const thisRaw = this.toBER();
    const otherRaw = other.toBER();
    return isEqualBuffer(thisRaw, otherRaw);
  }
}
BaseBlock6.NAME = "BaseBlock";
function prepareIndefiniteForm6(baseBlock) {
  var _a6;
  if (baseBlock instanceof typeStore6.Constructed) {
    for (const value of baseBlock.valueBlock.value) {
      if (prepareIndefiniteForm6(value)) {
        baseBlock.lenBlock.isIndefiniteForm = true;
      }
    }
  }
  return !!((_a6 = baseBlock.lenBlock) === null || _a6 === undefined ? undefined : _a6.isIndefiniteForm);
}

class BaseStringBlock6 extends BaseBlock6 {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  constructor({ value = EMPTY_STRING6, ...parameters2 } = {}, stringValueBlockType) {
    super(parameters2, stringValueBlockType);
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    this.fromBuffer(this.valueBlock.valueHexView);
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
  }
}
BaseStringBlock6.NAME = "BaseStringBlock";

class LocalPrimitiveValueBlock6 extends HexBlock6(ValueBlock6) {
  constructor({ isHexOnly = true, ...parameters2 } = {}) {
    super(parameters2);
    this.isHexOnly = isHexOnly;
  }
}
LocalPrimitiveValueBlock6.NAME = "PrimitiveValueBlock";
var _a$w6;

class Primitive6 extends BaseBlock6 {
  constructor(parameters2 = {}) {
    super(parameters2, LocalPrimitiveValueBlock6);
    this.idBlock.isConstructed = false;
  }
}
_a$w6 = Primitive6;
(() => {
  typeStore6.Primitive = _a$w6;
})();
Primitive6.NAME = "PRIMITIVE";
function localChangeType6(inputObject, newType) {
  if (inputObject instanceof newType) {
    return inputObject;
  }
  const newObject = new newType;
  newObject.idBlock = inputObject.idBlock;
  newObject.lenBlock = inputObject.lenBlock;
  newObject.warnings = inputObject.warnings;
  newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
  return newObject;
}
function localFromBER6(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
  const incomingOffset = inputOffset;
  let returnObject = new BaseBlock6({}, ValueBlock6);
  const baseBlock = new LocalBaseBlock6;
  if (!checkBufferParams6(baseBlock, inputBuffer, inputOffset, inputLength)) {
    returnObject.error = baseBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
  if (!intBuffer.length) {
    returnObject.error = "Zero buffer length";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.idBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.idBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.idBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.idBlock.blockLength;
  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.lenBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.lenBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.lenBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.lenBlock.blockLength;
  if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
    returnObject.error = "Indefinite length form used for primitive encoding form";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let newASN1Type = BaseBlock6;
  switch (returnObject.idBlock.tagClass) {
    case 1:
      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
        returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
        return {
          offset: -1,
          result: returnObject
        };
      }
      switch (returnObject.idBlock.tagNumber) {
        case 0:
          if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
            returnObject.error = "Type [UNIVERSAL 0] is reserved";
            return {
              offset: -1,
              result: returnObject
            };
          }
          newASN1Type = typeStore6.EndOfContent;
          break;
        case 1:
          newASN1Type = typeStore6.Boolean;
          break;
        case 2:
          newASN1Type = typeStore6.Integer;
          break;
        case 3:
          newASN1Type = typeStore6.BitString;
          break;
        case 4:
          newASN1Type = typeStore6.OctetString;
          break;
        case 5:
          newASN1Type = typeStore6.Null;
          break;
        case 6:
          newASN1Type = typeStore6.ObjectIdentifier;
          break;
        case 10:
          newASN1Type = typeStore6.Enumerated;
          break;
        case 12:
          newASN1Type = typeStore6.Utf8String;
          break;
        case 13:
          newASN1Type = typeStore6.RelativeObjectIdentifier;
          break;
        case 14:
          newASN1Type = typeStore6.TIME;
          break;
        case 15:
          returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
          return {
            offset: -1,
            result: returnObject
          };
        case 16:
          newASN1Type = typeStore6.Sequence;
          break;
        case 17:
          newASN1Type = typeStore6.Set;
          break;
        case 18:
          newASN1Type = typeStore6.NumericString;
          break;
        case 19:
          newASN1Type = typeStore6.PrintableString;
          break;
        case 20:
          newASN1Type = typeStore6.TeletexString;
          break;
        case 21:
          newASN1Type = typeStore6.VideotexString;
          break;
        case 22:
          newASN1Type = typeStore6.IA5String;
          break;
        case 23:
          newASN1Type = typeStore6.UTCTime;
          break;
        case 24:
          newASN1Type = typeStore6.GeneralizedTime;
          break;
        case 25:
          newASN1Type = typeStore6.GraphicString;
          break;
        case 26:
          newASN1Type = typeStore6.VisibleString;
          break;
        case 27:
          newASN1Type = typeStore6.GeneralString;
          break;
        case 28:
          newASN1Type = typeStore6.UniversalString;
          break;
        case 29:
          newASN1Type = typeStore6.CharacterString;
          break;
        case 30:
          newASN1Type = typeStore6.BmpString;
          break;
        case 31:
          newASN1Type = typeStore6.DATE;
          break;
        case 32:
          newASN1Type = typeStore6.TimeOfDay;
          break;
        case 33:
          newASN1Type = typeStore6.DateTime;
          break;
        case 34:
          newASN1Type = typeStore6.Duration;
          break;
        default: {
          const newObject = returnObject.idBlock.isConstructed ? new typeStore6.Constructed : new typeStore6.Primitive;
          newObject.idBlock = returnObject.idBlock;
          newObject.lenBlock = returnObject.lenBlock;
          newObject.warnings = returnObject.warnings;
          returnObject = newObject;
        }
      }
      break;
    case 2:
    case 3:
    case 4:
    default: {
      newASN1Type = returnObject.idBlock.isConstructed ? typeStore6.Constructed : typeStore6.Primitive;
    }
  }
  returnObject = localChangeType6(returnObject, newASN1Type);
  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
  returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
  return {
    offset: resultOffset,
    result: returnObject
  };
}
function fromBER6(inputBuffer) {
  if (!inputBuffer.byteLength) {
    const result = new BaseBlock6({}, ValueBlock6);
    result.error = "Input buffer has zero length";
    return {
      offset: -1,
      result
    };
  }
  return localFromBER6(BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
}
function checkLen6(indefiniteLength, length) {
  if (indefiniteLength) {
    return 1;
  }
  return length;
}

class LocalConstructedValueBlock6 extends ValueBlock6 {
  constructor({ value = [], isIndefiniteForm = false, ...parameters2 } = {}) {
    super(parameters2);
    this.value = value;
    this.isIndefiniteForm = isIndefiniteForm;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams6(this, view, inputOffset, inputLength)) {
      return -1;
    }
    this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
    if (this.valueBeforeDecodeView.length === 0) {
      this.warnings.push("Zero buffer length");
      return inputOffset;
    }
    let currentOffset = inputOffset;
    while (checkLen6(this.isIndefiniteForm, inputLength) > 0) {
      const returnObject = localFromBER6(view, currentOffset, inputLength);
      if (returnObject.offset === -1) {
        this.error = returnObject.result.error;
        this.warnings.concat(returnObject.result.warnings);
        return -1;
      }
      currentOffset = returnObject.offset;
      this.blockLength += returnObject.result.blockLength;
      inputLength -= returnObject.result.blockLength;
      this.value.push(returnObject.result);
      if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME6) {
        break;
      }
    }
    if (this.isIndefiniteForm) {
      if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME6) {
        this.value.pop();
      } else {
        this.warnings.push("No EndOfContent block encoded");
      }
    }
    return currentOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter6;
    for (let i = 0;i < this.value.length; i++) {
      this.value[i].toBER(sizeOnly, _writer);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER6;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      value: []
    };
    for (const value of this.value) {
      object.value.push(value.toJSON());
    }
    return object;
  }
}
LocalConstructedValueBlock6.NAME = "ConstructedValueBlock";
var _a$v6;

class Constructed6 extends BaseBlock6 {
  constructor(parameters2 = {}) {
    super(parameters2, LocalConstructedValueBlock6);
    this.idBlock.isConstructed = true;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    const values = [];
    for (const value of this.valueBlock.value) {
      values.push(value.toString("ascii").split(`
`).map((o) => `  ${o}`).join(`
`));
    }
    const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
    return values.length ? `${blockName} :
${values.join(`
`)}` : `${blockName} :`;
  }
}
_a$v6 = Constructed6;
(() => {
  typeStore6.Constructed = _a$v6;
})();
Constructed6.NAME = "CONSTRUCTED";

class LocalEndOfContentValueBlock6 extends ValueBlock6 {
  fromBER(inputBuffer, inputOffset, _inputLength) {
    return inputOffset;
  }
  toBER(_sizeOnly) {
    return EMPTY_BUFFER6;
  }
}
LocalEndOfContentValueBlock6.override = "EndOfContentValueBlock";
var _a$u6;

class EndOfContent6 extends BaseBlock6 {
  constructor(parameters2 = {}) {
    super(parameters2, LocalEndOfContentValueBlock6);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 0;
  }
}
_a$u6 = EndOfContent6;
(() => {
  typeStore6.EndOfContent = _a$u6;
})();
EndOfContent6.NAME = END_OF_CONTENT_NAME6;
var _a$t6;

class Null6 extends BaseBlock6 {
  constructor(parameters2 = {}) {
    super(parameters2, ValueBlock6);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 5;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (this.lenBlock.length > 0)
      this.warnings.push("Non-zero length of value block for Null type");
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    this.blockLength += inputLength;
    if (inputOffset + inputLength > inputBuffer.byteLength) {
      this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
      return -1;
    }
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    const retBuf = new ArrayBuffer(2);
    if (!sizeOnly) {
      const retView = new Uint8Array(retBuf);
      retView[0] = 5;
      retView[1] = 0;
    }
    if (writer) {
      writer.write(retBuf);
    }
    return retBuf;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME}`;
  }
}
_a$t6 = Null6;
(() => {
  typeStore6.Null = _a$t6;
})();
Null6.NAME = "NULL";

class LocalBooleanValueBlock6 extends HexBlock6(ValueBlock6) {
  get value() {
    for (const octet of this.valueHexView) {
      if (octet > 0) {
        return true;
      }
    }
    return false;
  }
  set value(value) {
    this.valueHexView[0] = value ? 255 : 0;
  }
  constructor({ value, ...parameters2 } = {}) {
    super(parameters2);
    if (parameters2.valueHex) {
      this.valueHexView = BufferSourceConverter.toUint8Array(parameters2.valueHex);
    } else {
      this.valueHexView = new Uint8Array(1);
    }
    if (value) {
      this.value = value;
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams6(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (inputLength > 1)
      this.warnings.push("Boolean value encoded in more then 1 octet");
    this.isHexOnly = true;
    utilDecodeTC.call(this);
    this.blockLength = inputLength;
    return inputOffset + inputLength;
  }
  toBER() {
    return this.valueHexView.slice();
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalBooleanValueBlock6.NAME = "BooleanValueBlock";
var _a$s6;

class Boolean7 extends BaseBlock6 {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  constructor(parameters2 = {}) {
    super(parameters2, LocalBooleanValueBlock6);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 1;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.getValue}`;
  }
}
_a$s6 = Boolean7;
(() => {
  typeStore6.Boolean = _a$s6;
})();
Boolean7.NAME = "BOOLEAN";

class LocalOctetStringValueBlock6 extends HexBlock6(LocalConstructedValueBlock6) {
  constructor({ isConstructed = false, ...parameters2 } = {}) {
    super(parameters2);
    this.isConstructed = isConstructed;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = 0;
    if (this.isConstructed) {
      this.isHexOnly = false;
      resultOffset = LocalConstructedValueBlock6.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (let i = 0;i < this.value.length; i++) {
        const currentBlockName = this.value[i].constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME6) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== OCTET_STRING_NAME6) {
          this.error = "OCTET STRING may consists of OCTET STRINGs only";
          return -1;
        }
      }
    } else {
      this.isHexOnly = true;
      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
      this.blockLength = inputLength;
    }
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed)
      return LocalConstructedValueBlock6.prototype.toBER.call(this, sizeOnly, writer);
    return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isConstructed: this.isConstructed
    };
  }
}
LocalOctetStringValueBlock6.NAME = "OctetStringValueBlock";
var _a$r6;

class OctetString11 extends BaseBlock6 {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters2 } = {}) {
    var _b, _c;
    (_b = parameters2.isConstructed) !== null && _b !== undefined || (parameters2.isConstructed = !!((_c = parameters2.value) === null || _c === undefined ? undefined : _c.length));
    super({
      idBlock: {
        isConstructed: parameters2.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters2.isIndefiniteForm
      },
      ...parameters2
    }, LocalOctetStringValueBlock6);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 4;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    if (inputLength === 0) {
      if (this.idBlock.error.length === 0)
        this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0)
        this.blockLength += this.lenBlock.blockLength;
      return inputOffset;
    }
    if (!this.valueBlock.isConstructed) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      const buf = view.subarray(inputOffset, inputOffset + inputLength);
      try {
        if (buf.byteLength) {
          const asn = localFromBER6(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength) {
            this.valueBlock.value = [asn.result];
          }
        }
      } catch {}
    }
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed6.prototype.onAsciiEncoding.call(this);
    }
    const name5 = this.constructor.NAME;
    const value = Convert.ToHex(this.valueBlock.valueHexView);
    return `${name5} : ${value}`;
  }
  getValue() {
    if (!this.idBlock.isConstructed) {
      return this.valueBlock.valueHexView.slice().buffer;
    }
    const array = [];
    for (const content of this.valueBlock.value) {
      if (content instanceof _a$r6) {
        array.push(content.valueBlock.valueHexView);
      }
    }
    return BufferSourceConverter.concat(array);
  }
}
_a$r6 = OctetString11;
(() => {
  typeStore6.OctetString = _a$r6;
})();
OctetString11.NAME = OCTET_STRING_NAME6;

class LocalBitStringValueBlock6 extends HexBlock6(LocalConstructedValueBlock6) {
  constructor({ unusedBits = 0, isConstructed = false, ...parameters2 } = {}) {
    super(parameters2);
    this.unusedBits = unusedBits;
    this.isConstructed = isConstructed;
    this.blockLength = this.valueHexView.byteLength;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    let resultOffset = -1;
    if (this.isConstructed) {
      resultOffset = LocalConstructedValueBlock6.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (const value of this.value) {
        const currentBlockName = value.constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME6) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== BIT_STRING_NAME6) {
          this.error = "BIT STRING may consists of BIT STRINGs only";
          return -1;
        }
        const valueBlock = value.valueBlock;
        if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
          this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
          return -1;
        }
        this.unusedBits = valueBlock.unusedBits;
      }
      return resultOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams6(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.unusedBits = intBuffer[0];
    if (this.unusedBits > 7) {
      this.error = "Unused bits for BitString must be in range 0-7";
      return -1;
    }
    if (!this.unusedBits) {
      const buf = intBuffer.subarray(1);
      try {
        if (buf.byteLength) {
          const asn = localFromBER6(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength - 1) {
            this.value = [asn.result];
          }
        }
      } catch {}
    }
    this.valueHexView = intBuffer.subarray(1);
    this.blockLength = intBuffer.length;
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed) {
      return LocalConstructedValueBlock6.prototype.toBER.call(this, sizeOnly, writer);
    }
    if (sizeOnly) {
      return new ArrayBuffer(this.valueHexView.byteLength + 1);
    }
    if (!this.valueHexView.byteLength) {
      return EMPTY_BUFFER6;
    }
    const retView = new Uint8Array(this.valueHexView.length + 1);
    retView[0] = this.unusedBits;
    retView.set(this.valueHexView, 1);
    return retView.buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      unusedBits: this.unusedBits,
      isConstructed: this.isConstructed
    };
  }
}
LocalBitStringValueBlock6.NAME = "BitStringValueBlock";
var _a$q6;

class BitString11 extends BaseBlock6 {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters2 } = {}) {
    var _b, _c;
    (_b = parameters2.isConstructed) !== null && _b !== undefined || (parameters2.isConstructed = !!((_c = parameters2.value) === null || _c === undefined ? undefined : _c.length));
    super({
      idBlock: {
        isConstructed: parameters2.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters2.isIndefiniteForm
      },
      ...parameters2
    }, LocalBitStringValueBlock6);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 3;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed6.prototype.onAsciiEncoding.call(this);
    } else {
      const bits = [];
      const valueHex = this.valueBlock.valueHexView;
      for (const byte of valueHex) {
        bits.push(byte.toString(2).padStart(8, "0"));
      }
      const bitsStr = bits.join("");
      const name5 = this.constructor.NAME;
      const value = bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits);
      return `${name5} : ${value}`;
    }
  }
}
_a$q6 = BitString11;
(() => {
  typeStore6.BitString = _a$q6;
})();
BitString11.NAME = BIT_STRING_NAME6;
var _a$p6;
function viewAdd6(first, second) {
  const c = new Uint8Array([0]);
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  let firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value = 0;
  const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
  let counter = 0;
  for (let i = max;i >= 0; i--, counter++) {
    switch (true) {
      case counter < secondViewCopy.length:
        value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
        break;
      default:
        value = firstViewCopy[firstViewCopyLength - counter] + c[0];
    }
    c[0] = value / 10;
    switch (true) {
      case counter >= firstViewCopy.length:
        firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
        break;
      default:
        firstViewCopy[firstViewCopyLength - counter] = value % 10;
    }
  }
  if (c[0] > 0)
    firstViewCopy = utilConcatView(c, firstViewCopy);
  return firstViewCopy;
}
function power26(n) {
  if (n >= powers26.length) {
    for (let p = powers26.length;p <= n; p++) {
      const c = new Uint8Array([0]);
      let digits = powers26[p - 1].slice(0);
      for (let i = digits.length - 1;i >= 0; i--) {
        const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
        c[0] = newValue[0] / 10;
        digits[i] = newValue[0] % 10;
      }
      if (c[0] > 0)
        digits = utilConcatView(c, digits);
      powers26.push(digits);
    }
  }
  return powers26[n];
}
function viewSub6(first, second) {
  let b = 0;
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  const firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value;
  let counter = 0;
  for (let i = secondViewCopyLength;i >= 0; i--, counter++) {
    value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
    switch (true) {
      case value < 0:
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
        break;
      default:
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
    }
  }
  if (b > 0) {
    for (let i = firstViewCopyLength - secondViewCopyLength + 1;i >= 0; i--, counter++) {
      value = firstViewCopy[firstViewCopyLength - counter] - b;
      if (value < 0) {
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
      } else {
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
        break;
      }
    }
  }
  return firstViewCopy.slice();
}

class LocalIntegerValueBlock6 extends HexBlock6(ValueBlock6) {
  setValueHex() {
    if (this.valueHexView.length >= 4) {
      this.warnings.push("Too big Integer for decoding, hex only");
      this.isHexOnly = true;
      this._valueDec = 0;
    } else {
      this.isHexOnly = false;
      if (this.valueHexView.length > 0) {
        this._valueDec = utilDecodeTC.call(this);
      }
    }
  }
  constructor({ value, ...parameters2 } = {}) {
    super(parameters2);
    this._valueDec = 0;
    if (parameters2.valueHex) {
      this.setValueHex();
    }
    if (value !== undefined) {
      this.valueDec = value;
    }
  }
  set valueDec(v) {
    this._valueDec = v;
    this.isHexOnly = false;
    this.valueHexView = new Uint8Array(utilEncodeTC(v));
  }
  get valueDec() {
    return this._valueDec;
  }
  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
    if (offset === -1)
      return offset;
    const view = this.valueHexView;
    if (view[0] === 0 && (view[1] & 128) !== 0) {
      this.valueHexView = view.subarray(1);
    } else {
      if (expectedLength !== 0) {
        if (view.length < expectedLength) {
          if (expectedLength - view.length > 1)
            expectedLength = view.length + 1;
          this.valueHexView = view.subarray(expectedLength - view.length);
        }
      }
    }
    return offset;
  }
  toDER(sizeOnly = false) {
    const view = this.valueHexView;
    switch (true) {
      case (view[0] & 128) !== 0:
        {
          const updatedView = new Uint8Array(this.valueHexView.length + 1);
          updatedView[0] = 0;
          updatedView.set(view, 1);
          this.valueHexView = updatedView;
        }
        break;
      case (view[0] === 0 && (view[1] & 128) === 0):
        {
          this.valueHexView = this.valueHexView.subarray(1);
        }
        break;
    }
    return this.toBER(sizeOnly);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
    if (resultOffset === -1) {
      return resultOffset;
    }
    this.setValueHex();
    return resultOffset;
  }
  toBER(sizeOnly) {
    return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
  toString() {
    const firstBit = this.valueHexView.length * 8 - 1;
    let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
    let bitNumber = 0;
    let currentByte;
    const asn1View = this.valueHexView;
    let result = "";
    let flag = false;
    for (let byteNumber = asn1View.byteLength - 1;byteNumber >= 0; byteNumber--) {
      currentByte = asn1View[byteNumber];
      for (let i = 0;i < 8; i++) {
        if ((currentByte & 1) === 1) {
          switch (bitNumber) {
            case firstBit:
              digits = viewSub6(power26(bitNumber), digits);
              result = "-";
              break;
            default:
              digits = viewAdd6(digits, power26(bitNumber));
          }
        }
        bitNumber++;
        currentByte >>= 1;
      }
    }
    for (let i = 0;i < digits.length; i++) {
      if (digits[i])
        flag = true;
      if (flag)
        result += digitsString6.charAt(digits[i]);
    }
    if (flag === false)
      result += digitsString6.charAt(0);
    return result;
  }
}
_a$p6 = LocalIntegerValueBlock6;
LocalIntegerValueBlock6.NAME = "IntegerValueBlock";
(() => {
  Object.defineProperty(_a$p6.prototype, "valueHex", {
    set: function(v) {
      this.valueHexView = new Uint8Array(v);
      this.setValueHex();
    },
    get: function() {
      return this.valueHexView.slice().buffer;
    }
  });
})();
var _a$o6;

class Integer6 extends BaseBlock6 {
  constructor(parameters2 = {}) {
    super(parameters2, LocalIntegerValueBlock6);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 2;
  }
  toBigInt() {
    assertBigInt6();
    return BigInt(this.valueBlock.toString());
  }
  static fromBigInt(value) {
    assertBigInt6();
    const bigIntValue = BigInt(value);
    const writer = new ViewWriter6;
    const hex = bigIntValue.toString(16).replace(/^-/, "");
    const view = new Uint8Array(Convert.FromHex(hex));
    if (bigIntValue < 0) {
      const first = new Uint8Array(view.length + (view[0] & 128 ? 1 : 0));
      first[0] |= 128;
      const firstInt = BigInt(`0x${Convert.ToHex(first)}`);
      const secondInt = firstInt + bigIntValue;
      const second = BufferSourceConverter.toUint8Array(Convert.FromHex(secondInt.toString(16)));
      second[0] |= 128;
      writer.write(second);
    } else {
      if (view[0] & 128) {
        writer.write(new Uint8Array([0]));
      }
      writer.write(view);
    }
    const res = new _a$o6({ valueHex: writer.final() });
    return res;
  }
  convertToDER() {
    const integer = new _a$o6({ valueHex: this.valueBlock.valueHexView });
    integer.valueBlock.toDER();
    return integer;
  }
  convertFromDER() {
    return new _a$o6({
      valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
    });
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
  }
}
_a$o6 = Integer6;
(() => {
  typeStore6.Integer = _a$o6;
})();
Integer6.NAME = "INTEGER";
var _a$n6;

class Enumerated6 extends Integer6 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 10;
  }
}
_a$n6 = Enumerated6;
(() => {
  typeStore6.Enumerated = _a$n6;
})();
Enumerated6.NAME = "ENUMERATED";

class LocalSidValueBlock6 extends HexBlock6(ValueBlock6) {
  constructor({ valueDec = -1, isFirstSid = false, ...parameters2 } = {}) {
    super(parameters2);
    this.valueDec = valueDec;
    this.isFirstSid = isFirstSid;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams6(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0;i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0;i < this.blockLength; i++) {
      tempView[i] = this.valueHexView[i];
    }
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  set valueBigInt(value) {
    assertBigInt6();
    let bits = BigInt(value).toString(2);
    while (bits.length % 7) {
      bits = "0" + bits;
    }
    const bytes = new Uint8Array(bits.length / 7);
    for (let i = 0;i < bytes.length; i++) {
      bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 128 : 0);
    }
    this.fromBER(bytes.buffer, 0, bytes.length);
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0;i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER6;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0;i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      if (this.isFirstSid) {
        let sidValue = this.valueDec;
        if (this.valueDec <= 39)
          result = "0.";
        else {
          if (this.valueDec <= 79) {
            result = "1.";
            sidValue -= 40;
          } else {
            result = "2.";
            sidValue -= 80;
          }
        }
        result += sidValue.toString();
      } else
        result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec,
      isFirstSid: this.isFirstSid
    };
  }
}
LocalSidValueBlock6.NAME = "sidBlock";

class LocalObjectIdentifierValueBlock6 extends ValueBlock6 {
  constructor({ value = EMPTY_STRING6, ...parameters2 } = {}) {
    super(parameters2);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalSidValueBlock6;
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      if (this.value.length === 0)
        sidBlock.isFirstSid = true;
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly) {
    const retBuffers = [];
    for (let i = 0;i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER6;
      }
      retBuffers.push(valueBuf);
    }
    return concat6(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    let flag = false;
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      if (flag) {
        const sidBlock = this.value[0];
        let plus = 0;
        switch (sidBlock.valueDec) {
          case 0:
            break;
          case 1:
            plus = 40;
            break;
          case 2:
            plus = 80;
            break;
          default:
            this.value = [];
            return;
        }
        const parsedSID = parseInt(sid, 10);
        if (isNaN(parsedSID))
          return;
        sidBlock.valueDec = parsedSID + plus;
        flag = false;
      } else {
        const sidBlock = new LocalSidValueBlock6;
        if (sid > Number.MAX_SAFE_INTEGER) {
          assertBigInt6();
          const sidValue = BigInt(sid);
          sidBlock.valueBigInt = sidValue;
        } else {
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec))
            return;
        }
        if (!this.value.length) {
          sidBlock.isFirstSid = true;
          flag = true;
        }
        this.value.push(sidBlock);
      }
    } while (pos2 !== -1);
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0;i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        if (this.value[i].isFirstSid)
          result = `2.{${sidStr} - 80}`;
        else
          result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0;i < this.value.length; i++) {
      object.sidArray.push(this.value[i].toJSON());
    }
    return object;
  }
}
LocalObjectIdentifierValueBlock6.NAME = "ObjectIdentifierValueBlock";
var _a$m6;

class ObjectIdentifier6 extends BaseBlock6 {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  constructor(parameters2 = {}) {
    super(parameters2, LocalObjectIdentifierValueBlock6);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 6;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$m6 = ObjectIdentifier6;
(() => {
  typeStore6.ObjectIdentifier = _a$m6;
})();
ObjectIdentifier6.NAME = "OBJECT IDENTIFIER";

class LocalRelativeSidValueBlock6 extends HexBlock6(LocalBaseBlock6) {
  constructor({ valueDec = 0, ...parameters2 } = {}) {
    super(parameters2);
    this.valueDec = valueDec;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (inputLength === 0)
      return inputOffset;
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams6(this, inputView, inputOffset, inputLength))
      return -1;
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0;i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0;i < this.blockLength; i++)
      tempView[i] = this.valueHexView[i];
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0;i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER6;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0;i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView.buffer;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
}
LocalRelativeSidValueBlock6.NAME = "relativeSidBlock";

class LocalRelativeObjectIdentifierValueBlock6 extends ValueBlock6 {
  constructor({ value = EMPTY_STRING6, ...parameters2 } = {}) {
    super(parameters2);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalRelativeSidValueBlock6;
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly, _writer) {
    const retBuffers = [];
    for (let i = 0;i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER6;
      }
      retBuffers.push(valueBuf);
    }
    return concat6(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      const sidBlock = new LocalRelativeSidValueBlock6;
      sidBlock.valueDec = parseInt(sid, 10);
      if (isNaN(sidBlock.valueDec))
        return true;
      this.value.push(sidBlock);
    } while (pos2 !== -1);
    return true;
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0;i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0;i < this.value.length; i++)
      object.sidArray.push(this.value[i].toJSON());
    return object;
  }
}
LocalRelativeObjectIdentifierValueBlock6.NAME = "RelativeObjectIdentifierValueBlock";
var _a$l6;

class RelativeObjectIdentifier6 extends BaseBlock6 {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  constructor(parameters2 = {}) {
    super(parameters2, LocalRelativeObjectIdentifierValueBlock6);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 13;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$l6 = RelativeObjectIdentifier6;
(() => {
  typeStore6.RelativeObjectIdentifier = _a$l6;
})();
RelativeObjectIdentifier6.NAME = "RelativeObjectIdentifier";
var _a$k6;

class Sequence6 extends Constructed6 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 16;
  }
}
_a$k6 = Sequence6;
(() => {
  typeStore6.Sequence = _a$k6;
})();
Sequence6.NAME = "SEQUENCE";
var _a$j6;

class Set7 extends Constructed6 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 17;
  }
}
_a$j6 = Set7;
(() => {
  typeStore6.Set = _a$j6;
})();
Set7.NAME = "SET";

class LocalStringValueBlock6 extends HexBlock6(ValueBlock6) {
  constructor({ ...parameters2 } = {}) {
    super(parameters2);
    this.isHexOnly = true;
    this.value = EMPTY_STRING6;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalStringValueBlock6.NAME = "StringValueBlock";

class LocalSimpleStringValueBlock6 extends LocalStringValueBlock6 {
}
LocalSimpleStringValueBlock6.NAME = "SimpleStringValueBlock";

class LocalSimpleStringBlock6 extends BaseStringBlock6 {
  constructor({ ...parameters2 } = {}) {
    super(parameters2, LocalSimpleStringValueBlock6);
  }
  fromBuffer(inputBuffer) {
    this.valueBlock.value = String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer));
  }
  fromString(inputString) {
    const strLen = inputString.length;
    const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
    for (let i = 0;i < strLen; i++)
      view[i] = inputString.charCodeAt(i);
    this.valueBlock.value = inputString;
  }
}
LocalSimpleStringBlock6.NAME = "SIMPLE STRING";

class LocalUtf8StringValueBlock6 extends LocalSimpleStringBlock6 {
  fromBuffer(inputBuffer) {
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
    try {
      this.valueBlock.value = Convert.ToUtf8String(inputBuffer);
    } catch (ex) {
      this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
      this.valueBlock.value = Convert.ToBinary(inputBuffer);
    }
  }
  fromString(inputString) {
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf8String(inputString));
    this.valueBlock.value = inputString;
  }
}
LocalUtf8StringValueBlock6.NAME = "Utf8StringValueBlock";
var _a$i6;

class Utf8String6 extends LocalUtf8StringValueBlock6 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 12;
  }
}
_a$i6 = Utf8String6;
(() => {
  typeStore6.Utf8String = _a$i6;
})();
Utf8String6.NAME = "UTF8String";

class LocalBmpStringValueBlock6 extends LocalSimpleStringBlock6 {
  fromBuffer(inputBuffer) {
    this.valueBlock.value = Convert.ToUtf16String(inputBuffer);
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
  }
  fromString(inputString) {
    this.valueBlock.value = inputString;
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf16String(inputString));
  }
}
LocalBmpStringValueBlock6.NAME = "BmpStringValueBlock";
var _a$h6;

class BmpString6 extends LocalBmpStringValueBlock6 {
  constructor({ ...parameters2 } = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 30;
  }
}
_a$h6 = BmpString6;
(() => {
  typeStore6.BmpString = _a$h6;
})();
BmpString6.NAME = "BMPString";

class LocalUniversalStringValueBlock6 extends LocalSimpleStringBlock6 {
  fromBuffer(inputBuffer) {
    const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
    const valueView = new Uint8Array(copyBuffer);
    for (let i = 0;i < valueView.length; i += 4) {
      valueView[i] = valueView[i + 3];
      valueView[i + 1] = valueView[i + 2];
      valueView[i + 2] = 0;
      valueView[i + 3] = 0;
    }
    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
  }
  fromString(inputString) {
    const strLength = inputString.length;
    const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
    for (let i = 0;i < strLength; i++) {
      const codeBuf = utilToBase(inputString.charCodeAt(i), 8);
      const codeView = new Uint8Array(codeBuf);
      if (codeView.length > 4)
        continue;
      const dif = 4 - codeView.length;
      for (let j = codeView.length - 1;j >= 0; j--)
        valueHexView[i * 4 + j + dif] = codeView[j];
    }
    this.valueBlock.value = inputString;
  }
}
LocalUniversalStringValueBlock6.NAME = "UniversalStringValueBlock";
var _a$g6;

class UniversalString6 extends LocalUniversalStringValueBlock6 {
  constructor({ ...parameters2 } = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 28;
  }
}
_a$g6 = UniversalString6;
(() => {
  typeStore6.UniversalString = _a$g6;
})();
UniversalString6.NAME = "UniversalString";
var _a$f6;

class NumericString6 extends LocalSimpleStringBlock6 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 18;
  }
}
_a$f6 = NumericString6;
(() => {
  typeStore6.NumericString = _a$f6;
})();
NumericString6.NAME = "NumericString";
var _a$e6;

class PrintableString6 extends LocalSimpleStringBlock6 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 19;
  }
}
_a$e6 = PrintableString6;
(() => {
  typeStore6.PrintableString = _a$e6;
})();
PrintableString6.NAME = "PrintableString";
var _a$d6;

class TeletexString6 extends LocalSimpleStringBlock6 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 20;
  }
}
_a$d6 = TeletexString6;
(() => {
  typeStore6.TeletexString = _a$d6;
})();
TeletexString6.NAME = "TeletexString";
var _a$c6;

class VideotexString6 extends LocalSimpleStringBlock6 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 21;
  }
}
_a$c6 = VideotexString6;
(() => {
  typeStore6.VideotexString = _a$c6;
})();
VideotexString6.NAME = "VideotexString";
var _a$b6;

class IA5String6 extends LocalSimpleStringBlock6 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 22;
  }
}
_a$b6 = IA5String6;
(() => {
  typeStore6.IA5String = _a$b6;
})();
IA5String6.NAME = "IA5String";
var _a$a6;

class GraphicString6 extends LocalSimpleStringBlock6 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 25;
  }
}
_a$a6 = GraphicString6;
(() => {
  typeStore6.GraphicString = _a$a6;
})();
GraphicString6.NAME = "GraphicString";
var _a$96;

class VisibleString6 extends LocalSimpleStringBlock6 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 26;
  }
}
_a$96 = VisibleString6;
(() => {
  typeStore6.VisibleString = _a$96;
})();
VisibleString6.NAME = "VisibleString";
var _a$86;

class GeneralString6 extends LocalSimpleStringBlock6 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 27;
  }
}
_a$86 = GeneralString6;
(() => {
  typeStore6.GeneralString = _a$86;
})();
GeneralString6.NAME = "GeneralString";
var _a$76;

class CharacterString6 extends LocalSimpleStringBlock6 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 29;
  }
}
_a$76 = CharacterString6;
(() => {
  typeStore6.CharacterString = _a$76;
})();
CharacterString6.NAME = "CharacterString";
var _a$66;

class UTCTime6 extends VisibleString6 {
  constructor({ value, valueDate, ...parameters2 } = {}) {
    super(parameters2);
    this.year = 0;
    this.month = 0;
    this.day = 0;
    this.hour = 0;
    this.minute = 0;
    this.second = 0;
    if (value) {
      this.fromString(value);
      this.valueBlock.valueHexView = new Uint8Array(value.length);
      for (let i = 0;i < value.length; i++)
        this.valueBlock.valueHexView[i] = value.charCodeAt(i);
    }
    if (valueDate) {
      this.fromDate(valueDate);
      this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
    }
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 23;
  }
  fromBuffer(inputBuffer) {
    this.fromString(String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer)));
  }
  toBuffer() {
    const str = this.toString();
    const buffer = new ArrayBuffer(str.length);
    const view = new Uint8Array(buffer);
    for (let i = 0;i < str.length; i++)
      view[i] = str.charCodeAt(i);
    return buffer;
  }
  fromDate(inputDate) {
    this.year = inputDate.getUTCFullYear();
    this.month = inputDate.getUTCMonth() + 1;
    this.day = inputDate.getUTCDate();
    this.hour = inputDate.getUTCHours();
    this.minute = inputDate.getUTCMinutes();
    this.second = inputDate.getUTCSeconds();
  }
  toDate() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
  }
  fromString(inputString) {
    const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
    const parserArray = parser.exec(inputString);
    if (parserArray === null) {
      this.error = "Wrong input string for conversion";
      return;
    }
    const year = parseInt(parserArray[1], 10);
    if (year >= 50)
      this.year = 1900 + year;
    else
      this.year = 2000 + year;
    this.month = parseInt(parserArray[2], 10);
    this.day = parseInt(parserArray[3], 10);
    this.hour = parseInt(parserArray[4], 10);
    this.minute = parseInt(parserArray[5], 10);
    this.second = parseInt(parserArray[6], 10);
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = new Array(7);
      outputArray[0] = padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);
      outputArray[1] = padNumber(this.month, 2);
      outputArray[2] = padNumber(this.day, 2);
      outputArray[3] = padNumber(this.hour, 2);
      outputArray[4] = padNumber(this.minute, 2);
      outputArray[5] = padNumber(this.second, 2);
      outputArray[6] = "Z";
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second
    };
  }
}
_a$66 = UTCTime6;
(() => {
  typeStore6.UTCTime = _a$66;
})();
UTCTime6.NAME = "UTCTime";
var _a$56;

class GeneralizedTime6 extends UTCTime6 {
  constructor(parameters2 = {}) {
    var _b;
    super(parameters2);
    (_b = this.millisecond) !== null && _b !== undefined || (this.millisecond = 0);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 24;
  }
  fromDate(inputDate) {
    super.fromDate(inputDate);
    this.millisecond = inputDate.getUTCMilliseconds();
  }
  toDate() {
    const utcDate = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond);
    return new Date(utcDate);
  }
  fromString(inputString) {
    let isUTC = false;
    let timeString = "";
    let dateTimeString = "";
    let fractionPart = 0;
    let parser;
    let hourDifference = 0;
    let minuteDifference = 0;
    if (inputString[inputString.length - 1] === "Z") {
      timeString = inputString.substring(0, inputString.length - 1);
      isUTC = true;
    } else {
      const number = new Number(inputString[inputString.length - 1]);
      if (isNaN(number.valueOf()))
        throw new Error("Wrong input string for conversion");
      timeString = inputString;
    }
    if (isUTC) {
      if (timeString.indexOf("+") !== -1)
        throw new Error("Wrong input string for conversion");
      if (timeString.indexOf("-") !== -1)
        throw new Error("Wrong input string for conversion");
    } else {
      let multiplier = 1;
      let differencePosition = timeString.indexOf("+");
      let differenceString = "";
      if (differencePosition === -1) {
        differencePosition = timeString.indexOf("-");
        multiplier = -1;
      }
      if (differencePosition !== -1) {
        differenceString = timeString.substring(differencePosition + 1);
        timeString = timeString.substring(0, differencePosition);
        if (differenceString.length !== 2 && differenceString.length !== 4)
          throw new Error("Wrong input string for conversion");
        let number = parseInt(differenceString.substring(0, 2), 10);
        if (isNaN(number.valueOf()))
          throw new Error("Wrong input string for conversion");
        hourDifference = multiplier * number;
        if (differenceString.length === 4) {
          number = parseInt(differenceString.substring(2, 4), 10);
          if (isNaN(number.valueOf()))
            throw new Error("Wrong input string for conversion");
          minuteDifference = multiplier * number;
        }
      }
    }
    let fractionPointPosition = timeString.indexOf(".");
    if (fractionPointPosition === -1)
      fractionPointPosition = timeString.indexOf(",");
    if (fractionPointPosition !== -1) {
      const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
      if (isNaN(fractionPartCheck.valueOf()))
        throw new Error("Wrong input string for conversion");
      fractionPart = fractionPartCheck.valueOf();
      dateTimeString = timeString.substring(0, fractionPointPosition);
    } else
      dateTimeString = timeString;
    switch (true) {
      case dateTimeString.length === 8:
        parser = /(\d{4})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1)
          throw new Error("Wrong input string for conversion");
        break;
      case dateTimeString.length === 10:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.minute = Math.floor(fractionResult);
          fractionResult = 60 * (fractionResult - this.minute);
          this.second = Math.floor(fractionResult);
          fractionResult = 1000 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 12:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.second = Math.floor(fractionResult);
          fractionResult = 1000 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 14:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          const fractionResult = 1000 * fractionPart;
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      default:
        throw new Error("Wrong input string for conversion");
    }
    const parserArray = parser.exec(dateTimeString);
    if (parserArray === null)
      throw new Error("Wrong input string for conversion");
    for (let j = 1;j < parserArray.length; j++) {
      switch (j) {
        case 1:
          this.year = parseInt(parserArray[j], 10);
          break;
        case 2:
          this.month = parseInt(parserArray[j], 10);
          break;
        case 3:
          this.day = parseInt(parserArray[j], 10);
          break;
        case 4:
          this.hour = parseInt(parserArray[j], 10) + hourDifference;
          break;
        case 5:
          this.minute = parseInt(parserArray[j], 10) + minuteDifference;
          break;
        case 6:
          this.second = parseInt(parserArray[j], 10);
          break;
        default:
          throw new Error("Wrong input string for conversion");
      }
    }
    if (isUTC === false) {
      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
      this.year = tempDate.getUTCFullYear();
      this.month = tempDate.getUTCMonth();
      this.day = tempDate.getUTCDay();
      this.hour = tempDate.getUTCHours();
      this.minute = tempDate.getUTCMinutes();
      this.second = tempDate.getUTCSeconds();
      this.millisecond = tempDate.getUTCMilliseconds();
    }
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = [];
      outputArray.push(padNumber(this.year, 4));
      outputArray.push(padNumber(this.month, 2));
      outputArray.push(padNumber(this.day, 2));
      outputArray.push(padNumber(this.hour, 2));
      outputArray.push(padNumber(this.minute, 2));
      outputArray.push(padNumber(this.second, 2));
      if (this.millisecond !== 0) {
        outputArray.push(".");
        outputArray.push(padNumber(this.millisecond, 3));
      }
      outputArray.push("Z");
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  toJSON() {
    return {
      ...super.toJSON(),
      millisecond: this.millisecond
    };
  }
}
_a$56 = GeneralizedTime6;
(() => {
  typeStore6.GeneralizedTime = _a$56;
})();
GeneralizedTime6.NAME = "GeneralizedTime";
var _a$46;

class DATE6 extends Utf8String6 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 31;
  }
}
_a$46 = DATE6;
(() => {
  typeStore6.DATE = _a$46;
})();
DATE6.NAME = "DATE";
var _a$36;

class TimeOfDay6 extends Utf8String6 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 32;
  }
}
_a$36 = TimeOfDay6;
(() => {
  typeStore6.TimeOfDay = _a$36;
})();
TimeOfDay6.NAME = "TimeOfDay";
var _a$26;

class DateTime6 extends Utf8String6 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 33;
  }
}
_a$26 = DateTime6;
(() => {
  typeStore6.DateTime = _a$26;
})();
DateTime6.NAME = "DateTime";
var _a$16;

class Duration6 extends Utf8String6 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 34;
  }
}
_a$16 = Duration6;
(() => {
  typeStore6.Duration = _a$16;
})();
Duration6.NAME = "Duration";
var _a6;

class TIME6 extends Utf8String6 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 14;
  }
}
_a6 = TIME6;
(() => {
  typeStore6.TIME = _a6;
})();
TIME6.NAME = "TIME";

class Any6 {
  constructor({ name: name5 = EMPTY_STRING6, optional = false } = {}) {
    this.name = name5;
    this.optional = optional;
  }
}

class Choice6 extends Any6 {
  constructor({ value = [], ...parameters2 } = {}) {
    super(parameters2);
    this.value = value;
  }
}

class Repeated6 extends Any6 {
  constructor({ value = new Any6, local = false, ...parameters2 } = {}) {
    super(parameters2);
    this.value = value;
    this.local = local;
  }
}

class RawData6 {
  get data() {
    return this.dataView.slice().buffer;
  }
  set data(value) {
    this.dataView = BufferSourceConverter.toUint8Array(value);
  }
  constructor({ data = EMPTY_VIEW6 } = {}) {
    this.dataView = BufferSourceConverter.toUint8Array(data);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const endLength = inputOffset + inputLength;
    this.dataView = BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
    return endLength;
  }
  toBER(_sizeOnly) {
    return this.dataView.slice().buffer;
  }
}
function compareSchema6(root, inputData, inputSchema) {
  if (inputSchema instanceof Choice6) {
    for (const element of inputSchema.value) {
      const result = compareSchema6(root, inputData, element);
      if (result.verified) {
        return {
          verified: true,
          result: root
        };
      }
    }
    {
      const _result = {
        verified: false,
        result: { error: "Wrong values for Choice type" }
      };
      if (inputSchema.hasOwnProperty(NAME6))
        _result.name = inputSchema.name;
      return _result;
    }
  }
  if (inputSchema instanceof Any6) {
    if (inputSchema.hasOwnProperty(NAME6))
      root[inputSchema.name] = inputData;
    return {
      verified: true,
      result: root
    };
  }
  if (root instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong root object" }
    };
  }
  if (inputData instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 data" }
    };
  }
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (ID_BLOCK6 in inputSchema === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (FROM_BER6 in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (TO_BER6 in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  const encodedId = inputSchema.idBlock.toBER(false);
  if (encodedId.byteLength === 0) {
    return {
      verified: false,
      result: { error: "Error encoding idBlock for ASN.1 schema" }
    };
  }
  const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
  if (decodedOffset === -1) {
    return {
      verified: false,
      result: { error: "Error decoding idBlock for ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS6) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER6) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED6) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
    return {
      verified: false,
      result: root
    };
  }
  if (!(IS_HEX_ONLY6 in inputSchema.idBlock)) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.isHexOnly) {
    if (VALUE_HEX_VIEW6 in inputSchema.idBlock === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    const schemaView = inputSchema.idBlock.valueHexView;
    const asn1View = inputData.idBlock.valueHexView;
    if (schemaView.length !== asn1View.length) {
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0;i < schemaView.length; i++) {
      if (schemaView[i] !== asn1View[1]) {
        return {
          verified: false,
          result: root
        };
      }
    }
  }
  if (inputSchema.name) {
    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING6);
    if (inputSchema.name)
      root[inputSchema.name] = inputData;
  }
  if (inputSchema instanceof typeStore6.Constructed) {
    let admission = 0;
    let result = {
      verified: false,
      result: { error: "Unknown error" }
    };
    let maxLength = inputSchema.valueBlock.value.length;
    if (maxLength > 0) {
      if (inputSchema.valueBlock.value[0] instanceof Repeated6) {
        maxLength = inputData.valueBlock.value.length;
      }
    }
    if (maxLength === 0) {
      return {
        verified: true,
        result: root
      };
    }
    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
      let _optional = true;
      for (let i = 0;i < inputSchema.valueBlock.value.length; i++)
        _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);
      if (_optional) {
        return {
          verified: true,
          result: root
        };
      }
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING6);
        if (inputSchema.name)
          delete root[inputSchema.name];
      }
      root.error = "Inconsistent object length";
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0;i < maxLength; i++) {
      if (i - admission >= inputData.valueBlock.value.length) {
        if (inputSchema.valueBlock.value[i].optional === false) {
          const _result = {
            verified: false,
            result: root
          };
          root.error = "Inconsistent length between ASN.1 data and schema";
          if (inputSchema.name) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING6);
            if (inputSchema.name) {
              delete root[inputSchema.name];
              _result.name = inputSchema.name;
            }
          }
          return _result;
        }
      } else {
        if (inputSchema.valueBlock.value[0] instanceof Repeated6) {
          result = compareSchema6(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[0].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING6);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
          if (NAME6 in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
            let arrayRoot = {};
            if (LOCAL6 in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local)
              arrayRoot = inputData;
            else
              arrayRoot = root;
            if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
              arrayRoot[inputSchema.valueBlock.value[0].name] = [];
            arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
          }
        } else {
          result = compareSchema6(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[i].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING6);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
        }
      }
    }
    if (result.verified === false) {
      const _result = {
        verified: false,
        result: root
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING6);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return {
      verified: true,
      result: root
    };
  }
  if (inputSchema.primitiveSchema && VALUE_HEX_VIEW6 in inputData.valueBlock) {
    const asn1 = localFromBER6(inputData.valueBlock.valueHexView);
    if (asn1.offset === -1) {
      const _result = {
        verified: false,
        result: asn1.result
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING6);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return compareSchema6(root, asn1.result, inputSchema.primitiveSchema);
  }
  return {
    verified: true,
    result: root
  };
}
function verifySchema6(inputBuffer, inputSchema) {
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema type" }
    };
  }
  const asn1 = localFromBER6(BufferSourceConverter.toUint8Array(inputBuffer));
  if (asn1.offset === -1) {
    return {
      verified: false,
      result: asn1.result
    };
  }
  return compareSchema6(asn1.result, asn1.result, inputSchema);
}

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-schema/build/es2015/enums.js
var AsnTypeTypes6;
(function(AsnTypeTypes7) {
  AsnTypeTypes7[AsnTypeTypes7["Sequence"] = 0] = "Sequence";
  AsnTypeTypes7[AsnTypeTypes7["Set"] = 1] = "Set";
  AsnTypeTypes7[AsnTypeTypes7["Choice"] = 2] = "Choice";
})(AsnTypeTypes6 || (AsnTypeTypes6 = {}));
var AsnPropTypes6;
(function(AsnPropTypes7) {
  AsnPropTypes7[AsnPropTypes7["Any"] = 1] = "Any";
  AsnPropTypes7[AsnPropTypes7["Boolean"] = 2] = "Boolean";
  AsnPropTypes7[AsnPropTypes7["OctetString"] = 3] = "OctetString";
  AsnPropTypes7[AsnPropTypes7["BitString"] = 4] = "BitString";
  AsnPropTypes7[AsnPropTypes7["Integer"] = 5] = "Integer";
  AsnPropTypes7[AsnPropTypes7["Enumerated"] = 6] = "Enumerated";
  AsnPropTypes7[AsnPropTypes7["ObjectIdentifier"] = 7] = "ObjectIdentifier";
  AsnPropTypes7[AsnPropTypes7["Utf8String"] = 8] = "Utf8String";
  AsnPropTypes7[AsnPropTypes7["BmpString"] = 9] = "BmpString";
  AsnPropTypes7[AsnPropTypes7["UniversalString"] = 10] = "UniversalString";
  AsnPropTypes7[AsnPropTypes7["NumericString"] = 11] = "NumericString";
  AsnPropTypes7[AsnPropTypes7["PrintableString"] = 12] = "PrintableString";
  AsnPropTypes7[AsnPropTypes7["TeletexString"] = 13] = "TeletexString";
  AsnPropTypes7[AsnPropTypes7["VideotexString"] = 14] = "VideotexString";
  AsnPropTypes7[AsnPropTypes7["IA5String"] = 15] = "IA5String";
  AsnPropTypes7[AsnPropTypes7["GraphicString"] = 16] = "GraphicString";
  AsnPropTypes7[AsnPropTypes7["VisibleString"] = 17] = "VisibleString";
  AsnPropTypes7[AsnPropTypes7["GeneralString"] = 18] = "GeneralString";
  AsnPropTypes7[AsnPropTypes7["CharacterString"] = 19] = "CharacterString";
  AsnPropTypes7[AsnPropTypes7["UTCTime"] = 20] = "UTCTime";
  AsnPropTypes7[AsnPropTypes7["GeneralizedTime"] = 21] = "GeneralizedTime";
  AsnPropTypes7[AsnPropTypes7["DATE"] = 22] = "DATE";
  AsnPropTypes7[AsnPropTypes7["TimeOfDay"] = 23] = "TimeOfDay";
  AsnPropTypes7[AsnPropTypes7["DateTime"] = 24] = "DateTime";
  AsnPropTypes7[AsnPropTypes7["Duration"] = 25] = "Duration";
  AsnPropTypes7[AsnPropTypes7["TIME"] = 26] = "TIME";
  AsnPropTypes7[AsnPropTypes7["Null"] = 27] = "Null";
})(AsnPropTypes6 || (AsnPropTypes6 = {}));

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-schema/build/es2015/types/bit_string.js
class BitString12 {
  constructor(params, unusedBits = 0) {
    this.unusedBits = 0;
    this.value = new ArrayBuffer(0);
    if (params) {
      if (typeof params === "number") {
        this.fromNumber(params);
      } else if (BufferSourceConverter.isBufferSource(params)) {
        this.unusedBits = unusedBits;
        this.value = BufferSourceConverter.toArrayBuffer(params);
      } else {
        throw TypeError("Unsupported type of 'params' argument for BitString");
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof BitString11)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 BitString");
    }
    this.unusedBits = asn.valueBlock.unusedBits;
    this.value = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new BitString11({ unusedBits: this.unusedBits, valueHex: this.value });
  }
  toSchema(name5) {
    return new BitString11({ name: name5 });
  }
  toNumber() {
    let res = "";
    const uintArray = new Uint8Array(this.value);
    for (const octet of uintArray) {
      res += octet.toString(2).padStart(8, "0");
    }
    res = res.split("").reverse().join("");
    if (this.unusedBits) {
      res = res.slice(this.unusedBits).padStart(this.unusedBits, "0");
    }
    return parseInt(res, 2);
  }
  fromNumber(value) {
    let bits = value.toString(2);
    const octetSize = bits.length + 7 >> 3;
    this.unusedBits = (octetSize << 3) - bits.length;
    const octets = new Uint8Array(octetSize);
    bits = bits.padStart(octetSize << 3, "0").split("").reverse().join("");
    let index = 0;
    while (index < octetSize) {
      octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);
      index++;
    }
    this.value = octets.buffer;
  }
}
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-schema/build/es2015/types/octet_string.js
class OctetString12 {
  get byteLength() {
    return this.buffer.byteLength;
  }
  get byteOffset() {
    return 0;
  }
  constructor(param) {
    if (typeof param === "number") {
      this.buffer = new ArrayBuffer(param);
    } else {
      if (BufferSourceConverter.isBufferSource(param)) {
        this.buffer = BufferSourceConverter.toArrayBuffer(param);
      } else if (Array.isArray(param)) {
        this.buffer = new Uint8Array(param);
      } else {
        this.buffer = new ArrayBuffer(0);
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof OctetString11)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString");
    }
    this.buffer = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new OctetString11({ valueHex: this.buffer });
  }
  toSchema(name5) {
    return new OctetString11({ name: name5 });
  }
}
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-schema/build/es2015/converters.js
var AsnAnyConverter6 = {
  fromASN: (value) => value instanceof Null6 ? null : value.valueBeforeDecodeView,
  toASN: (value) => {
    if (value === null) {
      return new Null6;
    }
    const schema = fromBER6(value);
    if (schema.result.error) {
      throw new Error(schema.result.error);
    }
    return schema.result;
  }
};
var AsnIntegerConverter6 = {
  fromASN: (value) => value.valueBlock.valueHexView.byteLength >= 4 ? value.valueBlock.toString() : value.valueBlock.valueDec,
  toASN: (value) => new Integer6({ value: +value })
};
var AsnEnumeratedConverter6 = {
  fromASN: (value) => value.valueBlock.valueDec,
  toASN: (value) => new Enumerated6({ value })
};
var AsnIntegerArrayBufferConverter6 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new Integer6({ valueHex: value })
};
var AsnBitStringConverter6 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new BitString11({ valueHex: value })
};
var AsnObjectIdentifierConverter6 = {
  fromASN: (value) => value.valueBlock.toString(),
  toASN: (value) => new ObjectIdentifier6({ value })
};
var AsnBooleanConverter6 = {
  fromASN: (value) => value.valueBlock.value,
  toASN: (value) => new Boolean7({ value })
};
var AsnOctetStringConverter6 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new OctetString11({ valueHex: value })
};
function createStringConverter6(Asn1Type) {
  return {
    fromASN: (value) => value.valueBlock.value,
    toASN: (value) => new Asn1Type({ value })
  };
}
var AsnUtf8StringConverter6 = createStringConverter6(Utf8String6);
var AsnBmpStringConverter6 = createStringConverter6(BmpString6);
var AsnUniversalStringConverter6 = createStringConverter6(UniversalString6);
var AsnNumericStringConverter6 = createStringConverter6(NumericString6);
var AsnPrintableStringConverter6 = createStringConverter6(PrintableString6);
var AsnTeletexStringConverter6 = createStringConverter6(TeletexString6);
var AsnVideotexStringConverter6 = createStringConverter6(VideotexString6);
var AsnIA5StringConverter6 = createStringConverter6(IA5String6);
var AsnGraphicStringConverter6 = createStringConverter6(GraphicString6);
var AsnVisibleStringConverter6 = createStringConverter6(VisibleString6);
var AsnGeneralStringConverter6 = createStringConverter6(GeneralString6);
var AsnCharacterStringConverter6 = createStringConverter6(CharacterString6);
var AsnUTCTimeConverter6 = {
  fromASN: (value) => value.toDate(),
  toASN: (value) => new UTCTime6({ valueDate: value })
};
var AsnGeneralizedTimeConverter6 = {
  fromASN: (value) => value.toDate(),
  toASN: (value) => new GeneralizedTime6({ valueDate: value })
};
var AsnNullConverter6 = {
  fromASN: () => null,
  toASN: () => {
    return new Null6;
  }
};
function defaultConverter6(type) {
  switch (type) {
    case AsnPropTypes6.Any:
      return AsnAnyConverter6;
    case AsnPropTypes6.BitString:
      return AsnBitStringConverter6;
    case AsnPropTypes6.BmpString:
      return AsnBmpStringConverter6;
    case AsnPropTypes6.Boolean:
      return AsnBooleanConverter6;
    case AsnPropTypes6.CharacterString:
      return AsnCharacterStringConverter6;
    case AsnPropTypes6.Enumerated:
      return AsnEnumeratedConverter6;
    case AsnPropTypes6.GeneralString:
      return AsnGeneralStringConverter6;
    case AsnPropTypes6.GeneralizedTime:
      return AsnGeneralizedTimeConverter6;
    case AsnPropTypes6.GraphicString:
      return AsnGraphicStringConverter6;
    case AsnPropTypes6.IA5String:
      return AsnIA5StringConverter6;
    case AsnPropTypes6.Integer:
      return AsnIntegerConverter6;
    case AsnPropTypes6.Null:
      return AsnNullConverter6;
    case AsnPropTypes6.NumericString:
      return AsnNumericStringConverter6;
    case AsnPropTypes6.ObjectIdentifier:
      return AsnObjectIdentifierConverter6;
    case AsnPropTypes6.OctetString:
      return AsnOctetStringConverter6;
    case AsnPropTypes6.PrintableString:
      return AsnPrintableStringConverter6;
    case AsnPropTypes6.TeletexString:
      return AsnTeletexStringConverter6;
    case AsnPropTypes6.UTCTime:
      return AsnUTCTimeConverter6;
    case AsnPropTypes6.UniversalString:
      return AsnUniversalStringConverter6;
    case AsnPropTypes6.Utf8String:
      return AsnUtf8StringConverter6;
    case AsnPropTypes6.VideotexString:
      return AsnVideotexStringConverter6;
    case AsnPropTypes6.VisibleString:
      return AsnVisibleStringConverter6;
    default:
      return null;
  }
}
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-schema/build/es2015/helper.js
function isConvertible6(target2) {
  if (typeof target2 === "function" && target2.prototype) {
    if (target2.prototype.toASN && target2.prototype.fromASN) {
      return true;
    } else {
      return isConvertible6(target2.prototype);
    }
  } else {
    return !!(target2 && typeof target2 === "object" && ("toASN" in target2) && ("fromASN" in target2));
  }
}
function isTypeOfArray6(target2) {
  var _a7;
  if (target2) {
    const proto = Object.getPrototypeOf(target2);
    if (((_a7 = proto === null || proto === undefined ? undefined : proto.prototype) === null || _a7 === undefined ? undefined : _a7.constructor) === Array) {
      return true;
    }
    return isTypeOfArray6(proto);
  }
  return false;
}
function isArrayEqual6(bytes1, bytes2) {
  if (!(bytes1 && bytes2)) {
    return false;
  }
  if (bytes1.byteLength !== bytes2.byteLength) {
    return false;
  }
  const b1 = new Uint8Array(bytes1);
  const b2 = new Uint8Array(bytes2);
  for (let i = 0;i < bytes1.byteLength; i++) {
    if (b1[i] !== b2[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-schema/build/es2015/schema.js
class AsnSchemaStorage6 {
  constructor() {
    this.items = new WeakMap;
  }
  has(target2) {
    return this.items.has(target2);
  }
  get(target2, checkSchema = false) {
    const schema = this.items.get(target2);
    if (!schema) {
      throw new Error(`Cannot get schema for '${target2.prototype.constructor.name}' target`);
    }
    if (checkSchema && !schema.schema) {
      throw new Error(`Schema '${target2.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);
    }
    return schema;
  }
  cache(target2) {
    const schema = this.get(target2);
    if (!schema.schema) {
      schema.schema = this.create(target2, true);
    }
  }
  createDefault(target2) {
    const schema = { type: AsnTypeTypes6.Sequence, items: {} };
    const parentSchema = this.findParentSchema(target2);
    if (parentSchema) {
      Object.assign(schema, parentSchema);
      schema.items = Object.assign({}, schema.items, parentSchema.items);
    }
    return schema;
  }
  create(target2, useNames) {
    const schema = this.items.get(target2) || this.createDefault(target2);
    const asn1Value = [];
    for (const key in schema.items) {
      const item = schema.items[key];
      const name5 = useNames ? key : "";
      let asn1Item;
      if (typeof item.type === "number") {
        const Asn1TypeName = AsnPropTypes6[item.type];
        const Asn1Type = exports_index_es7[Asn1TypeName];
        if (!Asn1Type) {
          throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
        }
        asn1Item = new Asn1Type({ name: name5 });
      } else if (isConvertible6(item.type)) {
        const instance2 = new item.type;
        asn1Item = instance2.toSchema(name5);
      } else if (item.optional) {
        const itemSchema = this.get(item.type);
        if (itemSchema.type === AsnTypeTypes6.Choice) {
          asn1Item = new Any6({ name: name5 });
        } else {
          asn1Item = this.create(item.type, false);
          asn1Item.name = name5;
        }
      } else {
        asn1Item = new Any6({ name: name5 });
      }
      const optional = !!item.optional || item.defaultValue !== undefined;
      if (item.repeated) {
        asn1Item.name = "";
        const Container = item.repeated === "set" ? Set7 : Sequence6;
        asn1Item = new Container({
          name: "",
          value: [new Repeated6({ name: name5, value: asn1Item })]
        });
      }
      if (item.context !== null && item.context !== undefined) {
        if (item.implicit) {
          if (typeof item.type === "number" || isConvertible6(item.type)) {
            const Container = item.repeated ? Constructed6 : Primitive6;
            asn1Value.push(new Container({ name: name5, optional, idBlock: { tagClass: 3, tagNumber: item.context } }));
          } else {
            this.cache(item.type);
            const isRepeated = !!item.repeated;
            let value = !isRepeated ? this.get(item.type, true).schema : asn1Item;
            value = "valueBlock" in value ? value.valueBlock.value : value.value;
            asn1Value.push(new Constructed6({
              name: !isRepeated ? name5 : "",
              optional,
              idBlock: { tagClass: 3, tagNumber: item.context },
              value
            }));
          }
        } else {
          asn1Value.push(new Constructed6({
            optional,
            idBlock: { tagClass: 3, tagNumber: item.context },
            value: [asn1Item]
          }));
        }
      } else {
        asn1Item.optional = optional;
        asn1Value.push(asn1Item);
      }
    }
    switch (schema.type) {
      case AsnTypeTypes6.Sequence:
        return new Sequence6({ value: asn1Value, name: "" });
      case AsnTypeTypes6.Set:
        return new Set7({ value: asn1Value, name: "" });
      case AsnTypeTypes6.Choice:
        return new Choice6({ value: asn1Value, name: "" });
      default:
        throw new Error(`Unsupported ASN1 type in use`);
    }
  }
  set(target2, schema) {
    this.items.set(target2, schema);
    return this;
  }
  findParentSchema(target2) {
    const parent = Object.getPrototypeOf(target2);
    if (parent) {
      const schema = this.items.get(parent);
      return schema || this.findParentSchema(parent);
    }
    return null;
  }
}

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-schema/build/es2015/storage.js
var schemaStorage6 = new AsnSchemaStorage6;

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-schema/build/es2015/decorators.js
var AsnType6 = (options) => (target2) => {
  let schema;
  if (!schemaStorage6.has(target2)) {
    schema = schemaStorage6.createDefault(target2);
    schemaStorage6.set(target2, schema);
  } else {
    schema = schemaStorage6.get(target2);
  }
  Object.assign(schema, options);
};
var AsnProp6 = (options) => (target2, propertyKey) => {
  let schema;
  if (!schemaStorage6.has(target2.constructor)) {
    schema = schemaStorage6.createDefault(target2.constructor);
    schemaStorage6.set(target2.constructor, schema);
  } else {
    schema = schemaStorage6.get(target2.constructor);
  }
  const copyOptions = Object.assign({}, options);
  if (typeof copyOptions.type === "number" && !copyOptions.converter) {
    const defaultConverter7 = defaultConverter6(options.type);
    if (!defaultConverter7) {
      throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target2.constructor.name}`);
    }
    copyOptions.converter = defaultConverter7;
  }
  copyOptions.raw = options.raw;
  schema.items[propertyKey] = copyOptions;
};
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-schema/build/es2015/errors/schema_validation.js
class AsnSchemaValidationError6 extends Error {
  constructor() {
    super(...arguments);
    this.schemas = [];
  }
}
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-schema/build/es2015/parser.js
class AsnParser6 {
  static parse(data, target2) {
    const asn1Parsed = fromBER6(data);
    if (asn1Parsed.result.error) {
      throw new Error(asn1Parsed.result.error);
    }
    const res = this.fromASN(asn1Parsed.result, target2);
    return res;
  }
  static fromASN(asn1Schema, target2) {
    try {
      if (isConvertible6(target2)) {
        const value = new target2;
        return value.fromASN(asn1Schema);
      }
      const schema = schemaStorage6.get(target2);
      schemaStorage6.cache(target2);
      let targetSchema = schema.schema;
      const choiceResult = this.handleChoiceTypes(asn1Schema, schema, target2, targetSchema);
      if (choiceResult === null || choiceResult === undefined ? undefined : choiceResult.result) {
        return choiceResult.result;
      }
      if (choiceResult === null || choiceResult === undefined ? undefined : choiceResult.targetSchema) {
        targetSchema = choiceResult.targetSchema;
      }
      const sequenceResult = this.handleSequenceTypes(asn1Schema, schema, target2, targetSchema);
      if (sequenceResult && "isManualMapping" in sequenceResult) {
        return sequenceResult.result;
      }
      const asn1ComparedSchema = sequenceResult;
      const res = new target2;
      if (isTypeOfArray6(target2)) {
        return this.handleArrayTypes(asn1Schema, schema, target2);
      }
      this.processSchemaItems(schema, asn1ComparedSchema, res);
      return res;
    } catch (error) {
      if (error instanceof AsnSchemaValidationError6) {
        error.schemas.push(target2.name);
      }
      throw error;
    }
  }
  static handleChoiceTypes(asn1Schema, schema, target2, targetSchema) {
    if (asn1Schema.constructor === Constructed6 && schema.type === AsnTypeTypes6.Choice && asn1Schema.idBlock.tagClass === 3) {
      for (const key in schema.items) {
        const schemaItem = schema.items[key];
        if (schemaItem.context === asn1Schema.idBlock.tagNumber && schemaItem.implicit) {
          if (typeof schemaItem.type === "function" && schemaStorage6.has(schemaItem.type)) {
            const fieldSchema = schemaStorage6.get(schemaItem.type);
            if (fieldSchema && fieldSchema.type === AsnTypeTypes6.Sequence) {
              const newSeq = new Sequence6;
              if ("value" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value) && "value" in newSeq.valueBlock) {
                newSeq.valueBlock.value = asn1Schema.valueBlock.value;
                const fieldValue = this.fromASN(newSeq, schemaItem.type);
                const res = new target2;
                res[key] = fieldValue;
                return { result: res };
              }
            }
          }
        }
      }
    } else if (asn1Schema.constructor === Constructed6 && schema.type !== AsnTypeTypes6.Choice) {
      const newTargetSchema = new Constructed6({
        idBlock: {
          tagClass: 3,
          tagNumber: asn1Schema.idBlock.tagNumber
        },
        value: schema.schema.valueBlock.value
      });
      for (const key in schema.items) {
        delete asn1Schema[key];
      }
      return { targetSchema: newTargetSchema };
    }
    return null;
  }
  static handleSequenceTypes(asn1Schema, schema, target2, targetSchema) {
    if (schema.type === AsnTypeTypes6.Sequence) {
      const optionalChoiceFields = Object.keys(schema.items).filter((key) => {
        const item = schema.items[key];
        return item.optional && typeof item.type === "function" && schemaStorage6.has(item.type) && schemaStorage6.get(item.type).type === AsnTypeTypes6.Choice;
      });
      if (optionalChoiceFields.length > 0 && "value" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value) && target2.name === "CertReqMsg") {
        return this.handleManualMapping(asn1Schema, schema, target2);
      }
      const asn1ComparedSchema = compareSchema6({}, asn1Schema, targetSchema);
      if (!asn1ComparedSchema.verified) {
        throw new AsnSchemaValidationError6(`Data does not match to ${target2.name} ASN1 schema.${asn1ComparedSchema.result.error ? ` ${asn1ComparedSchema.result.error}` : ""}`);
      }
      return asn1ComparedSchema;
    } else {
      const asn1ComparedSchema = compareSchema6({}, asn1Schema, targetSchema);
      if (!asn1ComparedSchema.verified) {
        throw new AsnSchemaValidationError6(`Data does not match to ${target2.name} ASN1 schema.${asn1ComparedSchema.result.error ? ` ${asn1ComparedSchema.result.error}` : ""}`);
      }
      return asn1ComparedSchema;
    }
  }
  static handleManualMapping(asn1Schema, schema, target2) {
    const res = new target2;
    const asn1Elements = asn1Schema.valueBlock.value;
    const schemaKeys = Object.keys(schema.items);
    let asn1Index = 0;
    for (let i = 0;i < schemaKeys.length; i++) {
      const key = schemaKeys[i];
      const schemaItem = schema.items[key];
      if (asn1Index >= asn1Elements.length)
        break;
      if (schemaItem.repeated) {
        res[key] = this.processRepeatedField(asn1Elements, asn1Index, schemaItem);
        break;
      } else if (typeof schemaItem.type === "number") {
        res[key] = this.processPrimitiveField(asn1Elements[asn1Index], schemaItem);
        asn1Index++;
      } else if (this.isOptionalChoiceField(schemaItem)) {
        const result = this.processOptionalChoiceField(asn1Elements[asn1Index], schemaItem);
        if (result.processed) {
          res[key] = result.value;
          asn1Index++;
        }
      } else {
        res[key] = this.fromASN(asn1Elements[asn1Index], schemaItem.type);
        asn1Index++;
      }
    }
    return { result: res, verified: true, isManualMapping: true };
  }
  static processRepeatedField(asn1Elements, asn1Index, schemaItem) {
    let elementsToProcess = asn1Elements.slice(asn1Index);
    if (elementsToProcess.length === 1 && elementsToProcess[0].constructor.name === "Sequence") {
      const seq = elementsToProcess[0];
      if (seq.valueBlock && seq.valueBlock.value && Array.isArray(seq.valueBlock.value)) {
        elementsToProcess = seq.valueBlock.value;
      }
    }
    if (typeof schemaItem.type === "number") {
      const converter = defaultConverter6(schemaItem.type);
      if (!converter)
        throw new Error(`No converter for ASN.1 type ${schemaItem.type}`);
      return elementsToProcess.filter((el) => el && el.valueBlock).map((el) => {
        try {
          return converter.fromASN(el);
        } catch {
          return;
        }
      }).filter((v) => v !== undefined);
    } else {
      return elementsToProcess.filter((el) => el && el.valueBlock).map((el) => {
        try {
          return this.fromASN(el, schemaItem.type);
        } catch {
          return;
        }
      }).filter((v) => v !== undefined);
    }
  }
  static processPrimitiveField(asn1Element, schemaItem) {
    const converter = defaultConverter6(schemaItem.type);
    if (!converter)
      throw new Error(`No converter for ASN.1 type ${schemaItem.type}`);
    return converter.fromASN(asn1Element);
  }
  static isOptionalChoiceField(schemaItem) {
    return schemaItem.optional && typeof schemaItem.type === "function" && schemaStorage6.has(schemaItem.type) && schemaStorage6.get(schemaItem.type).type === AsnTypeTypes6.Choice;
  }
  static processOptionalChoiceField(asn1Element, schemaItem) {
    try {
      const value = this.fromASN(asn1Element, schemaItem.type);
      return { processed: true, value };
    } catch (err) {
      if (err instanceof AsnSchemaValidationError6 && /Wrong values for Choice type/.test(err.message)) {
        return { processed: false };
      }
      throw err;
    }
  }
  static handleArrayTypes(asn1Schema, schema, target2) {
    if (!(("value" in asn1Schema.valueBlock) && Array.isArray(asn1Schema.valueBlock.value))) {
      throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);
    }
    const itemType = schema.itemType;
    if (typeof itemType === "number") {
      const converter = defaultConverter6(itemType);
      if (!converter) {
        throw new Error(`Cannot get default converter for array item of ${target2.name} ASN1 schema`);
      }
      return target2.from(asn1Schema.valueBlock.value, (element) => converter.fromASN(element));
    } else {
      return target2.from(asn1Schema.valueBlock.value, (element) => this.fromASN(element, itemType));
    }
  }
  static processSchemaItems(schema, asn1ComparedSchema, res) {
    for (const key in schema.items) {
      const asn1SchemaValue = asn1ComparedSchema.result[key];
      if (!asn1SchemaValue) {
        continue;
      }
      const schemaItem = schema.items[key];
      const schemaItemType = schemaItem.type;
      let parsedValue;
      if (typeof schemaItemType === "number" || isConvertible6(schemaItemType)) {
        parsedValue = this.processPrimitiveSchemaItem(asn1SchemaValue, schemaItem, schemaItemType);
      } else {
        parsedValue = this.processComplexSchemaItem(asn1SchemaValue, schemaItem, schemaItemType);
      }
      if (parsedValue && typeof parsedValue === "object" && "value" in parsedValue && "raw" in parsedValue) {
        res[key] = parsedValue.value;
        res[`${key}Raw`] = parsedValue.raw;
      } else {
        res[key] = parsedValue;
      }
    }
  }
  static processPrimitiveSchemaItem(asn1SchemaValue, schemaItem, schemaItemType) {
    var _a7;
    const converter = (_a7 = schemaItem.converter) !== null && _a7 !== undefined ? _a7 : isConvertible6(schemaItemType) ? new schemaItemType : null;
    if (!converter) {
      throw new Error("Converter is empty");
    }
    if (schemaItem.repeated) {
      return this.processRepeatedPrimitiveItem(asn1SchemaValue, schemaItem, converter);
    } else {
      return this.processSinglePrimitiveItem(asn1SchemaValue, schemaItem, schemaItemType, converter);
    }
  }
  static processRepeatedPrimitiveItem(asn1SchemaValue, schemaItem, converter) {
    if (schemaItem.implicit) {
      const Container = schemaItem.repeated === "sequence" ? Sequence6 : Set7;
      const newItem = new Container;
      newItem.valueBlock = asn1SchemaValue.valueBlock;
      const newItemAsn = fromBER6(newItem.toBER(false));
      if (newItemAsn.offset === -1) {
        throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);
      }
      if (!(("value" in newItemAsn.result.valueBlock) && Array.isArray(newItemAsn.result.valueBlock.value))) {
        throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");
      }
      const value = newItemAsn.result.valueBlock.value;
      return Array.from(value, (element) => converter.fromASN(element));
    } else {
      return Array.from(asn1SchemaValue, (element) => converter.fromASN(element));
    }
  }
  static processSinglePrimitiveItem(asn1SchemaValue, schemaItem, schemaItemType, converter) {
    let value = asn1SchemaValue;
    if (schemaItem.implicit) {
      let newItem;
      if (isConvertible6(schemaItemType)) {
        newItem = new schemaItemType().toSchema("");
      } else {
        const Asn1TypeName = AsnPropTypes6[schemaItemType];
        const Asn1Type = exports_index_es7[Asn1TypeName];
        if (!Asn1Type) {
          throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);
        }
        newItem = new Asn1Type;
      }
      newItem.valueBlock = value.valueBlock;
      value = fromBER6(newItem.toBER(false)).result;
    }
    return converter.fromASN(value);
  }
  static processComplexSchemaItem(asn1SchemaValue, schemaItem, schemaItemType) {
    if (schemaItem.repeated) {
      if (!Array.isArray(asn1SchemaValue)) {
        throw new Error("Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.");
      }
      return Array.from(asn1SchemaValue, (element) => this.fromASN(element, schemaItemType));
    } else {
      const valueToProcess = this.handleImplicitTagging(asn1SchemaValue, schemaItem, schemaItemType);
      if (this.isOptionalChoiceField(schemaItem)) {
        try {
          return this.fromASN(valueToProcess, schemaItemType);
        } catch (err) {
          if (err instanceof AsnSchemaValidationError6 && /Wrong values for Choice type/.test(err.message)) {
            return;
          }
          throw err;
        }
      } else {
        const parsedValue = this.fromASN(valueToProcess, schemaItemType);
        if (schemaItem.raw) {
          return {
            value: parsedValue,
            raw: asn1SchemaValue.valueBeforeDecodeView
          };
        }
        return parsedValue;
      }
    }
  }
  static handleImplicitTagging(asn1SchemaValue, schemaItem, schemaItemType) {
    if (schemaItem.implicit && typeof schemaItem.context === "number") {
      const schema = schemaStorage6.get(schemaItemType);
      if (schema.type === AsnTypeTypes6.Sequence) {
        const newSeq = new Sequence6;
        if ("value" in asn1SchemaValue.valueBlock && Array.isArray(asn1SchemaValue.valueBlock.value) && "value" in newSeq.valueBlock) {
          newSeq.valueBlock.value = asn1SchemaValue.valueBlock.value;
          return newSeq;
        }
      } else if (schema.type === AsnTypeTypes6.Set) {
        const newSet = new Set7;
        if ("value" in asn1SchemaValue.valueBlock && Array.isArray(asn1SchemaValue.valueBlock.value) && "value" in newSet.valueBlock) {
          newSet.valueBlock.value = asn1SchemaValue.valueBlock.value;
          return newSet;
        }
      }
    }
    return asn1SchemaValue;
  }
}
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-schema/build/es2015/serializer.js
class AsnSerializer6 {
  static serialize(obj) {
    if (obj instanceof BaseBlock6) {
      return obj.toBER(false);
    }
    return this.toASN(obj).toBER(false);
  }
  static toASN(obj) {
    if (obj && typeof obj === "object" && isConvertible6(obj)) {
      return obj.toASN();
    }
    if (!(obj && typeof obj === "object")) {
      throw new TypeError("Parameter 1 should be type of Object.");
    }
    const target2 = obj.constructor;
    const schema = schemaStorage6.get(target2);
    schemaStorage6.cache(target2);
    let asn1Value = [];
    if (schema.itemType) {
      if (!Array.isArray(obj)) {
        throw new TypeError("Parameter 1 should be type of Array.");
      }
      if (typeof schema.itemType === "number") {
        const converter = defaultConverter6(schema.itemType);
        if (!converter) {
          throw new Error(`Cannot get default converter for array item of ${target2.name} ASN1 schema`);
        }
        asn1Value = obj.map((o) => converter.toASN(o));
      } else {
        asn1Value = obj.map((o) => this.toAsnItem({ type: schema.itemType }, "[]", target2, o));
      }
    } else {
      for (const key in schema.items) {
        const schemaItem = schema.items[key];
        const objProp = obj[key];
        if (objProp === undefined || schemaItem.defaultValue === objProp || typeof schemaItem.defaultValue === "object" && typeof objProp === "object" && isArrayEqual6(this.serialize(schemaItem.defaultValue), this.serialize(objProp))) {
          continue;
        }
        const asn1Item = AsnSerializer6.toAsnItem(schemaItem, key, target2, objProp);
        if (typeof schemaItem.context === "number") {
          if (schemaItem.implicit) {
            if (!schemaItem.repeated && (typeof schemaItem.type === "number" || isConvertible6(schemaItem.type))) {
              const value = {};
              value.valueHex = asn1Item instanceof Null6 ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();
              asn1Value.push(new Primitive6({
                optional: schemaItem.optional,
                idBlock: {
                  tagClass: 3,
                  tagNumber: schemaItem.context
                },
                ...value
              }));
            } else {
              asn1Value.push(new Constructed6({
                optional: schemaItem.optional,
                idBlock: {
                  tagClass: 3,
                  tagNumber: schemaItem.context
                },
                value: asn1Item.valueBlock.value
              }));
            }
          } else {
            asn1Value.push(new Constructed6({
              optional: schemaItem.optional,
              idBlock: {
                tagClass: 3,
                tagNumber: schemaItem.context
              },
              value: [asn1Item]
            }));
          }
        } else if (schemaItem.repeated) {
          asn1Value = asn1Value.concat(asn1Item);
        } else {
          asn1Value.push(asn1Item);
        }
      }
    }
    let asnSchema;
    switch (schema.type) {
      case AsnTypeTypes6.Sequence:
        asnSchema = new Sequence6({ value: asn1Value });
        break;
      case AsnTypeTypes6.Set:
        asnSchema = new Set7({ value: asn1Value });
        break;
      case AsnTypeTypes6.Choice:
        if (!asn1Value[0]) {
          throw new Error(`Schema '${target2.name}' has wrong data. Choice cannot be empty.`);
        }
        asnSchema = asn1Value[0];
        break;
    }
    return asnSchema;
  }
  static toAsnItem(schemaItem, key, target2, objProp) {
    let asn1Item;
    if (typeof schemaItem.type === "number") {
      const converter = schemaItem.converter;
      if (!converter) {
        throw new Error(`Property '${key}' doesn't have converter for type ${AsnPropTypes6[schemaItem.type]} in schema '${target2.name}'`);
      }
      if (schemaItem.repeated) {
        if (!Array.isArray(objProp)) {
          throw new TypeError("Parameter 'objProp' should be type of Array.");
        }
        const items = Array.from(objProp, (element) => converter.toASN(element));
        const Container = schemaItem.repeated === "sequence" ? Sequence6 : Set7;
        asn1Item = new Container({
          value: items
        });
      } else {
        asn1Item = converter.toASN(objProp);
      }
    } else {
      if (schemaItem.repeated) {
        if (!Array.isArray(objProp)) {
          throw new TypeError("Parameter 'objProp' should be type of Array.");
        }
        const items = Array.from(objProp, (element) => this.toASN(element));
        const Container = schemaItem.repeated === "sequence" ? Sequence6 : Set7;
        asn1Item = new Container({
          value: items
        });
      } else {
        asn1Item = this.toASN(objProp);
      }
    }
    return asn1Item;
  }
}
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-schema/build/es2015/objects.js
class AsnArray6 extends Array {
  constructor(items = []) {
    if (typeof items === "number") {
      super(items);
    } else {
      super();
      for (const item of items) {
        this.push(item);
      }
    }
  }
}
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-schema/build/es2015/convert.js
class AsnConvert3 {
  static serialize(obj) {
    return AsnSerializer6.serialize(obj);
  }
  static parse(data, target2) {
    return AsnParser6.parse(data, target2);
  }
  static toString(data) {
    const buf = BufferSourceConverter.isBufferSource(data) ? BufferSourceConverter.toArrayBuffer(data) : AsnConvert3.serialize(data);
    const asn = fromBER6(buf);
    if (asn.offset === -1) {
      throw new Error(`Cannot decode ASN.1 data. ${asn.result.error}`);
    }
    return asn.result.toString();
  }
}
// node_modules/@peculiar/asn1-pfx/build/es2015/attribute.js
var PKCS12AttrSet_1;

class PKCS12Attribute {
  constructor(params = {}) {
    this.attrId = "";
    this.attrValues = [];
    Object.assign(params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.ObjectIdentifier })
], PKCS12Attribute.prototype, "attrId", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Any, repeated: "set" })
], PKCS12Attribute.prototype, "attrValues", undefined);
var PKCS12AttrSet = PKCS12AttrSet_1 = class PKCS12AttrSet2 extends AsnArray6 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, PKCS12AttrSet_1.prototype);
  }
};
PKCS12AttrSet = PKCS12AttrSet_1 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence, itemType: PKCS12Attribute })
], PKCS12AttrSet);
// node_modules/@peculiar/asn1-pfx/build/es2015/authenticated_safe.js
var AuthenticatedSafe_1;
var AuthenticatedSafe = AuthenticatedSafe_1 = class AuthenticatedSafe2 extends AsnArray6 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, AuthenticatedSafe_1.prototype);
  }
};
AuthenticatedSafe = AuthenticatedSafe_1 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence, itemType: ContentInfo })
], AuthenticatedSafe);
// node_modules/@peculiar/asn1-pfx/build/es2015/object_identifiers.js
var id_rsadsi = "1.2.840.113549";
var id_pkcs = `${id_rsadsi}.1`;
var id_pkcs_12 = `${id_pkcs}.12`;
var id_pkcs_12PbeIds = `${id_pkcs_12}.1`;
var id_pbeWithSHAAnd128BitRC4 = `${id_pkcs_12PbeIds}.1`;
var id_pbeWithSHAAnd40BitRC4 = `${id_pkcs_12PbeIds}.2`;
var id_pbeWithSHAAnd3_KeyTripleDES_CBC = `${id_pkcs_12PbeIds}.3`;
var id_pbeWithSHAAnd2_KeyTripleDES_CBC = `${id_pkcs_12PbeIds}.4`;
var id_pbeWithSHAAnd128BitRC2_CBC = `${id_pkcs_12PbeIds}.5`;
var id_pbewithSHAAnd40BitRC2_CBC = `${id_pkcs_12PbeIds}.6`;
var id_bagtypes = `${id_pkcs_12}.10.1`;

// node_modules/@peculiar/asn1-pfx/build/es2015/bags/types.js
var id_keyBag = `${id_bagtypes}.1`;
var id_pkcs8ShroudedKeyBag = `${id_bagtypes}.2`;
var id_certBag = `${id_bagtypes}.3`;
var id_CRLBag = `${id_bagtypes}.4`;
var id_SecretBag = `${id_bagtypes}.5`;
var id_SafeContents = `${id_bagtypes}.6`;
var id_pkcs_9 = "1.2.840.113549.1.9";

// node_modules/@peculiar/asn1-pfx/build/es2015/bags/cert_bag.js
class CertBag {
  constructor(params = {}) {
    this.certId = "";
    this.certValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.ObjectIdentifier })
], CertBag.prototype, "certId", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Any, context: 0 })
], CertBag.prototype, "certValue", undefined);
var id_certTypes = `${id_pkcs_9}.22`;
var id_x509Certificate = `${id_certTypes}.1`;
var id_sdsiCertificate = `${id_certTypes}.2`;
// node_modules/@peculiar/asn1-pfx/build/es2015/bags/crl_bag.js
class CRLBag {
  constructor(params = {}) {
    this.crlId = "";
    this.crltValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.ObjectIdentifier })
], CRLBag.prototype, "crlId", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Any, context: 0 })
], CRLBag.prototype, "crltValue", undefined);
var id_crlTypes = `${id_pkcs_9}.23`;
var id_x509CRL = `${id_crlTypes}.1`;
// node_modules/@peculiar/asn1-pkcs8/node_modules/asn1js/build/index.es.js
var exports_index_es8 = {};
__export(exports_index_es8, {
  verifySchema: () => verifySchema7,
  fromBER: () => fromBER7,
  compareSchema: () => compareSchema7,
  VisibleString: () => VisibleString7,
  ViewWriter: () => ViewWriter7,
  VideotexString: () => VideotexString7,
  ValueBlock: () => ValueBlock7,
  Utf8String: () => Utf8String7,
  UniversalString: () => UniversalString7,
  UTCTime: () => UTCTime7,
  TimeOfDay: () => TimeOfDay7,
  TeletexString: () => TeletexString7,
  TIME: () => TIME7,
  Set: () => Set8,
  Sequence: () => Sequence7,
  Repeated: () => Repeated7,
  RelativeObjectIdentifier: () => RelativeObjectIdentifier7,
  RawData: () => RawData7,
  PrintableString: () => PrintableString7,
  Primitive: () => Primitive7,
  OctetString: () => OctetString13,
  ObjectIdentifier: () => ObjectIdentifier7,
  NumericString: () => NumericString7,
  Null: () => Null7,
  Integer: () => Integer7,
  IA5String: () => IA5String7,
  HexBlock: () => HexBlock7,
  GraphicString: () => GraphicString7,
  GeneralizedTime: () => GeneralizedTime7,
  GeneralString: () => GeneralString7,
  Enumerated: () => Enumerated7,
  EndOfContent: () => EndOfContent7,
  Duration: () => Duration7,
  DateTime: () => DateTime7,
  DATE: () => DATE7,
  Constructed: () => Constructed7,
  Choice: () => Choice7,
  CharacterString: () => CharacterString7,
  Boolean: () => Boolean8,
  BmpString: () => BmpString7,
  BitString: () => BitString13,
  BaseStringBlock: () => BaseStringBlock7,
  BaseBlock: () => BaseBlock7,
  Any: () => Any7
});
/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
function assertBigInt7() {
  if (typeof BigInt === "undefined") {
    throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
  }
}
function concat7(buffers) {
  let outputLength = 0;
  let prevLength = 0;
  for (let i = 0;i < buffers.length; i++) {
    const buffer = buffers[i];
    outputLength += buffer.byteLength;
  }
  const retView = new Uint8Array(outputLength);
  for (let i = 0;i < buffers.length; i++) {
    const buffer = buffers[i];
    retView.set(new Uint8Array(buffer), prevLength);
    prevLength += buffer.byteLength;
  }
  return retView.buffer;
}
function checkBufferParams7(baseBlock, inputBuffer, inputOffset, inputLength) {
  if (!(inputBuffer instanceof Uint8Array)) {
    baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
    return false;
  }
  if (!inputBuffer.byteLength) {
    baseBlock.error = "Wrong parameter: inputBuffer has zero length";
    return false;
  }
  if (inputOffset < 0) {
    baseBlock.error = "Wrong parameter: inputOffset less than zero";
    return false;
  }
  if (inputLength < 0) {
    baseBlock.error = "Wrong parameter: inputLength less than zero";
    return false;
  }
  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
    baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
    return false;
  }
  return true;
}

class ViewWriter7 {
  constructor() {
    this.items = [];
  }
  write(buf) {
    this.items.push(buf);
  }
  final() {
    return concat7(this.items);
  }
}
var powers27 = [new Uint8Array([1])];
var digitsString7 = "0123456789";
var NAME7 = "name";
var VALUE_HEX_VIEW7 = "valueHexView";
var IS_HEX_ONLY7 = "isHexOnly";
var ID_BLOCK7 = "idBlock";
var TAG_CLASS7 = "tagClass";
var TAG_NUMBER7 = "tagNumber";
var IS_CONSTRUCTED7 = "isConstructed";
var FROM_BER7 = "fromBER";
var TO_BER7 = "toBER";
var LOCAL7 = "local";
var EMPTY_STRING7 = "";
var EMPTY_BUFFER7 = new ArrayBuffer(0);
var EMPTY_VIEW7 = new Uint8Array(0);
var END_OF_CONTENT_NAME7 = "EndOfContent";
var OCTET_STRING_NAME7 = "OCTET STRING";
var BIT_STRING_NAME7 = "BIT STRING";
function HexBlock7(BaseClass) {
  var _a7;
  return _a7 = class Some extends BaseClass {
    get valueHex() {
      return this.valueHexView.slice().buffer;
    }
    set valueHex(value) {
      this.valueHexView = new Uint8Array(value);
    }
    constructor(...args) {
      var _b;
      super(...args);
      const params = args[0] || {};
      this.isHexOnly = (_b = params.isHexOnly) !== null && _b !== undefined ? _b : false;
      this.valueHexView = params.valueHex ? BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW7;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      if (!checkBufferParams7(this, view, inputOffset, inputLength)) {
        return -1;
      }
      const endLength = inputOffset + inputLength;
      this.valueHexView = view.subarray(inputOffset, endLength);
      if (!this.valueHexView.length) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      }
      this.blockLength = inputLength;
      return endLength;
    }
    toBER(sizeOnly = false) {
      if (!this.isHexOnly) {
        this.error = "Flag 'isHexOnly' is not set, abort";
        return EMPTY_BUFFER7;
      }
      if (sizeOnly) {
        return new ArrayBuffer(this.valueHexView.byteLength);
      }
      return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        isHexOnly: this.isHexOnly,
        valueHex: Convert.ToHex(this.valueHexView)
      };
    }
  }, _a7.NAME = "hexBlock", _a7;
}

class LocalBaseBlock7 {
  static blockName() {
    return this.NAME;
  }
  get valueBeforeDecode() {
    return this.valueBeforeDecodeView.slice().buffer;
  }
  set valueBeforeDecode(value) {
    this.valueBeforeDecodeView = new Uint8Array(value);
  }
  constructor({ blockLength = 0, error = EMPTY_STRING7, warnings = [], valueBeforeDecode = EMPTY_VIEW7 } = {}) {
    this.blockLength = blockLength;
    this.error = error;
    this.warnings = warnings;
    this.valueBeforeDecodeView = BufferSourceConverter.toUint8Array(valueBeforeDecode);
  }
  toJSON() {
    return {
      blockName: this.constructor.NAME,
      blockLength: this.blockLength,
      error: this.error,
      warnings: this.warnings,
      valueBeforeDecode: Convert.ToHex(this.valueBeforeDecodeView)
    };
  }
}
LocalBaseBlock7.NAME = "baseBlock";

class ValueBlock7 extends LocalBaseBlock7 {
  fromBER(_inputBuffer, _inputOffset, _inputLength) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
  toBER(_sizeOnly, _writer) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
}
ValueBlock7.NAME = "valueBlock";

class LocalIdentificationBlock7 extends HexBlock7(LocalBaseBlock7) {
  constructor({ idBlock = {} } = {}) {
    var _a7, _b, _c, _d;
    super();
    if (idBlock) {
      this.isHexOnly = (_a7 = idBlock.isHexOnly) !== null && _a7 !== undefined ? _a7 : false;
      this.valueHexView = idBlock.valueHex ? BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW7;
      this.tagClass = (_b = idBlock.tagClass) !== null && _b !== undefined ? _b : -1;
      this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== undefined ? _c : -1;
      this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== undefined ? _d : false;
    } else {
      this.tagClass = -1;
      this.tagNumber = -1;
      this.isConstructed = false;
    }
  }
  toBER(sizeOnly = false) {
    let firstOctet = 0;
    switch (this.tagClass) {
      case 1:
        firstOctet |= 0;
        break;
      case 2:
        firstOctet |= 64;
        break;
      case 3:
        firstOctet |= 128;
        break;
      case 4:
        firstOctet |= 192;
        break;
      default:
        this.error = "Unknown tag class";
        return EMPTY_BUFFER7;
    }
    if (this.isConstructed)
      firstOctet |= 32;
    if (this.tagNumber < 31 && !this.isHexOnly) {
      const retView2 = new Uint8Array(1);
      if (!sizeOnly) {
        let number = this.tagNumber;
        number &= 31;
        firstOctet |= number;
        retView2[0] = firstOctet;
      }
      return retView2.buffer;
    }
    if (!this.isHexOnly) {
      const encodedBuf = utilToBase(this.tagNumber, 7);
      const encodedView = new Uint8Array(encodedBuf);
      const size = encodedBuf.byteLength;
      const retView2 = new Uint8Array(size + 1);
      retView2[0] = firstOctet | 31;
      if (!sizeOnly) {
        for (let i = 0;i < size - 1; i++)
          retView2[i + 1] = encodedView[i] | 128;
        retView2[size] = encodedView[size - 1];
      }
      return retView2.buffer;
    }
    const retView = new Uint8Array(this.valueHexView.byteLength + 1);
    retView[0] = firstOctet | 31;
    if (!sizeOnly) {
      const curView = this.valueHexView;
      for (let i = 0;i < curView.length - 1; i++)
        retView[i + 1] = curView[i] | 128;
      retView[this.valueHexView.byteLength] = curView[curView.length - 1];
    }
    return retView.buffer;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams7(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    const tagClassMask = intBuffer[0] & 192;
    switch (tagClassMask) {
      case 0:
        this.tagClass = 1;
        break;
      case 64:
        this.tagClass = 2;
        break;
      case 128:
        this.tagClass = 3;
        break;
      case 192:
        this.tagClass = 4;
        break;
      default:
        this.error = "Unknown tag class";
        return -1;
    }
    this.isConstructed = (intBuffer[0] & 32) === 32;
    this.isHexOnly = false;
    const tagNumberMask = intBuffer[0] & 31;
    if (tagNumberMask !== 31) {
      this.tagNumber = tagNumberMask;
      this.blockLength = 1;
    } else {
      let count = 1;
      let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
      let tagNumberBufferMaxLength = 255;
      while (intBuffer[count] & 128) {
        intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
        count++;
        if (count >= intBuffer.length) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (count === tagNumberBufferMaxLength) {
          tagNumberBufferMaxLength += 255;
          const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);
          for (let i = 0;i < intTagNumberBuffer.length; i++)
            tempBufferView2[i] = intTagNumberBuffer[i];
          intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
        }
      }
      this.blockLength = count + 1;
      intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
      const tempBufferView = new Uint8Array(count);
      for (let i = 0;i < count; i++)
        tempBufferView[i] = intTagNumberBuffer[i];
      intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
      intTagNumberBuffer.set(tempBufferView);
      if (this.blockLength <= 9)
        this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
      else {
        this.isHexOnly = true;
        this.warnings.push("Tag too long, represented as hex-coded");
      }
    }
    if (this.tagClass === 1 && this.isConstructed) {
      switch (this.tagNumber) {
        case 1:
        case 2:
        case 5:
        case 6:
        case 9:
        case 13:
        case 14:
        case 23:
        case 24:
        case 31:
        case 32:
        case 33:
        case 34:
          this.error = "Constructed encoding used for primitive type";
          return -1;
      }
    }
    return inputOffset + this.blockLength;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      tagClass: this.tagClass,
      tagNumber: this.tagNumber,
      isConstructed: this.isConstructed
    };
  }
}
LocalIdentificationBlock7.NAME = "identificationBlock";

class LocalLengthBlock7 extends LocalBaseBlock7 {
  constructor({ lenBlock = {} } = {}) {
    var _a7, _b, _c;
    super();
    this.isIndefiniteForm = (_a7 = lenBlock.isIndefiniteForm) !== null && _a7 !== undefined ? _a7 : false;
    this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== undefined ? _b : false;
    this.length = (_c = lenBlock.length) !== null && _c !== undefined ? _c : 0;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams7(this, view, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    if (intBuffer[0] === 255) {
      this.error = "Length block 0xFF is reserved by standard";
      return -1;
    }
    this.isIndefiniteForm = intBuffer[0] === 128;
    if (this.isIndefiniteForm) {
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    this.longFormUsed = !!(intBuffer[0] & 128);
    if (this.longFormUsed === false) {
      this.length = intBuffer[0];
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    const count = intBuffer[0] & 127;
    if (count > 8) {
      this.error = "Too big integer";
      return -1;
    }
    if (count + 1 > intBuffer.length) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    const lenOffset = inputOffset + 1;
    const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
    if (lengthBufferView[count - 1] === 0)
      this.warnings.push("Needlessly long encoded length");
    this.length = utilFromBase(lengthBufferView, 8);
    if (this.longFormUsed && this.length <= 127)
      this.warnings.push("Unnecessary usage of long length form");
    this.blockLength = count + 1;
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly = false) {
    let retBuf;
    let retView;
    if (this.length > 127)
      this.longFormUsed = true;
    if (this.isIndefiniteForm) {
      retBuf = new ArrayBuffer(1);
      if (sizeOnly === false) {
        retView = new Uint8Array(retBuf);
        retView[0] = 128;
      }
      return retBuf;
    }
    if (this.longFormUsed) {
      const encodedBuf = utilToBase(this.length, 8);
      if (encodedBuf.byteLength > 127) {
        this.error = "Too big length";
        return EMPTY_BUFFER7;
      }
      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
      if (sizeOnly)
        return retBuf;
      const encodedView = new Uint8Array(encodedBuf);
      retView = new Uint8Array(retBuf);
      retView[0] = encodedBuf.byteLength | 128;
      for (let i = 0;i < encodedBuf.byteLength; i++)
        retView[i + 1] = encodedView[i];
      return retBuf;
    }
    retBuf = new ArrayBuffer(1);
    if (sizeOnly === false) {
      retView = new Uint8Array(retBuf);
      retView[0] = this.length;
    }
    return retBuf;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      longFormUsed: this.longFormUsed,
      length: this.length
    };
  }
}
LocalLengthBlock7.NAME = "lengthBlock";
var typeStore7 = {};

class BaseBlock7 extends LocalBaseBlock7 {
  constructor({ name: name5 = EMPTY_STRING7, optional = false, primitiveSchema, ...parameters2 } = {}, valueBlockType) {
    super(parameters2);
    this.name = name5;
    this.optional = optional;
    if (primitiveSchema) {
      this.primitiveSchema = primitiveSchema;
    }
    this.idBlock = new LocalIdentificationBlock7(parameters2);
    this.lenBlock = new LocalLengthBlock7(parameters2);
    this.valueBlock = valueBlockType ? new valueBlockType(parameters2) : new ValueBlock7(parameters2);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter7;
    if (!writer) {
      prepareIndefiniteForm7(this);
    }
    const idBlockBuf = this.idBlock.toBER(sizeOnly);
    _writer.write(idBlockBuf);
    if (this.lenBlock.isIndefiniteForm) {
      _writer.write(new Uint8Array([128]).buffer);
      this.valueBlock.toBER(sizeOnly, _writer);
      _writer.write(new ArrayBuffer(2));
    } else {
      const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
      this.lenBlock.length = valueBlockBuf.byteLength;
      const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
      _writer.write(lenBlockBuf);
      _writer.write(valueBlockBuf);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER7;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      idBlock: this.idBlock.toJSON(),
      lenBlock: this.lenBlock.toJSON(),
      valueBlock: this.valueBlock.toJSON(),
      name: this.name,
      optional: this.optional
    };
    if (this.primitiveSchema)
      object.primitiveSchema = this.primitiveSchema.toJSON();
    return object;
  }
  toString(encoding = "ascii") {
    if (encoding === "ascii") {
      return this.onAsciiEncoding();
    }
    return Convert.ToHex(this.toBER());
  }
  onAsciiEncoding() {
    const name5 = this.constructor.NAME;
    const value = Convert.ToHex(this.valueBlock.valueBeforeDecodeView);
    return `${name5} : ${value}`;
  }
  isEqual(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof this.constructor)) {
      return false;
    }
    const thisRaw = this.toBER();
    const otherRaw = other.toBER();
    return isEqualBuffer(thisRaw, otherRaw);
  }
}
BaseBlock7.NAME = "BaseBlock";
function prepareIndefiniteForm7(baseBlock) {
  var _a7;
  if (baseBlock instanceof typeStore7.Constructed) {
    for (const value of baseBlock.valueBlock.value) {
      if (prepareIndefiniteForm7(value)) {
        baseBlock.lenBlock.isIndefiniteForm = true;
      }
    }
  }
  return !!((_a7 = baseBlock.lenBlock) === null || _a7 === undefined ? undefined : _a7.isIndefiniteForm);
}

class BaseStringBlock7 extends BaseBlock7 {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  constructor({ value = EMPTY_STRING7, ...parameters2 } = {}, stringValueBlockType) {
    super(parameters2, stringValueBlockType);
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    this.fromBuffer(this.valueBlock.valueHexView);
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
  }
}
BaseStringBlock7.NAME = "BaseStringBlock";

class LocalPrimitiveValueBlock7 extends HexBlock7(ValueBlock7) {
  constructor({ isHexOnly = true, ...parameters2 } = {}) {
    super(parameters2);
    this.isHexOnly = isHexOnly;
  }
}
LocalPrimitiveValueBlock7.NAME = "PrimitiveValueBlock";
var _a$w7;

class Primitive7 extends BaseBlock7 {
  constructor(parameters2 = {}) {
    super(parameters2, LocalPrimitiveValueBlock7);
    this.idBlock.isConstructed = false;
  }
}
_a$w7 = Primitive7;
(() => {
  typeStore7.Primitive = _a$w7;
})();
Primitive7.NAME = "PRIMITIVE";
function localChangeType7(inputObject, newType) {
  if (inputObject instanceof newType) {
    return inputObject;
  }
  const newObject = new newType;
  newObject.idBlock = inputObject.idBlock;
  newObject.lenBlock = inputObject.lenBlock;
  newObject.warnings = inputObject.warnings;
  newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
  return newObject;
}
function localFromBER7(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
  const incomingOffset = inputOffset;
  let returnObject = new BaseBlock7({}, ValueBlock7);
  const baseBlock = new LocalBaseBlock7;
  if (!checkBufferParams7(baseBlock, inputBuffer, inputOffset, inputLength)) {
    returnObject.error = baseBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
  if (!intBuffer.length) {
    returnObject.error = "Zero buffer length";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.idBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.idBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.idBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.idBlock.blockLength;
  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.lenBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.lenBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.lenBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.lenBlock.blockLength;
  if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
    returnObject.error = "Indefinite length form used for primitive encoding form";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let newASN1Type = BaseBlock7;
  switch (returnObject.idBlock.tagClass) {
    case 1:
      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
        returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
        return {
          offset: -1,
          result: returnObject
        };
      }
      switch (returnObject.idBlock.tagNumber) {
        case 0:
          if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
            returnObject.error = "Type [UNIVERSAL 0] is reserved";
            return {
              offset: -1,
              result: returnObject
            };
          }
          newASN1Type = typeStore7.EndOfContent;
          break;
        case 1:
          newASN1Type = typeStore7.Boolean;
          break;
        case 2:
          newASN1Type = typeStore7.Integer;
          break;
        case 3:
          newASN1Type = typeStore7.BitString;
          break;
        case 4:
          newASN1Type = typeStore7.OctetString;
          break;
        case 5:
          newASN1Type = typeStore7.Null;
          break;
        case 6:
          newASN1Type = typeStore7.ObjectIdentifier;
          break;
        case 10:
          newASN1Type = typeStore7.Enumerated;
          break;
        case 12:
          newASN1Type = typeStore7.Utf8String;
          break;
        case 13:
          newASN1Type = typeStore7.RelativeObjectIdentifier;
          break;
        case 14:
          newASN1Type = typeStore7.TIME;
          break;
        case 15:
          returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
          return {
            offset: -1,
            result: returnObject
          };
        case 16:
          newASN1Type = typeStore7.Sequence;
          break;
        case 17:
          newASN1Type = typeStore7.Set;
          break;
        case 18:
          newASN1Type = typeStore7.NumericString;
          break;
        case 19:
          newASN1Type = typeStore7.PrintableString;
          break;
        case 20:
          newASN1Type = typeStore7.TeletexString;
          break;
        case 21:
          newASN1Type = typeStore7.VideotexString;
          break;
        case 22:
          newASN1Type = typeStore7.IA5String;
          break;
        case 23:
          newASN1Type = typeStore7.UTCTime;
          break;
        case 24:
          newASN1Type = typeStore7.GeneralizedTime;
          break;
        case 25:
          newASN1Type = typeStore7.GraphicString;
          break;
        case 26:
          newASN1Type = typeStore7.VisibleString;
          break;
        case 27:
          newASN1Type = typeStore7.GeneralString;
          break;
        case 28:
          newASN1Type = typeStore7.UniversalString;
          break;
        case 29:
          newASN1Type = typeStore7.CharacterString;
          break;
        case 30:
          newASN1Type = typeStore7.BmpString;
          break;
        case 31:
          newASN1Type = typeStore7.DATE;
          break;
        case 32:
          newASN1Type = typeStore7.TimeOfDay;
          break;
        case 33:
          newASN1Type = typeStore7.DateTime;
          break;
        case 34:
          newASN1Type = typeStore7.Duration;
          break;
        default: {
          const newObject = returnObject.idBlock.isConstructed ? new typeStore7.Constructed : new typeStore7.Primitive;
          newObject.idBlock = returnObject.idBlock;
          newObject.lenBlock = returnObject.lenBlock;
          newObject.warnings = returnObject.warnings;
          returnObject = newObject;
        }
      }
      break;
    case 2:
    case 3:
    case 4:
    default: {
      newASN1Type = returnObject.idBlock.isConstructed ? typeStore7.Constructed : typeStore7.Primitive;
    }
  }
  returnObject = localChangeType7(returnObject, newASN1Type);
  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
  returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
  return {
    offset: resultOffset,
    result: returnObject
  };
}
function fromBER7(inputBuffer) {
  if (!inputBuffer.byteLength) {
    const result = new BaseBlock7({}, ValueBlock7);
    result.error = "Input buffer has zero length";
    return {
      offset: -1,
      result
    };
  }
  return localFromBER7(BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
}
function checkLen7(indefiniteLength, length) {
  if (indefiniteLength) {
    return 1;
  }
  return length;
}

class LocalConstructedValueBlock7 extends ValueBlock7 {
  constructor({ value = [], isIndefiniteForm = false, ...parameters2 } = {}) {
    super(parameters2);
    this.value = value;
    this.isIndefiniteForm = isIndefiniteForm;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams7(this, view, inputOffset, inputLength)) {
      return -1;
    }
    this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
    if (this.valueBeforeDecodeView.length === 0) {
      this.warnings.push("Zero buffer length");
      return inputOffset;
    }
    let currentOffset = inputOffset;
    while (checkLen7(this.isIndefiniteForm, inputLength) > 0) {
      const returnObject = localFromBER7(view, currentOffset, inputLength);
      if (returnObject.offset === -1) {
        this.error = returnObject.result.error;
        this.warnings.concat(returnObject.result.warnings);
        return -1;
      }
      currentOffset = returnObject.offset;
      this.blockLength += returnObject.result.blockLength;
      inputLength -= returnObject.result.blockLength;
      this.value.push(returnObject.result);
      if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME7) {
        break;
      }
    }
    if (this.isIndefiniteForm) {
      if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME7) {
        this.value.pop();
      } else {
        this.warnings.push("No EndOfContent block encoded");
      }
    }
    return currentOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter7;
    for (let i = 0;i < this.value.length; i++) {
      this.value[i].toBER(sizeOnly, _writer);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER7;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      value: []
    };
    for (const value of this.value) {
      object.value.push(value.toJSON());
    }
    return object;
  }
}
LocalConstructedValueBlock7.NAME = "ConstructedValueBlock";
var _a$v7;

class Constructed7 extends BaseBlock7 {
  constructor(parameters2 = {}) {
    super(parameters2, LocalConstructedValueBlock7);
    this.idBlock.isConstructed = true;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    const values = [];
    for (const value of this.valueBlock.value) {
      values.push(value.toString("ascii").split(`
`).map((o) => `  ${o}`).join(`
`));
    }
    const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
    return values.length ? `${blockName} :
${values.join(`
`)}` : `${blockName} :`;
  }
}
_a$v7 = Constructed7;
(() => {
  typeStore7.Constructed = _a$v7;
})();
Constructed7.NAME = "CONSTRUCTED";

class LocalEndOfContentValueBlock7 extends ValueBlock7 {
  fromBER(inputBuffer, inputOffset, _inputLength) {
    return inputOffset;
  }
  toBER(_sizeOnly) {
    return EMPTY_BUFFER7;
  }
}
LocalEndOfContentValueBlock7.override = "EndOfContentValueBlock";
var _a$u7;

class EndOfContent7 extends BaseBlock7 {
  constructor(parameters2 = {}) {
    super(parameters2, LocalEndOfContentValueBlock7);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 0;
  }
}
_a$u7 = EndOfContent7;
(() => {
  typeStore7.EndOfContent = _a$u7;
})();
EndOfContent7.NAME = END_OF_CONTENT_NAME7;
var _a$t7;

class Null7 extends BaseBlock7 {
  constructor(parameters2 = {}) {
    super(parameters2, ValueBlock7);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 5;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (this.lenBlock.length > 0)
      this.warnings.push("Non-zero length of value block for Null type");
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    this.blockLength += inputLength;
    if (inputOffset + inputLength > inputBuffer.byteLength) {
      this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
      return -1;
    }
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    const retBuf = new ArrayBuffer(2);
    if (!sizeOnly) {
      const retView = new Uint8Array(retBuf);
      retView[0] = 5;
      retView[1] = 0;
    }
    if (writer) {
      writer.write(retBuf);
    }
    return retBuf;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME}`;
  }
}
_a$t7 = Null7;
(() => {
  typeStore7.Null = _a$t7;
})();
Null7.NAME = "NULL";

class LocalBooleanValueBlock7 extends HexBlock7(ValueBlock7) {
  get value() {
    for (const octet of this.valueHexView) {
      if (octet > 0) {
        return true;
      }
    }
    return false;
  }
  set value(value) {
    this.valueHexView[0] = value ? 255 : 0;
  }
  constructor({ value, ...parameters2 } = {}) {
    super(parameters2);
    if (parameters2.valueHex) {
      this.valueHexView = BufferSourceConverter.toUint8Array(parameters2.valueHex);
    } else {
      this.valueHexView = new Uint8Array(1);
    }
    if (value) {
      this.value = value;
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams7(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (inputLength > 1)
      this.warnings.push("Boolean value encoded in more then 1 octet");
    this.isHexOnly = true;
    utilDecodeTC.call(this);
    this.blockLength = inputLength;
    return inputOffset + inputLength;
  }
  toBER() {
    return this.valueHexView.slice();
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalBooleanValueBlock7.NAME = "BooleanValueBlock";
var _a$s7;

class Boolean8 extends BaseBlock7 {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  constructor(parameters2 = {}) {
    super(parameters2, LocalBooleanValueBlock7);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 1;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.getValue}`;
  }
}
_a$s7 = Boolean8;
(() => {
  typeStore7.Boolean = _a$s7;
})();
Boolean8.NAME = "BOOLEAN";

class LocalOctetStringValueBlock7 extends HexBlock7(LocalConstructedValueBlock7) {
  constructor({ isConstructed = false, ...parameters2 } = {}) {
    super(parameters2);
    this.isConstructed = isConstructed;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = 0;
    if (this.isConstructed) {
      this.isHexOnly = false;
      resultOffset = LocalConstructedValueBlock7.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (let i = 0;i < this.value.length; i++) {
        const currentBlockName = this.value[i].constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME7) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== OCTET_STRING_NAME7) {
          this.error = "OCTET STRING may consists of OCTET STRINGs only";
          return -1;
        }
      }
    } else {
      this.isHexOnly = true;
      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
      this.blockLength = inputLength;
    }
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed)
      return LocalConstructedValueBlock7.prototype.toBER.call(this, sizeOnly, writer);
    return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isConstructed: this.isConstructed
    };
  }
}
LocalOctetStringValueBlock7.NAME = "OctetStringValueBlock";
var _a$r7;

class OctetString13 extends BaseBlock7 {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters2 } = {}) {
    var _b, _c;
    (_b = parameters2.isConstructed) !== null && _b !== undefined || (parameters2.isConstructed = !!((_c = parameters2.value) === null || _c === undefined ? undefined : _c.length));
    super({
      idBlock: {
        isConstructed: parameters2.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters2.isIndefiniteForm
      },
      ...parameters2
    }, LocalOctetStringValueBlock7);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 4;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    if (inputLength === 0) {
      if (this.idBlock.error.length === 0)
        this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0)
        this.blockLength += this.lenBlock.blockLength;
      return inputOffset;
    }
    if (!this.valueBlock.isConstructed) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      const buf = view.subarray(inputOffset, inputOffset + inputLength);
      try {
        if (buf.byteLength) {
          const asn = localFromBER7(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength) {
            this.valueBlock.value = [asn.result];
          }
        }
      } catch {}
    }
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed7.prototype.onAsciiEncoding.call(this);
    }
    const name5 = this.constructor.NAME;
    const value = Convert.ToHex(this.valueBlock.valueHexView);
    return `${name5} : ${value}`;
  }
  getValue() {
    if (!this.idBlock.isConstructed) {
      return this.valueBlock.valueHexView.slice().buffer;
    }
    const array = [];
    for (const content of this.valueBlock.value) {
      if (content instanceof _a$r7) {
        array.push(content.valueBlock.valueHexView);
      }
    }
    return BufferSourceConverter.concat(array);
  }
}
_a$r7 = OctetString13;
(() => {
  typeStore7.OctetString = _a$r7;
})();
OctetString13.NAME = OCTET_STRING_NAME7;

class LocalBitStringValueBlock7 extends HexBlock7(LocalConstructedValueBlock7) {
  constructor({ unusedBits = 0, isConstructed = false, ...parameters2 } = {}) {
    super(parameters2);
    this.unusedBits = unusedBits;
    this.isConstructed = isConstructed;
    this.blockLength = this.valueHexView.byteLength;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    let resultOffset = -1;
    if (this.isConstructed) {
      resultOffset = LocalConstructedValueBlock7.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (const value of this.value) {
        const currentBlockName = value.constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME7) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== BIT_STRING_NAME7) {
          this.error = "BIT STRING may consists of BIT STRINGs only";
          return -1;
        }
        const valueBlock = value.valueBlock;
        if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
          this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
          return -1;
        }
        this.unusedBits = valueBlock.unusedBits;
      }
      return resultOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams7(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.unusedBits = intBuffer[0];
    if (this.unusedBits > 7) {
      this.error = "Unused bits for BitString must be in range 0-7";
      return -1;
    }
    if (!this.unusedBits) {
      const buf = intBuffer.subarray(1);
      try {
        if (buf.byteLength) {
          const asn = localFromBER7(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength - 1) {
            this.value = [asn.result];
          }
        }
      } catch {}
    }
    this.valueHexView = intBuffer.subarray(1);
    this.blockLength = intBuffer.length;
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed) {
      return LocalConstructedValueBlock7.prototype.toBER.call(this, sizeOnly, writer);
    }
    if (sizeOnly) {
      return new ArrayBuffer(this.valueHexView.byteLength + 1);
    }
    if (!this.valueHexView.byteLength) {
      return EMPTY_BUFFER7;
    }
    const retView = new Uint8Array(this.valueHexView.length + 1);
    retView[0] = this.unusedBits;
    retView.set(this.valueHexView, 1);
    return retView.buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      unusedBits: this.unusedBits,
      isConstructed: this.isConstructed
    };
  }
}
LocalBitStringValueBlock7.NAME = "BitStringValueBlock";
var _a$q7;

class BitString13 extends BaseBlock7 {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters2 } = {}) {
    var _b, _c;
    (_b = parameters2.isConstructed) !== null && _b !== undefined || (parameters2.isConstructed = !!((_c = parameters2.value) === null || _c === undefined ? undefined : _c.length));
    super({
      idBlock: {
        isConstructed: parameters2.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters2.isIndefiniteForm
      },
      ...parameters2
    }, LocalBitStringValueBlock7);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 3;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed7.prototype.onAsciiEncoding.call(this);
    } else {
      const bits = [];
      const valueHex = this.valueBlock.valueHexView;
      for (const byte of valueHex) {
        bits.push(byte.toString(2).padStart(8, "0"));
      }
      const bitsStr = bits.join("");
      const name5 = this.constructor.NAME;
      const value = bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits);
      return `${name5} : ${value}`;
    }
  }
}
_a$q7 = BitString13;
(() => {
  typeStore7.BitString = _a$q7;
})();
BitString13.NAME = BIT_STRING_NAME7;
var _a$p7;
function viewAdd7(first, second) {
  const c = new Uint8Array([0]);
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  let firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value = 0;
  const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
  let counter = 0;
  for (let i = max;i >= 0; i--, counter++) {
    switch (true) {
      case counter < secondViewCopy.length:
        value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
        break;
      default:
        value = firstViewCopy[firstViewCopyLength - counter] + c[0];
    }
    c[0] = value / 10;
    switch (true) {
      case counter >= firstViewCopy.length:
        firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
        break;
      default:
        firstViewCopy[firstViewCopyLength - counter] = value % 10;
    }
  }
  if (c[0] > 0)
    firstViewCopy = utilConcatView(c, firstViewCopy);
  return firstViewCopy;
}
function power27(n) {
  if (n >= powers27.length) {
    for (let p = powers27.length;p <= n; p++) {
      const c = new Uint8Array([0]);
      let digits = powers27[p - 1].slice(0);
      for (let i = digits.length - 1;i >= 0; i--) {
        const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
        c[0] = newValue[0] / 10;
        digits[i] = newValue[0] % 10;
      }
      if (c[0] > 0)
        digits = utilConcatView(c, digits);
      powers27.push(digits);
    }
  }
  return powers27[n];
}
function viewSub7(first, second) {
  let b = 0;
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  const firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value;
  let counter = 0;
  for (let i = secondViewCopyLength;i >= 0; i--, counter++) {
    value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
    switch (true) {
      case value < 0:
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
        break;
      default:
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
    }
  }
  if (b > 0) {
    for (let i = firstViewCopyLength - secondViewCopyLength + 1;i >= 0; i--, counter++) {
      value = firstViewCopy[firstViewCopyLength - counter] - b;
      if (value < 0) {
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
      } else {
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
        break;
      }
    }
  }
  return firstViewCopy.slice();
}

class LocalIntegerValueBlock7 extends HexBlock7(ValueBlock7) {
  setValueHex() {
    if (this.valueHexView.length >= 4) {
      this.warnings.push("Too big Integer for decoding, hex only");
      this.isHexOnly = true;
      this._valueDec = 0;
    } else {
      this.isHexOnly = false;
      if (this.valueHexView.length > 0) {
        this._valueDec = utilDecodeTC.call(this);
      }
    }
  }
  constructor({ value, ...parameters2 } = {}) {
    super(parameters2);
    this._valueDec = 0;
    if (parameters2.valueHex) {
      this.setValueHex();
    }
    if (value !== undefined) {
      this.valueDec = value;
    }
  }
  set valueDec(v) {
    this._valueDec = v;
    this.isHexOnly = false;
    this.valueHexView = new Uint8Array(utilEncodeTC(v));
  }
  get valueDec() {
    return this._valueDec;
  }
  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
    if (offset === -1)
      return offset;
    const view = this.valueHexView;
    if (view[0] === 0 && (view[1] & 128) !== 0) {
      this.valueHexView = view.subarray(1);
    } else {
      if (expectedLength !== 0) {
        if (view.length < expectedLength) {
          if (expectedLength - view.length > 1)
            expectedLength = view.length + 1;
          this.valueHexView = view.subarray(expectedLength - view.length);
        }
      }
    }
    return offset;
  }
  toDER(sizeOnly = false) {
    const view = this.valueHexView;
    switch (true) {
      case (view[0] & 128) !== 0:
        {
          const updatedView = new Uint8Array(this.valueHexView.length + 1);
          updatedView[0] = 0;
          updatedView.set(view, 1);
          this.valueHexView = updatedView;
        }
        break;
      case (view[0] === 0 && (view[1] & 128) === 0):
        {
          this.valueHexView = this.valueHexView.subarray(1);
        }
        break;
    }
    return this.toBER(sizeOnly);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
    if (resultOffset === -1) {
      return resultOffset;
    }
    this.setValueHex();
    return resultOffset;
  }
  toBER(sizeOnly) {
    return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
  toString() {
    const firstBit = this.valueHexView.length * 8 - 1;
    let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
    let bitNumber = 0;
    let currentByte;
    const asn1View = this.valueHexView;
    let result = "";
    let flag = false;
    for (let byteNumber = asn1View.byteLength - 1;byteNumber >= 0; byteNumber--) {
      currentByte = asn1View[byteNumber];
      for (let i = 0;i < 8; i++) {
        if ((currentByte & 1) === 1) {
          switch (bitNumber) {
            case firstBit:
              digits = viewSub7(power27(bitNumber), digits);
              result = "-";
              break;
            default:
              digits = viewAdd7(digits, power27(bitNumber));
          }
        }
        bitNumber++;
        currentByte >>= 1;
      }
    }
    for (let i = 0;i < digits.length; i++) {
      if (digits[i])
        flag = true;
      if (flag)
        result += digitsString7.charAt(digits[i]);
    }
    if (flag === false)
      result += digitsString7.charAt(0);
    return result;
  }
}
_a$p7 = LocalIntegerValueBlock7;
LocalIntegerValueBlock7.NAME = "IntegerValueBlock";
(() => {
  Object.defineProperty(_a$p7.prototype, "valueHex", {
    set: function(v) {
      this.valueHexView = new Uint8Array(v);
      this.setValueHex();
    },
    get: function() {
      return this.valueHexView.slice().buffer;
    }
  });
})();
var _a$o7;

class Integer7 extends BaseBlock7 {
  constructor(parameters2 = {}) {
    super(parameters2, LocalIntegerValueBlock7);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 2;
  }
  toBigInt() {
    assertBigInt7();
    return BigInt(this.valueBlock.toString());
  }
  static fromBigInt(value) {
    assertBigInt7();
    const bigIntValue = BigInt(value);
    const writer = new ViewWriter7;
    const hex = bigIntValue.toString(16).replace(/^-/, "");
    const view = new Uint8Array(Convert.FromHex(hex));
    if (bigIntValue < 0) {
      const first = new Uint8Array(view.length + (view[0] & 128 ? 1 : 0));
      first[0] |= 128;
      const firstInt = BigInt(`0x${Convert.ToHex(first)}`);
      const secondInt = firstInt + bigIntValue;
      const second = BufferSourceConverter.toUint8Array(Convert.FromHex(secondInt.toString(16)));
      second[0] |= 128;
      writer.write(second);
    } else {
      if (view[0] & 128) {
        writer.write(new Uint8Array([0]));
      }
      writer.write(view);
    }
    const res = new _a$o7({ valueHex: writer.final() });
    return res;
  }
  convertToDER() {
    const integer = new _a$o7({ valueHex: this.valueBlock.valueHexView });
    integer.valueBlock.toDER();
    return integer;
  }
  convertFromDER() {
    return new _a$o7({
      valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
    });
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
  }
}
_a$o7 = Integer7;
(() => {
  typeStore7.Integer = _a$o7;
})();
Integer7.NAME = "INTEGER";
var _a$n7;

class Enumerated7 extends Integer7 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 10;
  }
}
_a$n7 = Enumerated7;
(() => {
  typeStore7.Enumerated = _a$n7;
})();
Enumerated7.NAME = "ENUMERATED";

class LocalSidValueBlock7 extends HexBlock7(ValueBlock7) {
  constructor({ valueDec = -1, isFirstSid = false, ...parameters2 } = {}) {
    super(parameters2);
    this.valueDec = valueDec;
    this.isFirstSid = isFirstSid;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams7(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0;i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0;i < this.blockLength; i++) {
      tempView[i] = this.valueHexView[i];
    }
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  set valueBigInt(value) {
    assertBigInt7();
    let bits = BigInt(value).toString(2);
    while (bits.length % 7) {
      bits = "0" + bits;
    }
    const bytes = new Uint8Array(bits.length / 7);
    for (let i = 0;i < bytes.length; i++) {
      bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 128 : 0);
    }
    this.fromBER(bytes.buffer, 0, bytes.length);
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0;i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER7;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0;i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      if (this.isFirstSid) {
        let sidValue = this.valueDec;
        if (this.valueDec <= 39)
          result = "0.";
        else {
          if (this.valueDec <= 79) {
            result = "1.";
            sidValue -= 40;
          } else {
            result = "2.";
            sidValue -= 80;
          }
        }
        result += sidValue.toString();
      } else
        result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec,
      isFirstSid: this.isFirstSid
    };
  }
}
LocalSidValueBlock7.NAME = "sidBlock";

class LocalObjectIdentifierValueBlock7 extends ValueBlock7 {
  constructor({ value = EMPTY_STRING7, ...parameters2 } = {}) {
    super(parameters2);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalSidValueBlock7;
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      if (this.value.length === 0)
        sidBlock.isFirstSid = true;
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly) {
    const retBuffers = [];
    for (let i = 0;i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER7;
      }
      retBuffers.push(valueBuf);
    }
    return concat7(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    let flag = false;
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      if (flag) {
        const sidBlock = this.value[0];
        let plus = 0;
        switch (sidBlock.valueDec) {
          case 0:
            break;
          case 1:
            plus = 40;
            break;
          case 2:
            plus = 80;
            break;
          default:
            this.value = [];
            return;
        }
        const parsedSID = parseInt(sid, 10);
        if (isNaN(parsedSID))
          return;
        sidBlock.valueDec = parsedSID + plus;
        flag = false;
      } else {
        const sidBlock = new LocalSidValueBlock7;
        if (sid > Number.MAX_SAFE_INTEGER) {
          assertBigInt7();
          const sidValue = BigInt(sid);
          sidBlock.valueBigInt = sidValue;
        } else {
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec))
            return;
        }
        if (!this.value.length) {
          sidBlock.isFirstSid = true;
          flag = true;
        }
        this.value.push(sidBlock);
      }
    } while (pos2 !== -1);
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0;i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        if (this.value[i].isFirstSid)
          result = `2.{${sidStr} - 80}`;
        else
          result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0;i < this.value.length; i++) {
      object.sidArray.push(this.value[i].toJSON());
    }
    return object;
  }
}
LocalObjectIdentifierValueBlock7.NAME = "ObjectIdentifierValueBlock";
var _a$m7;

class ObjectIdentifier7 extends BaseBlock7 {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  constructor(parameters2 = {}) {
    super(parameters2, LocalObjectIdentifierValueBlock7);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 6;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$m7 = ObjectIdentifier7;
(() => {
  typeStore7.ObjectIdentifier = _a$m7;
})();
ObjectIdentifier7.NAME = "OBJECT IDENTIFIER";

class LocalRelativeSidValueBlock7 extends HexBlock7(LocalBaseBlock7) {
  constructor({ valueDec = 0, ...parameters2 } = {}) {
    super(parameters2);
    this.valueDec = valueDec;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (inputLength === 0)
      return inputOffset;
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams7(this, inputView, inputOffset, inputLength))
      return -1;
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0;i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0;i < this.blockLength; i++)
      tempView[i] = this.valueHexView[i];
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0;i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER7;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0;i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView.buffer;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
}
LocalRelativeSidValueBlock7.NAME = "relativeSidBlock";

class LocalRelativeObjectIdentifierValueBlock7 extends ValueBlock7 {
  constructor({ value = EMPTY_STRING7, ...parameters2 } = {}) {
    super(parameters2);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalRelativeSidValueBlock7;
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly, _writer) {
    const retBuffers = [];
    for (let i = 0;i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER7;
      }
      retBuffers.push(valueBuf);
    }
    return concat7(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      const sidBlock = new LocalRelativeSidValueBlock7;
      sidBlock.valueDec = parseInt(sid, 10);
      if (isNaN(sidBlock.valueDec))
        return true;
      this.value.push(sidBlock);
    } while (pos2 !== -1);
    return true;
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0;i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0;i < this.value.length; i++)
      object.sidArray.push(this.value[i].toJSON());
    return object;
  }
}
LocalRelativeObjectIdentifierValueBlock7.NAME = "RelativeObjectIdentifierValueBlock";
var _a$l7;

class RelativeObjectIdentifier7 extends BaseBlock7 {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  constructor(parameters2 = {}) {
    super(parameters2, LocalRelativeObjectIdentifierValueBlock7);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 13;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$l7 = RelativeObjectIdentifier7;
(() => {
  typeStore7.RelativeObjectIdentifier = _a$l7;
})();
RelativeObjectIdentifier7.NAME = "RelativeObjectIdentifier";
var _a$k7;

class Sequence7 extends Constructed7 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 16;
  }
}
_a$k7 = Sequence7;
(() => {
  typeStore7.Sequence = _a$k7;
})();
Sequence7.NAME = "SEQUENCE";
var _a$j7;

class Set8 extends Constructed7 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 17;
  }
}
_a$j7 = Set8;
(() => {
  typeStore7.Set = _a$j7;
})();
Set8.NAME = "SET";

class LocalStringValueBlock7 extends HexBlock7(ValueBlock7) {
  constructor({ ...parameters2 } = {}) {
    super(parameters2);
    this.isHexOnly = true;
    this.value = EMPTY_STRING7;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalStringValueBlock7.NAME = "StringValueBlock";

class LocalSimpleStringValueBlock7 extends LocalStringValueBlock7 {
}
LocalSimpleStringValueBlock7.NAME = "SimpleStringValueBlock";

class LocalSimpleStringBlock7 extends BaseStringBlock7 {
  constructor({ ...parameters2 } = {}) {
    super(parameters2, LocalSimpleStringValueBlock7);
  }
  fromBuffer(inputBuffer) {
    this.valueBlock.value = String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer));
  }
  fromString(inputString) {
    const strLen = inputString.length;
    const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
    for (let i = 0;i < strLen; i++)
      view[i] = inputString.charCodeAt(i);
    this.valueBlock.value = inputString;
  }
}
LocalSimpleStringBlock7.NAME = "SIMPLE STRING";

class LocalUtf8StringValueBlock7 extends LocalSimpleStringBlock7 {
  fromBuffer(inputBuffer) {
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
    try {
      this.valueBlock.value = Convert.ToUtf8String(inputBuffer);
    } catch (ex) {
      this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
      this.valueBlock.value = Convert.ToBinary(inputBuffer);
    }
  }
  fromString(inputString) {
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf8String(inputString));
    this.valueBlock.value = inputString;
  }
}
LocalUtf8StringValueBlock7.NAME = "Utf8StringValueBlock";
var _a$i7;

class Utf8String7 extends LocalUtf8StringValueBlock7 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 12;
  }
}
_a$i7 = Utf8String7;
(() => {
  typeStore7.Utf8String = _a$i7;
})();
Utf8String7.NAME = "UTF8String";

class LocalBmpStringValueBlock7 extends LocalSimpleStringBlock7 {
  fromBuffer(inputBuffer) {
    this.valueBlock.value = Convert.ToUtf16String(inputBuffer);
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
  }
  fromString(inputString) {
    this.valueBlock.value = inputString;
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf16String(inputString));
  }
}
LocalBmpStringValueBlock7.NAME = "BmpStringValueBlock";
var _a$h7;

class BmpString7 extends LocalBmpStringValueBlock7 {
  constructor({ ...parameters2 } = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 30;
  }
}
_a$h7 = BmpString7;
(() => {
  typeStore7.BmpString = _a$h7;
})();
BmpString7.NAME = "BMPString";

class LocalUniversalStringValueBlock7 extends LocalSimpleStringBlock7 {
  fromBuffer(inputBuffer) {
    const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
    const valueView = new Uint8Array(copyBuffer);
    for (let i = 0;i < valueView.length; i += 4) {
      valueView[i] = valueView[i + 3];
      valueView[i + 1] = valueView[i + 2];
      valueView[i + 2] = 0;
      valueView[i + 3] = 0;
    }
    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
  }
  fromString(inputString) {
    const strLength = inputString.length;
    const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
    for (let i = 0;i < strLength; i++) {
      const codeBuf = utilToBase(inputString.charCodeAt(i), 8);
      const codeView = new Uint8Array(codeBuf);
      if (codeView.length > 4)
        continue;
      const dif = 4 - codeView.length;
      for (let j = codeView.length - 1;j >= 0; j--)
        valueHexView[i * 4 + j + dif] = codeView[j];
    }
    this.valueBlock.value = inputString;
  }
}
LocalUniversalStringValueBlock7.NAME = "UniversalStringValueBlock";
var _a$g7;

class UniversalString7 extends LocalUniversalStringValueBlock7 {
  constructor({ ...parameters2 } = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 28;
  }
}
_a$g7 = UniversalString7;
(() => {
  typeStore7.UniversalString = _a$g7;
})();
UniversalString7.NAME = "UniversalString";
var _a$f7;

class NumericString7 extends LocalSimpleStringBlock7 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 18;
  }
}
_a$f7 = NumericString7;
(() => {
  typeStore7.NumericString = _a$f7;
})();
NumericString7.NAME = "NumericString";
var _a$e7;

class PrintableString7 extends LocalSimpleStringBlock7 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 19;
  }
}
_a$e7 = PrintableString7;
(() => {
  typeStore7.PrintableString = _a$e7;
})();
PrintableString7.NAME = "PrintableString";
var _a$d7;

class TeletexString7 extends LocalSimpleStringBlock7 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 20;
  }
}
_a$d7 = TeletexString7;
(() => {
  typeStore7.TeletexString = _a$d7;
})();
TeletexString7.NAME = "TeletexString";
var _a$c7;

class VideotexString7 extends LocalSimpleStringBlock7 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 21;
  }
}
_a$c7 = VideotexString7;
(() => {
  typeStore7.VideotexString = _a$c7;
})();
VideotexString7.NAME = "VideotexString";
var _a$b7;

class IA5String7 extends LocalSimpleStringBlock7 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 22;
  }
}
_a$b7 = IA5String7;
(() => {
  typeStore7.IA5String = _a$b7;
})();
IA5String7.NAME = "IA5String";
var _a$a7;

class GraphicString7 extends LocalSimpleStringBlock7 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 25;
  }
}
_a$a7 = GraphicString7;
(() => {
  typeStore7.GraphicString = _a$a7;
})();
GraphicString7.NAME = "GraphicString";
var _a$97;

class VisibleString7 extends LocalSimpleStringBlock7 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 26;
  }
}
_a$97 = VisibleString7;
(() => {
  typeStore7.VisibleString = _a$97;
})();
VisibleString7.NAME = "VisibleString";
var _a$87;

class GeneralString7 extends LocalSimpleStringBlock7 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 27;
  }
}
_a$87 = GeneralString7;
(() => {
  typeStore7.GeneralString = _a$87;
})();
GeneralString7.NAME = "GeneralString";
var _a$77;

class CharacterString7 extends LocalSimpleStringBlock7 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 29;
  }
}
_a$77 = CharacterString7;
(() => {
  typeStore7.CharacterString = _a$77;
})();
CharacterString7.NAME = "CharacterString";
var _a$67;

class UTCTime7 extends VisibleString7 {
  constructor({ value, valueDate, ...parameters2 } = {}) {
    super(parameters2);
    this.year = 0;
    this.month = 0;
    this.day = 0;
    this.hour = 0;
    this.minute = 0;
    this.second = 0;
    if (value) {
      this.fromString(value);
      this.valueBlock.valueHexView = new Uint8Array(value.length);
      for (let i = 0;i < value.length; i++)
        this.valueBlock.valueHexView[i] = value.charCodeAt(i);
    }
    if (valueDate) {
      this.fromDate(valueDate);
      this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
    }
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 23;
  }
  fromBuffer(inputBuffer) {
    this.fromString(String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer)));
  }
  toBuffer() {
    const str = this.toString();
    const buffer = new ArrayBuffer(str.length);
    const view = new Uint8Array(buffer);
    for (let i = 0;i < str.length; i++)
      view[i] = str.charCodeAt(i);
    return buffer;
  }
  fromDate(inputDate) {
    this.year = inputDate.getUTCFullYear();
    this.month = inputDate.getUTCMonth() + 1;
    this.day = inputDate.getUTCDate();
    this.hour = inputDate.getUTCHours();
    this.minute = inputDate.getUTCMinutes();
    this.second = inputDate.getUTCSeconds();
  }
  toDate() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
  }
  fromString(inputString) {
    const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
    const parserArray = parser.exec(inputString);
    if (parserArray === null) {
      this.error = "Wrong input string for conversion";
      return;
    }
    const year = parseInt(parserArray[1], 10);
    if (year >= 50)
      this.year = 1900 + year;
    else
      this.year = 2000 + year;
    this.month = parseInt(parserArray[2], 10);
    this.day = parseInt(parserArray[3], 10);
    this.hour = parseInt(parserArray[4], 10);
    this.minute = parseInt(parserArray[5], 10);
    this.second = parseInt(parserArray[6], 10);
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = new Array(7);
      outputArray[0] = padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);
      outputArray[1] = padNumber(this.month, 2);
      outputArray[2] = padNumber(this.day, 2);
      outputArray[3] = padNumber(this.hour, 2);
      outputArray[4] = padNumber(this.minute, 2);
      outputArray[5] = padNumber(this.second, 2);
      outputArray[6] = "Z";
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second
    };
  }
}
_a$67 = UTCTime7;
(() => {
  typeStore7.UTCTime = _a$67;
})();
UTCTime7.NAME = "UTCTime";
var _a$57;

class GeneralizedTime7 extends UTCTime7 {
  constructor(parameters2 = {}) {
    var _b;
    super(parameters2);
    (_b = this.millisecond) !== null && _b !== undefined || (this.millisecond = 0);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 24;
  }
  fromDate(inputDate) {
    super.fromDate(inputDate);
    this.millisecond = inputDate.getUTCMilliseconds();
  }
  toDate() {
    const utcDate = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond);
    return new Date(utcDate);
  }
  fromString(inputString) {
    let isUTC = false;
    let timeString = "";
    let dateTimeString = "";
    let fractionPart = 0;
    let parser;
    let hourDifference = 0;
    let minuteDifference = 0;
    if (inputString[inputString.length - 1] === "Z") {
      timeString = inputString.substring(0, inputString.length - 1);
      isUTC = true;
    } else {
      const number = new Number(inputString[inputString.length - 1]);
      if (isNaN(number.valueOf()))
        throw new Error("Wrong input string for conversion");
      timeString = inputString;
    }
    if (isUTC) {
      if (timeString.indexOf("+") !== -1)
        throw new Error("Wrong input string for conversion");
      if (timeString.indexOf("-") !== -1)
        throw new Error("Wrong input string for conversion");
    } else {
      let multiplier = 1;
      let differencePosition = timeString.indexOf("+");
      let differenceString = "";
      if (differencePosition === -1) {
        differencePosition = timeString.indexOf("-");
        multiplier = -1;
      }
      if (differencePosition !== -1) {
        differenceString = timeString.substring(differencePosition + 1);
        timeString = timeString.substring(0, differencePosition);
        if (differenceString.length !== 2 && differenceString.length !== 4)
          throw new Error("Wrong input string for conversion");
        let number = parseInt(differenceString.substring(0, 2), 10);
        if (isNaN(number.valueOf()))
          throw new Error("Wrong input string for conversion");
        hourDifference = multiplier * number;
        if (differenceString.length === 4) {
          number = parseInt(differenceString.substring(2, 4), 10);
          if (isNaN(number.valueOf()))
            throw new Error("Wrong input string for conversion");
          minuteDifference = multiplier * number;
        }
      }
    }
    let fractionPointPosition = timeString.indexOf(".");
    if (fractionPointPosition === -1)
      fractionPointPosition = timeString.indexOf(",");
    if (fractionPointPosition !== -1) {
      const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
      if (isNaN(fractionPartCheck.valueOf()))
        throw new Error("Wrong input string for conversion");
      fractionPart = fractionPartCheck.valueOf();
      dateTimeString = timeString.substring(0, fractionPointPosition);
    } else
      dateTimeString = timeString;
    switch (true) {
      case dateTimeString.length === 8:
        parser = /(\d{4})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1)
          throw new Error("Wrong input string for conversion");
        break;
      case dateTimeString.length === 10:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.minute = Math.floor(fractionResult);
          fractionResult = 60 * (fractionResult - this.minute);
          this.second = Math.floor(fractionResult);
          fractionResult = 1000 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 12:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.second = Math.floor(fractionResult);
          fractionResult = 1000 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 14:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          const fractionResult = 1000 * fractionPart;
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      default:
        throw new Error("Wrong input string for conversion");
    }
    const parserArray = parser.exec(dateTimeString);
    if (parserArray === null)
      throw new Error("Wrong input string for conversion");
    for (let j = 1;j < parserArray.length; j++) {
      switch (j) {
        case 1:
          this.year = parseInt(parserArray[j], 10);
          break;
        case 2:
          this.month = parseInt(parserArray[j], 10);
          break;
        case 3:
          this.day = parseInt(parserArray[j], 10);
          break;
        case 4:
          this.hour = parseInt(parserArray[j], 10) + hourDifference;
          break;
        case 5:
          this.minute = parseInt(parserArray[j], 10) + minuteDifference;
          break;
        case 6:
          this.second = parseInt(parserArray[j], 10);
          break;
        default:
          throw new Error("Wrong input string for conversion");
      }
    }
    if (isUTC === false) {
      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
      this.year = tempDate.getUTCFullYear();
      this.month = tempDate.getUTCMonth();
      this.day = tempDate.getUTCDay();
      this.hour = tempDate.getUTCHours();
      this.minute = tempDate.getUTCMinutes();
      this.second = tempDate.getUTCSeconds();
      this.millisecond = tempDate.getUTCMilliseconds();
    }
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = [];
      outputArray.push(padNumber(this.year, 4));
      outputArray.push(padNumber(this.month, 2));
      outputArray.push(padNumber(this.day, 2));
      outputArray.push(padNumber(this.hour, 2));
      outputArray.push(padNumber(this.minute, 2));
      outputArray.push(padNumber(this.second, 2));
      if (this.millisecond !== 0) {
        outputArray.push(".");
        outputArray.push(padNumber(this.millisecond, 3));
      }
      outputArray.push("Z");
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  toJSON() {
    return {
      ...super.toJSON(),
      millisecond: this.millisecond
    };
  }
}
_a$57 = GeneralizedTime7;
(() => {
  typeStore7.GeneralizedTime = _a$57;
})();
GeneralizedTime7.NAME = "GeneralizedTime";
var _a$47;

class DATE7 extends Utf8String7 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 31;
  }
}
_a$47 = DATE7;
(() => {
  typeStore7.DATE = _a$47;
})();
DATE7.NAME = "DATE";
var _a$37;

class TimeOfDay7 extends Utf8String7 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 32;
  }
}
_a$37 = TimeOfDay7;
(() => {
  typeStore7.TimeOfDay = _a$37;
})();
TimeOfDay7.NAME = "TimeOfDay";
var _a$27;

class DateTime7 extends Utf8String7 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 33;
  }
}
_a$27 = DateTime7;
(() => {
  typeStore7.DateTime = _a$27;
})();
DateTime7.NAME = "DateTime";
var _a$17;

class Duration7 extends Utf8String7 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 34;
  }
}
_a$17 = Duration7;
(() => {
  typeStore7.Duration = _a$17;
})();
Duration7.NAME = "Duration";
var _a7;

class TIME7 extends Utf8String7 {
  constructor(parameters2 = {}) {
    super(parameters2);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 14;
  }
}
_a7 = TIME7;
(() => {
  typeStore7.TIME = _a7;
})();
TIME7.NAME = "TIME";

class Any7 {
  constructor({ name: name5 = EMPTY_STRING7, optional = false } = {}) {
    this.name = name5;
    this.optional = optional;
  }
}

class Choice7 extends Any7 {
  constructor({ value = [], ...parameters2 } = {}) {
    super(parameters2);
    this.value = value;
  }
}

class Repeated7 extends Any7 {
  constructor({ value = new Any7, local = false, ...parameters2 } = {}) {
    super(parameters2);
    this.value = value;
    this.local = local;
  }
}

class RawData7 {
  get data() {
    return this.dataView.slice().buffer;
  }
  set data(value) {
    this.dataView = BufferSourceConverter.toUint8Array(value);
  }
  constructor({ data = EMPTY_VIEW7 } = {}) {
    this.dataView = BufferSourceConverter.toUint8Array(data);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const endLength = inputOffset + inputLength;
    this.dataView = BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
    return endLength;
  }
  toBER(_sizeOnly) {
    return this.dataView.slice().buffer;
  }
}
function compareSchema7(root, inputData, inputSchema) {
  if (inputSchema instanceof Choice7) {
    for (const element of inputSchema.value) {
      const result = compareSchema7(root, inputData, element);
      if (result.verified) {
        return {
          verified: true,
          result: root
        };
      }
    }
    {
      const _result = {
        verified: false,
        result: { error: "Wrong values for Choice type" }
      };
      if (inputSchema.hasOwnProperty(NAME7))
        _result.name = inputSchema.name;
      return _result;
    }
  }
  if (inputSchema instanceof Any7) {
    if (inputSchema.hasOwnProperty(NAME7))
      root[inputSchema.name] = inputData;
    return {
      verified: true,
      result: root
    };
  }
  if (root instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong root object" }
    };
  }
  if (inputData instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 data" }
    };
  }
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (ID_BLOCK7 in inputSchema === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (FROM_BER7 in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (TO_BER7 in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  const encodedId = inputSchema.idBlock.toBER(false);
  if (encodedId.byteLength === 0) {
    return {
      verified: false,
      result: { error: "Error encoding idBlock for ASN.1 schema" }
    };
  }
  const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
  if (decodedOffset === -1) {
    return {
      verified: false,
      result: { error: "Error decoding idBlock for ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS7) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER7) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED7) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
    return {
      verified: false,
      result: root
    };
  }
  if (!(IS_HEX_ONLY7 in inputSchema.idBlock)) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.isHexOnly) {
    if (VALUE_HEX_VIEW7 in inputSchema.idBlock === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    const schemaView = inputSchema.idBlock.valueHexView;
    const asn1View = inputData.idBlock.valueHexView;
    if (schemaView.length !== asn1View.length) {
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0;i < schemaView.length; i++) {
      if (schemaView[i] !== asn1View[1]) {
        return {
          verified: false,
          result: root
        };
      }
    }
  }
  if (inputSchema.name) {
    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING7);
    if (inputSchema.name)
      root[inputSchema.name] = inputData;
  }
  if (inputSchema instanceof typeStore7.Constructed) {
    let admission = 0;
    let result = {
      verified: false,
      result: { error: "Unknown error" }
    };
    let maxLength = inputSchema.valueBlock.value.length;
    if (maxLength > 0) {
      if (inputSchema.valueBlock.value[0] instanceof Repeated7) {
        maxLength = inputData.valueBlock.value.length;
      }
    }
    if (maxLength === 0) {
      return {
        verified: true,
        result: root
      };
    }
    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
      let _optional = true;
      for (let i = 0;i < inputSchema.valueBlock.value.length; i++)
        _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);
      if (_optional) {
        return {
          verified: true,
          result: root
        };
      }
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING7);
        if (inputSchema.name)
          delete root[inputSchema.name];
      }
      root.error = "Inconsistent object length";
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0;i < maxLength; i++) {
      if (i - admission >= inputData.valueBlock.value.length) {
        if (inputSchema.valueBlock.value[i].optional === false) {
          const _result = {
            verified: false,
            result: root
          };
          root.error = "Inconsistent length between ASN.1 data and schema";
          if (inputSchema.name) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING7);
            if (inputSchema.name) {
              delete root[inputSchema.name];
              _result.name = inputSchema.name;
            }
          }
          return _result;
        }
      } else {
        if (inputSchema.valueBlock.value[0] instanceof Repeated7) {
          result = compareSchema7(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[0].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING7);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
          if (NAME7 in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
            let arrayRoot = {};
            if (LOCAL7 in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local)
              arrayRoot = inputData;
            else
              arrayRoot = root;
            if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
              arrayRoot[inputSchema.valueBlock.value[0].name] = [];
            arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
          }
        } else {
          result = compareSchema7(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[i].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING7);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
        }
      }
    }
    if (result.verified === false) {
      const _result = {
        verified: false,
        result: root
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING7);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return {
      verified: true,
      result: root
    };
  }
  if (inputSchema.primitiveSchema && VALUE_HEX_VIEW7 in inputData.valueBlock) {
    const asn1 = localFromBER7(inputData.valueBlock.valueHexView);
    if (asn1.offset === -1) {
      const _result = {
        verified: false,
        result: asn1.result
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING7);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return compareSchema7(root, asn1.result, inputSchema.primitiveSchema);
  }
  return {
    verified: true,
    result: root
  };
}
function verifySchema7(inputBuffer, inputSchema) {
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema type" }
    };
  }
  const asn1 = localFromBER7(BufferSourceConverter.toUint8Array(inputBuffer));
  if (asn1.offset === -1) {
    return {
      verified: false,
      result: asn1.result
    };
  }
  return compareSchema7(asn1.result, asn1.result, inputSchema);
}

// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-schema/build/es2015/enums.js
var AsnTypeTypes7;
(function(AsnTypeTypes8) {
  AsnTypeTypes8[AsnTypeTypes8["Sequence"] = 0] = "Sequence";
  AsnTypeTypes8[AsnTypeTypes8["Set"] = 1] = "Set";
  AsnTypeTypes8[AsnTypeTypes8["Choice"] = 2] = "Choice";
})(AsnTypeTypes7 || (AsnTypeTypes7 = {}));
var AsnPropTypes7;
(function(AsnPropTypes8) {
  AsnPropTypes8[AsnPropTypes8["Any"] = 1] = "Any";
  AsnPropTypes8[AsnPropTypes8["Boolean"] = 2] = "Boolean";
  AsnPropTypes8[AsnPropTypes8["OctetString"] = 3] = "OctetString";
  AsnPropTypes8[AsnPropTypes8["BitString"] = 4] = "BitString";
  AsnPropTypes8[AsnPropTypes8["Integer"] = 5] = "Integer";
  AsnPropTypes8[AsnPropTypes8["Enumerated"] = 6] = "Enumerated";
  AsnPropTypes8[AsnPropTypes8["ObjectIdentifier"] = 7] = "ObjectIdentifier";
  AsnPropTypes8[AsnPropTypes8["Utf8String"] = 8] = "Utf8String";
  AsnPropTypes8[AsnPropTypes8["BmpString"] = 9] = "BmpString";
  AsnPropTypes8[AsnPropTypes8["UniversalString"] = 10] = "UniversalString";
  AsnPropTypes8[AsnPropTypes8["NumericString"] = 11] = "NumericString";
  AsnPropTypes8[AsnPropTypes8["PrintableString"] = 12] = "PrintableString";
  AsnPropTypes8[AsnPropTypes8["TeletexString"] = 13] = "TeletexString";
  AsnPropTypes8[AsnPropTypes8["VideotexString"] = 14] = "VideotexString";
  AsnPropTypes8[AsnPropTypes8["IA5String"] = 15] = "IA5String";
  AsnPropTypes8[AsnPropTypes8["GraphicString"] = 16] = "GraphicString";
  AsnPropTypes8[AsnPropTypes8["VisibleString"] = 17] = "VisibleString";
  AsnPropTypes8[AsnPropTypes8["GeneralString"] = 18] = "GeneralString";
  AsnPropTypes8[AsnPropTypes8["CharacterString"] = 19] = "CharacterString";
  AsnPropTypes8[AsnPropTypes8["UTCTime"] = 20] = "UTCTime";
  AsnPropTypes8[AsnPropTypes8["GeneralizedTime"] = 21] = "GeneralizedTime";
  AsnPropTypes8[AsnPropTypes8["DATE"] = 22] = "DATE";
  AsnPropTypes8[AsnPropTypes8["TimeOfDay"] = 23] = "TimeOfDay";
  AsnPropTypes8[AsnPropTypes8["DateTime"] = 24] = "DateTime";
  AsnPropTypes8[AsnPropTypes8["Duration"] = 25] = "Duration";
  AsnPropTypes8[AsnPropTypes8["TIME"] = 26] = "TIME";
  AsnPropTypes8[AsnPropTypes8["Null"] = 27] = "Null";
})(AsnPropTypes7 || (AsnPropTypes7 = {}));

// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-schema/build/es2015/types/bit_string.js
class BitString14 {
  constructor(params, unusedBits = 0) {
    this.unusedBits = 0;
    this.value = new ArrayBuffer(0);
    if (params) {
      if (typeof params === "number") {
        this.fromNumber(params);
      } else if (BufferSourceConverter.isBufferSource(params)) {
        this.unusedBits = unusedBits;
        this.value = BufferSourceConverter.toArrayBuffer(params);
      } else {
        throw TypeError("Unsupported type of 'params' argument for BitString");
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof BitString13)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 BitString");
    }
    this.unusedBits = asn.valueBlock.unusedBits;
    this.value = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new BitString13({ unusedBits: this.unusedBits, valueHex: this.value });
  }
  toSchema(name5) {
    return new BitString13({ name: name5 });
  }
  toNumber() {
    let res = "";
    const uintArray = new Uint8Array(this.value);
    for (const octet of uintArray) {
      res += octet.toString(2).padStart(8, "0");
    }
    res = res.split("").reverse().join("");
    if (this.unusedBits) {
      res = res.slice(this.unusedBits).padStart(this.unusedBits, "0");
    }
    return parseInt(res, 2);
  }
  fromNumber(value) {
    let bits = value.toString(2);
    const octetSize = bits.length + 7 >> 3;
    this.unusedBits = (octetSize << 3) - bits.length;
    const octets = new Uint8Array(octetSize);
    bits = bits.padStart(octetSize << 3, "0").split("").reverse().join("");
    let index = 0;
    while (index < octetSize) {
      octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);
      index++;
    }
    this.value = octets.buffer;
  }
}
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-schema/build/es2015/types/octet_string.js
class OctetString14 {
  get byteLength() {
    return this.buffer.byteLength;
  }
  get byteOffset() {
    return 0;
  }
  constructor(param) {
    if (typeof param === "number") {
      this.buffer = new ArrayBuffer(param);
    } else {
      if (BufferSourceConverter.isBufferSource(param)) {
        this.buffer = BufferSourceConverter.toArrayBuffer(param);
      } else if (Array.isArray(param)) {
        this.buffer = new Uint8Array(param);
      } else {
        this.buffer = new ArrayBuffer(0);
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof OctetString13)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString");
    }
    this.buffer = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new OctetString13({ valueHex: this.buffer });
  }
  toSchema(name5) {
    return new OctetString13({ name: name5 });
  }
}
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-schema/build/es2015/converters.js
var AsnAnyConverter7 = {
  fromASN: (value) => value instanceof Null7 ? null : value.valueBeforeDecodeView,
  toASN: (value) => {
    if (value === null) {
      return new Null7;
    }
    const schema = fromBER7(value);
    if (schema.result.error) {
      throw new Error(schema.result.error);
    }
    return schema.result;
  }
};
var AsnIntegerConverter7 = {
  fromASN: (value) => value.valueBlock.valueHexView.byteLength >= 4 ? value.valueBlock.toString() : value.valueBlock.valueDec,
  toASN: (value) => new Integer7({ value: +value })
};
var AsnEnumeratedConverter7 = {
  fromASN: (value) => value.valueBlock.valueDec,
  toASN: (value) => new Enumerated7({ value })
};
var AsnIntegerArrayBufferConverter7 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new Integer7({ valueHex: value })
};
var AsnBitStringConverter7 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new BitString13({ valueHex: value })
};
var AsnObjectIdentifierConverter7 = {
  fromASN: (value) => value.valueBlock.toString(),
  toASN: (value) => new ObjectIdentifier7({ value })
};
var AsnBooleanConverter7 = {
  fromASN: (value) => value.valueBlock.value,
  toASN: (value) => new Boolean8({ value })
};
var AsnOctetStringConverter7 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new OctetString13({ valueHex: value })
};
function createStringConverter7(Asn1Type) {
  return {
    fromASN: (value) => value.valueBlock.value,
    toASN: (value) => new Asn1Type({ value })
  };
}
var AsnUtf8StringConverter7 = createStringConverter7(Utf8String7);
var AsnBmpStringConverter7 = createStringConverter7(BmpString7);
var AsnUniversalStringConverter7 = createStringConverter7(UniversalString7);
var AsnNumericStringConverter7 = createStringConverter7(NumericString7);
var AsnPrintableStringConverter7 = createStringConverter7(PrintableString7);
var AsnTeletexStringConverter7 = createStringConverter7(TeletexString7);
var AsnVideotexStringConverter7 = createStringConverter7(VideotexString7);
var AsnIA5StringConverter7 = createStringConverter7(IA5String7);
var AsnGraphicStringConverter7 = createStringConverter7(GraphicString7);
var AsnVisibleStringConverter7 = createStringConverter7(VisibleString7);
var AsnGeneralStringConverter7 = createStringConverter7(GeneralString7);
var AsnCharacterStringConverter7 = createStringConverter7(CharacterString7);
var AsnUTCTimeConverter7 = {
  fromASN: (value) => value.toDate(),
  toASN: (value) => new UTCTime7({ valueDate: value })
};
var AsnGeneralizedTimeConverter7 = {
  fromASN: (value) => value.toDate(),
  toASN: (value) => new GeneralizedTime7({ valueDate: value })
};
var AsnNullConverter7 = {
  fromASN: () => null,
  toASN: () => {
    return new Null7;
  }
};
function defaultConverter7(type) {
  switch (type) {
    case AsnPropTypes7.Any:
      return AsnAnyConverter7;
    case AsnPropTypes7.BitString:
      return AsnBitStringConverter7;
    case AsnPropTypes7.BmpString:
      return AsnBmpStringConverter7;
    case AsnPropTypes7.Boolean:
      return AsnBooleanConverter7;
    case AsnPropTypes7.CharacterString:
      return AsnCharacterStringConverter7;
    case AsnPropTypes7.Enumerated:
      return AsnEnumeratedConverter7;
    case AsnPropTypes7.GeneralString:
      return AsnGeneralStringConverter7;
    case AsnPropTypes7.GeneralizedTime:
      return AsnGeneralizedTimeConverter7;
    case AsnPropTypes7.GraphicString:
      return AsnGraphicStringConverter7;
    case AsnPropTypes7.IA5String:
      return AsnIA5StringConverter7;
    case AsnPropTypes7.Integer:
      return AsnIntegerConverter7;
    case AsnPropTypes7.Null:
      return AsnNullConverter7;
    case AsnPropTypes7.NumericString:
      return AsnNumericStringConverter7;
    case AsnPropTypes7.ObjectIdentifier:
      return AsnObjectIdentifierConverter7;
    case AsnPropTypes7.OctetString:
      return AsnOctetStringConverter7;
    case AsnPropTypes7.PrintableString:
      return AsnPrintableStringConverter7;
    case AsnPropTypes7.TeletexString:
      return AsnTeletexStringConverter7;
    case AsnPropTypes7.UTCTime:
      return AsnUTCTimeConverter7;
    case AsnPropTypes7.UniversalString:
      return AsnUniversalStringConverter7;
    case AsnPropTypes7.Utf8String:
      return AsnUtf8StringConverter7;
    case AsnPropTypes7.VideotexString:
      return AsnVideotexStringConverter7;
    case AsnPropTypes7.VisibleString:
      return AsnVisibleStringConverter7;
    default:
      return null;
  }
}
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-schema/build/es2015/helper.js
function isConvertible7(target2) {
  if (typeof target2 === "function" && target2.prototype) {
    if (target2.prototype.toASN && target2.prototype.fromASN) {
      return true;
    } else {
      return isConvertible7(target2.prototype);
    }
  } else {
    return !!(target2 && typeof target2 === "object" && ("toASN" in target2) && ("fromASN" in target2));
  }
}

// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-schema/build/es2015/schema.js
class AsnSchemaStorage7 {
  constructor() {
    this.items = new WeakMap;
  }
  has(target2) {
    return this.items.has(target2);
  }
  get(target2, checkSchema = false) {
    const schema = this.items.get(target2);
    if (!schema) {
      throw new Error(`Cannot get schema for '${target2.prototype.constructor.name}' target`);
    }
    if (checkSchema && !schema.schema) {
      throw new Error(`Schema '${target2.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);
    }
    return schema;
  }
  cache(target2) {
    const schema = this.get(target2);
    if (!schema.schema) {
      schema.schema = this.create(target2, true);
    }
  }
  createDefault(target2) {
    const schema = { type: AsnTypeTypes7.Sequence, items: {} };
    const parentSchema = this.findParentSchema(target2);
    if (parentSchema) {
      Object.assign(schema, parentSchema);
      schema.items = Object.assign({}, schema.items, parentSchema.items);
    }
    return schema;
  }
  create(target2, useNames) {
    const schema = this.items.get(target2) || this.createDefault(target2);
    const asn1Value = [];
    for (const key in schema.items) {
      const item = schema.items[key];
      const name5 = useNames ? key : "";
      let asn1Item;
      if (typeof item.type === "number") {
        const Asn1TypeName = AsnPropTypes7[item.type];
        const Asn1Type = exports_index_es8[Asn1TypeName];
        if (!Asn1Type) {
          throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
        }
        asn1Item = new Asn1Type({ name: name5 });
      } else if (isConvertible7(item.type)) {
        const instance2 = new item.type;
        asn1Item = instance2.toSchema(name5);
      } else if (item.optional) {
        const itemSchema = this.get(item.type);
        if (itemSchema.type === AsnTypeTypes7.Choice) {
          asn1Item = new Any7({ name: name5 });
        } else {
          asn1Item = this.create(item.type, false);
          asn1Item.name = name5;
        }
      } else {
        asn1Item = new Any7({ name: name5 });
      }
      const optional = !!item.optional || item.defaultValue !== undefined;
      if (item.repeated) {
        asn1Item.name = "";
        const Container = item.repeated === "set" ? Set8 : Sequence7;
        asn1Item = new Container({
          name: "",
          value: [new Repeated7({ name: name5, value: asn1Item })]
        });
      }
      if (item.context !== null && item.context !== undefined) {
        if (item.implicit) {
          if (typeof item.type === "number" || isConvertible7(item.type)) {
            const Container = item.repeated ? Constructed7 : Primitive7;
            asn1Value.push(new Container({ name: name5, optional, idBlock: { tagClass: 3, tagNumber: item.context } }));
          } else {
            this.cache(item.type);
            const isRepeated = !!item.repeated;
            let value = !isRepeated ? this.get(item.type, true).schema : asn1Item;
            value = "valueBlock" in value ? value.valueBlock.value : value.value;
            asn1Value.push(new Constructed7({
              name: !isRepeated ? name5 : "",
              optional,
              idBlock: { tagClass: 3, tagNumber: item.context },
              value
            }));
          }
        } else {
          asn1Value.push(new Constructed7({
            optional,
            idBlock: { tagClass: 3, tagNumber: item.context },
            value: [asn1Item]
          }));
        }
      } else {
        asn1Item.optional = optional;
        asn1Value.push(asn1Item);
      }
    }
    switch (schema.type) {
      case AsnTypeTypes7.Sequence:
        return new Sequence7({ value: asn1Value, name: "" });
      case AsnTypeTypes7.Set:
        return new Set8({ value: asn1Value, name: "" });
      case AsnTypeTypes7.Choice:
        return new Choice7({ value: asn1Value, name: "" });
      default:
        throw new Error(`Unsupported ASN1 type in use`);
    }
  }
  set(target2, schema) {
    this.items.set(target2, schema);
    return this;
  }
  findParentSchema(target2) {
    const parent = Object.getPrototypeOf(target2);
    if (parent) {
      const schema = this.items.get(parent);
      return schema || this.findParentSchema(parent);
    }
    return null;
  }
}

// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-schema/build/es2015/storage.js
var schemaStorage7 = new AsnSchemaStorage7;

// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-schema/build/es2015/decorators.js
var AsnType7 = (options) => (target2) => {
  let schema;
  if (!schemaStorage7.has(target2)) {
    schema = schemaStorage7.createDefault(target2);
    schemaStorage7.set(target2, schema);
  } else {
    schema = schemaStorage7.get(target2);
  }
  Object.assign(schema, options);
};
var AsnProp7 = (options) => (target2, propertyKey) => {
  let schema;
  if (!schemaStorage7.has(target2.constructor)) {
    schema = schemaStorage7.createDefault(target2.constructor);
    schemaStorage7.set(target2.constructor, schema);
  } else {
    schema = schemaStorage7.get(target2.constructor);
  }
  const copyOptions = Object.assign({}, options);
  if (typeof copyOptions.type === "number" && !copyOptions.converter) {
    const defaultConverter8 = defaultConverter7(options.type);
    if (!defaultConverter8) {
      throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target2.constructor.name}`);
    }
    copyOptions.converter = defaultConverter8;
  }
  copyOptions.raw = options.raw;
  schema.items[propertyKey] = copyOptions;
};
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-schema/build/es2015/objects.js
class AsnArray7 extends Array {
  constructor(items = []) {
    if (typeof items === "number") {
      super(items);
    } else {
      super();
      for (const item of items) {
        this.push(item);
      }
    }
  }
}
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/ip_converter.js
class IpConverter5 {
  static isIPv4(ip2) {
    return /^(\d{1,3}\.){3}\d{1,3}$/.test(ip2);
  }
  static parseIPv4(ip2) {
    const parts = ip2.split(".");
    if (parts.length !== 4) {
      throw new Error("Invalid IPv4 address");
    }
    return parts.map((part) => {
      const num = parseInt(part, 10);
      if (isNaN(num) || num < 0 || num > 255) {
        throw new Error("Invalid IPv4 address part");
      }
      return num;
    });
  }
  static parseIPv6(ip2) {
    const expandedIP = this.expandIPv6(ip2);
    const parts = expandedIP.split(":");
    if (parts.length !== 8) {
      throw new Error("Invalid IPv6 address");
    }
    return parts.reduce((bytes, part) => {
      const num = parseInt(part, 16);
      if (isNaN(num) || num < 0 || num > 65535) {
        throw new Error("Invalid IPv6 address part");
      }
      bytes.push(num >> 8 & 255);
      bytes.push(num & 255);
      return bytes;
    }, []);
  }
  static expandIPv6(ip2) {
    if (!ip2.includes("::")) {
      return ip2;
    }
    const parts = ip2.split("::");
    if (parts.length > 2) {
      throw new Error("Invalid IPv6 address");
    }
    const left = parts[0] ? parts[0].split(":") : [];
    const right = parts[1] ? parts[1].split(":") : [];
    const missing = 8 - (left.length + right.length);
    if (missing < 0) {
      throw new Error("Invalid IPv6 address");
    }
    return [...left, ...Array(missing).fill("0"), ...right].join(":");
  }
  static formatIPv6(bytes) {
    const parts = [];
    for (let i = 0;i < 16; i += 2) {
      parts.push((bytes[i] << 8 | bytes[i + 1]).toString(16));
    }
    return this.compressIPv6(parts.join(":"));
  }
  static compressIPv6(ip2) {
    const parts = ip2.split(":");
    let longestZeroStart = -1;
    let longestZeroLength = 0;
    let currentZeroStart = -1;
    let currentZeroLength = 0;
    for (let i = 0;i < parts.length; i++) {
      if (parts[i] === "0") {
        if (currentZeroStart === -1) {
          currentZeroStart = i;
        }
        currentZeroLength++;
      } else {
        if (currentZeroLength > longestZeroLength) {
          longestZeroStart = currentZeroStart;
          longestZeroLength = currentZeroLength;
        }
        currentZeroStart = -1;
        currentZeroLength = 0;
      }
    }
    if (currentZeroLength > longestZeroLength) {
      longestZeroStart = currentZeroStart;
      longestZeroLength = currentZeroLength;
    }
    if (longestZeroLength > 1) {
      const before = parts.slice(0, longestZeroStart).join(":");
      const after = parts.slice(longestZeroStart + longestZeroLength).join(":");
      return `${before}::${after}`;
    }
    return ip2;
  }
  static parseCIDR(text) {
    const [addr, prefixStr] = text.split("/");
    const prefix = parseInt(prefixStr, 10);
    if (this.isIPv4(addr)) {
      if (prefix < 0 || prefix > 32) {
        throw new Error("Invalid IPv4 prefix length");
      }
      return [this.parseIPv4(addr), prefix];
    } else {
      if (prefix < 0 || prefix > 128) {
        throw new Error("Invalid IPv6 prefix length");
      }
      return [this.parseIPv6(addr), prefix];
    }
  }
  static decodeIP(value) {
    if (value.length === 64 && parseInt(value, 16) === 0) {
      return "::/0";
    }
    if (value.length !== 16) {
      return value;
    }
    const mask = parseInt(value.slice(8), 16).toString(2).split("").reduce((a, k) => a + +k, 0);
    let ip2 = value.slice(0, 8).replace(/(.{2})/g, (match2) => `${parseInt(match2, 16)}.`);
    ip2 = ip2.slice(0, -1);
    return `${ip2}/${mask}`;
  }
  static toString(buf) {
    const uint8 = new Uint8Array(buf);
    if (uint8.length === 4) {
      return Array.from(uint8).join(".");
    }
    if (uint8.length === 16) {
      return this.formatIPv6(uint8);
    }
    if (uint8.length === 8 || uint8.length === 32) {
      const half = uint8.length / 2;
      const addrBytes = uint8.slice(0, half);
      const maskBytes = uint8.slice(half);
      const isAllZeros = uint8.every((byte) => byte === 0);
      if (isAllZeros) {
        return uint8.length === 8 ? "0.0.0.0/0" : "::/0";
      }
      const prefixLen = maskBytes.reduce((a, b) => a + (b.toString(2).match(/1/g) || []).length, 0);
      if (uint8.length === 8) {
        const addrStr = Array.from(addrBytes).join(".");
        return `${addrStr}/${prefixLen}`;
      } else {
        const addrStr = this.formatIPv6(addrBytes);
        return `${addrStr}/${prefixLen}`;
      }
    }
    return this.decodeIP(Convert.ToHex(buf));
  }
  static fromString(text) {
    if (text.includes("/")) {
      const [addr, prefix] = this.parseCIDR(text);
      const maskBytes = new Uint8Array(addr.length);
      let bitsLeft = prefix;
      for (let i = 0;i < maskBytes.length; i++) {
        if (bitsLeft >= 8) {
          maskBytes[i] = 255;
          bitsLeft -= 8;
        } else if (bitsLeft > 0) {
          maskBytes[i] = 255 << 8 - bitsLeft;
          bitsLeft = 0;
        }
      }
      const out = new Uint8Array(addr.length * 2);
      out.set(addr, 0);
      out.set(maskBytes, addr.length);
      return out.buffer;
    }
    const bytes = this.isIPv4(text) ? this.parseIPv4(text) : this.parseIPv6(text);
    return new Uint8Array(bytes).buffer;
  }
}

// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/name.js
var RelativeDistinguishedName_15;
var RDNSequence_15;
var Name_15;
var DirectoryString9 = class DirectoryString10 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.bmpString || this.printableString || this.teletexString || this.universalString || this.utf8String || "";
  }
};
__decorate([
  AsnProp7({ type: AsnPropTypes7.TeletexString })
], DirectoryString9.prototype, "teletexString", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.PrintableString })
], DirectoryString9.prototype, "printableString", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.UniversalString })
], DirectoryString9.prototype, "universalString", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.Utf8String })
], DirectoryString9.prototype, "utf8String", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.BmpString })
], DirectoryString9.prototype, "bmpString", undefined);
DirectoryString9 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Choice })
], DirectoryString9);
var AttributeValue9 = class AttributeValue10 extends DirectoryString9 {
  constructor(params = {}) {
    super(params);
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || (this.anyValue ? Convert.ToHex(this.anyValue) : super.toString());
  }
};
__decorate([
  AsnProp7({ type: AsnPropTypes7.IA5String })
], AttributeValue9.prototype, "ia5String", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.Any })
], AttributeValue9.prototype, "anyValue", undefined);
AttributeValue9 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Choice })
], AttributeValue9);
class AttributeTypeAndValue5 {
  constructor(params = {}) {
    this.type = "";
    this.value = new AttributeValue9;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: AsnPropTypes7.ObjectIdentifier })
], AttributeTypeAndValue5.prototype, "type", undefined);
__decorate([
  AsnProp7({ type: AttributeValue9 })
], AttributeTypeAndValue5.prototype, "value", undefined);
var RelativeDistinguishedName9 = RelativeDistinguishedName_15 = class RelativeDistinguishedName10 extends AsnArray7 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RelativeDistinguishedName_15.prototype);
  }
};
RelativeDistinguishedName9 = RelativeDistinguishedName_15 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Set, itemType: AttributeTypeAndValue5 })
], RelativeDistinguishedName9);
var RDNSequence9 = RDNSequence_15 = class RDNSequence10 extends AsnArray7 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RDNSequence_15.prototype);
  }
};
RDNSequence9 = RDNSequence_15 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Sequence, itemType: RelativeDistinguishedName9 })
], RDNSequence9);
var Name9 = Name_15 = class Name10 extends RDNSequence9 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Name_15.prototype);
  }
};
Name9 = Name_15 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Sequence })
], Name9);

// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/general_name.js
var AsnIpConverter5 = {
  fromASN: (value) => IpConverter5.toString(AsnOctetStringConverter7.fromASN(value)),
  toASN: (value) => AsnOctetStringConverter7.toASN(IpConverter5.fromString(value))
};

class OtherName5 {
  constructor(params = {}) {
    this.typeId = "";
    this.value = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: AsnPropTypes7.ObjectIdentifier })
], OtherName5.prototype, "typeId", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.Any, context: 0 })
], OtherName5.prototype, "value", undefined);

class EDIPartyName5 {
  constructor(params = {}) {
    this.partyName = new DirectoryString9;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: DirectoryString9, optional: true, context: 0, implicit: true })
], EDIPartyName5.prototype, "nameAssigner", undefined);
__decorate([
  AsnProp7({ type: DirectoryString9, context: 1, implicit: true })
], EDIPartyName5.prototype, "partyName", undefined);
var GeneralName9 = class GeneralName10 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp7({ type: OtherName5, context: 0, implicit: true })
], GeneralName9.prototype, "otherName", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.IA5String, context: 1, implicit: true })
], GeneralName9.prototype, "rfc822Name", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.IA5String, context: 2, implicit: true })
], GeneralName9.prototype, "dNSName", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.Any, context: 3, implicit: true })
], GeneralName9.prototype, "x400Address", undefined);
__decorate([
  AsnProp7({ type: Name9, context: 4, implicit: false })
], GeneralName9.prototype, "directoryName", undefined);
__decorate([
  AsnProp7({ type: EDIPartyName5, context: 5 })
], GeneralName9.prototype, "ediPartyName", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.IA5String, context: 6, implicit: true })
], GeneralName9.prototype, "uniformResourceIdentifier", undefined);
__decorate([
  AsnProp7({
    type: AsnPropTypes7.OctetString,
    context: 7,
    implicit: true,
    converter: AsnIpConverter5
  })
], GeneralName9.prototype, "iPAddress", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.ObjectIdentifier, context: 8, implicit: true })
], GeneralName9.prototype, "registeredID", undefined);
GeneralName9 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Choice })
], GeneralName9);

// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js
var id_pkix5 = "1.3.6.1.5.5.7";
var id_pe5 = `${id_pkix5}.1`;
var id_qt5 = `${id_pkix5}.2`;
var id_kp5 = `${id_pkix5}.3`;
var id_ad5 = `${id_pkix5}.48`;
var id_qt_csp5 = `${id_qt5}.1`;
var id_qt_unotice5 = `${id_qt5}.2`;
var id_ad_ocsp5 = `${id_ad5}.1`;
var id_ad_caIssuers5 = `${id_ad5}.2`;
var id_ad_timeStamping5 = `${id_ad5}.3`;
var id_ad_caRepository5 = `${id_ad5}.5`;
var id_ce5 = "2.5.29";

// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_information_access.js
var AuthorityInfoAccessSyntax_15;
var id_pe_authorityInfoAccess5 = `${id_pe5}.1`;

class AccessDescription5 {
  constructor(params = {}) {
    this.accessMethod = "";
    this.accessLocation = new GeneralName9;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: AsnPropTypes7.ObjectIdentifier })
], AccessDescription5.prototype, "accessMethod", undefined);
__decorate([
  AsnProp7({ type: GeneralName9 })
], AccessDescription5.prototype, "accessLocation", undefined);
var AuthorityInfoAccessSyntax9 = AuthorityInfoAccessSyntax_15 = class AuthorityInfoAccessSyntax10 extends AsnArray7 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, AuthorityInfoAccessSyntax_15.prototype);
  }
};
AuthorityInfoAccessSyntax9 = AuthorityInfoAccessSyntax_15 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Sequence, itemType: AccessDescription5 })
], AuthorityInfoAccessSyntax9);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_key_identifier.js
var id_ce_authorityKeyIdentifier5 = `${id_ce5}.35`;

class KeyIdentifier5 extends OctetString14 {
}

class AuthorityKeyIdentifier5 {
  constructor(params = {}) {
    if (params) {
      Object.assign(this, params);
    }
  }
}
__decorate([
  AsnProp7({ type: KeyIdentifier5, context: 0, optional: true, implicit: true })
], AuthorityKeyIdentifier5.prototype, "keyIdentifier", undefined);
__decorate([
  AsnProp7({ type: GeneralName9, context: 1, optional: true, implicit: true, repeated: "sequence" })
], AuthorityKeyIdentifier5.prototype, "authorityCertIssuer", undefined);
__decorate([
  AsnProp7({
    type: AsnPropTypes7.Integer,
    context: 2,
    optional: true,
    implicit: true,
    converter: AsnIntegerArrayBufferConverter7
  })
], AuthorityKeyIdentifier5.prototype, "authorityCertSerialNumber", undefined);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/basic_constraints.js
var id_ce_basicConstraints5 = `${id_ce5}.19`;

class BasicConstraints5 {
  constructor(params = {}) {
    this.cA = false;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: AsnPropTypes7.Boolean, defaultValue: false })
], BasicConstraints5.prototype, "cA", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.Integer, optional: true })
], BasicConstraints5.prototype, "pathLenConstraint", undefined);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/general_names.js
var GeneralNames_15;
var GeneralNames9 = GeneralNames_15 = class GeneralNames10 extends AsnArray7 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralNames_15.prototype);
  }
};
GeneralNames9 = GeneralNames_15 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Sequence, itemType: GeneralName9 })
], GeneralNames9);

// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_issuer.js
var CertificateIssuer_15;
var id_ce_certificateIssuer5 = `${id_ce5}.29`;
var CertificateIssuer9 = CertificateIssuer_15 = class CertificateIssuer10 extends GeneralNames9 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificateIssuer_15.prototype);
  }
};
CertificateIssuer9 = CertificateIssuer_15 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Sequence })
], CertificateIssuer9);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_policies.js
var CertificatePolicies_15;
var id_ce_certificatePolicies5 = `${id_ce5}.32`;
var id_ce_certificatePolicies_anyPolicy5 = `${id_ce_certificatePolicies5}.0`;
var DisplayText9 = class DisplayText10 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || this.visibleString || this.bmpString || this.utf8String || "";
  }
};
__decorate([
  AsnProp7({ type: AsnPropTypes7.IA5String })
], DisplayText9.prototype, "ia5String", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.VisibleString })
], DisplayText9.prototype, "visibleString", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.BmpString })
], DisplayText9.prototype, "bmpString", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.Utf8String })
], DisplayText9.prototype, "utf8String", undefined);
DisplayText9 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Choice })
], DisplayText9);
class NoticeReference5 {
  constructor(params = {}) {
    this.organization = new DisplayText9;
    this.noticeNumbers = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: DisplayText9 })
], NoticeReference5.prototype, "organization", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.Integer, repeated: "sequence" })
], NoticeReference5.prototype, "noticeNumbers", undefined);

class UserNotice5 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: NoticeReference5, optional: true })
], UserNotice5.prototype, "noticeRef", undefined);
__decorate([
  AsnProp7({ type: DisplayText9, optional: true })
], UserNotice5.prototype, "explicitText", undefined);
var Qualifier9 = class Qualifier10 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp7({ type: AsnPropTypes7.IA5String })
], Qualifier9.prototype, "cPSuri", undefined);
__decorate([
  AsnProp7({ type: UserNotice5 })
], Qualifier9.prototype, "userNotice", undefined);
Qualifier9 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Choice })
], Qualifier9);
class PolicyQualifierInfo5 {
  constructor(params = {}) {
    this.policyQualifierId = "";
    this.qualifier = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: AsnPropTypes7.ObjectIdentifier })
], PolicyQualifierInfo5.prototype, "policyQualifierId", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.Any })
], PolicyQualifierInfo5.prototype, "qualifier", undefined);

class PolicyInformation5 {
  constructor(params = {}) {
    this.policyIdentifier = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: AsnPropTypes7.ObjectIdentifier })
], PolicyInformation5.prototype, "policyIdentifier", undefined);
__decorate([
  AsnProp7({ type: PolicyQualifierInfo5, repeated: "sequence", optional: true })
], PolicyInformation5.prototype, "policyQualifiers", undefined);
var CertificatePolicies9 = CertificatePolicies_15 = class CertificatePolicies10 extends AsnArray7 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificatePolicies_15.prototype);
  }
};
CertificatePolicies9 = CertificatePolicies_15 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Sequence, itemType: PolicyInformation5 })
], CertificatePolicies9);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_number.js
var id_ce_cRLNumber5 = `${id_ce5}.20`;
var CRLNumber9 = class CRLNumber10 {
  constructor(value = 0) {
    this.value = value;
  }
};
__decorate([
  AsnProp7({ type: AsnPropTypes7.Integer })
], CRLNumber9.prototype, "value", undefined);
CRLNumber9 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Choice })
], CRLNumber9);

// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_delta_indicator.js
var id_ce_deltaCRLIndicator5 = `${id_ce5}.27`;
var BaseCRLNumber9 = class BaseCRLNumber10 extends CRLNumber9 {
};
BaseCRLNumber9 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Choice })
], BaseCRLNumber9);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_distribution_points.js
var CRLDistributionPoints_15;
var id_ce_cRLDistributionPoints5 = `${id_ce5}.31`;
var ReasonFlags5;
(function(ReasonFlags6) {
  ReasonFlags6[ReasonFlags6["unused"] = 1] = "unused";
  ReasonFlags6[ReasonFlags6["keyCompromise"] = 2] = "keyCompromise";
  ReasonFlags6[ReasonFlags6["cACompromise"] = 4] = "cACompromise";
  ReasonFlags6[ReasonFlags6["affiliationChanged"] = 8] = "affiliationChanged";
  ReasonFlags6[ReasonFlags6["superseded"] = 16] = "superseded";
  ReasonFlags6[ReasonFlags6["cessationOfOperation"] = 32] = "cessationOfOperation";
  ReasonFlags6[ReasonFlags6["certificateHold"] = 64] = "certificateHold";
  ReasonFlags6[ReasonFlags6["privilegeWithdrawn"] = 128] = "privilegeWithdrawn";
  ReasonFlags6[ReasonFlags6["aACompromise"] = 256] = "aACompromise";
})(ReasonFlags5 || (ReasonFlags5 = {}));

class Reason5 extends BitString14 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & ReasonFlags5.aACompromise) {
      res.push("aACompromise");
    }
    if (flags & ReasonFlags5.affiliationChanged) {
      res.push("affiliationChanged");
    }
    if (flags & ReasonFlags5.cACompromise) {
      res.push("cACompromise");
    }
    if (flags & ReasonFlags5.certificateHold) {
      res.push("certificateHold");
    }
    if (flags & ReasonFlags5.cessationOfOperation) {
      res.push("cessationOfOperation");
    }
    if (flags & ReasonFlags5.keyCompromise) {
      res.push("keyCompromise");
    }
    if (flags & ReasonFlags5.privilegeWithdrawn) {
      res.push("privilegeWithdrawn");
    }
    if (flags & ReasonFlags5.superseded) {
      res.push("superseded");
    }
    if (flags & ReasonFlags5.unused) {
      res.push("unused");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
}
var DistributionPointName9 = class DistributionPointName10 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp7({ type: GeneralName9, context: 0, repeated: "sequence", implicit: true })
], DistributionPointName9.prototype, "fullName", undefined);
__decorate([
  AsnProp7({ type: RelativeDistinguishedName9, context: 1, implicit: true })
], DistributionPointName9.prototype, "nameRelativeToCRLIssuer", undefined);
DistributionPointName9 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Choice })
], DistributionPointName9);
class DistributionPoint5 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: DistributionPointName9, context: 0, optional: true })
], DistributionPoint5.prototype, "distributionPoint", undefined);
__decorate([
  AsnProp7({ type: Reason5, context: 1, optional: true, implicit: true })
], DistributionPoint5.prototype, "reasons", undefined);
__decorate([
  AsnProp7({ type: GeneralName9, context: 2, optional: true, repeated: "sequence", implicit: true })
], DistributionPoint5.prototype, "cRLIssuer", undefined);
var CRLDistributionPoints9 = CRLDistributionPoints_15 = class CRLDistributionPoints10 extends AsnArray7 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CRLDistributionPoints_15.prototype);
  }
};
CRLDistributionPoints9 = CRLDistributionPoints_15 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Sequence, itemType: DistributionPoint5 })
], CRLDistributionPoints9);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_freshest.js
var FreshestCRL_15;
var id_ce_freshestCRL5 = `${id_ce5}.46`;
var FreshestCRL9 = FreshestCRL_15 = class FreshestCRL10 extends CRLDistributionPoints9 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, FreshestCRL_15.prototype);
  }
};
FreshestCRL9 = FreshestCRL_15 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Sequence, itemType: DistributionPoint5 })
], FreshestCRL9);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_issuing_distribution_point.js
var id_ce_issuingDistributionPoint5 = `${id_ce5}.28`;

class IssuingDistributionPoint5 {
  constructor(params = {}) {
    this.onlyContainsUserCerts = IssuingDistributionPoint5.ONLY;
    this.onlyContainsCACerts = IssuingDistributionPoint5.ONLY;
    this.indirectCRL = IssuingDistributionPoint5.ONLY;
    this.onlyContainsAttributeCerts = IssuingDistributionPoint5.ONLY;
    Object.assign(this, params);
  }
}
IssuingDistributionPoint5.ONLY = false;
__decorate([
  AsnProp7({ type: DistributionPointName9, context: 0, optional: true })
], IssuingDistributionPoint5.prototype, "distributionPoint", undefined);
__decorate([
  AsnProp7({
    type: AsnPropTypes7.Boolean,
    context: 1,
    defaultValue: IssuingDistributionPoint5.ONLY,
    implicit: true
  })
], IssuingDistributionPoint5.prototype, "onlyContainsUserCerts", undefined);
__decorate([
  AsnProp7({
    type: AsnPropTypes7.Boolean,
    context: 2,
    defaultValue: IssuingDistributionPoint5.ONLY,
    implicit: true
  })
], IssuingDistributionPoint5.prototype, "onlyContainsCACerts", undefined);
__decorate([
  AsnProp7({ type: Reason5, context: 3, optional: true, implicit: true })
], IssuingDistributionPoint5.prototype, "onlySomeReasons", undefined);
__decorate([
  AsnProp7({
    type: AsnPropTypes7.Boolean,
    context: 4,
    defaultValue: IssuingDistributionPoint5.ONLY,
    implicit: true
  })
], IssuingDistributionPoint5.prototype, "indirectCRL", undefined);
__decorate([
  AsnProp7({
    type: AsnPropTypes7.Boolean,
    context: 5,
    defaultValue: IssuingDistributionPoint5.ONLY,
    implicit: true
  })
], IssuingDistributionPoint5.prototype, "onlyContainsAttributeCerts", undefined);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_reason.js
var id_ce_cRLReasons5 = `${id_ce5}.21`;
var CRLReasons5;
(function(CRLReasons6) {
  CRLReasons6[CRLReasons6["unspecified"] = 0] = "unspecified";
  CRLReasons6[CRLReasons6["keyCompromise"] = 1] = "keyCompromise";
  CRLReasons6[CRLReasons6["cACompromise"] = 2] = "cACompromise";
  CRLReasons6[CRLReasons6["affiliationChanged"] = 3] = "affiliationChanged";
  CRLReasons6[CRLReasons6["superseded"] = 4] = "superseded";
  CRLReasons6[CRLReasons6["cessationOfOperation"] = 5] = "cessationOfOperation";
  CRLReasons6[CRLReasons6["certificateHold"] = 6] = "certificateHold";
  CRLReasons6[CRLReasons6["removeFromCRL"] = 8] = "removeFromCRL";
  CRLReasons6[CRLReasons6["privilegeWithdrawn"] = 9] = "privilegeWithdrawn";
  CRLReasons6[CRLReasons6["aACompromise"] = 10] = "aACompromise";
})(CRLReasons5 || (CRLReasons5 = {}));
var CRLReason9 = class CRLReason10 {
  constructor(reason = CRLReasons5.unspecified) {
    this.reason = CRLReasons5.unspecified;
    this.reason = reason;
  }
  toJSON() {
    return CRLReasons5[this.reason];
  }
  toString() {
    return this.toJSON();
  }
};
__decorate([
  AsnProp7({ type: AsnPropTypes7.Enumerated })
], CRLReason9.prototype, "reason", undefined);
CRLReason9 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Choice })
], CRLReason9);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/extended_key_usage.js
var ExtendedKeyUsage_15;
var id_ce_extKeyUsage5 = `${id_ce5}.37`;
var ExtendedKeyUsage9 = ExtendedKeyUsage_15 = class ExtendedKeyUsage10 extends AsnArray7 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, ExtendedKeyUsage_15.prototype);
  }
};
ExtendedKeyUsage9 = ExtendedKeyUsage_15 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Sequence, itemType: AsnPropTypes7.ObjectIdentifier })
], ExtendedKeyUsage9);
var anyExtendedKeyUsage5 = `${id_ce_extKeyUsage5}.0`;
var id_kp_serverAuth5 = `${id_kp5}.1`;
var id_kp_clientAuth5 = `${id_kp5}.2`;
var id_kp_codeSigning5 = `${id_kp5}.3`;
var id_kp_emailProtection5 = `${id_kp5}.4`;
var id_kp_timeStamping5 = `${id_kp5}.8`;
var id_kp_OCSPSigning5 = `${id_kp5}.9`;
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/inhibit_any_policy.js
var id_ce_inhibitAnyPolicy5 = `${id_ce5}.54`;
var InhibitAnyPolicy9 = class InhibitAnyPolicy10 {
  constructor(value = new ArrayBuffer(0)) {
    this.value = value;
  }
};
__decorate([
  AsnProp7({ type: AsnPropTypes7.Integer, converter: AsnIntegerArrayBufferConverter7 })
], InhibitAnyPolicy9.prototype, "value", undefined);
InhibitAnyPolicy9 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Choice })
], InhibitAnyPolicy9);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/invalidity_date.js
var id_ce_invalidityDate5 = `${id_ce5}.24`;
var InvalidityDate9 = class InvalidityDate10 {
  constructor(value) {
    this.value = new Date;
    if (value) {
      this.value = value;
    }
  }
};
__decorate([
  AsnProp7({ type: AsnPropTypes7.GeneralizedTime })
], InvalidityDate9.prototype, "value", undefined);
InvalidityDate9 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Choice })
], InvalidityDate9);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/issuer_alternative_name.js
var IssueAlternativeName_15;
var id_ce_issuerAltName5 = `${id_ce5}.18`;
var IssueAlternativeName9 = IssueAlternativeName_15 = class IssueAlternativeName10 extends GeneralNames9 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, IssueAlternativeName_15.prototype);
  }
};
IssueAlternativeName9 = IssueAlternativeName_15 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Sequence })
], IssueAlternativeName9);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/key_usage.js
var id_ce_keyUsage5 = `${id_ce5}.15`;
var KeyUsageFlags5;
(function(KeyUsageFlags6) {
  KeyUsageFlags6[KeyUsageFlags6["digitalSignature"] = 1] = "digitalSignature";
  KeyUsageFlags6[KeyUsageFlags6["nonRepudiation"] = 2] = "nonRepudiation";
  KeyUsageFlags6[KeyUsageFlags6["keyEncipherment"] = 4] = "keyEncipherment";
  KeyUsageFlags6[KeyUsageFlags6["dataEncipherment"] = 8] = "dataEncipherment";
  KeyUsageFlags6[KeyUsageFlags6["keyAgreement"] = 16] = "keyAgreement";
  KeyUsageFlags6[KeyUsageFlags6["keyCertSign"] = 32] = "keyCertSign";
  KeyUsageFlags6[KeyUsageFlags6["cRLSign"] = 64] = "cRLSign";
  KeyUsageFlags6[KeyUsageFlags6["encipherOnly"] = 128] = "encipherOnly";
  KeyUsageFlags6[KeyUsageFlags6["decipherOnly"] = 256] = "decipherOnly";
})(KeyUsageFlags5 || (KeyUsageFlags5 = {}));
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/name_constraints.js
var GeneralSubtrees_15;
var id_ce_nameConstraints5 = `${id_ce5}.30`;

class GeneralSubtree5 {
  constructor(params = {}) {
    this.base = new GeneralName9;
    this.minimum = 0;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: GeneralName9 })
], GeneralSubtree5.prototype, "base", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.Integer, context: 0, defaultValue: 0, implicit: true })
], GeneralSubtree5.prototype, "minimum", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.Integer, context: 1, optional: true, implicit: true })
], GeneralSubtree5.prototype, "maximum", undefined);
var GeneralSubtrees9 = GeneralSubtrees_15 = class GeneralSubtrees10 extends AsnArray7 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralSubtrees_15.prototype);
  }
};
GeneralSubtrees9 = GeneralSubtrees_15 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Sequence, itemType: GeneralSubtree5 })
], GeneralSubtrees9);
class NameConstraints5 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: GeneralSubtrees9, context: 0, optional: true, implicit: true })
], NameConstraints5.prototype, "permittedSubtrees", undefined);
__decorate([
  AsnProp7({ type: GeneralSubtrees9, context: 1, optional: true, implicit: true })
], NameConstraints5.prototype, "excludedSubtrees", undefined);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_constraints.js
var id_ce_policyConstraints5 = `${id_ce5}.36`;

class PolicyConstraints5 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({
    type: AsnPropTypes7.Integer,
    context: 0,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter7
  })
], PolicyConstraints5.prototype, "requireExplicitPolicy", undefined);
__decorate([
  AsnProp7({
    type: AsnPropTypes7.Integer,
    context: 1,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter7
  })
], PolicyConstraints5.prototype, "inhibitPolicyMapping", undefined);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_mappings.js
var PolicyMappings_15;
var id_ce_policyMappings5 = `${id_ce5}.33`;

class PolicyMapping5 {
  constructor(params = {}) {
    this.issuerDomainPolicy = "";
    this.subjectDomainPolicy = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: AsnPropTypes7.ObjectIdentifier })
], PolicyMapping5.prototype, "issuerDomainPolicy", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.ObjectIdentifier })
], PolicyMapping5.prototype, "subjectDomainPolicy", undefined);
var PolicyMappings9 = PolicyMappings_15 = class PolicyMappings10 extends AsnArray7 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, PolicyMappings_15.prototype);
  }
};
PolicyMappings9 = PolicyMappings_15 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Sequence, itemType: PolicyMapping5 })
], PolicyMappings9);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_alternative_name.js
var SubjectAlternativeName_15;
var id_ce_subjectAltName5 = `${id_ce5}.17`;
var SubjectAlternativeName9 = SubjectAlternativeName_15 = class SubjectAlternativeName10 extends GeneralNames9 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectAlternativeName_15.prototype);
  }
};
SubjectAlternativeName9 = SubjectAlternativeName_15 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Sequence })
], SubjectAlternativeName9);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/attribute.js
class Attribute6 {
  constructor(params = {}) {
    this.type = "";
    this.values = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: AsnPropTypes7.ObjectIdentifier })
], Attribute6.prototype, "type", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.Any, repeated: "set" })
], Attribute6.prototype, "values", undefined);

// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_directory_attributes.js
var SubjectDirectoryAttributes_15;
var id_ce_subjectDirectoryAttributes5 = `${id_ce5}.9`;
var SubjectDirectoryAttributes9 = SubjectDirectoryAttributes_15 = class SubjectDirectoryAttributes10 extends AsnArray7 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectDirectoryAttributes_15.prototype);
  }
};
SubjectDirectoryAttributes9 = SubjectDirectoryAttributes_15 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Sequence, itemType: Attribute6 })
], SubjectDirectoryAttributes9);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_key_identifier.js
var id_ce_subjectKeyIdentifier5 = `${id_ce5}.14`;
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/private_key_usage_period.js
var id_ce_privateKeyUsagePeriod5 = `${id_ce5}.16`;

class PrivateKeyUsagePeriod5 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: AsnPropTypes7.GeneralizedTime, context: 0, implicit: true, optional: true })
], PrivateKeyUsagePeriod5.prototype, "notBefore", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.GeneralizedTime, context: 1, implicit: true, optional: true })
], PrivateKeyUsagePeriod5.prototype, "notAfter", undefined);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/entrust_version_info.js
var EntrustInfoFlags5;
(function(EntrustInfoFlags6) {
  EntrustInfoFlags6[EntrustInfoFlags6["keyUpdateAllowed"] = 1] = "keyUpdateAllowed";
  EntrustInfoFlags6[EntrustInfoFlags6["newExtensions"] = 2] = "newExtensions";
  EntrustInfoFlags6[EntrustInfoFlags6["pKIXCertificate"] = 4] = "pKIXCertificate";
})(EntrustInfoFlags5 || (EntrustInfoFlags5 = {}));

class EntrustInfo5 extends BitString14 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & EntrustInfoFlags5.pKIXCertificate) {
      res.push("pKIXCertificate");
    }
    if (flags & EntrustInfoFlags5.newExtensions) {
      res.push("newExtensions");
    }
    if (flags & EntrustInfoFlags5.keyUpdateAllowed) {
      res.push("keyUpdateAllowed");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
}

class EntrustVersionInfo5 {
  constructor(params = {}) {
    this.entrustVers = "";
    this.entrustInfoFlags = new EntrustInfo5;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: AsnPropTypes7.GeneralString })
], EntrustVersionInfo5.prototype, "entrustVers", undefined);
__decorate([
  AsnProp7({ type: EntrustInfo5 })
], EntrustVersionInfo5.prototype, "entrustInfoFlags", undefined);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_info_access.js
var SubjectInfoAccessSyntax_15;
var id_pe_subjectInfoAccess5 = `${id_pe5}.11`;
var SubjectInfoAccessSyntax9 = SubjectInfoAccessSyntax_15 = class SubjectInfoAccessSyntax10 extends AsnArray7 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectInfoAccessSyntax_15.prototype);
  }
};
SubjectInfoAccessSyntax9 = SubjectInfoAccessSyntax_15 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Sequence, itemType: AccessDescription5 })
], SubjectInfoAccessSyntax9);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js
class AlgorithmIdentifier5 {
  constructor(params = {}) {
    this.algorithm = "";
    Object.assign(this, params);
  }
  isEqual(data) {
    return data instanceof AlgorithmIdentifier5 && data.algorithm == this.algorithm && (data.parameters && this.parameters && isEqual(data.parameters, this.parameters) || data.parameters === this.parameters);
  }
}
__decorate([
  AsnProp7({
    type: AsnPropTypes7.ObjectIdentifier
  })
], AlgorithmIdentifier5.prototype, "algorithm", undefined);
__decorate([
  AsnProp7({
    type: AsnPropTypes7.Any,
    optional: true
  })
], AlgorithmIdentifier5.prototype, "parameters", undefined);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/subject_public_key_info.js
class SubjectPublicKeyInfo5 {
  constructor(params = {}) {
    this.algorithm = new AlgorithmIdentifier5;
    this.subjectPublicKey = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: AlgorithmIdentifier5 })
], SubjectPublicKeyInfo5.prototype, "algorithm", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.BitString })
], SubjectPublicKeyInfo5.prototype, "subjectPublicKey", undefined);

// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/time.js
var Time9 = class Time10 {
  constructor(time6) {
    if (time6) {
      if (typeof time6 === "string" || typeof time6 === "number" || time6 instanceof Date) {
        const date = new Date(time6);
        if (date.getUTCFullYear() > 2049) {
          this.generalTime = date;
        } else {
          this.utcTime = date;
        }
      } else {
        Object.assign(this, time6);
      }
    }
  }
  getTime() {
    const time6 = this.utcTime || this.generalTime;
    if (!time6) {
      throw new Error("Cannot get time from CHOICE object");
    }
    return time6;
  }
};
__decorate([
  AsnProp7({
    type: AsnPropTypes7.UTCTime
  })
], Time9.prototype, "utcTime", undefined);
__decorate([
  AsnProp7({
    type: AsnPropTypes7.GeneralizedTime
  })
], Time9.prototype, "generalTime", undefined);
Time9 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Choice })
], Time9);

// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/validity.js
class Validity5 {
  constructor(params) {
    this.notBefore = new Time9(new Date);
    this.notAfter = new Time9(new Date);
    if (params) {
      this.notBefore = new Time9(params.notBefore);
      this.notAfter = new Time9(params.notAfter);
    }
  }
}
__decorate([
  AsnProp7({ type: Time9 })
], Validity5.prototype, "notBefore", undefined);
__decorate([
  AsnProp7({ type: Time9 })
], Validity5.prototype, "notAfter", undefined);

// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/extension.js
var Extensions_15;

class Extension5 {
  constructor(params = {}) {
    this.extnID = "";
    this.critical = Extension5.CRITICAL;
    this.extnValue = new OctetString14;
    Object.assign(this, params);
  }
}
Extension5.CRITICAL = false;
__decorate([
  AsnProp7({ type: AsnPropTypes7.ObjectIdentifier })
], Extension5.prototype, "extnID", undefined);
__decorate([
  AsnProp7({
    type: AsnPropTypes7.Boolean,
    defaultValue: Extension5.CRITICAL
  })
], Extension5.prototype, "critical", undefined);
__decorate([
  AsnProp7({ type: OctetString14 })
], Extension5.prototype, "extnValue", undefined);
var Extensions9 = Extensions_15 = class Extensions10 extends AsnArray7 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Extensions_15.prototype);
  }
};
Extensions9 = Extensions_15 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Sequence, itemType: Extension5 })
], Extensions9);

// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/types.js
var Version5;
(function(Version6) {
  Version6[Version6["v1"] = 0] = "v1";
  Version6[Version6["v2"] = 1] = "v2";
  Version6[Version6["v3"] = 2] = "v3";
})(Version5 || (Version5 = {}));

// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/tbs_certificate.js
class TBSCertificate5 {
  constructor(params = {}) {
    this.version = Version5.v1;
    this.serialNumber = new ArrayBuffer(0);
    this.signature = new AlgorithmIdentifier5;
    this.issuer = new Name9;
    this.validity = new Validity5;
    this.subject = new Name9;
    this.subjectPublicKeyInfo = new SubjectPublicKeyInfo5;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({
    type: AsnPropTypes7.Integer,
    context: 0,
    defaultValue: Version5.v1
  })
], TBSCertificate5.prototype, "version", undefined);
__decorate([
  AsnProp7({
    type: AsnPropTypes7.Integer,
    converter: AsnIntegerArrayBufferConverter7
  })
], TBSCertificate5.prototype, "serialNumber", undefined);
__decorate([
  AsnProp7({ type: AlgorithmIdentifier5 })
], TBSCertificate5.prototype, "signature", undefined);
__decorate([
  AsnProp7({ type: Name9 })
], TBSCertificate5.prototype, "issuer", undefined);
__decorate([
  AsnProp7({ type: Validity5 })
], TBSCertificate5.prototype, "validity", undefined);
__decorate([
  AsnProp7({ type: Name9 })
], TBSCertificate5.prototype, "subject", undefined);
__decorate([
  AsnProp7({ type: SubjectPublicKeyInfo5 })
], TBSCertificate5.prototype, "subjectPublicKeyInfo", undefined);
__decorate([
  AsnProp7({
    type: AsnPropTypes7.BitString,
    context: 1,
    implicit: true,
    optional: true
  })
], TBSCertificate5.prototype, "issuerUniqueID", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.BitString, context: 2, implicit: true, optional: true })
], TBSCertificate5.prototype, "subjectUniqueID", undefined);
__decorate([
  AsnProp7({ type: Extensions9, context: 3, optional: true })
], TBSCertificate5.prototype, "extensions", undefined);

// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/certificate.js
class Certificate5 {
  constructor(params = {}) {
    this.tbsCertificate = new TBSCertificate5;
    this.signatureAlgorithm = new AlgorithmIdentifier5;
    this.signatureValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: TBSCertificate5, raw: true })
], Certificate5.prototype, "tbsCertificate", undefined);
__decorate([
  AsnProp7({ type: AlgorithmIdentifier5 })
], Certificate5.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.BitString })
], Certificate5.prototype, "signatureValue", undefined);
// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/tbs_cert_list.js
class RevokedCertificate5 {
  constructor(params = {}) {
    this.userCertificate = new ArrayBuffer(0);
    this.revocationDate = new Time9;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: AsnPropTypes7.Integer, converter: AsnIntegerArrayBufferConverter7 })
], RevokedCertificate5.prototype, "userCertificate", undefined);
__decorate([
  AsnProp7({ type: Time9 })
], RevokedCertificate5.prototype, "revocationDate", undefined);
__decorate([
  AsnProp7({ type: Extension5, optional: true, repeated: "sequence" })
], RevokedCertificate5.prototype, "crlEntryExtensions", undefined);

class TBSCertList5 {
  constructor(params = {}) {
    this.signature = new AlgorithmIdentifier5;
    this.issuer = new Name9;
    this.thisUpdate = new Time9;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: AsnPropTypes7.Integer, optional: true })
], TBSCertList5.prototype, "version", undefined);
__decorate([
  AsnProp7({ type: AlgorithmIdentifier5 })
], TBSCertList5.prototype, "signature", undefined);
__decorate([
  AsnProp7({ type: Name9 })
], TBSCertList5.prototype, "issuer", undefined);
__decorate([
  AsnProp7({ type: Time9 })
], TBSCertList5.prototype, "thisUpdate", undefined);
__decorate([
  AsnProp7({ type: Time9, optional: true })
], TBSCertList5.prototype, "nextUpdate", undefined);
__decorate([
  AsnProp7({ type: RevokedCertificate5, repeated: "sequence", optional: true })
], TBSCertList5.prototype, "revokedCertificates", undefined);
__decorate([
  AsnProp7({ type: Extension5, optional: true, context: 0, repeated: "sequence" })
], TBSCertList5.prototype, "crlExtensions", undefined);

// node_modules/@peculiar/asn1-pkcs8/node_modules/@peculiar/asn1-x509/build/es2015/certificate_list.js
class CertificateList5 {
  constructor(params = {}) {
    this.tbsCertList = new TBSCertList5;
    this.signatureAlgorithm = new AlgorithmIdentifier5;
    this.signature = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: TBSCertList5, raw: true })
], CertificateList5.prototype, "tbsCertList", undefined);
__decorate([
  AsnProp7({ type: AlgorithmIdentifier5 })
], CertificateList5.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp7({ type: AsnPropTypes7.BitString })
], CertificateList5.prototype, "signature", undefined);
// node_modules/@peculiar/asn1-pkcs8/build/es2015/encrypted_private_key_info.js
class EncryptedData extends OctetString14 {
}

class EncryptedPrivateKeyInfo {
  constructor(params = {}) {
    this.encryptionAlgorithm = new AlgorithmIdentifier5;
    this.encryptedData = new EncryptedData;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: AlgorithmIdentifier5 })
], EncryptedPrivateKeyInfo.prototype, "encryptionAlgorithm", undefined);
__decorate([
  AsnProp7({ type: EncryptedData })
], EncryptedPrivateKeyInfo.prototype, "encryptedData", undefined);
// node_modules/@peculiar/asn1-pkcs8/build/es2015/private_key_info.js
var Attributes_1;
var Version6;
(function(Version7) {
  Version7[Version7["v1"] = 0] = "v1";
})(Version6 || (Version6 = {}));

class PrivateKey extends OctetString14 {
}
var Attributes = Attributes_1 = class Attributes2 extends AsnArray7 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Attributes_1.prototype);
  }
};
Attributes = Attributes_1 = __decorate([
  AsnType7({ type: AsnTypeTypes7.Sequence, itemType: Attribute6 })
], Attributes);
class PrivateKeyInfo {
  constructor(params = {}) {
    this.version = Version6.v1;
    this.privateKeyAlgorithm = new AlgorithmIdentifier5;
    this.privateKey = new PrivateKey;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp7({ type: AsnPropTypes7.Integer })
], PrivateKeyInfo.prototype, "version", undefined);
__decorate([
  AsnProp7({ type: AlgorithmIdentifier5 })
], PrivateKeyInfo.prototype, "privateKeyAlgorithm", undefined);
__decorate([
  AsnProp7({ type: PrivateKey })
], PrivateKeyInfo.prototype, "privateKey", undefined);
__decorate([
  AsnProp7({ type: Attributes, implicit: true, context: 0, optional: true })
], PrivateKeyInfo.prototype, "attributes", undefined);
// node_modules/@peculiar/asn1-pfx/build/es2015/bags/key_bag.js
var KeyBag = class KeyBag2 extends PrivateKeyInfo {
};
KeyBag = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence })
], KeyBag);
// node_modules/@peculiar/asn1-pfx/build/es2015/bags/pkcs8_shrouded_key_bag.js
var PKCS8ShroudedKeyBag = class PKCS8ShroudedKeyBag2 extends EncryptedPrivateKeyInfo {
};
PKCS8ShroudedKeyBag = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence })
], PKCS8ShroudedKeyBag);
// node_modules/@peculiar/asn1-pfx/build/es2015/bags/secret_bag.js
class SecretBag {
  constructor(params = {}) {
    this.secretTypeId = "";
    this.secretValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.ObjectIdentifier })
], SecretBag.prototype, "secretTypeId", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Any, context: 0 })
], SecretBag.prototype, "secretValue", undefined);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/ip_converter.js
class IpConverter6 {
  static isIPv4(ip2) {
    return /^(\d{1,3}\.){3}\d{1,3}$/.test(ip2);
  }
  static parseIPv4(ip2) {
    const parts = ip2.split(".");
    if (parts.length !== 4) {
      throw new Error("Invalid IPv4 address");
    }
    return parts.map((part) => {
      const num = parseInt(part, 10);
      if (isNaN(num) || num < 0 || num > 255) {
        throw new Error("Invalid IPv4 address part");
      }
      return num;
    });
  }
  static parseIPv6(ip2) {
    const expandedIP = this.expandIPv6(ip2);
    const parts = expandedIP.split(":");
    if (parts.length !== 8) {
      throw new Error("Invalid IPv6 address");
    }
    return parts.reduce((bytes, part) => {
      const num = parseInt(part, 16);
      if (isNaN(num) || num < 0 || num > 65535) {
        throw new Error("Invalid IPv6 address part");
      }
      bytes.push(num >> 8 & 255);
      bytes.push(num & 255);
      return bytes;
    }, []);
  }
  static expandIPv6(ip2) {
    if (!ip2.includes("::")) {
      return ip2;
    }
    const parts = ip2.split("::");
    if (parts.length > 2) {
      throw new Error("Invalid IPv6 address");
    }
    const left = parts[0] ? parts[0].split(":") : [];
    const right = parts[1] ? parts[1].split(":") : [];
    const missing = 8 - (left.length + right.length);
    if (missing < 0) {
      throw new Error("Invalid IPv6 address");
    }
    return [...left, ...Array(missing).fill("0"), ...right].join(":");
  }
  static formatIPv6(bytes) {
    const parts = [];
    for (let i = 0;i < 16; i += 2) {
      parts.push((bytes[i] << 8 | bytes[i + 1]).toString(16));
    }
    return this.compressIPv6(parts.join(":"));
  }
  static compressIPv6(ip2) {
    const parts = ip2.split(":");
    let longestZeroStart = -1;
    let longestZeroLength = 0;
    let currentZeroStart = -1;
    let currentZeroLength = 0;
    for (let i = 0;i < parts.length; i++) {
      if (parts[i] === "0") {
        if (currentZeroStart === -1) {
          currentZeroStart = i;
        }
        currentZeroLength++;
      } else {
        if (currentZeroLength > longestZeroLength) {
          longestZeroStart = currentZeroStart;
          longestZeroLength = currentZeroLength;
        }
        currentZeroStart = -1;
        currentZeroLength = 0;
      }
    }
    if (currentZeroLength > longestZeroLength) {
      longestZeroStart = currentZeroStart;
      longestZeroLength = currentZeroLength;
    }
    if (longestZeroLength > 1) {
      const before = parts.slice(0, longestZeroStart).join(":");
      const after = parts.slice(longestZeroStart + longestZeroLength).join(":");
      return `${before}::${after}`;
    }
    return ip2;
  }
  static parseCIDR(text) {
    const [addr, prefixStr] = text.split("/");
    const prefix = parseInt(prefixStr, 10);
    if (this.isIPv4(addr)) {
      if (prefix < 0 || prefix > 32) {
        throw new Error("Invalid IPv4 prefix length");
      }
      return [this.parseIPv4(addr), prefix];
    } else {
      if (prefix < 0 || prefix > 128) {
        throw new Error("Invalid IPv6 prefix length");
      }
      return [this.parseIPv6(addr), prefix];
    }
  }
  static decodeIP(value) {
    if (value.length === 64 && parseInt(value, 16) === 0) {
      return "::/0";
    }
    if (value.length !== 16) {
      return value;
    }
    const mask = parseInt(value.slice(8), 16).toString(2).split("").reduce((a, k) => a + +k, 0);
    let ip2 = value.slice(0, 8).replace(/(.{2})/g, (match2) => `${parseInt(match2, 16)}.`);
    ip2 = ip2.slice(0, -1);
    return `${ip2}/${mask}`;
  }
  static toString(buf) {
    const uint8 = new Uint8Array(buf);
    if (uint8.length === 4) {
      return Array.from(uint8).join(".");
    }
    if (uint8.length === 16) {
      return this.formatIPv6(uint8);
    }
    if (uint8.length === 8 || uint8.length === 32) {
      const half = uint8.length / 2;
      const addrBytes = uint8.slice(0, half);
      const maskBytes = uint8.slice(half);
      const isAllZeros = uint8.every((byte) => byte === 0);
      if (isAllZeros) {
        return uint8.length === 8 ? "0.0.0.0/0" : "::/0";
      }
      const prefixLen = maskBytes.reduce((a, b) => a + (b.toString(2).match(/1/g) || []).length, 0);
      if (uint8.length === 8) {
        const addrStr = Array.from(addrBytes).join(".");
        return `${addrStr}/${prefixLen}`;
      } else {
        const addrStr = this.formatIPv6(addrBytes);
        return `${addrStr}/${prefixLen}`;
      }
    }
    return this.decodeIP(Convert.ToHex(buf));
  }
  static fromString(text) {
    if (text.includes("/")) {
      const [addr, prefix] = this.parseCIDR(text);
      const maskBytes = new Uint8Array(addr.length);
      let bitsLeft = prefix;
      for (let i = 0;i < maskBytes.length; i++) {
        if (bitsLeft >= 8) {
          maskBytes[i] = 255;
          bitsLeft -= 8;
        } else if (bitsLeft > 0) {
          maskBytes[i] = 255 << 8 - bitsLeft;
          bitsLeft = 0;
        }
      }
      const out = new Uint8Array(addr.length * 2);
      out.set(addr, 0);
      out.set(maskBytes, addr.length);
      return out.buffer;
    }
    const bytes = this.isIPv4(text) ? this.parseIPv4(text) : this.parseIPv6(text);
    return new Uint8Array(bytes).buffer;
  }
}

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/name.js
var RelativeDistinguishedName_16;
var RDNSequence_16;
var Name_16;
var DirectoryString11 = class DirectoryString12 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.bmpString || this.printableString || this.teletexString || this.universalString || this.utf8String || "";
  }
};
__decorate([
  AsnProp6({ type: AsnPropTypes6.TeletexString })
], DirectoryString11.prototype, "teletexString", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.PrintableString })
], DirectoryString11.prototype, "printableString", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.UniversalString })
], DirectoryString11.prototype, "universalString", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Utf8String })
], DirectoryString11.prototype, "utf8String", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.BmpString })
], DirectoryString11.prototype, "bmpString", undefined);
DirectoryString11 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Choice })
], DirectoryString11);
var AttributeValue11 = class AttributeValue12 extends DirectoryString11 {
  constructor(params = {}) {
    super(params);
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || (this.anyValue ? Convert.ToHex(this.anyValue) : super.toString());
  }
};
__decorate([
  AsnProp6({ type: AsnPropTypes6.IA5String })
], AttributeValue11.prototype, "ia5String", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Any })
], AttributeValue11.prototype, "anyValue", undefined);
AttributeValue11 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Choice })
], AttributeValue11);
class AttributeTypeAndValue6 {
  constructor(params = {}) {
    this.type = "";
    this.value = new AttributeValue11;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.ObjectIdentifier })
], AttributeTypeAndValue6.prototype, "type", undefined);
__decorate([
  AsnProp6({ type: AttributeValue11 })
], AttributeTypeAndValue6.prototype, "value", undefined);
var RelativeDistinguishedName11 = RelativeDistinguishedName_16 = class RelativeDistinguishedName12 extends AsnArray6 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RelativeDistinguishedName_16.prototype);
  }
};
RelativeDistinguishedName11 = RelativeDistinguishedName_16 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Set, itemType: AttributeTypeAndValue6 })
], RelativeDistinguishedName11);
var RDNSequence11 = RDNSequence_16 = class RDNSequence12 extends AsnArray6 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RDNSequence_16.prototype);
  }
};
RDNSequence11 = RDNSequence_16 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence, itemType: RelativeDistinguishedName11 })
], RDNSequence11);
var Name11 = Name_16 = class Name12 extends RDNSequence11 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Name_16.prototype);
  }
};
Name11 = Name_16 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence })
], Name11);

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/general_name.js
var AsnIpConverter6 = {
  fromASN: (value) => IpConverter6.toString(AsnOctetStringConverter6.fromASN(value)),
  toASN: (value) => AsnOctetStringConverter6.toASN(IpConverter6.fromString(value))
};

class OtherName6 {
  constructor(params = {}) {
    this.typeId = "";
    this.value = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.ObjectIdentifier })
], OtherName6.prototype, "typeId", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Any, context: 0 })
], OtherName6.prototype, "value", undefined);

class EDIPartyName6 {
  constructor(params = {}) {
    this.partyName = new DirectoryString11;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: DirectoryString11, optional: true, context: 0, implicit: true })
], EDIPartyName6.prototype, "nameAssigner", undefined);
__decorate([
  AsnProp6({ type: DirectoryString11, context: 1, implicit: true })
], EDIPartyName6.prototype, "partyName", undefined);
var GeneralName11 = class GeneralName12 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp6({ type: OtherName6, context: 0, implicit: true })
], GeneralName11.prototype, "otherName", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.IA5String, context: 1, implicit: true })
], GeneralName11.prototype, "rfc822Name", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.IA5String, context: 2, implicit: true })
], GeneralName11.prototype, "dNSName", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Any, context: 3, implicit: true })
], GeneralName11.prototype, "x400Address", undefined);
__decorate([
  AsnProp6({ type: Name11, context: 4, implicit: false })
], GeneralName11.prototype, "directoryName", undefined);
__decorate([
  AsnProp6({ type: EDIPartyName6, context: 5 })
], GeneralName11.prototype, "ediPartyName", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.IA5String, context: 6, implicit: true })
], GeneralName11.prototype, "uniformResourceIdentifier", undefined);
__decorate([
  AsnProp6({
    type: AsnPropTypes6.OctetString,
    context: 7,
    implicit: true,
    converter: AsnIpConverter6
  })
], GeneralName11.prototype, "iPAddress", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.ObjectIdentifier, context: 8, implicit: true })
], GeneralName11.prototype, "registeredID", undefined);
GeneralName11 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Choice })
], GeneralName11);

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js
var id_pkix6 = "1.3.6.1.5.5.7";
var id_pe6 = `${id_pkix6}.1`;
var id_qt6 = `${id_pkix6}.2`;
var id_kp6 = `${id_pkix6}.3`;
var id_ad6 = `${id_pkix6}.48`;
var id_qt_csp6 = `${id_qt6}.1`;
var id_qt_unotice6 = `${id_qt6}.2`;
var id_ad_ocsp6 = `${id_ad6}.1`;
var id_ad_caIssuers6 = `${id_ad6}.2`;
var id_ad_timeStamping6 = `${id_ad6}.3`;
var id_ad_caRepository6 = `${id_ad6}.5`;
var id_ce6 = "2.5.29";

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_information_access.js
var AuthorityInfoAccessSyntax_16;
var id_pe_authorityInfoAccess6 = `${id_pe6}.1`;

class AccessDescription6 {
  constructor(params = {}) {
    this.accessMethod = "";
    this.accessLocation = new GeneralName11;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.ObjectIdentifier })
], AccessDescription6.prototype, "accessMethod", undefined);
__decorate([
  AsnProp6({ type: GeneralName11 })
], AccessDescription6.prototype, "accessLocation", undefined);
var AuthorityInfoAccessSyntax11 = AuthorityInfoAccessSyntax_16 = class AuthorityInfoAccessSyntax12 extends AsnArray6 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, AuthorityInfoAccessSyntax_16.prototype);
  }
};
AuthorityInfoAccessSyntax11 = AuthorityInfoAccessSyntax_16 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence, itemType: AccessDescription6 })
], AuthorityInfoAccessSyntax11);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_key_identifier.js
var id_ce_authorityKeyIdentifier6 = `${id_ce6}.35`;

class KeyIdentifier6 extends OctetString12 {
}

class AuthorityKeyIdentifier6 {
  constructor(params = {}) {
    if (params) {
      Object.assign(this, params);
    }
  }
}
__decorate([
  AsnProp6({ type: KeyIdentifier6, context: 0, optional: true, implicit: true })
], AuthorityKeyIdentifier6.prototype, "keyIdentifier", undefined);
__decorate([
  AsnProp6({ type: GeneralName11, context: 1, optional: true, implicit: true, repeated: "sequence" })
], AuthorityKeyIdentifier6.prototype, "authorityCertIssuer", undefined);
__decorate([
  AsnProp6({
    type: AsnPropTypes6.Integer,
    context: 2,
    optional: true,
    implicit: true,
    converter: AsnIntegerArrayBufferConverter6
  })
], AuthorityKeyIdentifier6.prototype, "authorityCertSerialNumber", undefined);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/basic_constraints.js
var id_ce_basicConstraints6 = `${id_ce6}.19`;

class BasicConstraints6 {
  constructor(params = {}) {
    this.cA = false;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.Boolean, defaultValue: false })
], BasicConstraints6.prototype, "cA", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, optional: true })
], BasicConstraints6.prototype, "pathLenConstraint", undefined);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/general_names.js
var GeneralNames_16;
var GeneralNames11 = GeneralNames_16 = class GeneralNames12 extends AsnArray6 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralNames_16.prototype);
  }
};
GeneralNames11 = GeneralNames_16 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence, itemType: GeneralName11 })
], GeneralNames11);

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_issuer.js
var CertificateIssuer_16;
var id_ce_certificateIssuer6 = `${id_ce6}.29`;
var CertificateIssuer11 = CertificateIssuer_16 = class CertificateIssuer12 extends GeneralNames11 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificateIssuer_16.prototype);
  }
};
CertificateIssuer11 = CertificateIssuer_16 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence })
], CertificateIssuer11);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_policies.js
var CertificatePolicies_16;
var id_ce_certificatePolicies6 = `${id_ce6}.32`;
var id_ce_certificatePolicies_anyPolicy6 = `${id_ce_certificatePolicies6}.0`;
var DisplayText11 = class DisplayText12 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || this.visibleString || this.bmpString || this.utf8String || "";
  }
};
__decorate([
  AsnProp6({ type: AsnPropTypes6.IA5String })
], DisplayText11.prototype, "ia5String", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.VisibleString })
], DisplayText11.prototype, "visibleString", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.BmpString })
], DisplayText11.prototype, "bmpString", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Utf8String })
], DisplayText11.prototype, "utf8String", undefined);
DisplayText11 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Choice })
], DisplayText11);
class NoticeReference6 {
  constructor(params = {}) {
    this.organization = new DisplayText11;
    this.noticeNumbers = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: DisplayText11 })
], NoticeReference6.prototype, "organization", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, repeated: "sequence" })
], NoticeReference6.prototype, "noticeNumbers", undefined);

class UserNotice6 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: NoticeReference6, optional: true })
], UserNotice6.prototype, "noticeRef", undefined);
__decorate([
  AsnProp6({ type: DisplayText11, optional: true })
], UserNotice6.prototype, "explicitText", undefined);
var Qualifier11 = class Qualifier12 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp6({ type: AsnPropTypes6.IA5String })
], Qualifier11.prototype, "cPSuri", undefined);
__decorate([
  AsnProp6({ type: UserNotice6 })
], Qualifier11.prototype, "userNotice", undefined);
Qualifier11 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Choice })
], Qualifier11);
class PolicyQualifierInfo6 {
  constructor(params = {}) {
    this.policyQualifierId = "";
    this.qualifier = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.ObjectIdentifier })
], PolicyQualifierInfo6.prototype, "policyQualifierId", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Any })
], PolicyQualifierInfo6.prototype, "qualifier", undefined);

class PolicyInformation6 {
  constructor(params = {}) {
    this.policyIdentifier = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.ObjectIdentifier })
], PolicyInformation6.prototype, "policyIdentifier", undefined);
__decorate([
  AsnProp6({ type: PolicyQualifierInfo6, repeated: "sequence", optional: true })
], PolicyInformation6.prototype, "policyQualifiers", undefined);
var CertificatePolicies11 = CertificatePolicies_16 = class CertificatePolicies12 extends AsnArray6 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificatePolicies_16.prototype);
  }
};
CertificatePolicies11 = CertificatePolicies_16 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence, itemType: PolicyInformation6 })
], CertificatePolicies11);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_number.js
var id_ce_cRLNumber6 = `${id_ce6}.20`;
var CRLNumber11 = class CRLNumber12 {
  constructor(value = 0) {
    this.value = value;
  }
};
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer })
], CRLNumber11.prototype, "value", undefined);
CRLNumber11 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Choice })
], CRLNumber11);

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_delta_indicator.js
var id_ce_deltaCRLIndicator6 = `${id_ce6}.27`;
var BaseCRLNumber11 = class BaseCRLNumber12 extends CRLNumber11 {
};
BaseCRLNumber11 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Choice })
], BaseCRLNumber11);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_distribution_points.js
var CRLDistributionPoints_16;
var id_ce_cRLDistributionPoints6 = `${id_ce6}.31`;
var ReasonFlags6;
(function(ReasonFlags7) {
  ReasonFlags7[ReasonFlags7["unused"] = 1] = "unused";
  ReasonFlags7[ReasonFlags7["keyCompromise"] = 2] = "keyCompromise";
  ReasonFlags7[ReasonFlags7["cACompromise"] = 4] = "cACompromise";
  ReasonFlags7[ReasonFlags7["affiliationChanged"] = 8] = "affiliationChanged";
  ReasonFlags7[ReasonFlags7["superseded"] = 16] = "superseded";
  ReasonFlags7[ReasonFlags7["cessationOfOperation"] = 32] = "cessationOfOperation";
  ReasonFlags7[ReasonFlags7["certificateHold"] = 64] = "certificateHold";
  ReasonFlags7[ReasonFlags7["privilegeWithdrawn"] = 128] = "privilegeWithdrawn";
  ReasonFlags7[ReasonFlags7["aACompromise"] = 256] = "aACompromise";
})(ReasonFlags6 || (ReasonFlags6 = {}));

class Reason6 extends BitString12 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & ReasonFlags6.aACompromise) {
      res.push("aACompromise");
    }
    if (flags & ReasonFlags6.affiliationChanged) {
      res.push("affiliationChanged");
    }
    if (flags & ReasonFlags6.cACompromise) {
      res.push("cACompromise");
    }
    if (flags & ReasonFlags6.certificateHold) {
      res.push("certificateHold");
    }
    if (flags & ReasonFlags6.cessationOfOperation) {
      res.push("cessationOfOperation");
    }
    if (flags & ReasonFlags6.keyCompromise) {
      res.push("keyCompromise");
    }
    if (flags & ReasonFlags6.privilegeWithdrawn) {
      res.push("privilegeWithdrawn");
    }
    if (flags & ReasonFlags6.superseded) {
      res.push("superseded");
    }
    if (flags & ReasonFlags6.unused) {
      res.push("unused");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
}
var DistributionPointName11 = class DistributionPointName12 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp6({ type: GeneralName11, context: 0, repeated: "sequence", implicit: true })
], DistributionPointName11.prototype, "fullName", undefined);
__decorate([
  AsnProp6({ type: RelativeDistinguishedName11, context: 1, implicit: true })
], DistributionPointName11.prototype, "nameRelativeToCRLIssuer", undefined);
DistributionPointName11 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Choice })
], DistributionPointName11);
class DistributionPoint6 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: DistributionPointName11, context: 0, optional: true })
], DistributionPoint6.prototype, "distributionPoint", undefined);
__decorate([
  AsnProp6({ type: Reason6, context: 1, optional: true, implicit: true })
], DistributionPoint6.prototype, "reasons", undefined);
__decorate([
  AsnProp6({ type: GeneralName11, context: 2, optional: true, repeated: "sequence", implicit: true })
], DistributionPoint6.prototype, "cRLIssuer", undefined);
var CRLDistributionPoints11 = CRLDistributionPoints_16 = class CRLDistributionPoints12 extends AsnArray6 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CRLDistributionPoints_16.prototype);
  }
};
CRLDistributionPoints11 = CRLDistributionPoints_16 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence, itemType: DistributionPoint6 })
], CRLDistributionPoints11);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_freshest.js
var FreshestCRL_16;
var id_ce_freshestCRL6 = `${id_ce6}.46`;
var FreshestCRL11 = FreshestCRL_16 = class FreshestCRL12 extends CRLDistributionPoints11 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, FreshestCRL_16.prototype);
  }
};
FreshestCRL11 = FreshestCRL_16 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence, itemType: DistributionPoint6 })
], FreshestCRL11);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_issuing_distribution_point.js
var id_ce_issuingDistributionPoint6 = `${id_ce6}.28`;

class IssuingDistributionPoint6 {
  constructor(params = {}) {
    this.onlyContainsUserCerts = IssuingDistributionPoint6.ONLY;
    this.onlyContainsCACerts = IssuingDistributionPoint6.ONLY;
    this.indirectCRL = IssuingDistributionPoint6.ONLY;
    this.onlyContainsAttributeCerts = IssuingDistributionPoint6.ONLY;
    Object.assign(this, params);
  }
}
IssuingDistributionPoint6.ONLY = false;
__decorate([
  AsnProp6({ type: DistributionPointName11, context: 0, optional: true })
], IssuingDistributionPoint6.prototype, "distributionPoint", undefined);
__decorate([
  AsnProp6({
    type: AsnPropTypes6.Boolean,
    context: 1,
    defaultValue: IssuingDistributionPoint6.ONLY,
    implicit: true
  })
], IssuingDistributionPoint6.prototype, "onlyContainsUserCerts", undefined);
__decorate([
  AsnProp6({
    type: AsnPropTypes6.Boolean,
    context: 2,
    defaultValue: IssuingDistributionPoint6.ONLY,
    implicit: true
  })
], IssuingDistributionPoint6.prototype, "onlyContainsCACerts", undefined);
__decorate([
  AsnProp6({ type: Reason6, context: 3, optional: true, implicit: true })
], IssuingDistributionPoint6.prototype, "onlySomeReasons", undefined);
__decorate([
  AsnProp6({
    type: AsnPropTypes6.Boolean,
    context: 4,
    defaultValue: IssuingDistributionPoint6.ONLY,
    implicit: true
  })
], IssuingDistributionPoint6.prototype, "indirectCRL", undefined);
__decorate([
  AsnProp6({
    type: AsnPropTypes6.Boolean,
    context: 5,
    defaultValue: IssuingDistributionPoint6.ONLY,
    implicit: true
  })
], IssuingDistributionPoint6.prototype, "onlyContainsAttributeCerts", undefined);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_reason.js
var id_ce_cRLReasons6 = `${id_ce6}.21`;
var CRLReasons6;
(function(CRLReasons7) {
  CRLReasons7[CRLReasons7["unspecified"] = 0] = "unspecified";
  CRLReasons7[CRLReasons7["keyCompromise"] = 1] = "keyCompromise";
  CRLReasons7[CRLReasons7["cACompromise"] = 2] = "cACompromise";
  CRLReasons7[CRLReasons7["affiliationChanged"] = 3] = "affiliationChanged";
  CRLReasons7[CRLReasons7["superseded"] = 4] = "superseded";
  CRLReasons7[CRLReasons7["cessationOfOperation"] = 5] = "cessationOfOperation";
  CRLReasons7[CRLReasons7["certificateHold"] = 6] = "certificateHold";
  CRLReasons7[CRLReasons7["removeFromCRL"] = 8] = "removeFromCRL";
  CRLReasons7[CRLReasons7["privilegeWithdrawn"] = 9] = "privilegeWithdrawn";
  CRLReasons7[CRLReasons7["aACompromise"] = 10] = "aACompromise";
})(CRLReasons6 || (CRLReasons6 = {}));
var CRLReason11 = class CRLReason12 {
  constructor(reason = CRLReasons6.unspecified) {
    this.reason = CRLReasons6.unspecified;
    this.reason = reason;
  }
  toJSON() {
    return CRLReasons6[this.reason];
  }
  toString() {
    return this.toJSON();
  }
};
__decorate([
  AsnProp6({ type: AsnPropTypes6.Enumerated })
], CRLReason11.prototype, "reason", undefined);
CRLReason11 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Choice })
], CRLReason11);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/extended_key_usage.js
var ExtendedKeyUsage_16;
var id_ce_extKeyUsage6 = `${id_ce6}.37`;
var ExtendedKeyUsage11 = ExtendedKeyUsage_16 = class ExtendedKeyUsage12 extends AsnArray6 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, ExtendedKeyUsage_16.prototype);
  }
};
ExtendedKeyUsage11 = ExtendedKeyUsage_16 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence, itemType: AsnPropTypes6.ObjectIdentifier })
], ExtendedKeyUsage11);
var anyExtendedKeyUsage6 = `${id_ce_extKeyUsage6}.0`;
var id_kp_serverAuth6 = `${id_kp6}.1`;
var id_kp_clientAuth6 = `${id_kp6}.2`;
var id_kp_codeSigning6 = `${id_kp6}.3`;
var id_kp_emailProtection6 = `${id_kp6}.4`;
var id_kp_timeStamping6 = `${id_kp6}.8`;
var id_kp_OCSPSigning6 = `${id_kp6}.9`;
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/inhibit_any_policy.js
var id_ce_inhibitAnyPolicy6 = `${id_ce6}.54`;
var InhibitAnyPolicy11 = class InhibitAnyPolicy12 {
  constructor(value = new ArrayBuffer(0)) {
    this.value = value;
  }
};
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, converter: AsnIntegerArrayBufferConverter6 })
], InhibitAnyPolicy11.prototype, "value", undefined);
InhibitAnyPolicy11 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Choice })
], InhibitAnyPolicy11);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/invalidity_date.js
var id_ce_invalidityDate6 = `${id_ce6}.24`;
var InvalidityDate11 = class InvalidityDate12 {
  constructor(value) {
    this.value = new Date;
    if (value) {
      this.value = value;
    }
  }
};
__decorate([
  AsnProp6({ type: AsnPropTypes6.GeneralizedTime })
], InvalidityDate11.prototype, "value", undefined);
InvalidityDate11 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Choice })
], InvalidityDate11);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/issuer_alternative_name.js
var IssueAlternativeName_16;
var id_ce_issuerAltName6 = `${id_ce6}.18`;
var IssueAlternativeName11 = IssueAlternativeName_16 = class IssueAlternativeName12 extends GeneralNames11 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, IssueAlternativeName_16.prototype);
  }
};
IssueAlternativeName11 = IssueAlternativeName_16 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence })
], IssueAlternativeName11);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/key_usage.js
var id_ce_keyUsage6 = `${id_ce6}.15`;
var KeyUsageFlags6;
(function(KeyUsageFlags7) {
  KeyUsageFlags7[KeyUsageFlags7["digitalSignature"] = 1] = "digitalSignature";
  KeyUsageFlags7[KeyUsageFlags7["nonRepudiation"] = 2] = "nonRepudiation";
  KeyUsageFlags7[KeyUsageFlags7["keyEncipherment"] = 4] = "keyEncipherment";
  KeyUsageFlags7[KeyUsageFlags7["dataEncipherment"] = 8] = "dataEncipherment";
  KeyUsageFlags7[KeyUsageFlags7["keyAgreement"] = 16] = "keyAgreement";
  KeyUsageFlags7[KeyUsageFlags7["keyCertSign"] = 32] = "keyCertSign";
  KeyUsageFlags7[KeyUsageFlags7["cRLSign"] = 64] = "cRLSign";
  KeyUsageFlags7[KeyUsageFlags7["encipherOnly"] = 128] = "encipherOnly";
  KeyUsageFlags7[KeyUsageFlags7["decipherOnly"] = 256] = "decipherOnly";
})(KeyUsageFlags6 || (KeyUsageFlags6 = {}));
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/name_constraints.js
var GeneralSubtrees_16;
var id_ce_nameConstraints6 = `${id_ce6}.30`;

class GeneralSubtree6 {
  constructor(params = {}) {
    this.base = new GeneralName11;
    this.minimum = 0;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: GeneralName11 })
], GeneralSubtree6.prototype, "base", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, context: 0, defaultValue: 0, implicit: true })
], GeneralSubtree6.prototype, "minimum", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, context: 1, optional: true, implicit: true })
], GeneralSubtree6.prototype, "maximum", undefined);
var GeneralSubtrees11 = GeneralSubtrees_16 = class GeneralSubtrees12 extends AsnArray6 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralSubtrees_16.prototype);
  }
};
GeneralSubtrees11 = GeneralSubtrees_16 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence, itemType: GeneralSubtree6 })
], GeneralSubtrees11);
class NameConstraints6 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: GeneralSubtrees11, context: 0, optional: true, implicit: true })
], NameConstraints6.prototype, "permittedSubtrees", undefined);
__decorate([
  AsnProp6({ type: GeneralSubtrees11, context: 1, optional: true, implicit: true })
], NameConstraints6.prototype, "excludedSubtrees", undefined);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_constraints.js
var id_ce_policyConstraints6 = `${id_ce6}.36`;

class PolicyConstraints6 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({
    type: AsnPropTypes6.Integer,
    context: 0,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter6
  })
], PolicyConstraints6.prototype, "requireExplicitPolicy", undefined);
__decorate([
  AsnProp6({
    type: AsnPropTypes6.Integer,
    context: 1,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter6
  })
], PolicyConstraints6.prototype, "inhibitPolicyMapping", undefined);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_mappings.js
var PolicyMappings_16;
var id_ce_policyMappings6 = `${id_ce6}.33`;

class PolicyMapping6 {
  constructor(params = {}) {
    this.issuerDomainPolicy = "";
    this.subjectDomainPolicy = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.ObjectIdentifier })
], PolicyMapping6.prototype, "issuerDomainPolicy", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.ObjectIdentifier })
], PolicyMapping6.prototype, "subjectDomainPolicy", undefined);
var PolicyMappings11 = PolicyMappings_16 = class PolicyMappings12 extends AsnArray6 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, PolicyMappings_16.prototype);
  }
};
PolicyMappings11 = PolicyMappings_16 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence, itemType: PolicyMapping6 })
], PolicyMappings11);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_alternative_name.js
var SubjectAlternativeName_16;
var id_ce_subjectAltName6 = `${id_ce6}.17`;
var SubjectAlternativeName11 = SubjectAlternativeName_16 = class SubjectAlternativeName12 extends GeneralNames11 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectAlternativeName_16.prototype);
  }
};
SubjectAlternativeName11 = SubjectAlternativeName_16 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence })
], SubjectAlternativeName11);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/attribute.js
class Attribute7 {
  constructor(params = {}) {
    this.type = "";
    this.values = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.ObjectIdentifier })
], Attribute7.prototype, "type", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Any, repeated: "set" })
], Attribute7.prototype, "values", undefined);

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_directory_attributes.js
var SubjectDirectoryAttributes_16;
var id_ce_subjectDirectoryAttributes6 = `${id_ce6}.9`;
var SubjectDirectoryAttributes11 = SubjectDirectoryAttributes_16 = class SubjectDirectoryAttributes12 extends AsnArray6 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectDirectoryAttributes_16.prototype);
  }
};
SubjectDirectoryAttributes11 = SubjectDirectoryAttributes_16 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence, itemType: Attribute7 })
], SubjectDirectoryAttributes11);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_key_identifier.js
var id_ce_subjectKeyIdentifier6 = `${id_ce6}.14`;
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/private_key_usage_period.js
var id_ce_privateKeyUsagePeriod6 = `${id_ce6}.16`;

class PrivateKeyUsagePeriod6 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.GeneralizedTime, context: 0, implicit: true, optional: true })
], PrivateKeyUsagePeriod6.prototype, "notBefore", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.GeneralizedTime, context: 1, implicit: true, optional: true })
], PrivateKeyUsagePeriod6.prototype, "notAfter", undefined);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/entrust_version_info.js
var EntrustInfoFlags6;
(function(EntrustInfoFlags7) {
  EntrustInfoFlags7[EntrustInfoFlags7["keyUpdateAllowed"] = 1] = "keyUpdateAllowed";
  EntrustInfoFlags7[EntrustInfoFlags7["newExtensions"] = 2] = "newExtensions";
  EntrustInfoFlags7[EntrustInfoFlags7["pKIXCertificate"] = 4] = "pKIXCertificate";
})(EntrustInfoFlags6 || (EntrustInfoFlags6 = {}));

class EntrustInfo6 extends BitString12 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & EntrustInfoFlags6.pKIXCertificate) {
      res.push("pKIXCertificate");
    }
    if (flags & EntrustInfoFlags6.newExtensions) {
      res.push("newExtensions");
    }
    if (flags & EntrustInfoFlags6.keyUpdateAllowed) {
      res.push("keyUpdateAllowed");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
}

class EntrustVersionInfo6 {
  constructor(params = {}) {
    this.entrustVers = "";
    this.entrustInfoFlags = new EntrustInfo6;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.GeneralString })
], EntrustVersionInfo6.prototype, "entrustVers", undefined);
__decorate([
  AsnProp6({ type: EntrustInfo6 })
], EntrustVersionInfo6.prototype, "entrustInfoFlags", undefined);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_info_access.js
var SubjectInfoAccessSyntax_16;
var id_pe_subjectInfoAccess6 = `${id_pe6}.11`;
var SubjectInfoAccessSyntax11 = SubjectInfoAccessSyntax_16 = class SubjectInfoAccessSyntax12 extends AsnArray6 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectInfoAccessSyntax_16.prototype);
  }
};
SubjectInfoAccessSyntax11 = SubjectInfoAccessSyntax_16 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence, itemType: AccessDescription6 })
], SubjectInfoAccessSyntax11);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js
class AlgorithmIdentifier6 {
  constructor(params = {}) {
    this.algorithm = "";
    Object.assign(this, params);
  }
  isEqual(data) {
    return data instanceof AlgorithmIdentifier6 && data.algorithm == this.algorithm && (data.parameters && this.parameters && isEqual(data.parameters, this.parameters) || data.parameters === this.parameters);
  }
}
__decorate([
  AsnProp6({
    type: AsnPropTypes6.ObjectIdentifier
  })
], AlgorithmIdentifier6.prototype, "algorithm", undefined);
__decorate([
  AsnProp6({
    type: AsnPropTypes6.Any,
    optional: true
  })
], AlgorithmIdentifier6.prototype, "parameters", undefined);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/subject_public_key_info.js
class SubjectPublicKeyInfo6 {
  constructor(params = {}) {
    this.algorithm = new AlgorithmIdentifier6;
    this.subjectPublicKey = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AlgorithmIdentifier6 })
], SubjectPublicKeyInfo6.prototype, "algorithm", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.BitString })
], SubjectPublicKeyInfo6.prototype, "subjectPublicKey", undefined);

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/time.js
var Time11 = class Time12 {
  constructor(time7) {
    if (time7) {
      if (typeof time7 === "string" || typeof time7 === "number" || time7 instanceof Date) {
        const date = new Date(time7);
        if (date.getUTCFullYear() > 2049) {
          this.generalTime = date;
        } else {
          this.utcTime = date;
        }
      } else {
        Object.assign(this, time7);
      }
    }
  }
  getTime() {
    const time7 = this.utcTime || this.generalTime;
    if (!time7) {
      throw new Error("Cannot get time from CHOICE object");
    }
    return time7;
  }
};
__decorate([
  AsnProp6({
    type: AsnPropTypes6.UTCTime
  })
], Time11.prototype, "utcTime", undefined);
__decorate([
  AsnProp6({
    type: AsnPropTypes6.GeneralizedTime
  })
], Time11.prototype, "generalTime", undefined);
Time11 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Choice })
], Time11);

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/validity.js
class Validity6 {
  constructor(params) {
    this.notBefore = new Time11(new Date);
    this.notAfter = new Time11(new Date);
    if (params) {
      this.notBefore = new Time11(params.notBefore);
      this.notAfter = new Time11(params.notAfter);
    }
  }
}
__decorate([
  AsnProp6({ type: Time11 })
], Validity6.prototype, "notBefore", undefined);
__decorate([
  AsnProp6({ type: Time11 })
], Validity6.prototype, "notAfter", undefined);

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/extension.js
var Extensions_16;

class Extension6 {
  constructor(params = {}) {
    this.extnID = "";
    this.critical = Extension6.CRITICAL;
    this.extnValue = new OctetString12;
    Object.assign(this, params);
  }
}
Extension6.CRITICAL = false;
__decorate([
  AsnProp6({ type: AsnPropTypes6.ObjectIdentifier })
], Extension6.prototype, "extnID", undefined);
__decorate([
  AsnProp6({
    type: AsnPropTypes6.Boolean,
    defaultValue: Extension6.CRITICAL
  })
], Extension6.prototype, "critical", undefined);
__decorate([
  AsnProp6({ type: OctetString12 })
], Extension6.prototype, "extnValue", undefined);
var Extensions11 = Extensions_16 = class Extensions12 extends AsnArray6 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Extensions_16.prototype);
  }
};
Extensions11 = Extensions_16 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence, itemType: Extension6 })
], Extensions11);

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/types.js
var Version7;
(function(Version8) {
  Version8[Version8["v1"] = 0] = "v1";
  Version8[Version8["v2"] = 1] = "v2";
  Version8[Version8["v3"] = 2] = "v3";
})(Version7 || (Version7 = {}));

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/tbs_certificate.js
class TBSCertificate6 {
  constructor(params = {}) {
    this.version = Version7.v1;
    this.serialNumber = new ArrayBuffer(0);
    this.signature = new AlgorithmIdentifier6;
    this.issuer = new Name11;
    this.validity = new Validity6;
    this.subject = new Name11;
    this.subjectPublicKeyInfo = new SubjectPublicKeyInfo6;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({
    type: AsnPropTypes6.Integer,
    context: 0,
    defaultValue: Version7.v1
  })
], TBSCertificate6.prototype, "version", undefined);
__decorate([
  AsnProp6({
    type: AsnPropTypes6.Integer,
    converter: AsnIntegerArrayBufferConverter6
  })
], TBSCertificate6.prototype, "serialNumber", undefined);
__decorate([
  AsnProp6({ type: AlgorithmIdentifier6 })
], TBSCertificate6.prototype, "signature", undefined);
__decorate([
  AsnProp6({ type: Name11 })
], TBSCertificate6.prototype, "issuer", undefined);
__decorate([
  AsnProp6({ type: Validity6 })
], TBSCertificate6.prototype, "validity", undefined);
__decorate([
  AsnProp6({ type: Name11 })
], TBSCertificate6.prototype, "subject", undefined);
__decorate([
  AsnProp6({ type: SubjectPublicKeyInfo6 })
], TBSCertificate6.prototype, "subjectPublicKeyInfo", undefined);
__decorate([
  AsnProp6({
    type: AsnPropTypes6.BitString,
    context: 1,
    implicit: true,
    optional: true
  })
], TBSCertificate6.prototype, "issuerUniqueID", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.BitString, context: 2, implicit: true, optional: true })
], TBSCertificate6.prototype, "subjectUniqueID", undefined);
__decorate([
  AsnProp6({ type: Extensions11, context: 3, optional: true })
], TBSCertificate6.prototype, "extensions", undefined);

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/certificate.js
class Certificate6 {
  constructor(params = {}) {
    this.tbsCertificate = new TBSCertificate6;
    this.signatureAlgorithm = new AlgorithmIdentifier6;
    this.signatureValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: TBSCertificate6, raw: true })
], Certificate6.prototype, "tbsCertificate", undefined);
__decorate([
  AsnProp6({ type: AlgorithmIdentifier6 })
], Certificate6.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.BitString })
], Certificate6.prototype, "signatureValue", undefined);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/tbs_cert_list.js
class RevokedCertificate6 {
  constructor(params = {}) {
    this.userCertificate = new ArrayBuffer(0);
    this.revocationDate = new Time11;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, converter: AsnIntegerArrayBufferConverter6 })
], RevokedCertificate6.prototype, "userCertificate", undefined);
__decorate([
  AsnProp6({ type: Time11 })
], RevokedCertificate6.prototype, "revocationDate", undefined);
__decorate([
  AsnProp6({ type: Extension6, optional: true, repeated: "sequence" })
], RevokedCertificate6.prototype, "crlEntryExtensions", undefined);

class TBSCertList6 {
  constructor(params = {}) {
    this.signature = new AlgorithmIdentifier6;
    this.issuer = new Name11;
    this.thisUpdate = new Time11;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, optional: true })
], TBSCertList6.prototype, "version", undefined);
__decorate([
  AsnProp6({ type: AlgorithmIdentifier6 })
], TBSCertList6.prototype, "signature", undefined);
__decorate([
  AsnProp6({ type: Name11 })
], TBSCertList6.prototype, "issuer", undefined);
__decorate([
  AsnProp6({ type: Time11 })
], TBSCertList6.prototype, "thisUpdate", undefined);
__decorate([
  AsnProp6({ type: Time11, optional: true })
], TBSCertList6.prototype, "nextUpdate", undefined);
__decorate([
  AsnProp6({ type: RevokedCertificate6, repeated: "sequence", optional: true })
], TBSCertList6.prototype, "revokedCertificates", undefined);
__decorate([
  AsnProp6({ type: Extension6, optional: true, context: 0, repeated: "sequence" })
], TBSCertList6.prototype, "crlExtensions", undefined);

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/node_modules/@peculiar/asn1-x509/build/es2015/certificate_list.js
class CertificateList6 {
  constructor(params = {}) {
    this.tbsCertList = new TBSCertList6;
    this.signatureAlgorithm = new AlgorithmIdentifier6;
    this.signature = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: TBSCertList6, raw: true })
], CertificateList6.prototype, "tbsCertList", undefined);
__decorate([
  AsnProp6({ type: AlgorithmIdentifier6 })
], CertificateList6.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.BitString })
], CertificateList6.prototype, "signature", undefined);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/build/es2015/object_identifiers.js
var id_pkcs_13 = "1.2.840.113549.1.1";
var id_rsaEncryption2 = `${id_pkcs_13}.1`;
var id_RSAES_OAEP2 = `${id_pkcs_13}.7`;
var id_pSpecified2 = `${id_pkcs_13}.9`;
var id_RSASSA_PSS2 = `${id_pkcs_13}.10`;
var id_md2WithRSAEncryption2 = `${id_pkcs_13}.2`;
var id_md5WithRSAEncryption2 = `${id_pkcs_13}.4`;
var id_sha1WithRSAEncryption2 = `${id_pkcs_13}.5`;
var id_sha224WithRSAEncryption2 = `${id_pkcs_13}.14`;
var id_sha256WithRSAEncryption2 = `${id_pkcs_13}.11`;
var id_sha384WithRSAEncryption2 = `${id_pkcs_13}.12`;
var id_sha512WithRSAEncryption2 = `${id_pkcs_13}.13`;
var id_sha512_224WithRSAEncryption2 = `${id_pkcs_13}.15`;
var id_sha512_256WithRSAEncryption2 = `${id_pkcs_13}.16`;
var id_sha12 = "1.3.14.3.2.26";
var id_sha2242 = "2.16.840.1.101.3.4.2.4";
var id_sha2562 = "2.16.840.1.101.3.4.2.1";
var id_sha3842 = "2.16.840.1.101.3.4.2.2";
var id_sha5122 = "2.16.840.1.101.3.4.2.3";
var id_sha512_2242 = "2.16.840.1.101.3.4.2.5";
var id_sha512_2562 = "2.16.840.1.101.3.4.2.6";
var id_md22 = "1.2.840.113549.2.2";
var id_md52 = "1.2.840.113549.2.5";
var id_mgf12 = `${id_pkcs_13}.8`;

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/build/es2015/algorithms.js
function create3(algorithm2) {
  return new AlgorithmIdentifier6({ algorithm: algorithm2, parameters: null });
}
var md22 = create3(id_md22);
var md42 = create3(id_md52);
var sha12 = create3(id_sha12);
var sha2242 = create3(id_sha2242);
var sha2562 = create3(id_sha2562);
var sha3842 = create3(id_sha3842);
var sha5122 = create3(id_sha5122);
var sha512_2242 = create3(id_sha512_2242);
var sha512_2562 = create3(id_sha512_2562);
var mgf1SHA12 = new AlgorithmIdentifier6({
  algorithm: id_mgf12,
  parameters: AsnConvert3.serialize(sha12)
});
var pSpecifiedEmpty2 = new AlgorithmIdentifier6({
  algorithm: id_pSpecified2,
  parameters: AsnConvert3.serialize(AsnOctetStringConverter6.toASN(new Uint8Array([
    218,
    57,
    163,
    238,
    94,
    107,
    75,
    13,
    50,
    85,
    191,
    239,
    149,
    96,
    24,
    144,
    175,
    216,
    7,
    9
  ]).buffer))
});
var rsaEncryption2 = create3(id_rsaEncryption2);
var md2WithRSAEncryption2 = create3(id_md2WithRSAEncryption2);
var md5WithRSAEncryption2 = create3(id_md5WithRSAEncryption2);
var sha1WithRSAEncryption2 = create3(id_sha1WithRSAEncryption2);
var sha224WithRSAEncryption2 = create3(id_sha512_224WithRSAEncryption2);
var sha256WithRSAEncryption2 = create3(id_sha512_256WithRSAEncryption2);
var sha384WithRSAEncryption2 = create3(id_sha384WithRSAEncryption2);
var sha512WithRSAEncryption2 = create3(id_sha512WithRSAEncryption2);
var sha512_224WithRSAEncryption2 = create3(id_sha512_224WithRSAEncryption2);
var sha512_256WithRSAEncryption2 = create3(id_sha512_256WithRSAEncryption2);

// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsaes_oaep.js
class RsaEsOaepParams2 {
  constructor(params = {}) {
    this.hashAlgorithm = new AlgorithmIdentifier6(sha12);
    this.maskGenAlgorithm = new AlgorithmIdentifier6({
      algorithm: id_mgf12,
      parameters: AsnConvert3.serialize(sha12)
    });
    this.pSourceAlgorithm = new AlgorithmIdentifier6(pSpecifiedEmpty2);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AlgorithmIdentifier6, context: 0, defaultValue: sha12 })
], RsaEsOaepParams2.prototype, "hashAlgorithm", undefined);
__decorate([
  AsnProp6({ type: AlgorithmIdentifier6, context: 1, defaultValue: mgf1SHA12 })
], RsaEsOaepParams2.prototype, "maskGenAlgorithm", undefined);
__decorate([
  AsnProp6({ type: AlgorithmIdentifier6, context: 2, defaultValue: pSpecifiedEmpty2 })
], RsaEsOaepParams2.prototype, "pSourceAlgorithm", undefined);
var RSAES_OAEP2 = new AlgorithmIdentifier6({
  algorithm: id_RSAES_OAEP2,
  parameters: AsnConvert3.serialize(new RsaEsOaepParams2)
});
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pss.js
class RsaSaPssParams2 {
  constructor(params = {}) {
    this.hashAlgorithm = new AlgorithmIdentifier6(sha12);
    this.maskGenAlgorithm = new AlgorithmIdentifier6({
      algorithm: id_mgf12,
      parameters: AsnConvert3.serialize(sha12)
    });
    this.saltLength = 20;
    this.trailerField = 1;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AlgorithmIdentifier6, context: 0, defaultValue: sha12 })
], RsaSaPssParams2.prototype, "hashAlgorithm", undefined);
__decorate([
  AsnProp6({ type: AlgorithmIdentifier6, context: 1, defaultValue: mgf1SHA12 })
], RsaSaPssParams2.prototype, "maskGenAlgorithm", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, context: 2, defaultValue: 20 })
], RsaSaPssParams2.prototype, "saltLength", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, context: 3, defaultValue: 1 })
], RsaSaPssParams2.prototype, "trailerField", undefined);
var RSASSA_PSS2 = new AlgorithmIdentifier6({
  algorithm: id_RSASSA_PSS2,
  parameters: AsnConvert3.serialize(new RsaSaPssParams2)
});
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pkcs1_v1_5.js
class DigestInfo2 {
  constructor(params = {}) {
    this.digestAlgorithm = new AlgorithmIdentifier6;
    this.digest = new OctetString12;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AlgorithmIdentifier6 })
], DigestInfo2.prototype, "digestAlgorithm", undefined);
__decorate([
  AsnProp6({ type: OctetString12 })
], DigestInfo2.prototype, "digest", undefined);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/build/es2015/other_prime_info.js
var OtherPrimeInfos_12;

class OtherPrimeInfo2 {
  constructor(params = {}) {
    this.prime = new ArrayBuffer(0);
    this.exponent = new ArrayBuffer(0);
    this.coefficient = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, converter: AsnIntegerArrayBufferConverter6 })
], OtherPrimeInfo2.prototype, "prime", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, converter: AsnIntegerArrayBufferConverter6 })
], OtherPrimeInfo2.prototype, "exponent", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, converter: AsnIntegerArrayBufferConverter6 })
], OtherPrimeInfo2.prototype, "coefficient", undefined);
var OtherPrimeInfos3 = OtherPrimeInfos_12 = class OtherPrimeInfos4 extends AsnArray6 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, OtherPrimeInfos_12.prototype);
  }
};
OtherPrimeInfos3 = OtherPrimeInfos_12 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence, itemType: OtherPrimeInfo2 })
], OtherPrimeInfos3);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/build/es2015/rsa_private_key.js
class RSAPrivateKey2 {
  constructor(params = {}) {
    this.version = 0;
    this.modulus = new ArrayBuffer(0);
    this.publicExponent = new ArrayBuffer(0);
    this.privateExponent = new ArrayBuffer(0);
    this.prime1 = new ArrayBuffer(0);
    this.prime2 = new ArrayBuffer(0);
    this.exponent1 = new ArrayBuffer(0);
    this.exponent2 = new ArrayBuffer(0);
    this.coefficient = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer })
], RSAPrivateKey2.prototype, "version", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, converter: AsnIntegerArrayBufferConverter6 })
], RSAPrivateKey2.prototype, "modulus", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, converter: AsnIntegerArrayBufferConverter6 })
], RSAPrivateKey2.prototype, "publicExponent", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, converter: AsnIntegerArrayBufferConverter6 })
], RSAPrivateKey2.prototype, "privateExponent", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, converter: AsnIntegerArrayBufferConverter6 })
], RSAPrivateKey2.prototype, "prime1", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, converter: AsnIntegerArrayBufferConverter6 })
], RSAPrivateKey2.prototype, "prime2", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, converter: AsnIntegerArrayBufferConverter6 })
], RSAPrivateKey2.prototype, "exponent1", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, converter: AsnIntegerArrayBufferConverter6 })
], RSAPrivateKey2.prototype, "exponent2", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, converter: AsnIntegerArrayBufferConverter6 })
], RSAPrivateKey2.prototype, "coefficient", undefined);
__decorate([
  AsnProp6({ type: OtherPrimeInfos3, optional: true })
], RSAPrivateKey2.prototype, "otherPrimeInfos", undefined);
// node_modules/@peculiar/asn1-pfx/node_modules/@peculiar/asn1-rsa/build/es2015/rsa_public_key.js
class RSAPublicKey2 {
  constructor(params = {}) {
    this.modulus = new ArrayBuffer(0);
    this.publicExponent = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, converter: AsnIntegerArrayBufferConverter6 })
], RSAPublicKey2.prototype, "modulus", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, converter: AsnIntegerArrayBufferConverter6 })
], RSAPublicKey2.prototype, "publicExponent", undefined);
// node_modules/@peculiar/asn1-pfx/build/es2015/mac_data.js
class MacData {
  constructor(params = {}) {
    this.mac = new DigestInfo2;
    this.macSalt = new OctetString12;
    this.iterations = 1;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: DigestInfo2 })
], MacData.prototype, "mac", undefined);
__decorate([
  AsnProp6({ type: OctetString12 })
], MacData.prototype, "macSalt", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer, defaultValue: 1 })
], MacData.prototype, "iterations", undefined);
// node_modules/@peculiar/asn1-pfx/build/es2015/pfx.js
class PFX {
  constructor(params = {}) {
    this.version = 3;
    this.authSafe = new ContentInfo;
    this.macData = new MacData;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.Integer })
], PFX.prototype, "version", undefined);
__decorate([
  AsnProp6({ type: ContentInfo })
], PFX.prototype, "authSafe", undefined);
__decorate([
  AsnProp6({ type: MacData, optional: true })
], PFX.prototype, "macData", undefined);
// node_modules/@peculiar/asn1-pfx/build/es2015/safe_bag.js
var SafeContents_1;

class SafeBag {
  constructor(params = {}) {
    this.bagId = "";
    this.bagValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp6({ type: AsnPropTypes6.ObjectIdentifier })
], SafeBag.prototype, "bagId", undefined);
__decorate([
  AsnProp6({ type: AsnPropTypes6.Any, context: 0 })
], SafeBag.prototype, "bagValue", undefined);
__decorate([
  AsnProp6({ type: PKCS12Attribute, repeated: "set", optional: true })
], SafeBag.prototype, "bagAttributes", undefined);
var SafeContents = SafeContents_1 = class SafeContents2 extends AsnArray6 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SafeContents_1.prototype);
  }
};
SafeContents = SafeContents_1 = __decorate([
  AsnType6({ type: AsnTypeTypes6.Sequence, itemType: SafeBag })
], SafeContents);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/ip_converter.js
class IpConverter7 {
  static isIPv4(ip2) {
    return /^(\d{1,3}\.){3}\d{1,3}$/.test(ip2);
  }
  static parseIPv4(ip2) {
    const parts = ip2.split(".");
    if (parts.length !== 4) {
      throw new Error("Invalid IPv4 address");
    }
    return parts.map((part) => {
      const num = parseInt(part, 10);
      if (isNaN(num) || num < 0 || num > 255) {
        throw new Error("Invalid IPv4 address part");
      }
      return num;
    });
  }
  static parseIPv6(ip2) {
    const expandedIP = this.expandIPv6(ip2);
    const parts = expandedIP.split(":");
    if (parts.length !== 8) {
      throw new Error("Invalid IPv6 address");
    }
    return parts.reduce((bytes, part) => {
      const num = parseInt(part, 16);
      if (isNaN(num) || num < 0 || num > 65535) {
        throw new Error("Invalid IPv6 address part");
      }
      bytes.push(num >> 8 & 255);
      bytes.push(num & 255);
      return bytes;
    }, []);
  }
  static expandIPv6(ip2) {
    if (!ip2.includes("::")) {
      return ip2;
    }
    const parts = ip2.split("::");
    if (parts.length > 2) {
      throw new Error("Invalid IPv6 address");
    }
    const left = parts[0] ? parts[0].split(":") : [];
    const right = parts[1] ? parts[1].split(":") : [];
    const missing = 8 - (left.length + right.length);
    if (missing < 0) {
      throw new Error("Invalid IPv6 address");
    }
    return [...left, ...Array(missing).fill("0"), ...right].join(":");
  }
  static formatIPv6(bytes) {
    const parts = [];
    for (let i = 0;i < 16; i += 2) {
      parts.push((bytes[i] << 8 | bytes[i + 1]).toString(16));
    }
    return this.compressIPv6(parts.join(":"));
  }
  static compressIPv6(ip2) {
    const parts = ip2.split(":");
    let longestZeroStart = -1;
    let longestZeroLength = 0;
    let currentZeroStart = -1;
    let currentZeroLength = 0;
    for (let i = 0;i < parts.length; i++) {
      if (parts[i] === "0") {
        if (currentZeroStart === -1) {
          currentZeroStart = i;
        }
        currentZeroLength++;
      } else {
        if (currentZeroLength > longestZeroLength) {
          longestZeroStart = currentZeroStart;
          longestZeroLength = currentZeroLength;
        }
        currentZeroStart = -1;
        currentZeroLength = 0;
      }
    }
    if (currentZeroLength > longestZeroLength) {
      longestZeroStart = currentZeroStart;
      longestZeroLength = currentZeroLength;
    }
    if (longestZeroLength > 1) {
      const before = parts.slice(0, longestZeroStart).join(":");
      const after = parts.slice(longestZeroStart + longestZeroLength).join(":");
      return `${before}::${after}`;
    }
    return ip2;
  }
  static parseCIDR(text) {
    const [addr, prefixStr] = text.split("/");
    const prefix = parseInt(prefixStr, 10);
    if (this.isIPv4(addr)) {
      if (prefix < 0 || prefix > 32) {
        throw new Error("Invalid IPv4 prefix length");
      }
      return [this.parseIPv4(addr), prefix];
    } else {
      if (prefix < 0 || prefix > 128) {
        throw new Error("Invalid IPv6 prefix length");
      }
      return [this.parseIPv6(addr), prefix];
    }
  }
  static decodeIP(value) {
    if (value.length === 64 && parseInt(value, 16) === 0) {
      return "::/0";
    }
    if (value.length !== 16) {
      return value;
    }
    const mask = parseInt(value.slice(8), 16).toString(2).split("").reduce((a, k) => a + +k, 0);
    let ip2 = value.slice(0, 8).replace(/(.{2})/g, (match2) => `${parseInt(match2, 16)}.`);
    ip2 = ip2.slice(0, -1);
    return `${ip2}/${mask}`;
  }
  static toString(buf) {
    const uint8 = new Uint8Array(buf);
    if (uint8.length === 4) {
      return Array.from(uint8).join(".");
    }
    if (uint8.length === 16) {
      return this.formatIPv6(uint8);
    }
    if (uint8.length === 8 || uint8.length === 32) {
      const half = uint8.length / 2;
      const addrBytes = uint8.slice(0, half);
      const maskBytes = uint8.slice(half);
      const isAllZeros = uint8.every((byte) => byte === 0);
      if (isAllZeros) {
        return uint8.length === 8 ? "0.0.0.0/0" : "::/0";
      }
      const prefixLen = maskBytes.reduce((a, b) => a + (b.toString(2).match(/1/g) || []).length, 0);
      if (uint8.length === 8) {
        const addrStr = Array.from(addrBytes).join(".");
        return `${addrStr}/${prefixLen}`;
      } else {
        const addrStr = this.formatIPv6(addrBytes);
        return `${addrStr}/${prefixLen}`;
      }
    }
    return this.decodeIP(Convert.ToHex(buf));
  }
  static fromString(text) {
    if (text.includes("/")) {
      const [addr, prefix] = this.parseCIDR(text);
      const maskBytes = new Uint8Array(addr.length);
      let bitsLeft = prefix;
      for (let i = 0;i < maskBytes.length; i++) {
        if (bitsLeft >= 8) {
          maskBytes[i] = 255;
          bitsLeft -= 8;
        } else if (bitsLeft > 0) {
          maskBytes[i] = 255 << 8 - bitsLeft;
          bitsLeft = 0;
        }
      }
      const out = new Uint8Array(addr.length * 2);
      out.set(addr, 0);
      out.set(maskBytes, addr.length);
      return out.buffer;
    }
    const bytes = this.isIPv4(text) ? this.parseIPv4(text) : this.parseIPv6(text);
    return new Uint8Array(bytes).buffer;
  }
}

// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/name.js
var RelativeDistinguishedName_17;
var RDNSequence_17;
var Name_17;
var DirectoryString13 = class DirectoryString14 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.bmpString || this.printableString || this.teletexString || this.universalString || this.utf8String || "";
  }
};
__decorate([
  AsnProp5({ type: AsnPropTypes5.TeletexString })
], DirectoryString13.prototype, "teletexString", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.PrintableString })
], DirectoryString13.prototype, "printableString", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.UniversalString })
], DirectoryString13.prototype, "universalString", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.Utf8String })
], DirectoryString13.prototype, "utf8String", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.BmpString })
], DirectoryString13.prototype, "bmpString", undefined);
DirectoryString13 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], DirectoryString13);
var AttributeValue13 = class AttributeValue14 extends DirectoryString13 {
  constructor(params = {}) {
    super(params);
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || (this.anyValue ? Convert.ToHex(this.anyValue) : super.toString());
  }
};
__decorate([
  AsnProp5({ type: AsnPropTypes5.IA5String })
], AttributeValue13.prototype, "ia5String", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.Any })
], AttributeValue13.prototype, "anyValue", undefined);
AttributeValue13 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], AttributeValue13);
class AttributeTypeAndValue7 {
  constructor(params = {}) {
    this.type = "";
    this.value = new AttributeValue13;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: AsnPropTypes5.ObjectIdentifier })
], AttributeTypeAndValue7.prototype, "type", undefined);
__decorate([
  AsnProp5({ type: AttributeValue13 })
], AttributeTypeAndValue7.prototype, "value", undefined);
var RelativeDistinguishedName13 = RelativeDistinguishedName_17 = class RelativeDistinguishedName14 extends AsnArray5 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RelativeDistinguishedName_17.prototype);
  }
};
RelativeDistinguishedName13 = RelativeDistinguishedName_17 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Set, itemType: AttributeTypeAndValue7 })
], RelativeDistinguishedName13);
var RDNSequence13 = RDNSequence_17 = class RDNSequence14 extends AsnArray5 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RDNSequence_17.prototype);
  }
};
RDNSequence13 = RDNSequence_17 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence, itemType: RelativeDistinguishedName13 })
], RDNSequence13);
var Name13 = Name_17 = class Name14 extends RDNSequence13 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Name_17.prototype);
  }
};
Name13 = Name_17 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence })
], Name13);

// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/general_name.js
var AsnIpConverter7 = {
  fromASN: (value) => IpConverter7.toString(AsnOctetStringConverter5.fromASN(value)),
  toASN: (value) => AsnOctetStringConverter5.toASN(IpConverter7.fromString(value))
};

class OtherName7 {
  constructor(params = {}) {
    this.typeId = "";
    this.value = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: AsnPropTypes5.ObjectIdentifier })
], OtherName7.prototype, "typeId", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.Any, context: 0 })
], OtherName7.prototype, "value", undefined);

class EDIPartyName7 {
  constructor(params = {}) {
    this.partyName = new DirectoryString13;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: DirectoryString13, optional: true, context: 0, implicit: true })
], EDIPartyName7.prototype, "nameAssigner", undefined);
__decorate([
  AsnProp5({ type: DirectoryString13, context: 1, implicit: true })
], EDIPartyName7.prototype, "partyName", undefined);
var GeneralName13 = class GeneralName14 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp5({ type: OtherName7, context: 0, implicit: true })
], GeneralName13.prototype, "otherName", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.IA5String, context: 1, implicit: true })
], GeneralName13.prototype, "rfc822Name", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.IA5String, context: 2, implicit: true })
], GeneralName13.prototype, "dNSName", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.Any, context: 3, implicit: true })
], GeneralName13.prototype, "x400Address", undefined);
__decorate([
  AsnProp5({ type: Name13, context: 4, implicit: false })
], GeneralName13.prototype, "directoryName", undefined);
__decorate([
  AsnProp5({ type: EDIPartyName7, context: 5 })
], GeneralName13.prototype, "ediPartyName", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.IA5String, context: 6, implicit: true })
], GeneralName13.prototype, "uniformResourceIdentifier", undefined);
__decorate([
  AsnProp5({
    type: AsnPropTypes5.OctetString,
    context: 7,
    implicit: true,
    converter: AsnIpConverter7
  })
], GeneralName13.prototype, "iPAddress", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.ObjectIdentifier, context: 8, implicit: true })
], GeneralName13.prototype, "registeredID", undefined);
GeneralName13 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], GeneralName13);

// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js
var id_pkix7 = "1.3.6.1.5.5.7";
var id_pe7 = `${id_pkix7}.1`;
var id_qt7 = `${id_pkix7}.2`;
var id_kp7 = `${id_pkix7}.3`;
var id_ad7 = `${id_pkix7}.48`;
var id_qt_csp7 = `${id_qt7}.1`;
var id_qt_unotice7 = `${id_qt7}.2`;
var id_ad_ocsp7 = `${id_ad7}.1`;
var id_ad_caIssuers7 = `${id_ad7}.2`;
var id_ad_timeStamping7 = `${id_ad7}.3`;
var id_ad_caRepository7 = `${id_ad7}.5`;
var id_ce7 = "2.5.29";

// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_information_access.js
var AuthorityInfoAccessSyntax_17;
var id_pe_authorityInfoAccess7 = `${id_pe7}.1`;

class AccessDescription7 {
  constructor(params = {}) {
    this.accessMethod = "";
    this.accessLocation = new GeneralName13;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: AsnPropTypes5.ObjectIdentifier })
], AccessDescription7.prototype, "accessMethod", undefined);
__decorate([
  AsnProp5({ type: GeneralName13 })
], AccessDescription7.prototype, "accessLocation", undefined);
var AuthorityInfoAccessSyntax13 = AuthorityInfoAccessSyntax_17 = class AuthorityInfoAccessSyntax14 extends AsnArray5 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, AuthorityInfoAccessSyntax_17.prototype);
  }
};
AuthorityInfoAccessSyntax13 = AuthorityInfoAccessSyntax_17 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence, itemType: AccessDescription7 })
], AuthorityInfoAccessSyntax13);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_key_identifier.js
var id_ce_authorityKeyIdentifier7 = `${id_ce7}.35`;

class KeyIdentifier7 extends OctetString10 {
}

class AuthorityKeyIdentifier7 {
  constructor(params = {}) {
    if (params) {
      Object.assign(this, params);
    }
  }
}
__decorate([
  AsnProp5({ type: KeyIdentifier7, context: 0, optional: true, implicit: true })
], AuthorityKeyIdentifier7.prototype, "keyIdentifier", undefined);
__decorate([
  AsnProp5({ type: GeneralName13, context: 1, optional: true, implicit: true, repeated: "sequence" })
], AuthorityKeyIdentifier7.prototype, "authorityCertIssuer", undefined);
__decorate([
  AsnProp5({
    type: AsnPropTypes5.Integer,
    context: 2,
    optional: true,
    implicit: true,
    converter: AsnIntegerArrayBufferConverter5
  })
], AuthorityKeyIdentifier7.prototype, "authorityCertSerialNumber", undefined);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/basic_constraints.js
var id_ce_basicConstraints7 = `${id_ce7}.19`;

class BasicConstraints7 {
  constructor(params = {}) {
    this.cA = false;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: AsnPropTypes5.Boolean, defaultValue: false })
], BasicConstraints7.prototype, "cA", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.Integer, optional: true })
], BasicConstraints7.prototype, "pathLenConstraint", undefined);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/general_names.js
var GeneralNames_17;
var GeneralNames13 = GeneralNames_17 = class GeneralNames14 extends AsnArray5 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralNames_17.prototype);
  }
};
GeneralNames13 = GeneralNames_17 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence, itemType: GeneralName13 })
], GeneralNames13);

// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_issuer.js
var CertificateIssuer_17;
var id_ce_certificateIssuer7 = `${id_ce7}.29`;
var CertificateIssuer13 = CertificateIssuer_17 = class CertificateIssuer14 extends GeneralNames13 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificateIssuer_17.prototype);
  }
};
CertificateIssuer13 = CertificateIssuer_17 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence })
], CertificateIssuer13);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_policies.js
var CertificatePolicies_17;
var id_ce_certificatePolicies7 = `${id_ce7}.32`;
var id_ce_certificatePolicies_anyPolicy7 = `${id_ce_certificatePolicies7}.0`;
var DisplayText13 = class DisplayText14 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || this.visibleString || this.bmpString || this.utf8String || "";
  }
};
__decorate([
  AsnProp5({ type: AsnPropTypes5.IA5String })
], DisplayText13.prototype, "ia5String", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.VisibleString })
], DisplayText13.prototype, "visibleString", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.BmpString })
], DisplayText13.prototype, "bmpString", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.Utf8String })
], DisplayText13.prototype, "utf8String", undefined);
DisplayText13 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], DisplayText13);
class NoticeReference7 {
  constructor(params = {}) {
    this.organization = new DisplayText13;
    this.noticeNumbers = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: DisplayText13 })
], NoticeReference7.prototype, "organization", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.Integer, repeated: "sequence" })
], NoticeReference7.prototype, "noticeNumbers", undefined);

class UserNotice7 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: NoticeReference7, optional: true })
], UserNotice7.prototype, "noticeRef", undefined);
__decorate([
  AsnProp5({ type: DisplayText13, optional: true })
], UserNotice7.prototype, "explicitText", undefined);
var Qualifier13 = class Qualifier14 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp5({ type: AsnPropTypes5.IA5String })
], Qualifier13.prototype, "cPSuri", undefined);
__decorate([
  AsnProp5({ type: UserNotice7 })
], Qualifier13.prototype, "userNotice", undefined);
Qualifier13 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], Qualifier13);
class PolicyQualifierInfo7 {
  constructor(params = {}) {
    this.policyQualifierId = "";
    this.qualifier = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: AsnPropTypes5.ObjectIdentifier })
], PolicyQualifierInfo7.prototype, "policyQualifierId", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.Any })
], PolicyQualifierInfo7.prototype, "qualifier", undefined);

class PolicyInformation7 {
  constructor(params = {}) {
    this.policyIdentifier = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: AsnPropTypes5.ObjectIdentifier })
], PolicyInformation7.prototype, "policyIdentifier", undefined);
__decorate([
  AsnProp5({ type: PolicyQualifierInfo7, repeated: "sequence", optional: true })
], PolicyInformation7.prototype, "policyQualifiers", undefined);
var CertificatePolicies13 = CertificatePolicies_17 = class CertificatePolicies14 extends AsnArray5 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificatePolicies_17.prototype);
  }
};
CertificatePolicies13 = CertificatePolicies_17 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence, itemType: PolicyInformation7 })
], CertificatePolicies13);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_number.js
var id_ce_cRLNumber7 = `${id_ce7}.20`;
var CRLNumber13 = class CRLNumber14 {
  constructor(value = 0) {
    this.value = value;
  }
};
__decorate([
  AsnProp5({ type: AsnPropTypes5.Integer })
], CRLNumber13.prototype, "value", undefined);
CRLNumber13 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], CRLNumber13);

// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_delta_indicator.js
var id_ce_deltaCRLIndicator7 = `${id_ce7}.27`;
var BaseCRLNumber13 = class BaseCRLNumber14 extends CRLNumber13 {
};
BaseCRLNumber13 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], BaseCRLNumber13);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_distribution_points.js
var CRLDistributionPoints_17;
var id_ce_cRLDistributionPoints7 = `${id_ce7}.31`;
var ReasonFlags7;
(function(ReasonFlags8) {
  ReasonFlags8[ReasonFlags8["unused"] = 1] = "unused";
  ReasonFlags8[ReasonFlags8["keyCompromise"] = 2] = "keyCompromise";
  ReasonFlags8[ReasonFlags8["cACompromise"] = 4] = "cACompromise";
  ReasonFlags8[ReasonFlags8["affiliationChanged"] = 8] = "affiliationChanged";
  ReasonFlags8[ReasonFlags8["superseded"] = 16] = "superseded";
  ReasonFlags8[ReasonFlags8["cessationOfOperation"] = 32] = "cessationOfOperation";
  ReasonFlags8[ReasonFlags8["certificateHold"] = 64] = "certificateHold";
  ReasonFlags8[ReasonFlags8["privilegeWithdrawn"] = 128] = "privilegeWithdrawn";
  ReasonFlags8[ReasonFlags8["aACompromise"] = 256] = "aACompromise";
})(ReasonFlags7 || (ReasonFlags7 = {}));

class Reason7 extends BitString10 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & ReasonFlags7.aACompromise) {
      res.push("aACompromise");
    }
    if (flags & ReasonFlags7.affiliationChanged) {
      res.push("affiliationChanged");
    }
    if (flags & ReasonFlags7.cACompromise) {
      res.push("cACompromise");
    }
    if (flags & ReasonFlags7.certificateHold) {
      res.push("certificateHold");
    }
    if (flags & ReasonFlags7.cessationOfOperation) {
      res.push("cessationOfOperation");
    }
    if (flags & ReasonFlags7.keyCompromise) {
      res.push("keyCompromise");
    }
    if (flags & ReasonFlags7.privilegeWithdrawn) {
      res.push("privilegeWithdrawn");
    }
    if (flags & ReasonFlags7.superseded) {
      res.push("superseded");
    }
    if (flags & ReasonFlags7.unused) {
      res.push("unused");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
}
var DistributionPointName13 = class DistributionPointName14 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp5({ type: GeneralName13, context: 0, repeated: "sequence", implicit: true })
], DistributionPointName13.prototype, "fullName", undefined);
__decorate([
  AsnProp5({ type: RelativeDistinguishedName13, context: 1, implicit: true })
], DistributionPointName13.prototype, "nameRelativeToCRLIssuer", undefined);
DistributionPointName13 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], DistributionPointName13);
class DistributionPoint7 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: DistributionPointName13, context: 0, optional: true })
], DistributionPoint7.prototype, "distributionPoint", undefined);
__decorate([
  AsnProp5({ type: Reason7, context: 1, optional: true, implicit: true })
], DistributionPoint7.prototype, "reasons", undefined);
__decorate([
  AsnProp5({ type: GeneralName13, context: 2, optional: true, repeated: "sequence", implicit: true })
], DistributionPoint7.prototype, "cRLIssuer", undefined);
var CRLDistributionPoints13 = CRLDistributionPoints_17 = class CRLDistributionPoints14 extends AsnArray5 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CRLDistributionPoints_17.prototype);
  }
};
CRLDistributionPoints13 = CRLDistributionPoints_17 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence, itemType: DistributionPoint7 })
], CRLDistributionPoints13);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_freshest.js
var FreshestCRL_17;
var id_ce_freshestCRL7 = `${id_ce7}.46`;
var FreshestCRL13 = FreshestCRL_17 = class FreshestCRL14 extends CRLDistributionPoints13 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, FreshestCRL_17.prototype);
  }
};
FreshestCRL13 = FreshestCRL_17 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence, itemType: DistributionPoint7 })
], FreshestCRL13);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_issuing_distribution_point.js
var id_ce_issuingDistributionPoint7 = `${id_ce7}.28`;

class IssuingDistributionPoint7 {
  constructor(params = {}) {
    this.onlyContainsUserCerts = IssuingDistributionPoint7.ONLY;
    this.onlyContainsCACerts = IssuingDistributionPoint7.ONLY;
    this.indirectCRL = IssuingDistributionPoint7.ONLY;
    this.onlyContainsAttributeCerts = IssuingDistributionPoint7.ONLY;
    Object.assign(this, params);
  }
}
IssuingDistributionPoint7.ONLY = false;
__decorate([
  AsnProp5({ type: DistributionPointName13, context: 0, optional: true })
], IssuingDistributionPoint7.prototype, "distributionPoint", undefined);
__decorate([
  AsnProp5({
    type: AsnPropTypes5.Boolean,
    context: 1,
    defaultValue: IssuingDistributionPoint7.ONLY,
    implicit: true
  })
], IssuingDistributionPoint7.prototype, "onlyContainsUserCerts", undefined);
__decorate([
  AsnProp5({
    type: AsnPropTypes5.Boolean,
    context: 2,
    defaultValue: IssuingDistributionPoint7.ONLY,
    implicit: true
  })
], IssuingDistributionPoint7.prototype, "onlyContainsCACerts", undefined);
__decorate([
  AsnProp5({ type: Reason7, context: 3, optional: true, implicit: true })
], IssuingDistributionPoint7.prototype, "onlySomeReasons", undefined);
__decorate([
  AsnProp5({
    type: AsnPropTypes5.Boolean,
    context: 4,
    defaultValue: IssuingDistributionPoint7.ONLY,
    implicit: true
  })
], IssuingDistributionPoint7.prototype, "indirectCRL", undefined);
__decorate([
  AsnProp5({
    type: AsnPropTypes5.Boolean,
    context: 5,
    defaultValue: IssuingDistributionPoint7.ONLY,
    implicit: true
  })
], IssuingDistributionPoint7.prototype, "onlyContainsAttributeCerts", undefined);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_reason.js
var id_ce_cRLReasons7 = `${id_ce7}.21`;
var CRLReasons7;
(function(CRLReasons8) {
  CRLReasons8[CRLReasons8["unspecified"] = 0] = "unspecified";
  CRLReasons8[CRLReasons8["keyCompromise"] = 1] = "keyCompromise";
  CRLReasons8[CRLReasons8["cACompromise"] = 2] = "cACompromise";
  CRLReasons8[CRLReasons8["affiliationChanged"] = 3] = "affiliationChanged";
  CRLReasons8[CRLReasons8["superseded"] = 4] = "superseded";
  CRLReasons8[CRLReasons8["cessationOfOperation"] = 5] = "cessationOfOperation";
  CRLReasons8[CRLReasons8["certificateHold"] = 6] = "certificateHold";
  CRLReasons8[CRLReasons8["removeFromCRL"] = 8] = "removeFromCRL";
  CRLReasons8[CRLReasons8["privilegeWithdrawn"] = 9] = "privilegeWithdrawn";
  CRLReasons8[CRLReasons8["aACompromise"] = 10] = "aACompromise";
})(CRLReasons7 || (CRLReasons7 = {}));
var CRLReason13 = class CRLReason14 {
  constructor(reason = CRLReasons7.unspecified) {
    this.reason = CRLReasons7.unspecified;
    this.reason = reason;
  }
  toJSON() {
    return CRLReasons7[this.reason];
  }
  toString() {
    return this.toJSON();
  }
};
__decorate([
  AsnProp5({ type: AsnPropTypes5.Enumerated })
], CRLReason13.prototype, "reason", undefined);
CRLReason13 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], CRLReason13);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/extended_key_usage.js
var ExtendedKeyUsage_17;
var id_ce_extKeyUsage7 = `${id_ce7}.37`;
var ExtendedKeyUsage13 = ExtendedKeyUsage_17 = class ExtendedKeyUsage14 extends AsnArray5 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, ExtendedKeyUsage_17.prototype);
  }
};
ExtendedKeyUsage13 = ExtendedKeyUsage_17 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence, itemType: AsnPropTypes5.ObjectIdentifier })
], ExtendedKeyUsage13);
var anyExtendedKeyUsage7 = `${id_ce_extKeyUsage7}.0`;
var id_kp_serverAuth7 = `${id_kp7}.1`;
var id_kp_clientAuth7 = `${id_kp7}.2`;
var id_kp_codeSigning7 = `${id_kp7}.3`;
var id_kp_emailProtection7 = `${id_kp7}.4`;
var id_kp_timeStamping7 = `${id_kp7}.8`;
var id_kp_OCSPSigning7 = `${id_kp7}.9`;
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/inhibit_any_policy.js
var id_ce_inhibitAnyPolicy7 = `${id_ce7}.54`;
var InhibitAnyPolicy13 = class InhibitAnyPolicy14 {
  constructor(value = new ArrayBuffer(0)) {
    this.value = value;
  }
};
__decorate([
  AsnProp5({ type: AsnPropTypes5.Integer, converter: AsnIntegerArrayBufferConverter5 })
], InhibitAnyPolicy13.prototype, "value", undefined);
InhibitAnyPolicy13 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], InhibitAnyPolicy13);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/invalidity_date.js
var id_ce_invalidityDate7 = `${id_ce7}.24`;
var InvalidityDate13 = class InvalidityDate14 {
  constructor(value) {
    this.value = new Date;
    if (value) {
      this.value = value;
    }
  }
};
__decorate([
  AsnProp5({ type: AsnPropTypes5.GeneralizedTime })
], InvalidityDate13.prototype, "value", undefined);
InvalidityDate13 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], InvalidityDate13);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/issuer_alternative_name.js
var IssueAlternativeName_17;
var id_ce_issuerAltName7 = `${id_ce7}.18`;
var IssueAlternativeName13 = IssueAlternativeName_17 = class IssueAlternativeName14 extends GeneralNames13 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, IssueAlternativeName_17.prototype);
  }
};
IssueAlternativeName13 = IssueAlternativeName_17 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence })
], IssueAlternativeName13);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/key_usage.js
var id_ce_keyUsage7 = `${id_ce7}.15`;
var KeyUsageFlags7;
(function(KeyUsageFlags8) {
  KeyUsageFlags8[KeyUsageFlags8["digitalSignature"] = 1] = "digitalSignature";
  KeyUsageFlags8[KeyUsageFlags8["nonRepudiation"] = 2] = "nonRepudiation";
  KeyUsageFlags8[KeyUsageFlags8["keyEncipherment"] = 4] = "keyEncipherment";
  KeyUsageFlags8[KeyUsageFlags8["dataEncipherment"] = 8] = "dataEncipherment";
  KeyUsageFlags8[KeyUsageFlags8["keyAgreement"] = 16] = "keyAgreement";
  KeyUsageFlags8[KeyUsageFlags8["keyCertSign"] = 32] = "keyCertSign";
  KeyUsageFlags8[KeyUsageFlags8["cRLSign"] = 64] = "cRLSign";
  KeyUsageFlags8[KeyUsageFlags8["encipherOnly"] = 128] = "encipherOnly";
  KeyUsageFlags8[KeyUsageFlags8["decipherOnly"] = 256] = "decipherOnly";
})(KeyUsageFlags7 || (KeyUsageFlags7 = {}));
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/name_constraints.js
var GeneralSubtrees_17;
var id_ce_nameConstraints7 = `${id_ce7}.30`;

class GeneralSubtree7 {
  constructor(params = {}) {
    this.base = new GeneralName13;
    this.minimum = 0;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: GeneralName13 })
], GeneralSubtree7.prototype, "base", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.Integer, context: 0, defaultValue: 0, implicit: true })
], GeneralSubtree7.prototype, "minimum", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.Integer, context: 1, optional: true, implicit: true })
], GeneralSubtree7.prototype, "maximum", undefined);
var GeneralSubtrees13 = GeneralSubtrees_17 = class GeneralSubtrees14 extends AsnArray5 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralSubtrees_17.prototype);
  }
};
GeneralSubtrees13 = GeneralSubtrees_17 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence, itemType: GeneralSubtree7 })
], GeneralSubtrees13);
class NameConstraints7 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: GeneralSubtrees13, context: 0, optional: true, implicit: true })
], NameConstraints7.prototype, "permittedSubtrees", undefined);
__decorate([
  AsnProp5({ type: GeneralSubtrees13, context: 1, optional: true, implicit: true })
], NameConstraints7.prototype, "excludedSubtrees", undefined);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_constraints.js
var id_ce_policyConstraints7 = `${id_ce7}.36`;

class PolicyConstraints7 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({
    type: AsnPropTypes5.Integer,
    context: 0,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter5
  })
], PolicyConstraints7.prototype, "requireExplicitPolicy", undefined);
__decorate([
  AsnProp5({
    type: AsnPropTypes5.Integer,
    context: 1,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter5
  })
], PolicyConstraints7.prototype, "inhibitPolicyMapping", undefined);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_mappings.js
var PolicyMappings_17;
var id_ce_policyMappings7 = `${id_ce7}.33`;

class PolicyMapping7 {
  constructor(params = {}) {
    this.issuerDomainPolicy = "";
    this.subjectDomainPolicy = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: AsnPropTypes5.ObjectIdentifier })
], PolicyMapping7.prototype, "issuerDomainPolicy", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.ObjectIdentifier })
], PolicyMapping7.prototype, "subjectDomainPolicy", undefined);
var PolicyMappings13 = PolicyMappings_17 = class PolicyMappings14 extends AsnArray5 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, PolicyMappings_17.prototype);
  }
};
PolicyMappings13 = PolicyMappings_17 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence, itemType: PolicyMapping7 })
], PolicyMappings13);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_alternative_name.js
var SubjectAlternativeName_17;
var id_ce_subjectAltName7 = `${id_ce7}.17`;
var SubjectAlternativeName13 = SubjectAlternativeName_17 = class SubjectAlternativeName14 extends GeneralNames13 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectAlternativeName_17.prototype);
  }
};
SubjectAlternativeName13 = SubjectAlternativeName_17 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence })
], SubjectAlternativeName13);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/attribute.js
class Attribute8 {
  constructor(params = {}) {
    this.type = "";
    this.values = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: AsnPropTypes5.ObjectIdentifier })
], Attribute8.prototype, "type", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.Any, repeated: "set" })
], Attribute8.prototype, "values", undefined);

// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_directory_attributes.js
var SubjectDirectoryAttributes_17;
var id_ce_subjectDirectoryAttributes7 = `${id_ce7}.9`;
var SubjectDirectoryAttributes13 = SubjectDirectoryAttributes_17 = class SubjectDirectoryAttributes14 extends AsnArray5 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectDirectoryAttributes_17.prototype);
  }
};
SubjectDirectoryAttributes13 = SubjectDirectoryAttributes_17 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence, itemType: Attribute8 })
], SubjectDirectoryAttributes13);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_key_identifier.js
var id_ce_subjectKeyIdentifier7 = `${id_ce7}.14`;
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/private_key_usage_period.js
var id_ce_privateKeyUsagePeriod7 = `${id_ce7}.16`;

class PrivateKeyUsagePeriod7 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: AsnPropTypes5.GeneralizedTime, context: 0, implicit: true, optional: true })
], PrivateKeyUsagePeriod7.prototype, "notBefore", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.GeneralizedTime, context: 1, implicit: true, optional: true })
], PrivateKeyUsagePeriod7.prototype, "notAfter", undefined);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/entrust_version_info.js
var EntrustInfoFlags7;
(function(EntrustInfoFlags8) {
  EntrustInfoFlags8[EntrustInfoFlags8["keyUpdateAllowed"] = 1] = "keyUpdateAllowed";
  EntrustInfoFlags8[EntrustInfoFlags8["newExtensions"] = 2] = "newExtensions";
  EntrustInfoFlags8[EntrustInfoFlags8["pKIXCertificate"] = 4] = "pKIXCertificate";
})(EntrustInfoFlags7 || (EntrustInfoFlags7 = {}));

class EntrustInfo7 extends BitString10 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & EntrustInfoFlags7.pKIXCertificate) {
      res.push("pKIXCertificate");
    }
    if (flags & EntrustInfoFlags7.newExtensions) {
      res.push("newExtensions");
    }
    if (flags & EntrustInfoFlags7.keyUpdateAllowed) {
      res.push("keyUpdateAllowed");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
}

class EntrustVersionInfo7 {
  constructor(params = {}) {
    this.entrustVers = "";
    this.entrustInfoFlags = new EntrustInfo7;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: AsnPropTypes5.GeneralString })
], EntrustVersionInfo7.prototype, "entrustVers", undefined);
__decorate([
  AsnProp5({ type: EntrustInfo7 })
], EntrustVersionInfo7.prototype, "entrustInfoFlags", undefined);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_info_access.js
var SubjectInfoAccessSyntax_17;
var id_pe_subjectInfoAccess7 = `${id_pe7}.11`;
var SubjectInfoAccessSyntax13 = SubjectInfoAccessSyntax_17 = class SubjectInfoAccessSyntax14 extends AsnArray5 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectInfoAccessSyntax_17.prototype);
  }
};
SubjectInfoAccessSyntax13 = SubjectInfoAccessSyntax_17 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence, itemType: AccessDescription7 })
], SubjectInfoAccessSyntax13);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js
class AlgorithmIdentifier7 {
  constructor(params = {}) {
    this.algorithm = "";
    Object.assign(this, params);
  }
  isEqual(data) {
    return data instanceof AlgorithmIdentifier7 && data.algorithm == this.algorithm && (data.parameters && this.parameters && isEqual(data.parameters, this.parameters) || data.parameters === this.parameters);
  }
}
__decorate([
  AsnProp5({
    type: AsnPropTypes5.ObjectIdentifier
  })
], AlgorithmIdentifier7.prototype, "algorithm", undefined);
__decorate([
  AsnProp5({
    type: AsnPropTypes5.Any,
    optional: true
  })
], AlgorithmIdentifier7.prototype, "parameters", undefined);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/subject_public_key_info.js
class SubjectPublicKeyInfo7 {
  constructor(params = {}) {
    this.algorithm = new AlgorithmIdentifier7;
    this.subjectPublicKey = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: AlgorithmIdentifier7 })
], SubjectPublicKeyInfo7.prototype, "algorithm", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.BitString })
], SubjectPublicKeyInfo7.prototype, "subjectPublicKey", undefined);

// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/time.js
var Time13 = class Time14 {
  constructor(time8) {
    if (time8) {
      if (typeof time8 === "string" || typeof time8 === "number" || time8 instanceof Date) {
        const date = new Date(time8);
        if (date.getUTCFullYear() > 2049) {
          this.generalTime = date;
        } else {
          this.utcTime = date;
        }
      } else {
        Object.assign(this, time8);
      }
    }
  }
  getTime() {
    const time8 = this.utcTime || this.generalTime;
    if (!time8) {
      throw new Error("Cannot get time from CHOICE object");
    }
    return time8;
  }
};
__decorate([
  AsnProp5({
    type: AsnPropTypes5.UTCTime
  })
], Time13.prototype, "utcTime", undefined);
__decorate([
  AsnProp5({
    type: AsnPropTypes5.GeneralizedTime
  })
], Time13.prototype, "generalTime", undefined);
Time13 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], Time13);

// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/validity.js
class Validity7 {
  constructor(params) {
    this.notBefore = new Time13(new Date);
    this.notAfter = new Time13(new Date);
    if (params) {
      this.notBefore = new Time13(params.notBefore);
      this.notAfter = new Time13(params.notAfter);
    }
  }
}
__decorate([
  AsnProp5({ type: Time13 })
], Validity7.prototype, "notBefore", undefined);
__decorate([
  AsnProp5({ type: Time13 })
], Validity7.prototype, "notAfter", undefined);

// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/extension.js
var Extensions_17;

class Extension7 {
  constructor(params = {}) {
    this.extnID = "";
    this.critical = Extension7.CRITICAL;
    this.extnValue = new OctetString10;
    Object.assign(this, params);
  }
}
Extension7.CRITICAL = false;
__decorate([
  AsnProp5({ type: AsnPropTypes5.ObjectIdentifier })
], Extension7.prototype, "extnID", undefined);
__decorate([
  AsnProp5({
    type: AsnPropTypes5.Boolean,
    defaultValue: Extension7.CRITICAL
  })
], Extension7.prototype, "critical", undefined);
__decorate([
  AsnProp5({ type: OctetString10 })
], Extension7.prototype, "extnValue", undefined);
var Extensions13 = Extensions_17 = class Extensions14 extends AsnArray5 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Extensions_17.prototype);
  }
};
Extensions13 = Extensions_17 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence, itemType: Extension7 })
], Extensions13);

// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/types.js
var Version8;
(function(Version9) {
  Version9[Version9["v1"] = 0] = "v1";
  Version9[Version9["v2"] = 1] = "v2";
  Version9[Version9["v3"] = 2] = "v3";
})(Version8 || (Version8 = {}));

// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/tbs_certificate.js
class TBSCertificate7 {
  constructor(params = {}) {
    this.version = Version8.v1;
    this.serialNumber = new ArrayBuffer(0);
    this.signature = new AlgorithmIdentifier7;
    this.issuer = new Name13;
    this.validity = new Validity7;
    this.subject = new Name13;
    this.subjectPublicKeyInfo = new SubjectPublicKeyInfo7;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({
    type: AsnPropTypes5.Integer,
    context: 0,
    defaultValue: Version8.v1
  })
], TBSCertificate7.prototype, "version", undefined);
__decorate([
  AsnProp5({
    type: AsnPropTypes5.Integer,
    converter: AsnIntegerArrayBufferConverter5
  })
], TBSCertificate7.prototype, "serialNumber", undefined);
__decorate([
  AsnProp5({ type: AlgorithmIdentifier7 })
], TBSCertificate7.prototype, "signature", undefined);
__decorate([
  AsnProp5({ type: Name13 })
], TBSCertificate7.prototype, "issuer", undefined);
__decorate([
  AsnProp5({ type: Validity7 })
], TBSCertificate7.prototype, "validity", undefined);
__decorate([
  AsnProp5({ type: Name13 })
], TBSCertificate7.prototype, "subject", undefined);
__decorate([
  AsnProp5({ type: SubjectPublicKeyInfo7 })
], TBSCertificate7.prototype, "subjectPublicKeyInfo", undefined);
__decorate([
  AsnProp5({
    type: AsnPropTypes5.BitString,
    context: 1,
    implicit: true,
    optional: true
  })
], TBSCertificate7.prototype, "issuerUniqueID", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.BitString, context: 2, implicit: true, optional: true })
], TBSCertificate7.prototype, "subjectUniqueID", undefined);
__decorate([
  AsnProp5({ type: Extensions13, context: 3, optional: true })
], TBSCertificate7.prototype, "extensions", undefined);

// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/certificate.js
class Certificate7 {
  constructor(params = {}) {
    this.tbsCertificate = new TBSCertificate7;
    this.signatureAlgorithm = new AlgorithmIdentifier7;
    this.signatureValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: TBSCertificate7, raw: true })
], Certificate7.prototype, "tbsCertificate", undefined);
__decorate([
  AsnProp5({ type: AlgorithmIdentifier7 })
], Certificate7.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.BitString })
], Certificate7.prototype, "signatureValue", undefined);
// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/tbs_cert_list.js
class RevokedCertificate7 {
  constructor(params = {}) {
    this.userCertificate = new ArrayBuffer(0);
    this.revocationDate = new Time13;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: AsnPropTypes5.Integer, converter: AsnIntegerArrayBufferConverter5 })
], RevokedCertificate7.prototype, "userCertificate", undefined);
__decorate([
  AsnProp5({ type: Time13 })
], RevokedCertificate7.prototype, "revocationDate", undefined);
__decorate([
  AsnProp5({ type: Extension7, optional: true, repeated: "sequence" })
], RevokedCertificate7.prototype, "crlEntryExtensions", undefined);

class TBSCertList7 {
  constructor(params = {}) {
    this.signature = new AlgorithmIdentifier7;
    this.issuer = new Name13;
    this.thisUpdate = new Time13;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: AsnPropTypes5.Integer, optional: true })
], TBSCertList7.prototype, "version", undefined);
__decorate([
  AsnProp5({ type: AlgorithmIdentifier7 })
], TBSCertList7.prototype, "signature", undefined);
__decorate([
  AsnProp5({ type: Name13 })
], TBSCertList7.prototype, "issuer", undefined);
__decorate([
  AsnProp5({ type: Time13 })
], TBSCertList7.prototype, "thisUpdate", undefined);
__decorate([
  AsnProp5({ type: Time13, optional: true })
], TBSCertList7.prototype, "nextUpdate", undefined);
__decorate([
  AsnProp5({ type: RevokedCertificate7, repeated: "sequence", optional: true })
], TBSCertList7.prototype, "revokedCertificates", undefined);
__decorate([
  AsnProp5({ type: Extension7, optional: true, context: 0, repeated: "sequence" })
], TBSCertList7.prototype, "crlExtensions", undefined);

// node_modules/@peculiar/asn1-pkcs9/node_modules/@peculiar/asn1-x509/build/es2015/certificate_list.js
class CertificateList7 {
  constructor(params = {}) {
    this.tbsCertList = new TBSCertList7;
    this.signatureAlgorithm = new AlgorithmIdentifier7;
    this.signature = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp5({ type: TBSCertList7, raw: true })
], CertificateList7.prototype, "tbsCertList", undefined);
__decorate([
  AsnProp5({ type: AlgorithmIdentifier7 })
], CertificateList7.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp5({ type: AsnPropTypes5.BitString })
], CertificateList7.prototype, "signature", undefined);
// node_modules/@peculiar/asn1-pkcs9/build/es2015/index.js
var ExtensionRequest_1;
var ExtendedCertificateAttributes_1;
var SMIMECapabilities_1;
var id_pkcs9 = "1.2.840.113549.1.9";
var id_pkcs9_mo = `${id_pkcs9}.0`;
var id_pkcs9_oc = `${id_pkcs9}.24`;
var id_pkcs9_at = `${id_pkcs9}.25`;
var id_pkcs9_sx = `${id_pkcs9}.26`;
var id_pkcs9_mr = `${id_pkcs9}.27`;
var id_pkcs9_oc_pkcsEntity = `${id_pkcs9_oc}.1`;
var id_pkcs9_oc_naturalPerson = `${id_pkcs9_oc}.2`;
var id_pkcs9_at_emailAddress = `${id_pkcs9}.1`;
var id_pkcs9_at_unstructuredName = `${id_pkcs9}.2`;
var id_pkcs9_at_contentType = `${id_pkcs9}.3`;
var id_pkcs9_at_messageDigest = `${id_pkcs9}.4`;
var id_pkcs9_at_signingTime = `${id_pkcs9}.5`;
var id_pkcs9_at_counterSignature = `${id_pkcs9}.6`;
var id_pkcs9_at_challengePassword = `${id_pkcs9}.7`;
var id_pkcs9_at_unstructuredAddress = `${id_pkcs9}.8`;
var id_pkcs9_at_extendedCertificateAttributes = `${id_pkcs9}.9`;
var id_pkcs9_at_signingDescription = `${id_pkcs9}.13`;
var id_pkcs9_at_extensionRequest = `${id_pkcs9}.14`;
var id_pkcs9_at_smimeCapabilities = `${id_pkcs9}.15`;
var id_pkcs9_at_friendlyName = `${id_pkcs9}.20`;
var id_pkcs9_at_localKeyId = `${id_pkcs9}.21`;
var id_pkcs9_at_pkcs15Token = `${id_pkcs9_at}.1`;
var id_pkcs9_at_encryptedPrivateKeyInfo = `${id_pkcs9_at}.2`;
var id_pkcs9_at_randomNonce = `${id_pkcs9_at}.3`;
var id_pkcs9_at_sequenceNumber = `${id_pkcs9_at}.4`;
var id_pkcs9_at_pkcs7PDU = `${id_pkcs9_at}.5`;
var id_ietf_at = `1.3.6.1.5.5.7.9`;
var id_pkcs9_at_dateOfBirth = `${id_ietf_at}.1`;
var id_pkcs9_at_placeOfBirth = `${id_ietf_at}.2`;
var id_pkcs9_at_gender = `${id_ietf_at}.3`;
var id_pkcs9_at_countryOfCitizenship = `${id_ietf_at}.4`;
var id_pkcs9_at_countryOfResidence = `${id_ietf_at}.5`;
var id_pkcs9_sx_pkcs9String = `${id_pkcs9_sx}.1`;
var id_pkcs9_sx_signingTime = `${id_pkcs9_sx}.2`;
var id_pkcs9_mr_caseIgnoreMatch = `${id_pkcs9_mr}.1`;
var id_pkcs9_mr_signingTimeMatch = `${id_pkcs9_mr}.2`;
var id_smime = `${id_pkcs9}.16`;
var id_certTypes2 = `${id_pkcs9}.22`;
var crlTypes = `${id_pkcs9}.23`;
var id_at_pseudonym = `${id_at}.65`;
var PKCS9String = class PKCS9String2 extends DirectoryString13 {
  constructor(params = {}) {
    super(params);
  }
  toString() {
    const o = {};
    o.toString();
    return this.ia5String || super.toString();
  }
};
__decorate([
  AsnProp5({ type: AsnPropTypes5.IA5String })
], PKCS9String.prototype, "ia5String", undefined);
PKCS9String = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], PKCS9String);
var Pkcs7PDU = class Pkcs7PDU2 extends ContentInfo {
};
Pkcs7PDU = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence })
], Pkcs7PDU);
var UserPKCS12 = class UserPKCS122 extends PFX {
};
UserPKCS12 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence })
], UserPKCS12);
var EncryptedPrivateKeyInfo2 = class EncryptedPrivateKeyInfo3 extends EncryptedPrivateKeyInfo {
};
EncryptedPrivateKeyInfo2 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence })
], EncryptedPrivateKeyInfo2);
var EmailAddress = class EmailAddress2 {
  constructor(value = "") {
    this.value = value;
  }
  toString() {
    return this.value;
  }
};
__decorate([
  AsnProp5({ type: AsnPropTypes5.IA5String })
], EmailAddress.prototype, "value", undefined);
EmailAddress = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], EmailAddress);
var UnstructuredName = class UnstructuredName2 extends PKCS9String {
};
UnstructuredName = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], UnstructuredName);
var UnstructuredAddress = class UnstructuredAddress2 extends DirectoryString13 {
};
UnstructuredAddress = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], UnstructuredAddress);
var DateOfBirth = class DateOfBirth2 {
  constructor(value = new Date) {
    this.value = value;
  }
};
__decorate([
  AsnProp5({ type: AsnPropTypes5.GeneralizedTime })
], DateOfBirth.prototype, "value", undefined);
DateOfBirth = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], DateOfBirth);
var PlaceOfBirth = class PlaceOfBirth2 extends DirectoryString13 {
};
PlaceOfBirth = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], PlaceOfBirth);
var Gender = class Gender2 {
  constructor(value = "M") {
    this.value = value;
  }
  toString() {
    return this.value;
  }
};
__decorate([
  AsnProp5({ type: AsnPropTypes5.PrintableString })
], Gender.prototype, "value", undefined);
Gender = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], Gender);
var CountryOfCitizenship = class CountryOfCitizenship2 {
  constructor(value = "") {
    this.value = value;
  }
  toString() {
    return this.value;
  }
};
__decorate([
  AsnProp5({ type: AsnPropTypes5.PrintableString })
], CountryOfCitizenship.prototype, "value", undefined);
CountryOfCitizenship = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], CountryOfCitizenship);
var CountryOfResidence = class CountryOfResidence2 extends CountryOfCitizenship {
};
CountryOfResidence = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], CountryOfResidence);
var Pseudonym = class Pseudonym2 extends DirectoryString13 {
};
Pseudonym = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], Pseudonym);
var ContentType = class ContentType2 {
  constructor(value = "") {
    this.value = value;
  }
  toString() {
    return this.value;
  }
};
__decorate([
  AsnProp5({ type: AsnPropTypes5.ObjectIdentifier })
], ContentType.prototype, "value", undefined);
ContentType = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], ContentType);
var SigningTime3 = class SigningTime4 extends Time13 {
};
SigningTime3 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], SigningTime3);
var SequenceNumber = class SequenceNumber2 {
  constructor(value = 0) {
    this.value = value;
  }
  toString() {
    return this.value.toString();
  }
};
__decorate([
  AsnProp5({ type: AsnPropTypes5.Integer })
], SequenceNumber.prototype, "value", undefined);
SequenceNumber = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], SequenceNumber);
var CounterSignature3 = class CounterSignature4 extends SignerInfo {
};
CounterSignature3 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence })
], CounterSignature3);
var ChallengePassword = class ChallengePassword2 extends DirectoryString13 {
};
ChallengePassword = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], ChallengePassword);
var ExtensionRequest = ExtensionRequest_1 = class ExtensionRequest2 extends Extensions13 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, ExtensionRequest_1.prototype);
  }
};
ExtensionRequest = ExtensionRequest_1 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence })
], ExtensionRequest);
var ExtendedCertificateAttributes = ExtendedCertificateAttributes_1 = class ExtendedCertificateAttributes2 extends AsnArray5 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, ExtendedCertificateAttributes_1.prototype);
  }
};
ExtendedCertificateAttributes = ExtendedCertificateAttributes_1 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Set, itemType: Attribute4 })
], ExtendedCertificateAttributes);
var FriendlyName = class FriendlyName2 {
  constructor(value = "") {
    this.value = value;
  }
  toString() {
    return this.value;
  }
};
__decorate([
  AsnProp5({ type: AsnPropTypes5.BmpString })
], FriendlyName.prototype, "value", undefined);
FriendlyName = __decorate([
  AsnType5({ type: AsnTypeTypes5.Choice })
], FriendlyName);
var SMIMECapability = class SMIMECapability2 extends AlgorithmIdentifier7 {
};
SMIMECapability = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence })
], SMIMECapability);
var SMIMECapabilities = SMIMECapabilities_1 = class SMIMECapabilities2 extends AsnArray5 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SMIMECapabilities_1.prototype);
  }
};
SMIMECapabilities = SMIMECapabilities_1 = __decorate([
  AsnType5({ type: AsnTypeTypes5.Sequence, itemType: SMIMECapability })
], SMIMECapabilities);

// node_modules/@peculiar/asn1-csr/node_modules/asn1js/build/index.es.js
var exports_index_es9 = {};
__export(exports_index_es9, {
  verifySchema: () => verifySchema8,
  fromBER: () => fromBER8,
  compareSchema: () => compareSchema8,
  VisibleString: () => VisibleString8,
  ViewWriter: () => ViewWriter8,
  VideotexString: () => VideotexString8,
  ValueBlock: () => ValueBlock8,
  Utf8String: () => Utf8String8,
  UniversalString: () => UniversalString8,
  UTCTime: () => UTCTime8,
  TimeOfDay: () => TimeOfDay8,
  TeletexString: () => TeletexString8,
  TIME: () => TIME8,
  Set: () => Set9,
  Sequence: () => Sequence8,
  Repeated: () => Repeated8,
  RelativeObjectIdentifier: () => RelativeObjectIdentifier8,
  RawData: () => RawData8,
  PrintableString: () => PrintableString8,
  Primitive: () => Primitive8,
  OctetString: () => OctetString15,
  ObjectIdentifier: () => ObjectIdentifier8,
  NumericString: () => NumericString8,
  Null: () => Null8,
  Integer: () => Integer8,
  IA5String: () => IA5String8,
  HexBlock: () => HexBlock8,
  GraphicString: () => GraphicString8,
  GeneralizedTime: () => GeneralizedTime8,
  GeneralString: () => GeneralString8,
  Enumerated: () => Enumerated8,
  EndOfContent: () => EndOfContent8,
  Duration: () => Duration8,
  DateTime: () => DateTime8,
  DATE: () => DATE8,
  Constructed: () => Constructed8,
  Choice: () => Choice8,
  CharacterString: () => CharacterString8,
  Boolean: () => Boolean9,
  BmpString: () => BmpString8,
  BitString: () => BitString15,
  BaseStringBlock: () => BaseStringBlock8,
  BaseBlock: () => BaseBlock8,
  Any: () => Any8
});
/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
function assertBigInt8() {
  if (typeof BigInt === "undefined") {
    throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
  }
}
function concat8(buffers) {
  let outputLength = 0;
  let prevLength = 0;
  for (let i = 0;i < buffers.length; i++) {
    const buffer = buffers[i];
    outputLength += buffer.byteLength;
  }
  const retView = new Uint8Array(outputLength);
  for (let i = 0;i < buffers.length; i++) {
    const buffer = buffers[i];
    retView.set(new Uint8Array(buffer), prevLength);
    prevLength += buffer.byteLength;
  }
  return retView.buffer;
}
function checkBufferParams8(baseBlock, inputBuffer, inputOffset, inputLength) {
  if (!(inputBuffer instanceof Uint8Array)) {
    baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
    return false;
  }
  if (!inputBuffer.byteLength) {
    baseBlock.error = "Wrong parameter: inputBuffer has zero length";
    return false;
  }
  if (inputOffset < 0) {
    baseBlock.error = "Wrong parameter: inputOffset less than zero";
    return false;
  }
  if (inputLength < 0) {
    baseBlock.error = "Wrong parameter: inputLength less than zero";
    return false;
  }
  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
    baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
    return false;
  }
  return true;
}

class ViewWriter8 {
  constructor() {
    this.items = [];
  }
  write(buf) {
    this.items.push(buf);
  }
  final() {
    return concat8(this.items);
  }
}
var powers28 = [new Uint8Array([1])];
var digitsString8 = "0123456789";
var NAME8 = "name";
var VALUE_HEX_VIEW8 = "valueHexView";
var IS_HEX_ONLY8 = "isHexOnly";
var ID_BLOCK8 = "idBlock";
var TAG_CLASS8 = "tagClass";
var TAG_NUMBER8 = "tagNumber";
var IS_CONSTRUCTED8 = "isConstructed";
var FROM_BER8 = "fromBER";
var TO_BER8 = "toBER";
var LOCAL8 = "local";
var EMPTY_STRING8 = "";
var EMPTY_BUFFER8 = new ArrayBuffer(0);
var EMPTY_VIEW8 = new Uint8Array(0);
var END_OF_CONTENT_NAME8 = "EndOfContent";
var OCTET_STRING_NAME8 = "OCTET STRING";
var BIT_STRING_NAME8 = "BIT STRING";
function HexBlock8(BaseClass) {
  var _a8;
  return _a8 = class Some extends BaseClass {
    get valueHex() {
      return this.valueHexView.slice().buffer;
    }
    set valueHex(value) {
      this.valueHexView = new Uint8Array(value);
    }
    constructor(...args) {
      var _b;
      super(...args);
      const params = args[0] || {};
      this.isHexOnly = (_b = params.isHexOnly) !== null && _b !== undefined ? _b : false;
      this.valueHexView = params.valueHex ? BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW8;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      if (!checkBufferParams8(this, view, inputOffset, inputLength)) {
        return -1;
      }
      const endLength = inputOffset + inputLength;
      this.valueHexView = view.subarray(inputOffset, endLength);
      if (!this.valueHexView.length) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      }
      this.blockLength = inputLength;
      return endLength;
    }
    toBER(sizeOnly = false) {
      if (!this.isHexOnly) {
        this.error = "Flag 'isHexOnly' is not set, abort";
        return EMPTY_BUFFER8;
      }
      if (sizeOnly) {
        return new ArrayBuffer(this.valueHexView.byteLength);
      }
      return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        isHexOnly: this.isHexOnly,
        valueHex: Convert.ToHex(this.valueHexView)
      };
    }
  }, _a8.NAME = "hexBlock", _a8;
}

class LocalBaseBlock8 {
  static blockName() {
    return this.NAME;
  }
  get valueBeforeDecode() {
    return this.valueBeforeDecodeView.slice().buffer;
  }
  set valueBeforeDecode(value) {
    this.valueBeforeDecodeView = new Uint8Array(value);
  }
  constructor({ blockLength = 0, error = EMPTY_STRING8, warnings = [], valueBeforeDecode = EMPTY_VIEW8 } = {}) {
    this.blockLength = blockLength;
    this.error = error;
    this.warnings = warnings;
    this.valueBeforeDecodeView = BufferSourceConverter.toUint8Array(valueBeforeDecode);
  }
  toJSON() {
    return {
      blockName: this.constructor.NAME,
      blockLength: this.blockLength,
      error: this.error,
      warnings: this.warnings,
      valueBeforeDecode: Convert.ToHex(this.valueBeforeDecodeView)
    };
  }
}
LocalBaseBlock8.NAME = "baseBlock";

class ValueBlock8 extends LocalBaseBlock8 {
  fromBER(_inputBuffer, _inputOffset, _inputLength) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
  toBER(_sizeOnly, _writer) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
}
ValueBlock8.NAME = "valueBlock";

class LocalIdentificationBlock8 extends HexBlock8(LocalBaseBlock8) {
  constructor({ idBlock = {} } = {}) {
    var _a8, _b, _c, _d;
    super();
    if (idBlock) {
      this.isHexOnly = (_a8 = idBlock.isHexOnly) !== null && _a8 !== undefined ? _a8 : false;
      this.valueHexView = idBlock.valueHex ? BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW8;
      this.tagClass = (_b = idBlock.tagClass) !== null && _b !== undefined ? _b : -1;
      this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== undefined ? _c : -1;
      this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== undefined ? _d : false;
    } else {
      this.tagClass = -1;
      this.tagNumber = -1;
      this.isConstructed = false;
    }
  }
  toBER(sizeOnly = false) {
    let firstOctet = 0;
    switch (this.tagClass) {
      case 1:
        firstOctet |= 0;
        break;
      case 2:
        firstOctet |= 64;
        break;
      case 3:
        firstOctet |= 128;
        break;
      case 4:
        firstOctet |= 192;
        break;
      default:
        this.error = "Unknown tag class";
        return EMPTY_BUFFER8;
    }
    if (this.isConstructed)
      firstOctet |= 32;
    if (this.tagNumber < 31 && !this.isHexOnly) {
      const retView2 = new Uint8Array(1);
      if (!sizeOnly) {
        let number = this.tagNumber;
        number &= 31;
        firstOctet |= number;
        retView2[0] = firstOctet;
      }
      return retView2.buffer;
    }
    if (!this.isHexOnly) {
      const encodedBuf = utilToBase(this.tagNumber, 7);
      const encodedView = new Uint8Array(encodedBuf);
      const size = encodedBuf.byteLength;
      const retView2 = new Uint8Array(size + 1);
      retView2[0] = firstOctet | 31;
      if (!sizeOnly) {
        for (let i = 0;i < size - 1; i++)
          retView2[i + 1] = encodedView[i] | 128;
        retView2[size] = encodedView[size - 1];
      }
      return retView2.buffer;
    }
    const retView = new Uint8Array(this.valueHexView.byteLength + 1);
    retView[0] = firstOctet | 31;
    if (!sizeOnly) {
      const curView = this.valueHexView;
      for (let i = 0;i < curView.length - 1; i++)
        retView[i + 1] = curView[i] | 128;
      retView[this.valueHexView.byteLength] = curView[curView.length - 1];
    }
    return retView.buffer;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams8(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    const tagClassMask = intBuffer[0] & 192;
    switch (tagClassMask) {
      case 0:
        this.tagClass = 1;
        break;
      case 64:
        this.tagClass = 2;
        break;
      case 128:
        this.tagClass = 3;
        break;
      case 192:
        this.tagClass = 4;
        break;
      default:
        this.error = "Unknown tag class";
        return -1;
    }
    this.isConstructed = (intBuffer[0] & 32) === 32;
    this.isHexOnly = false;
    const tagNumberMask = intBuffer[0] & 31;
    if (tagNumberMask !== 31) {
      this.tagNumber = tagNumberMask;
      this.blockLength = 1;
    } else {
      let count = 1;
      let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
      let tagNumberBufferMaxLength = 255;
      while (intBuffer[count] & 128) {
        intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
        count++;
        if (count >= intBuffer.length) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (count === tagNumberBufferMaxLength) {
          tagNumberBufferMaxLength += 255;
          const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);
          for (let i = 0;i < intTagNumberBuffer.length; i++)
            tempBufferView2[i] = intTagNumberBuffer[i];
          intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
        }
      }
      this.blockLength = count + 1;
      intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
      const tempBufferView = new Uint8Array(count);
      for (let i = 0;i < count; i++)
        tempBufferView[i] = intTagNumberBuffer[i];
      intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
      intTagNumberBuffer.set(tempBufferView);
      if (this.blockLength <= 9)
        this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
      else {
        this.isHexOnly = true;
        this.warnings.push("Tag too long, represented as hex-coded");
      }
    }
    if (this.tagClass === 1 && this.isConstructed) {
      switch (this.tagNumber) {
        case 1:
        case 2:
        case 5:
        case 6:
        case 9:
        case 13:
        case 14:
        case 23:
        case 24:
        case 31:
        case 32:
        case 33:
        case 34:
          this.error = "Constructed encoding used for primitive type";
          return -1;
      }
    }
    return inputOffset + this.blockLength;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      tagClass: this.tagClass,
      tagNumber: this.tagNumber,
      isConstructed: this.isConstructed
    };
  }
}
LocalIdentificationBlock8.NAME = "identificationBlock";

class LocalLengthBlock8 extends LocalBaseBlock8 {
  constructor({ lenBlock = {} } = {}) {
    var _a8, _b, _c;
    super();
    this.isIndefiniteForm = (_a8 = lenBlock.isIndefiniteForm) !== null && _a8 !== undefined ? _a8 : false;
    this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== undefined ? _b : false;
    this.length = (_c = lenBlock.length) !== null && _c !== undefined ? _c : 0;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams8(this, view, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    if (intBuffer[0] === 255) {
      this.error = "Length block 0xFF is reserved by standard";
      return -1;
    }
    this.isIndefiniteForm = intBuffer[0] === 128;
    if (this.isIndefiniteForm) {
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    this.longFormUsed = !!(intBuffer[0] & 128);
    if (this.longFormUsed === false) {
      this.length = intBuffer[0];
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    const count = intBuffer[0] & 127;
    if (count > 8) {
      this.error = "Too big integer";
      return -1;
    }
    if (count + 1 > intBuffer.length) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    const lenOffset = inputOffset + 1;
    const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
    if (lengthBufferView[count - 1] === 0)
      this.warnings.push("Needlessly long encoded length");
    this.length = utilFromBase(lengthBufferView, 8);
    if (this.longFormUsed && this.length <= 127)
      this.warnings.push("Unnecessary usage of long length form");
    this.blockLength = count + 1;
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly = false) {
    let retBuf;
    let retView;
    if (this.length > 127)
      this.longFormUsed = true;
    if (this.isIndefiniteForm) {
      retBuf = new ArrayBuffer(1);
      if (sizeOnly === false) {
        retView = new Uint8Array(retBuf);
        retView[0] = 128;
      }
      return retBuf;
    }
    if (this.longFormUsed) {
      const encodedBuf = utilToBase(this.length, 8);
      if (encodedBuf.byteLength > 127) {
        this.error = "Too big length";
        return EMPTY_BUFFER8;
      }
      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
      if (sizeOnly)
        return retBuf;
      const encodedView = new Uint8Array(encodedBuf);
      retView = new Uint8Array(retBuf);
      retView[0] = encodedBuf.byteLength | 128;
      for (let i = 0;i < encodedBuf.byteLength; i++)
        retView[i + 1] = encodedView[i];
      return retBuf;
    }
    retBuf = new ArrayBuffer(1);
    if (sizeOnly === false) {
      retView = new Uint8Array(retBuf);
      retView[0] = this.length;
    }
    return retBuf;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      longFormUsed: this.longFormUsed,
      length: this.length
    };
  }
}
LocalLengthBlock8.NAME = "lengthBlock";
var typeStore8 = {};

class BaseBlock8 extends LocalBaseBlock8 {
  constructor({ name: name8 = EMPTY_STRING8, optional = false, primitiveSchema, ...parameters3 } = {}, valueBlockType) {
    super(parameters3);
    this.name = name8;
    this.optional = optional;
    if (primitiveSchema) {
      this.primitiveSchema = primitiveSchema;
    }
    this.idBlock = new LocalIdentificationBlock8(parameters3);
    this.lenBlock = new LocalLengthBlock8(parameters3);
    this.valueBlock = valueBlockType ? new valueBlockType(parameters3) : new ValueBlock8(parameters3);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter8;
    if (!writer) {
      prepareIndefiniteForm8(this);
    }
    const idBlockBuf = this.idBlock.toBER(sizeOnly);
    _writer.write(idBlockBuf);
    if (this.lenBlock.isIndefiniteForm) {
      _writer.write(new Uint8Array([128]).buffer);
      this.valueBlock.toBER(sizeOnly, _writer);
      _writer.write(new ArrayBuffer(2));
    } else {
      const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
      this.lenBlock.length = valueBlockBuf.byteLength;
      const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
      _writer.write(lenBlockBuf);
      _writer.write(valueBlockBuf);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER8;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      idBlock: this.idBlock.toJSON(),
      lenBlock: this.lenBlock.toJSON(),
      valueBlock: this.valueBlock.toJSON(),
      name: this.name,
      optional: this.optional
    };
    if (this.primitiveSchema)
      object.primitiveSchema = this.primitiveSchema.toJSON();
    return object;
  }
  toString(encoding = "ascii") {
    if (encoding === "ascii") {
      return this.onAsciiEncoding();
    }
    return Convert.ToHex(this.toBER());
  }
  onAsciiEncoding() {
    const name8 = this.constructor.NAME;
    const value = Convert.ToHex(this.valueBlock.valueBeforeDecodeView);
    return `${name8} : ${value}`;
  }
  isEqual(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof this.constructor)) {
      return false;
    }
    const thisRaw = this.toBER();
    const otherRaw = other.toBER();
    return isEqualBuffer(thisRaw, otherRaw);
  }
}
BaseBlock8.NAME = "BaseBlock";
function prepareIndefiniteForm8(baseBlock) {
  var _a8;
  if (baseBlock instanceof typeStore8.Constructed) {
    for (const value of baseBlock.valueBlock.value) {
      if (prepareIndefiniteForm8(value)) {
        baseBlock.lenBlock.isIndefiniteForm = true;
      }
    }
  }
  return !!((_a8 = baseBlock.lenBlock) === null || _a8 === undefined ? undefined : _a8.isIndefiniteForm);
}

class BaseStringBlock8 extends BaseBlock8 {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  constructor({ value = EMPTY_STRING8, ...parameters3 } = {}, stringValueBlockType) {
    super(parameters3, stringValueBlockType);
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    this.fromBuffer(this.valueBlock.valueHexView);
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
  }
}
BaseStringBlock8.NAME = "BaseStringBlock";

class LocalPrimitiveValueBlock8 extends HexBlock8(ValueBlock8) {
  constructor({ isHexOnly = true, ...parameters3 } = {}) {
    super(parameters3);
    this.isHexOnly = isHexOnly;
  }
}
LocalPrimitiveValueBlock8.NAME = "PrimitiveValueBlock";
var _a$w8;

class Primitive8 extends BaseBlock8 {
  constructor(parameters3 = {}) {
    super(parameters3, LocalPrimitiveValueBlock8);
    this.idBlock.isConstructed = false;
  }
}
_a$w8 = Primitive8;
(() => {
  typeStore8.Primitive = _a$w8;
})();
Primitive8.NAME = "PRIMITIVE";
function localChangeType8(inputObject, newType) {
  if (inputObject instanceof newType) {
    return inputObject;
  }
  const newObject = new newType;
  newObject.idBlock = inputObject.idBlock;
  newObject.lenBlock = inputObject.lenBlock;
  newObject.warnings = inputObject.warnings;
  newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
  return newObject;
}
function localFromBER8(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
  const incomingOffset = inputOffset;
  let returnObject = new BaseBlock8({}, ValueBlock8);
  const baseBlock = new LocalBaseBlock8;
  if (!checkBufferParams8(baseBlock, inputBuffer, inputOffset, inputLength)) {
    returnObject.error = baseBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
  if (!intBuffer.length) {
    returnObject.error = "Zero buffer length";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.idBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.idBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.idBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.idBlock.blockLength;
  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.lenBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.lenBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.lenBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.lenBlock.blockLength;
  if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
    returnObject.error = "Indefinite length form used for primitive encoding form";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let newASN1Type = BaseBlock8;
  switch (returnObject.idBlock.tagClass) {
    case 1:
      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
        returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
        return {
          offset: -1,
          result: returnObject
        };
      }
      switch (returnObject.idBlock.tagNumber) {
        case 0:
          if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
            returnObject.error = "Type [UNIVERSAL 0] is reserved";
            return {
              offset: -1,
              result: returnObject
            };
          }
          newASN1Type = typeStore8.EndOfContent;
          break;
        case 1:
          newASN1Type = typeStore8.Boolean;
          break;
        case 2:
          newASN1Type = typeStore8.Integer;
          break;
        case 3:
          newASN1Type = typeStore8.BitString;
          break;
        case 4:
          newASN1Type = typeStore8.OctetString;
          break;
        case 5:
          newASN1Type = typeStore8.Null;
          break;
        case 6:
          newASN1Type = typeStore8.ObjectIdentifier;
          break;
        case 10:
          newASN1Type = typeStore8.Enumerated;
          break;
        case 12:
          newASN1Type = typeStore8.Utf8String;
          break;
        case 13:
          newASN1Type = typeStore8.RelativeObjectIdentifier;
          break;
        case 14:
          newASN1Type = typeStore8.TIME;
          break;
        case 15:
          returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
          return {
            offset: -1,
            result: returnObject
          };
        case 16:
          newASN1Type = typeStore8.Sequence;
          break;
        case 17:
          newASN1Type = typeStore8.Set;
          break;
        case 18:
          newASN1Type = typeStore8.NumericString;
          break;
        case 19:
          newASN1Type = typeStore8.PrintableString;
          break;
        case 20:
          newASN1Type = typeStore8.TeletexString;
          break;
        case 21:
          newASN1Type = typeStore8.VideotexString;
          break;
        case 22:
          newASN1Type = typeStore8.IA5String;
          break;
        case 23:
          newASN1Type = typeStore8.UTCTime;
          break;
        case 24:
          newASN1Type = typeStore8.GeneralizedTime;
          break;
        case 25:
          newASN1Type = typeStore8.GraphicString;
          break;
        case 26:
          newASN1Type = typeStore8.VisibleString;
          break;
        case 27:
          newASN1Type = typeStore8.GeneralString;
          break;
        case 28:
          newASN1Type = typeStore8.UniversalString;
          break;
        case 29:
          newASN1Type = typeStore8.CharacterString;
          break;
        case 30:
          newASN1Type = typeStore8.BmpString;
          break;
        case 31:
          newASN1Type = typeStore8.DATE;
          break;
        case 32:
          newASN1Type = typeStore8.TimeOfDay;
          break;
        case 33:
          newASN1Type = typeStore8.DateTime;
          break;
        case 34:
          newASN1Type = typeStore8.Duration;
          break;
        default: {
          const newObject = returnObject.idBlock.isConstructed ? new typeStore8.Constructed : new typeStore8.Primitive;
          newObject.idBlock = returnObject.idBlock;
          newObject.lenBlock = returnObject.lenBlock;
          newObject.warnings = returnObject.warnings;
          returnObject = newObject;
        }
      }
      break;
    case 2:
    case 3:
    case 4:
    default: {
      newASN1Type = returnObject.idBlock.isConstructed ? typeStore8.Constructed : typeStore8.Primitive;
    }
  }
  returnObject = localChangeType8(returnObject, newASN1Type);
  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
  returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
  return {
    offset: resultOffset,
    result: returnObject
  };
}
function fromBER8(inputBuffer) {
  if (!inputBuffer.byteLength) {
    const result = new BaseBlock8({}, ValueBlock8);
    result.error = "Input buffer has zero length";
    return {
      offset: -1,
      result
    };
  }
  return localFromBER8(BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
}
function checkLen8(indefiniteLength, length) {
  if (indefiniteLength) {
    return 1;
  }
  return length;
}

class LocalConstructedValueBlock8 extends ValueBlock8 {
  constructor({ value = [], isIndefiniteForm = false, ...parameters3 } = {}) {
    super(parameters3);
    this.value = value;
    this.isIndefiniteForm = isIndefiniteForm;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams8(this, view, inputOffset, inputLength)) {
      return -1;
    }
    this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
    if (this.valueBeforeDecodeView.length === 0) {
      this.warnings.push("Zero buffer length");
      return inputOffset;
    }
    let currentOffset = inputOffset;
    while (checkLen8(this.isIndefiniteForm, inputLength) > 0) {
      const returnObject = localFromBER8(view, currentOffset, inputLength);
      if (returnObject.offset === -1) {
        this.error = returnObject.result.error;
        this.warnings.concat(returnObject.result.warnings);
        return -1;
      }
      currentOffset = returnObject.offset;
      this.blockLength += returnObject.result.blockLength;
      inputLength -= returnObject.result.blockLength;
      this.value.push(returnObject.result);
      if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME8) {
        break;
      }
    }
    if (this.isIndefiniteForm) {
      if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME8) {
        this.value.pop();
      } else {
        this.warnings.push("No EndOfContent block encoded");
      }
    }
    return currentOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter8;
    for (let i = 0;i < this.value.length; i++) {
      this.value[i].toBER(sizeOnly, _writer);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER8;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      value: []
    };
    for (const value of this.value) {
      object.value.push(value.toJSON());
    }
    return object;
  }
}
LocalConstructedValueBlock8.NAME = "ConstructedValueBlock";
var _a$v8;

class Constructed8 extends BaseBlock8 {
  constructor(parameters3 = {}) {
    super(parameters3, LocalConstructedValueBlock8);
    this.idBlock.isConstructed = true;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    const values = [];
    for (const value of this.valueBlock.value) {
      values.push(value.toString("ascii").split(`
`).map((o) => `  ${o}`).join(`
`));
    }
    const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
    return values.length ? `${blockName} :
${values.join(`
`)}` : `${blockName} :`;
  }
}
_a$v8 = Constructed8;
(() => {
  typeStore8.Constructed = _a$v8;
})();
Constructed8.NAME = "CONSTRUCTED";

class LocalEndOfContentValueBlock8 extends ValueBlock8 {
  fromBER(inputBuffer, inputOffset, _inputLength) {
    return inputOffset;
  }
  toBER(_sizeOnly) {
    return EMPTY_BUFFER8;
  }
}
LocalEndOfContentValueBlock8.override = "EndOfContentValueBlock";
var _a$u8;

class EndOfContent8 extends BaseBlock8 {
  constructor(parameters3 = {}) {
    super(parameters3, LocalEndOfContentValueBlock8);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 0;
  }
}
_a$u8 = EndOfContent8;
(() => {
  typeStore8.EndOfContent = _a$u8;
})();
EndOfContent8.NAME = END_OF_CONTENT_NAME8;
var _a$t8;

class Null8 extends BaseBlock8 {
  constructor(parameters3 = {}) {
    super(parameters3, ValueBlock8);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 5;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (this.lenBlock.length > 0)
      this.warnings.push("Non-zero length of value block for Null type");
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    this.blockLength += inputLength;
    if (inputOffset + inputLength > inputBuffer.byteLength) {
      this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
      return -1;
    }
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    const retBuf = new ArrayBuffer(2);
    if (!sizeOnly) {
      const retView = new Uint8Array(retBuf);
      retView[0] = 5;
      retView[1] = 0;
    }
    if (writer) {
      writer.write(retBuf);
    }
    return retBuf;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME}`;
  }
}
_a$t8 = Null8;
(() => {
  typeStore8.Null = _a$t8;
})();
Null8.NAME = "NULL";

class LocalBooleanValueBlock8 extends HexBlock8(ValueBlock8) {
  get value() {
    for (const octet of this.valueHexView) {
      if (octet > 0) {
        return true;
      }
    }
    return false;
  }
  set value(value) {
    this.valueHexView[0] = value ? 255 : 0;
  }
  constructor({ value, ...parameters3 } = {}) {
    super(parameters3);
    if (parameters3.valueHex) {
      this.valueHexView = BufferSourceConverter.toUint8Array(parameters3.valueHex);
    } else {
      this.valueHexView = new Uint8Array(1);
    }
    if (value) {
      this.value = value;
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams8(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (inputLength > 1)
      this.warnings.push("Boolean value encoded in more then 1 octet");
    this.isHexOnly = true;
    utilDecodeTC.call(this);
    this.blockLength = inputLength;
    return inputOffset + inputLength;
  }
  toBER() {
    return this.valueHexView.slice();
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalBooleanValueBlock8.NAME = "BooleanValueBlock";
var _a$s8;

class Boolean9 extends BaseBlock8 {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  constructor(parameters3 = {}) {
    super(parameters3, LocalBooleanValueBlock8);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 1;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.getValue}`;
  }
}
_a$s8 = Boolean9;
(() => {
  typeStore8.Boolean = _a$s8;
})();
Boolean9.NAME = "BOOLEAN";

class LocalOctetStringValueBlock8 extends HexBlock8(LocalConstructedValueBlock8) {
  constructor({ isConstructed = false, ...parameters3 } = {}) {
    super(parameters3);
    this.isConstructed = isConstructed;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = 0;
    if (this.isConstructed) {
      this.isHexOnly = false;
      resultOffset = LocalConstructedValueBlock8.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (let i = 0;i < this.value.length; i++) {
        const currentBlockName = this.value[i].constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME8) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== OCTET_STRING_NAME8) {
          this.error = "OCTET STRING may consists of OCTET STRINGs only";
          return -1;
        }
      }
    } else {
      this.isHexOnly = true;
      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
      this.blockLength = inputLength;
    }
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed)
      return LocalConstructedValueBlock8.prototype.toBER.call(this, sizeOnly, writer);
    return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isConstructed: this.isConstructed
    };
  }
}
LocalOctetStringValueBlock8.NAME = "OctetStringValueBlock";
var _a$r8;

class OctetString15 extends BaseBlock8 {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters3 } = {}) {
    var _b, _c;
    (_b = parameters3.isConstructed) !== null && _b !== undefined || (parameters3.isConstructed = !!((_c = parameters3.value) === null || _c === undefined ? undefined : _c.length));
    super({
      idBlock: {
        isConstructed: parameters3.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters3.isIndefiniteForm
      },
      ...parameters3
    }, LocalOctetStringValueBlock8);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 4;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    if (inputLength === 0) {
      if (this.idBlock.error.length === 0)
        this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0)
        this.blockLength += this.lenBlock.blockLength;
      return inputOffset;
    }
    if (!this.valueBlock.isConstructed) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      const buf = view.subarray(inputOffset, inputOffset + inputLength);
      try {
        if (buf.byteLength) {
          const asn = localFromBER8(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength) {
            this.valueBlock.value = [asn.result];
          }
        }
      } catch {}
    }
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed8.prototype.onAsciiEncoding.call(this);
    }
    const name8 = this.constructor.NAME;
    const value = Convert.ToHex(this.valueBlock.valueHexView);
    return `${name8} : ${value}`;
  }
  getValue() {
    if (!this.idBlock.isConstructed) {
      return this.valueBlock.valueHexView.slice().buffer;
    }
    const array = [];
    for (const content of this.valueBlock.value) {
      if (content instanceof _a$r8) {
        array.push(content.valueBlock.valueHexView);
      }
    }
    return BufferSourceConverter.concat(array);
  }
}
_a$r8 = OctetString15;
(() => {
  typeStore8.OctetString = _a$r8;
})();
OctetString15.NAME = OCTET_STRING_NAME8;

class LocalBitStringValueBlock8 extends HexBlock8(LocalConstructedValueBlock8) {
  constructor({ unusedBits = 0, isConstructed = false, ...parameters3 } = {}) {
    super(parameters3);
    this.unusedBits = unusedBits;
    this.isConstructed = isConstructed;
    this.blockLength = this.valueHexView.byteLength;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    let resultOffset = -1;
    if (this.isConstructed) {
      resultOffset = LocalConstructedValueBlock8.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (const value of this.value) {
        const currentBlockName = value.constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME8) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== BIT_STRING_NAME8) {
          this.error = "BIT STRING may consists of BIT STRINGs only";
          return -1;
        }
        const valueBlock = value.valueBlock;
        if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
          this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
          return -1;
        }
        this.unusedBits = valueBlock.unusedBits;
      }
      return resultOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams8(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.unusedBits = intBuffer[0];
    if (this.unusedBits > 7) {
      this.error = "Unused bits for BitString must be in range 0-7";
      return -1;
    }
    if (!this.unusedBits) {
      const buf = intBuffer.subarray(1);
      try {
        if (buf.byteLength) {
          const asn = localFromBER8(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength - 1) {
            this.value = [asn.result];
          }
        }
      } catch {}
    }
    this.valueHexView = intBuffer.subarray(1);
    this.blockLength = intBuffer.length;
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed) {
      return LocalConstructedValueBlock8.prototype.toBER.call(this, sizeOnly, writer);
    }
    if (sizeOnly) {
      return new ArrayBuffer(this.valueHexView.byteLength + 1);
    }
    if (!this.valueHexView.byteLength) {
      return EMPTY_BUFFER8;
    }
    const retView = new Uint8Array(this.valueHexView.length + 1);
    retView[0] = this.unusedBits;
    retView.set(this.valueHexView, 1);
    return retView.buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      unusedBits: this.unusedBits,
      isConstructed: this.isConstructed
    };
  }
}
LocalBitStringValueBlock8.NAME = "BitStringValueBlock";
var _a$q8;

class BitString15 extends BaseBlock8 {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters3 } = {}) {
    var _b, _c;
    (_b = parameters3.isConstructed) !== null && _b !== undefined || (parameters3.isConstructed = !!((_c = parameters3.value) === null || _c === undefined ? undefined : _c.length));
    super({
      idBlock: {
        isConstructed: parameters3.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters3.isIndefiniteForm
      },
      ...parameters3
    }, LocalBitStringValueBlock8);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 3;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed8.prototype.onAsciiEncoding.call(this);
    } else {
      const bits = [];
      const valueHex = this.valueBlock.valueHexView;
      for (const byte of valueHex) {
        bits.push(byte.toString(2).padStart(8, "0"));
      }
      const bitsStr = bits.join("");
      const name8 = this.constructor.NAME;
      const value = bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits);
      return `${name8} : ${value}`;
    }
  }
}
_a$q8 = BitString15;
(() => {
  typeStore8.BitString = _a$q8;
})();
BitString15.NAME = BIT_STRING_NAME8;
var _a$p8;
function viewAdd8(first, second) {
  const c = new Uint8Array([0]);
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  let firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value = 0;
  const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
  let counter = 0;
  for (let i = max;i >= 0; i--, counter++) {
    switch (true) {
      case counter < secondViewCopy.length:
        value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
        break;
      default:
        value = firstViewCopy[firstViewCopyLength - counter] + c[0];
    }
    c[0] = value / 10;
    switch (true) {
      case counter >= firstViewCopy.length:
        firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
        break;
      default:
        firstViewCopy[firstViewCopyLength - counter] = value % 10;
    }
  }
  if (c[0] > 0)
    firstViewCopy = utilConcatView(c, firstViewCopy);
  return firstViewCopy;
}
function power28(n) {
  if (n >= powers28.length) {
    for (let p = powers28.length;p <= n; p++) {
      const c = new Uint8Array([0]);
      let digits = powers28[p - 1].slice(0);
      for (let i = digits.length - 1;i >= 0; i--) {
        const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
        c[0] = newValue[0] / 10;
        digits[i] = newValue[0] % 10;
      }
      if (c[0] > 0)
        digits = utilConcatView(c, digits);
      powers28.push(digits);
    }
  }
  return powers28[n];
}
function viewSub8(first, second) {
  let b = 0;
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  const firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value;
  let counter = 0;
  for (let i = secondViewCopyLength;i >= 0; i--, counter++) {
    value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
    switch (true) {
      case value < 0:
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
        break;
      default:
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
    }
  }
  if (b > 0) {
    for (let i = firstViewCopyLength - secondViewCopyLength + 1;i >= 0; i--, counter++) {
      value = firstViewCopy[firstViewCopyLength - counter] - b;
      if (value < 0) {
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
      } else {
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
        break;
      }
    }
  }
  return firstViewCopy.slice();
}

class LocalIntegerValueBlock8 extends HexBlock8(ValueBlock8) {
  setValueHex() {
    if (this.valueHexView.length >= 4) {
      this.warnings.push("Too big Integer for decoding, hex only");
      this.isHexOnly = true;
      this._valueDec = 0;
    } else {
      this.isHexOnly = false;
      if (this.valueHexView.length > 0) {
        this._valueDec = utilDecodeTC.call(this);
      }
    }
  }
  constructor({ value, ...parameters3 } = {}) {
    super(parameters3);
    this._valueDec = 0;
    if (parameters3.valueHex) {
      this.setValueHex();
    }
    if (value !== undefined) {
      this.valueDec = value;
    }
  }
  set valueDec(v) {
    this._valueDec = v;
    this.isHexOnly = false;
    this.valueHexView = new Uint8Array(utilEncodeTC(v));
  }
  get valueDec() {
    return this._valueDec;
  }
  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
    if (offset === -1)
      return offset;
    const view = this.valueHexView;
    if (view[0] === 0 && (view[1] & 128) !== 0) {
      this.valueHexView = view.subarray(1);
    } else {
      if (expectedLength !== 0) {
        if (view.length < expectedLength) {
          if (expectedLength - view.length > 1)
            expectedLength = view.length + 1;
          this.valueHexView = view.subarray(expectedLength - view.length);
        }
      }
    }
    return offset;
  }
  toDER(sizeOnly = false) {
    const view = this.valueHexView;
    switch (true) {
      case (view[0] & 128) !== 0:
        {
          const updatedView = new Uint8Array(this.valueHexView.length + 1);
          updatedView[0] = 0;
          updatedView.set(view, 1);
          this.valueHexView = updatedView;
        }
        break;
      case (view[0] === 0 && (view[1] & 128) === 0):
        {
          this.valueHexView = this.valueHexView.subarray(1);
        }
        break;
    }
    return this.toBER(sizeOnly);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
    if (resultOffset === -1) {
      return resultOffset;
    }
    this.setValueHex();
    return resultOffset;
  }
  toBER(sizeOnly) {
    return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
  toString() {
    const firstBit = this.valueHexView.length * 8 - 1;
    let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
    let bitNumber = 0;
    let currentByte;
    const asn1View = this.valueHexView;
    let result = "";
    let flag = false;
    for (let byteNumber = asn1View.byteLength - 1;byteNumber >= 0; byteNumber--) {
      currentByte = asn1View[byteNumber];
      for (let i = 0;i < 8; i++) {
        if ((currentByte & 1) === 1) {
          switch (bitNumber) {
            case firstBit:
              digits = viewSub8(power28(bitNumber), digits);
              result = "-";
              break;
            default:
              digits = viewAdd8(digits, power28(bitNumber));
          }
        }
        bitNumber++;
        currentByte >>= 1;
      }
    }
    for (let i = 0;i < digits.length; i++) {
      if (digits[i])
        flag = true;
      if (flag)
        result += digitsString8.charAt(digits[i]);
    }
    if (flag === false)
      result += digitsString8.charAt(0);
    return result;
  }
}
_a$p8 = LocalIntegerValueBlock8;
LocalIntegerValueBlock8.NAME = "IntegerValueBlock";
(() => {
  Object.defineProperty(_a$p8.prototype, "valueHex", {
    set: function(v) {
      this.valueHexView = new Uint8Array(v);
      this.setValueHex();
    },
    get: function() {
      return this.valueHexView.slice().buffer;
    }
  });
})();
var _a$o8;

class Integer8 extends BaseBlock8 {
  constructor(parameters3 = {}) {
    super(parameters3, LocalIntegerValueBlock8);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 2;
  }
  toBigInt() {
    assertBigInt8();
    return BigInt(this.valueBlock.toString());
  }
  static fromBigInt(value) {
    assertBigInt8();
    const bigIntValue = BigInt(value);
    const writer = new ViewWriter8;
    const hex = bigIntValue.toString(16).replace(/^-/, "");
    const view = new Uint8Array(Convert.FromHex(hex));
    if (bigIntValue < 0) {
      const first = new Uint8Array(view.length + (view[0] & 128 ? 1 : 0));
      first[0] |= 128;
      const firstInt = BigInt(`0x${Convert.ToHex(first)}`);
      const secondInt = firstInt + bigIntValue;
      const second = BufferSourceConverter.toUint8Array(Convert.FromHex(secondInt.toString(16)));
      second[0] |= 128;
      writer.write(second);
    } else {
      if (view[0] & 128) {
        writer.write(new Uint8Array([0]));
      }
      writer.write(view);
    }
    const res = new _a$o8({ valueHex: writer.final() });
    return res;
  }
  convertToDER() {
    const integer = new _a$o8({ valueHex: this.valueBlock.valueHexView });
    integer.valueBlock.toDER();
    return integer;
  }
  convertFromDER() {
    return new _a$o8({
      valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
    });
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
  }
}
_a$o8 = Integer8;
(() => {
  typeStore8.Integer = _a$o8;
})();
Integer8.NAME = "INTEGER";
var _a$n8;

class Enumerated8 extends Integer8 {
  constructor(parameters3 = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 10;
  }
}
_a$n8 = Enumerated8;
(() => {
  typeStore8.Enumerated = _a$n8;
})();
Enumerated8.NAME = "ENUMERATED";

class LocalSidValueBlock8 extends HexBlock8(ValueBlock8) {
  constructor({ valueDec = -1, isFirstSid = false, ...parameters3 } = {}) {
    super(parameters3);
    this.valueDec = valueDec;
    this.isFirstSid = isFirstSid;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams8(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0;i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0;i < this.blockLength; i++) {
      tempView[i] = this.valueHexView[i];
    }
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  set valueBigInt(value) {
    assertBigInt8();
    let bits = BigInt(value).toString(2);
    while (bits.length % 7) {
      bits = "0" + bits;
    }
    const bytes = new Uint8Array(bits.length / 7);
    for (let i = 0;i < bytes.length; i++) {
      bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 128 : 0);
    }
    this.fromBER(bytes.buffer, 0, bytes.length);
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0;i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER8;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0;i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      if (this.isFirstSid) {
        let sidValue = this.valueDec;
        if (this.valueDec <= 39)
          result = "0.";
        else {
          if (this.valueDec <= 79) {
            result = "1.";
            sidValue -= 40;
          } else {
            result = "2.";
            sidValue -= 80;
          }
        }
        result += sidValue.toString();
      } else
        result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec,
      isFirstSid: this.isFirstSid
    };
  }
}
LocalSidValueBlock8.NAME = "sidBlock";

class LocalObjectIdentifierValueBlock8 extends ValueBlock8 {
  constructor({ value = EMPTY_STRING8, ...parameters3 } = {}) {
    super(parameters3);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalSidValueBlock8;
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      if (this.value.length === 0)
        sidBlock.isFirstSid = true;
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly) {
    const retBuffers = [];
    for (let i = 0;i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER8;
      }
      retBuffers.push(valueBuf);
    }
    return concat8(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    let flag = false;
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      if (flag) {
        const sidBlock = this.value[0];
        let plus = 0;
        switch (sidBlock.valueDec) {
          case 0:
            break;
          case 1:
            plus = 40;
            break;
          case 2:
            plus = 80;
            break;
          default:
            this.value = [];
            return;
        }
        const parsedSID = parseInt(sid, 10);
        if (isNaN(parsedSID))
          return;
        sidBlock.valueDec = parsedSID + plus;
        flag = false;
      } else {
        const sidBlock = new LocalSidValueBlock8;
        if (sid > Number.MAX_SAFE_INTEGER) {
          assertBigInt8();
          const sidValue = BigInt(sid);
          sidBlock.valueBigInt = sidValue;
        } else {
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec))
            return;
        }
        if (!this.value.length) {
          sidBlock.isFirstSid = true;
          flag = true;
        }
        this.value.push(sidBlock);
      }
    } while (pos2 !== -1);
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0;i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        if (this.value[i].isFirstSid)
          result = `2.{${sidStr} - 80}`;
        else
          result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0;i < this.value.length; i++) {
      object.sidArray.push(this.value[i].toJSON());
    }
    return object;
  }
}
LocalObjectIdentifierValueBlock8.NAME = "ObjectIdentifierValueBlock";
var _a$m8;

class ObjectIdentifier8 extends BaseBlock8 {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  constructor(parameters3 = {}) {
    super(parameters3, LocalObjectIdentifierValueBlock8);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 6;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$m8 = ObjectIdentifier8;
(() => {
  typeStore8.ObjectIdentifier = _a$m8;
})();
ObjectIdentifier8.NAME = "OBJECT IDENTIFIER";

class LocalRelativeSidValueBlock8 extends HexBlock8(LocalBaseBlock8) {
  constructor({ valueDec = 0, ...parameters3 } = {}) {
    super(parameters3);
    this.valueDec = valueDec;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (inputLength === 0)
      return inputOffset;
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams8(this, inputView, inputOffset, inputLength))
      return -1;
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0;i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0;i < this.blockLength; i++)
      tempView[i] = this.valueHexView[i];
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0;i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER8;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0;i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView.buffer;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
}
LocalRelativeSidValueBlock8.NAME = "relativeSidBlock";

class LocalRelativeObjectIdentifierValueBlock8 extends ValueBlock8 {
  constructor({ value = EMPTY_STRING8, ...parameters3 } = {}) {
    super(parameters3);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalRelativeSidValueBlock8;
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly, _writer) {
    const retBuffers = [];
    for (let i = 0;i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER8;
      }
      retBuffers.push(valueBuf);
    }
    return concat8(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      const sidBlock = new LocalRelativeSidValueBlock8;
      sidBlock.valueDec = parseInt(sid, 10);
      if (isNaN(sidBlock.valueDec))
        return true;
      this.value.push(sidBlock);
    } while (pos2 !== -1);
    return true;
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0;i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0;i < this.value.length; i++)
      object.sidArray.push(this.value[i].toJSON());
    return object;
  }
}
LocalRelativeObjectIdentifierValueBlock8.NAME = "RelativeObjectIdentifierValueBlock";
var _a$l8;

class RelativeObjectIdentifier8 extends BaseBlock8 {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  constructor(parameters3 = {}) {
    super(parameters3, LocalRelativeObjectIdentifierValueBlock8);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 13;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$l8 = RelativeObjectIdentifier8;
(() => {
  typeStore8.RelativeObjectIdentifier = _a$l8;
})();
RelativeObjectIdentifier8.NAME = "RelativeObjectIdentifier";
var _a$k8;

class Sequence8 extends Constructed8 {
  constructor(parameters3 = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 16;
  }
}
_a$k8 = Sequence8;
(() => {
  typeStore8.Sequence = _a$k8;
})();
Sequence8.NAME = "SEQUENCE";
var _a$j8;

class Set9 extends Constructed8 {
  constructor(parameters3 = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 17;
  }
}
_a$j8 = Set9;
(() => {
  typeStore8.Set = _a$j8;
})();
Set9.NAME = "SET";

class LocalStringValueBlock8 extends HexBlock8(ValueBlock8) {
  constructor({ ...parameters3 } = {}) {
    super(parameters3);
    this.isHexOnly = true;
    this.value = EMPTY_STRING8;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalStringValueBlock8.NAME = "StringValueBlock";

class LocalSimpleStringValueBlock8 extends LocalStringValueBlock8 {
}
LocalSimpleStringValueBlock8.NAME = "SimpleStringValueBlock";

class LocalSimpleStringBlock8 extends BaseStringBlock8 {
  constructor({ ...parameters3 } = {}) {
    super(parameters3, LocalSimpleStringValueBlock8);
  }
  fromBuffer(inputBuffer) {
    this.valueBlock.value = String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer));
  }
  fromString(inputString) {
    const strLen = inputString.length;
    const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
    for (let i = 0;i < strLen; i++)
      view[i] = inputString.charCodeAt(i);
    this.valueBlock.value = inputString;
  }
}
LocalSimpleStringBlock8.NAME = "SIMPLE STRING";

class LocalUtf8StringValueBlock8 extends LocalSimpleStringBlock8 {
  fromBuffer(inputBuffer) {
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
    try {
      this.valueBlock.value = Convert.ToUtf8String(inputBuffer);
    } catch (ex) {
      this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
      this.valueBlock.value = Convert.ToBinary(inputBuffer);
    }
  }
  fromString(inputString) {
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf8String(inputString));
    this.valueBlock.value = inputString;
  }
}
LocalUtf8StringValueBlock8.NAME = "Utf8StringValueBlock";
var _a$i8;

class Utf8String8 extends LocalUtf8StringValueBlock8 {
  constructor(parameters3 = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 12;
  }
}
_a$i8 = Utf8String8;
(() => {
  typeStore8.Utf8String = _a$i8;
})();
Utf8String8.NAME = "UTF8String";

class LocalBmpStringValueBlock8 extends LocalSimpleStringBlock8 {
  fromBuffer(inputBuffer) {
    this.valueBlock.value = Convert.ToUtf16String(inputBuffer);
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
  }
  fromString(inputString) {
    this.valueBlock.value = inputString;
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf16String(inputString));
  }
}
LocalBmpStringValueBlock8.NAME = "BmpStringValueBlock";
var _a$h8;

class BmpString8 extends LocalBmpStringValueBlock8 {
  constructor({ ...parameters3 } = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 30;
  }
}
_a$h8 = BmpString8;
(() => {
  typeStore8.BmpString = _a$h8;
})();
BmpString8.NAME = "BMPString";

class LocalUniversalStringValueBlock8 extends LocalSimpleStringBlock8 {
  fromBuffer(inputBuffer) {
    const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
    const valueView = new Uint8Array(copyBuffer);
    for (let i = 0;i < valueView.length; i += 4) {
      valueView[i] = valueView[i + 3];
      valueView[i + 1] = valueView[i + 2];
      valueView[i + 2] = 0;
      valueView[i + 3] = 0;
    }
    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
  }
  fromString(inputString) {
    const strLength = inputString.length;
    const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
    for (let i = 0;i < strLength; i++) {
      const codeBuf = utilToBase(inputString.charCodeAt(i), 8);
      const codeView = new Uint8Array(codeBuf);
      if (codeView.length > 4)
        continue;
      const dif = 4 - codeView.length;
      for (let j = codeView.length - 1;j >= 0; j--)
        valueHexView[i * 4 + j + dif] = codeView[j];
    }
    this.valueBlock.value = inputString;
  }
}
LocalUniversalStringValueBlock8.NAME = "UniversalStringValueBlock";
var _a$g8;

class UniversalString8 extends LocalUniversalStringValueBlock8 {
  constructor({ ...parameters3 } = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 28;
  }
}
_a$g8 = UniversalString8;
(() => {
  typeStore8.UniversalString = _a$g8;
})();
UniversalString8.NAME = "UniversalString";
var _a$f8;

class NumericString8 extends LocalSimpleStringBlock8 {
  constructor(parameters3 = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 18;
  }
}
_a$f8 = NumericString8;
(() => {
  typeStore8.NumericString = _a$f8;
})();
NumericString8.NAME = "NumericString";
var _a$e8;

class PrintableString8 extends LocalSimpleStringBlock8 {
  constructor(parameters3 = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 19;
  }
}
_a$e8 = PrintableString8;
(() => {
  typeStore8.PrintableString = _a$e8;
})();
PrintableString8.NAME = "PrintableString";
var _a$d8;

class TeletexString8 extends LocalSimpleStringBlock8 {
  constructor(parameters3 = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 20;
  }
}
_a$d8 = TeletexString8;
(() => {
  typeStore8.TeletexString = _a$d8;
})();
TeletexString8.NAME = "TeletexString";
var _a$c8;

class VideotexString8 extends LocalSimpleStringBlock8 {
  constructor(parameters3 = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 21;
  }
}
_a$c8 = VideotexString8;
(() => {
  typeStore8.VideotexString = _a$c8;
})();
VideotexString8.NAME = "VideotexString";
var _a$b8;

class IA5String8 extends LocalSimpleStringBlock8 {
  constructor(parameters3 = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 22;
  }
}
_a$b8 = IA5String8;
(() => {
  typeStore8.IA5String = _a$b8;
})();
IA5String8.NAME = "IA5String";
var _a$a8;

class GraphicString8 extends LocalSimpleStringBlock8 {
  constructor(parameters3 = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 25;
  }
}
_a$a8 = GraphicString8;
(() => {
  typeStore8.GraphicString = _a$a8;
})();
GraphicString8.NAME = "GraphicString";
var _a$98;

class VisibleString8 extends LocalSimpleStringBlock8 {
  constructor(parameters3 = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 26;
  }
}
_a$98 = VisibleString8;
(() => {
  typeStore8.VisibleString = _a$98;
})();
VisibleString8.NAME = "VisibleString";
var _a$88;

class GeneralString8 extends LocalSimpleStringBlock8 {
  constructor(parameters3 = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 27;
  }
}
_a$88 = GeneralString8;
(() => {
  typeStore8.GeneralString = _a$88;
})();
GeneralString8.NAME = "GeneralString";
var _a$78;

class CharacterString8 extends LocalSimpleStringBlock8 {
  constructor(parameters3 = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 29;
  }
}
_a$78 = CharacterString8;
(() => {
  typeStore8.CharacterString = _a$78;
})();
CharacterString8.NAME = "CharacterString";
var _a$68;

class UTCTime8 extends VisibleString8 {
  constructor({ value, valueDate, ...parameters3 } = {}) {
    super(parameters3);
    this.year = 0;
    this.month = 0;
    this.day = 0;
    this.hour = 0;
    this.minute = 0;
    this.second = 0;
    if (value) {
      this.fromString(value);
      this.valueBlock.valueHexView = new Uint8Array(value.length);
      for (let i = 0;i < value.length; i++)
        this.valueBlock.valueHexView[i] = value.charCodeAt(i);
    }
    if (valueDate) {
      this.fromDate(valueDate);
      this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
    }
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 23;
  }
  fromBuffer(inputBuffer) {
    this.fromString(String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer)));
  }
  toBuffer() {
    const str = this.toString();
    const buffer = new ArrayBuffer(str.length);
    const view = new Uint8Array(buffer);
    for (let i = 0;i < str.length; i++)
      view[i] = str.charCodeAt(i);
    return buffer;
  }
  fromDate(inputDate) {
    this.year = inputDate.getUTCFullYear();
    this.month = inputDate.getUTCMonth() + 1;
    this.day = inputDate.getUTCDate();
    this.hour = inputDate.getUTCHours();
    this.minute = inputDate.getUTCMinutes();
    this.second = inputDate.getUTCSeconds();
  }
  toDate() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
  }
  fromString(inputString) {
    const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
    const parserArray = parser.exec(inputString);
    if (parserArray === null) {
      this.error = "Wrong input string for conversion";
      return;
    }
    const year = parseInt(parserArray[1], 10);
    if (year >= 50)
      this.year = 1900 + year;
    else
      this.year = 2000 + year;
    this.month = parseInt(parserArray[2], 10);
    this.day = parseInt(parserArray[3], 10);
    this.hour = parseInt(parserArray[4], 10);
    this.minute = parseInt(parserArray[5], 10);
    this.second = parseInt(parserArray[6], 10);
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = new Array(7);
      outputArray[0] = padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);
      outputArray[1] = padNumber(this.month, 2);
      outputArray[2] = padNumber(this.day, 2);
      outputArray[3] = padNumber(this.hour, 2);
      outputArray[4] = padNumber(this.minute, 2);
      outputArray[5] = padNumber(this.second, 2);
      outputArray[6] = "Z";
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second
    };
  }
}
_a$68 = UTCTime8;
(() => {
  typeStore8.UTCTime = _a$68;
})();
UTCTime8.NAME = "UTCTime";
var _a$58;

class GeneralizedTime8 extends UTCTime8 {
  constructor(parameters3 = {}) {
    var _b;
    super(parameters3);
    (_b = this.millisecond) !== null && _b !== undefined || (this.millisecond = 0);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 24;
  }
  fromDate(inputDate) {
    super.fromDate(inputDate);
    this.millisecond = inputDate.getUTCMilliseconds();
  }
  toDate() {
    const utcDate = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond);
    return new Date(utcDate);
  }
  fromString(inputString) {
    let isUTC = false;
    let timeString = "";
    let dateTimeString = "";
    let fractionPart = 0;
    let parser;
    let hourDifference = 0;
    let minuteDifference = 0;
    if (inputString[inputString.length - 1] === "Z") {
      timeString = inputString.substring(0, inputString.length - 1);
      isUTC = true;
    } else {
      const number = new Number(inputString[inputString.length - 1]);
      if (isNaN(number.valueOf()))
        throw new Error("Wrong input string for conversion");
      timeString = inputString;
    }
    if (isUTC) {
      if (timeString.indexOf("+") !== -1)
        throw new Error("Wrong input string for conversion");
      if (timeString.indexOf("-") !== -1)
        throw new Error("Wrong input string for conversion");
    } else {
      let multiplier = 1;
      let differencePosition = timeString.indexOf("+");
      let differenceString = "";
      if (differencePosition === -1) {
        differencePosition = timeString.indexOf("-");
        multiplier = -1;
      }
      if (differencePosition !== -1) {
        differenceString = timeString.substring(differencePosition + 1);
        timeString = timeString.substring(0, differencePosition);
        if (differenceString.length !== 2 && differenceString.length !== 4)
          throw new Error("Wrong input string for conversion");
        let number = parseInt(differenceString.substring(0, 2), 10);
        if (isNaN(number.valueOf()))
          throw new Error("Wrong input string for conversion");
        hourDifference = multiplier * number;
        if (differenceString.length === 4) {
          number = parseInt(differenceString.substring(2, 4), 10);
          if (isNaN(number.valueOf()))
            throw new Error("Wrong input string for conversion");
          minuteDifference = multiplier * number;
        }
      }
    }
    let fractionPointPosition = timeString.indexOf(".");
    if (fractionPointPosition === -1)
      fractionPointPosition = timeString.indexOf(",");
    if (fractionPointPosition !== -1) {
      const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
      if (isNaN(fractionPartCheck.valueOf()))
        throw new Error("Wrong input string for conversion");
      fractionPart = fractionPartCheck.valueOf();
      dateTimeString = timeString.substring(0, fractionPointPosition);
    } else
      dateTimeString = timeString;
    switch (true) {
      case dateTimeString.length === 8:
        parser = /(\d{4})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1)
          throw new Error("Wrong input string for conversion");
        break;
      case dateTimeString.length === 10:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.minute = Math.floor(fractionResult);
          fractionResult = 60 * (fractionResult - this.minute);
          this.second = Math.floor(fractionResult);
          fractionResult = 1000 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 12:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.second = Math.floor(fractionResult);
          fractionResult = 1000 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 14:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          const fractionResult = 1000 * fractionPart;
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      default:
        throw new Error("Wrong input string for conversion");
    }
    const parserArray = parser.exec(dateTimeString);
    if (parserArray === null)
      throw new Error("Wrong input string for conversion");
    for (let j = 1;j < parserArray.length; j++) {
      switch (j) {
        case 1:
          this.year = parseInt(parserArray[j], 10);
          break;
        case 2:
          this.month = parseInt(parserArray[j], 10);
          break;
        case 3:
          this.day = parseInt(parserArray[j], 10);
          break;
        case 4:
          this.hour = parseInt(parserArray[j], 10) + hourDifference;
          break;
        case 5:
          this.minute = parseInt(parserArray[j], 10) + minuteDifference;
          break;
        case 6:
          this.second = parseInt(parserArray[j], 10);
          break;
        default:
          throw new Error("Wrong input string for conversion");
      }
    }
    if (isUTC === false) {
      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
      this.year = tempDate.getUTCFullYear();
      this.month = tempDate.getUTCMonth();
      this.day = tempDate.getUTCDay();
      this.hour = tempDate.getUTCHours();
      this.minute = tempDate.getUTCMinutes();
      this.second = tempDate.getUTCSeconds();
      this.millisecond = tempDate.getUTCMilliseconds();
    }
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = [];
      outputArray.push(padNumber(this.year, 4));
      outputArray.push(padNumber(this.month, 2));
      outputArray.push(padNumber(this.day, 2));
      outputArray.push(padNumber(this.hour, 2));
      outputArray.push(padNumber(this.minute, 2));
      outputArray.push(padNumber(this.second, 2));
      if (this.millisecond !== 0) {
        outputArray.push(".");
        outputArray.push(padNumber(this.millisecond, 3));
      }
      outputArray.push("Z");
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  toJSON() {
    return {
      ...super.toJSON(),
      millisecond: this.millisecond
    };
  }
}
_a$58 = GeneralizedTime8;
(() => {
  typeStore8.GeneralizedTime = _a$58;
})();
GeneralizedTime8.NAME = "GeneralizedTime";
var _a$48;

class DATE8 extends Utf8String8 {
  constructor(parameters3 = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 31;
  }
}
_a$48 = DATE8;
(() => {
  typeStore8.DATE = _a$48;
})();
DATE8.NAME = "DATE";
var _a$38;

class TimeOfDay8 extends Utf8String8 {
  constructor(parameters3 = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 32;
  }
}
_a$38 = TimeOfDay8;
(() => {
  typeStore8.TimeOfDay = _a$38;
})();
TimeOfDay8.NAME = "TimeOfDay";
var _a$28;

class DateTime8 extends Utf8String8 {
  constructor(parameters3 = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 33;
  }
}
_a$28 = DateTime8;
(() => {
  typeStore8.DateTime = _a$28;
})();
DateTime8.NAME = "DateTime";
var _a$18;

class Duration8 extends Utf8String8 {
  constructor(parameters3 = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 34;
  }
}
_a$18 = Duration8;
(() => {
  typeStore8.Duration = _a$18;
})();
Duration8.NAME = "Duration";
var _a8;

class TIME8 extends Utf8String8 {
  constructor(parameters3 = {}) {
    super(parameters3);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 14;
  }
}
_a8 = TIME8;
(() => {
  typeStore8.TIME = _a8;
})();
TIME8.NAME = "TIME";

class Any8 {
  constructor({ name: name8 = EMPTY_STRING8, optional = false } = {}) {
    this.name = name8;
    this.optional = optional;
  }
}

class Choice8 extends Any8 {
  constructor({ value = [], ...parameters3 } = {}) {
    super(parameters3);
    this.value = value;
  }
}

class Repeated8 extends Any8 {
  constructor({ value = new Any8, local = false, ...parameters3 } = {}) {
    super(parameters3);
    this.value = value;
    this.local = local;
  }
}

class RawData8 {
  get data() {
    return this.dataView.slice().buffer;
  }
  set data(value) {
    this.dataView = BufferSourceConverter.toUint8Array(value);
  }
  constructor({ data = EMPTY_VIEW8 } = {}) {
    this.dataView = BufferSourceConverter.toUint8Array(data);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const endLength = inputOffset + inputLength;
    this.dataView = BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
    return endLength;
  }
  toBER(_sizeOnly) {
    return this.dataView.slice().buffer;
  }
}
function compareSchema8(root, inputData, inputSchema) {
  if (inputSchema instanceof Choice8) {
    for (const element of inputSchema.value) {
      const result = compareSchema8(root, inputData, element);
      if (result.verified) {
        return {
          verified: true,
          result: root
        };
      }
    }
    {
      const _result = {
        verified: false,
        result: { error: "Wrong values for Choice type" }
      };
      if (inputSchema.hasOwnProperty(NAME8))
        _result.name = inputSchema.name;
      return _result;
    }
  }
  if (inputSchema instanceof Any8) {
    if (inputSchema.hasOwnProperty(NAME8))
      root[inputSchema.name] = inputData;
    return {
      verified: true,
      result: root
    };
  }
  if (root instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong root object" }
    };
  }
  if (inputData instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 data" }
    };
  }
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (ID_BLOCK8 in inputSchema === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (FROM_BER8 in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (TO_BER8 in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  const encodedId = inputSchema.idBlock.toBER(false);
  if (encodedId.byteLength === 0) {
    return {
      verified: false,
      result: { error: "Error encoding idBlock for ASN.1 schema" }
    };
  }
  const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
  if (decodedOffset === -1) {
    return {
      verified: false,
      result: { error: "Error decoding idBlock for ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS8) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER8) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED8) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
    return {
      verified: false,
      result: root
    };
  }
  if (!(IS_HEX_ONLY8 in inputSchema.idBlock)) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.isHexOnly) {
    if (VALUE_HEX_VIEW8 in inputSchema.idBlock === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    const schemaView = inputSchema.idBlock.valueHexView;
    const asn1View = inputData.idBlock.valueHexView;
    if (schemaView.length !== asn1View.length) {
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0;i < schemaView.length; i++) {
      if (schemaView[i] !== asn1View[1]) {
        return {
          verified: false,
          result: root
        };
      }
    }
  }
  if (inputSchema.name) {
    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING8);
    if (inputSchema.name)
      root[inputSchema.name] = inputData;
  }
  if (inputSchema instanceof typeStore8.Constructed) {
    let admission = 0;
    let result = {
      verified: false,
      result: { error: "Unknown error" }
    };
    let maxLength = inputSchema.valueBlock.value.length;
    if (maxLength > 0) {
      if (inputSchema.valueBlock.value[0] instanceof Repeated8) {
        maxLength = inputData.valueBlock.value.length;
      }
    }
    if (maxLength === 0) {
      return {
        verified: true,
        result: root
      };
    }
    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
      let _optional = true;
      for (let i = 0;i < inputSchema.valueBlock.value.length; i++)
        _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);
      if (_optional) {
        return {
          verified: true,
          result: root
        };
      }
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING8);
        if (inputSchema.name)
          delete root[inputSchema.name];
      }
      root.error = "Inconsistent object length";
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0;i < maxLength; i++) {
      if (i - admission >= inputData.valueBlock.value.length) {
        if (inputSchema.valueBlock.value[i].optional === false) {
          const _result = {
            verified: false,
            result: root
          };
          root.error = "Inconsistent length between ASN.1 data and schema";
          if (inputSchema.name) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING8);
            if (inputSchema.name) {
              delete root[inputSchema.name];
              _result.name = inputSchema.name;
            }
          }
          return _result;
        }
      } else {
        if (inputSchema.valueBlock.value[0] instanceof Repeated8) {
          result = compareSchema8(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[0].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING8);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
          if (NAME8 in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
            let arrayRoot = {};
            if (LOCAL8 in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local)
              arrayRoot = inputData;
            else
              arrayRoot = root;
            if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
              arrayRoot[inputSchema.valueBlock.value[0].name] = [];
            arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
          }
        } else {
          result = compareSchema8(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[i].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING8);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
        }
      }
    }
    if (result.verified === false) {
      const _result = {
        verified: false,
        result: root
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING8);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return {
      verified: true,
      result: root
    };
  }
  if (inputSchema.primitiveSchema && VALUE_HEX_VIEW8 in inputData.valueBlock) {
    const asn1 = localFromBER8(inputData.valueBlock.valueHexView);
    if (asn1.offset === -1) {
      const _result = {
        verified: false,
        result: asn1.result
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING8);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return compareSchema8(root, asn1.result, inputSchema.primitiveSchema);
  }
  return {
    verified: true,
    result: root
  };
}
function verifySchema8(inputBuffer, inputSchema) {
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema type" }
    };
  }
  const asn1 = localFromBER8(BufferSourceConverter.toUint8Array(inputBuffer));
  if (asn1.offset === -1) {
    return {
      verified: false,
      result: asn1.result
    };
  }
  return compareSchema8(asn1.result, asn1.result, inputSchema);
}

// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-schema/build/es2015/enums.js
var AsnTypeTypes8;
(function(AsnTypeTypes9) {
  AsnTypeTypes9[AsnTypeTypes9["Sequence"] = 0] = "Sequence";
  AsnTypeTypes9[AsnTypeTypes9["Set"] = 1] = "Set";
  AsnTypeTypes9[AsnTypeTypes9["Choice"] = 2] = "Choice";
})(AsnTypeTypes8 || (AsnTypeTypes8 = {}));
var AsnPropTypes8;
(function(AsnPropTypes9) {
  AsnPropTypes9[AsnPropTypes9["Any"] = 1] = "Any";
  AsnPropTypes9[AsnPropTypes9["Boolean"] = 2] = "Boolean";
  AsnPropTypes9[AsnPropTypes9["OctetString"] = 3] = "OctetString";
  AsnPropTypes9[AsnPropTypes9["BitString"] = 4] = "BitString";
  AsnPropTypes9[AsnPropTypes9["Integer"] = 5] = "Integer";
  AsnPropTypes9[AsnPropTypes9["Enumerated"] = 6] = "Enumerated";
  AsnPropTypes9[AsnPropTypes9["ObjectIdentifier"] = 7] = "ObjectIdentifier";
  AsnPropTypes9[AsnPropTypes9["Utf8String"] = 8] = "Utf8String";
  AsnPropTypes9[AsnPropTypes9["BmpString"] = 9] = "BmpString";
  AsnPropTypes9[AsnPropTypes9["UniversalString"] = 10] = "UniversalString";
  AsnPropTypes9[AsnPropTypes9["NumericString"] = 11] = "NumericString";
  AsnPropTypes9[AsnPropTypes9["PrintableString"] = 12] = "PrintableString";
  AsnPropTypes9[AsnPropTypes9["TeletexString"] = 13] = "TeletexString";
  AsnPropTypes9[AsnPropTypes9["VideotexString"] = 14] = "VideotexString";
  AsnPropTypes9[AsnPropTypes9["IA5String"] = 15] = "IA5String";
  AsnPropTypes9[AsnPropTypes9["GraphicString"] = 16] = "GraphicString";
  AsnPropTypes9[AsnPropTypes9["VisibleString"] = 17] = "VisibleString";
  AsnPropTypes9[AsnPropTypes9["GeneralString"] = 18] = "GeneralString";
  AsnPropTypes9[AsnPropTypes9["CharacterString"] = 19] = "CharacterString";
  AsnPropTypes9[AsnPropTypes9["UTCTime"] = 20] = "UTCTime";
  AsnPropTypes9[AsnPropTypes9["GeneralizedTime"] = 21] = "GeneralizedTime";
  AsnPropTypes9[AsnPropTypes9["DATE"] = 22] = "DATE";
  AsnPropTypes9[AsnPropTypes9["TimeOfDay"] = 23] = "TimeOfDay";
  AsnPropTypes9[AsnPropTypes9["DateTime"] = 24] = "DateTime";
  AsnPropTypes9[AsnPropTypes9["Duration"] = 25] = "Duration";
  AsnPropTypes9[AsnPropTypes9["TIME"] = 26] = "TIME";
  AsnPropTypes9[AsnPropTypes9["Null"] = 27] = "Null";
})(AsnPropTypes8 || (AsnPropTypes8 = {}));

// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-schema/build/es2015/types/bit_string.js
class BitString16 {
  constructor(params, unusedBits = 0) {
    this.unusedBits = 0;
    this.value = new ArrayBuffer(0);
    if (params) {
      if (typeof params === "number") {
        this.fromNumber(params);
      } else if (BufferSourceConverter.isBufferSource(params)) {
        this.unusedBits = unusedBits;
        this.value = BufferSourceConverter.toArrayBuffer(params);
      } else {
        throw TypeError("Unsupported type of 'params' argument for BitString");
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof BitString15)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 BitString");
    }
    this.unusedBits = asn.valueBlock.unusedBits;
    this.value = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new BitString15({ unusedBits: this.unusedBits, valueHex: this.value });
  }
  toSchema(name8) {
    return new BitString15({ name: name8 });
  }
  toNumber() {
    let res = "";
    const uintArray = new Uint8Array(this.value);
    for (const octet of uintArray) {
      res += octet.toString(2).padStart(8, "0");
    }
    res = res.split("").reverse().join("");
    if (this.unusedBits) {
      res = res.slice(this.unusedBits).padStart(this.unusedBits, "0");
    }
    return parseInt(res, 2);
  }
  fromNumber(value) {
    let bits = value.toString(2);
    const octetSize = bits.length + 7 >> 3;
    this.unusedBits = (octetSize << 3) - bits.length;
    const octets = new Uint8Array(octetSize);
    bits = bits.padStart(octetSize << 3, "0").split("").reverse().join("");
    let index = 0;
    while (index < octetSize) {
      octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);
      index++;
    }
    this.value = octets.buffer;
  }
}
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-schema/build/es2015/types/octet_string.js
class OctetString16 {
  get byteLength() {
    return this.buffer.byteLength;
  }
  get byteOffset() {
    return 0;
  }
  constructor(param) {
    if (typeof param === "number") {
      this.buffer = new ArrayBuffer(param);
    } else {
      if (BufferSourceConverter.isBufferSource(param)) {
        this.buffer = BufferSourceConverter.toArrayBuffer(param);
      } else if (Array.isArray(param)) {
        this.buffer = new Uint8Array(param);
      } else {
        this.buffer = new ArrayBuffer(0);
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof OctetString15)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString");
    }
    this.buffer = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new OctetString15({ valueHex: this.buffer });
  }
  toSchema(name8) {
    return new OctetString15({ name: name8 });
  }
}
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-schema/build/es2015/converters.js
var AsnAnyConverter8 = {
  fromASN: (value) => value instanceof Null8 ? null : value.valueBeforeDecodeView,
  toASN: (value) => {
    if (value === null) {
      return new Null8;
    }
    const schema = fromBER8(value);
    if (schema.result.error) {
      throw new Error(schema.result.error);
    }
    return schema.result;
  }
};
var AsnIntegerConverter8 = {
  fromASN: (value) => value.valueBlock.valueHexView.byteLength >= 4 ? value.valueBlock.toString() : value.valueBlock.valueDec,
  toASN: (value) => new Integer8({ value: +value })
};
var AsnEnumeratedConverter8 = {
  fromASN: (value) => value.valueBlock.valueDec,
  toASN: (value) => new Enumerated8({ value })
};
var AsnIntegerArrayBufferConverter8 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new Integer8({ valueHex: value })
};
var AsnBitStringConverter8 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new BitString15({ valueHex: value })
};
var AsnObjectIdentifierConverter8 = {
  fromASN: (value) => value.valueBlock.toString(),
  toASN: (value) => new ObjectIdentifier8({ value })
};
var AsnBooleanConverter8 = {
  fromASN: (value) => value.valueBlock.value,
  toASN: (value) => new Boolean9({ value })
};
var AsnOctetStringConverter8 = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new OctetString15({ valueHex: value })
};
function createStringConverter8(Asn1Type) {
  return {
    fromASN: (value) => value.valueBlock.value,
    toASN: (value) => new Asn1Type({ value })
  };
}
var AsnUtf8StringConverter8 = createStringConverter8(Utf8String8);
var AsnBmpStringConverter8 = createStringConverter8(BmpString8);
var AsnUniversalStringConverter8 = createStringConverter8(UniversalString8);
var AsnNumericStringConverter8 = createStringConverter8(NumericString8);
var AsnPrintableStringConverter8 = createStringConverter8(PrintableString8);
var AsnTeletexStringConverter8 = createStringConverter8(TeletexString8);
var AsnVideotexStringConverter8 = createStringConverter8(VideotexString8);
var AsnIA5StringConverter8 = createStringConverter8(IA5String8);
var AsnGraphicStringConverter8 = createStringConverter8(GraphicString8);
var AsnVisibleStringConverter8 = createStringConverter8(VisibleString8);
var AsnGeneralStringConverter8 = createStringConverter8(GeneralString8);
var AsnCharacterStringConverter8 = createStringConverter8(CharacterString8);
var AsnUTCTimeConverter8 = {
  fromASN: (value) => value.toDate(),
  toASN: (value) => new UTCTime8({ valueDate: value })
};
var AsnGeneralizedTimeConverter8 = {
  fromASN: (value) => value.toDate(),
  toASN: (value) => new GeneralizedTime8({ valueDate: value })
};
var AsnNullConverter8 = {
  fromASN: () => null,
  toASN: () => {
    return new Null8;
  }
};
function defaultConverter8(type) {
  switch (type) {
    case AsnPropTypes8.Any:
      return AsnAnyConverter8;
    case AsnPropTypes8.BitString:
      return AsnBitStringConverter8;
    case AsnPropTypes8.BmpString:
      return AsnBmpStringConverter8;
    case AsnPropTypes8.Boolean:
      return AsnBooleanConverter8;
    case AsnPropTypes8.CharacterString:
      return AsnCharacterStringConverter8;
    case AsnPropTypes8.Enumerated:
      return AsnEnumeratedConverter8;
    case AsnPropTypes8.GeneralString:
      return AsnGeneralStringConverter8;
    case AsnPropTypes8.GeneralizedTime:
      return AsnGeneralizedTimeConverter8;
    case AsnPropTypes8.GraphicString:
      return AsnGraphicStringConverter8;
    case AsnPropTypes8.IA5String:
      return AsnIA5StringConverter8;
    case AsnPropTypes8.Integer:
      return AsnIntegerConverter8;
    case AsnPropTypes8.Null:
      return AsnNullConverter8;
    case AsnPropTypes8.NumericString:
      return AsnNumericStringConverter8;
    case AsnPropTypes8.ObjectIdentifier:
      return AsnObjectIdentifierConverter8;
    case AsnPropTypes8.OctetString:
      return AsnOctetStringConverter8;
    case AsnPropTypes8.PrintableString:
      return AsnPrintableStringConverter8;
    case AsnPropTypes8.TeletexString:
      return AsnTeletexStringConverter8;
    case AsnPropTypes8.UTCTime:
      return AsnUTCTimeConverter8;
    case AsnPropTypes8.UniversalString:
      return AsnUniversalStringConverter8;
    case AsnPropTypes8.Utf8String:
      return AsnUtf8StringConverter8;
    case AsnPropTypes8.VideotexString:
      return AsnVideotexStringConverter8;
    case AsnPropTypes8.VisibleString:
      return AsnVisibleStringConverter8;
    default:
      return null;
  }
}
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-schema/build/es2015/helper.js
function isConvertible8(target2) {
  if (typeof target2 === "function" && target2.prototype) {
    if (target2.prototype.toASN && target2.prototype.fromASN) {
      return true;
    } else {
      return isConvertible8(target2.prototype);
    }
  } else {
    return !!(target2 && typeof target2 === "object" && ("toASN" in target2) && ("fromASN" in target2));
  }
}

// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-schema/build/es2015/schema.js
class AsnSchemaStorage8 {
  constructor() {
    this.items = new WeakMap;
  }
  has(target2) {
    return this.items.has(target2);
  }
  get(target2, checkSchema = false) {
    const schema = this.items.get(target2);
    if (!schema) {
      throw new Error(`Cannot get schema for '${target2.prototype.constructor.name}' target`);
    }
    if (checkSchema && !schema.schema) {
      throw new Error(`Schema '${target2.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);
    }
    return schema;
  }
  cache(target2) {
    const schema = this.get(target2);
    if (!schema.schema) {
      schema.schema = this.create(target2, true);
    }
  }
  createDefault(target2) {
    const schema = { type: AsnTypeTypes8.Sequence, items: {} };
    const parentSchema = this.findParentSchema(target2);
    if (parentSchema) {
      Object.assign(schema, parentSchema);
      schema.items = Object.assign({}, schema.items, parentSchema.items);
    }
    return schema;
  }
  create(target2, useNames) {
    const schema = this.items.get(target2) || this.createDefault(target2);
    const asn1Value = [];
    for (const key in schema.items) {
      const item = schema.items[key];
      const name8 = useNames ? key : "";
      let asn1Item;
      if (typeof item.type === "number") {
        const Asn1TypeName = AsnPropTypes8[item.type];
        const Asn1Type = exports_index_es9[Asn1TypeName];
        if (!Asn1Type) {
          throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
        }
        asn1Item = new Asn1Type({ name: name8 });
      } else if (isConvertible8(item.type)) {
        const instance2 = new item.type;
        asn1Item = instance2.toSchema(name8);
      } else if (item.optional) {
        const itemSchema = this.get(item.type);
        if (itemSchema.type === AsnTypeTypes8.Choice) {
          asn1Item = new Any8({ name: name8 });
        } else {
          asn1Item = this.create(item.type, false);
          asn1Item.name = name8;
        }
      } else {
        asn1Item = new Any8({ name: name8 });
      }
      const optional = !!item.optional || item.defaultValue !== undefined;
      if (item.repeated) {
        asn1Item.name = "";
        const Container = item.repeated === "set" ? Set9 : Sequence8;
        asn1Item = new Container({
          name: "",
          value: [new Repeated8({ name: name8, value: asn1Item })]
        });
      }
      if (item.context !== null && item.context !== undefined) {
        if (item.implicit) {
          if (typeof item.type === "number" || isConvertible8(item.type)) {
            const Container = item.repeated ? Constructed8 : Primitive8;
            asn1Value.push(new Container({ name: name8, optional, idBlock: { tagClass: 3, tagNumber: item.context } }));
          } else {
            this.cache(item.type);
            const isRepeated = !!item.repeated;
            let value = !isRepeated ? this.get(item.type, true).schema : asn1Item;
            value = "valueBlock" in value ? value.valueBlock.value : value.value;
            asn1Value.push(new Constructed8({
              name: !isRepeated ? name8 : "",
              optional,
              idBlock: { tagClass: 3, tagNumber: item.context },
              value
            }));
          }
        } else {
          asn1Value.push(new Constructed8({
            optional,
            idBlock: { tagClass: 3, tagNumber: item.context },
            value: [asn1Item]
          }));
        }
      } else {
        asn1Item.optional = optional;
        asn1Value.push(asn1Item);
      }
    }
    switch (schema.type) {
      case AsnTypeTypes8.Sequence:
        return new Sequence8({ value: asn1Value, name: "" });
      case AsnTypeTypes8.Set:
        return new Set9({ value: asn1Value, name: "" });
      case AsnTypeTypes8.Choice:
        return new Choice8({ value: asn1Value, name: "" });
      default:
        throw new Error(`Unsupported ASN1 type in use`);
    }
  }
  set(target2, schema) {
    this.items.set(target2, schema);
    return this;
  }
  findParentSchema(target2) {
    const parent = Object.getPrototypeOf(target2);
    if (parent) {
      const schema = this.items.get(parent);
      return schema || this.findParentSchema(parent);
    }
    return null;
  }
}

// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-schema/build/es2015/storage.js
var schemaStorage8 = new AsnSchemaStorage8;

// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-schema/build/es2015/decorators.js
var AsnType8 = (options) => (target2) => {
  let schema;
  if (!schemaStorage8.has(target2)) {
    schema = schemaStorage8.createDefault(target2);
    schemaStorage8.set(target2, schema);
  } else {
    schema = schemaStorage8.get(target2);
  }
  Object.assign(schema, options);
};
var AsnProp8 = (options) => (target2, propertyKey) => {
  let schema;
  if (!schemaStorage8.has(target2.constructor)) {
    schema = schemaStorage8.createDefault(target2.constructor);
    schemaStorage8.set(target2.constructor, schema);
  } else {
    schema = schemaStorage8.get(target2.constructor);
  }
  const copyOptions = Object.assign({}, options);
  if (typeof copyOptions.type === "number" && !copyOptions.converter) {
    const defaultConverter9 = defaultConverter8(options.type);
    if (!defaultConverter9) {
      throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target2.constructor.name}`);
    }
    copyOptions.converter = defaultConverter9;
  }
  copyOptions.raw = options.raw;
  schema.items[propertyKey] = copyOptions;
};
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-schema/build/es2015/objects.js
class AsnArray8 extends Array {
  constructor(items = []) {
    if (typeof items === "number") {
      super(items);
    } else {
      super();
      for (const item of items) {
        this.push(item);
      }
    }
  }
}
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/ip_converter.js
class IpConverter8 {
  static isIPv4(ip2) {
    return /^(\d{1,3}\.){3}\d{1,3}$/.test(ip2);
  }
  static parseIPv4(ip2) {
    const parts = ip2.split(".");
    if (parts.length !== 4) {
      throw new Error("Invalid IPv4 address");
    }
    return parts.map((part) => {
      const num = parseInt(part, 10);
      if (isNaN(num) || num < 0 || num > 255) {
        throw new Error("Invalid IPv4 address part");
      }
      return num;
    });
  }
  static parseIPv6(ip2) {
    const expandedIP = this.expandIPv6(ip2);
    const parts = expandedIP.split(":");
    if (parts.length !== 8) {
      throw new Error("Invalid IPv6 address");
    }
    return parts.reduce((bytes, part) => {
      const num = parseInt(part, 16);
      if (isNaN(num) || num < 0 || num > 65535) {
        throw new Error("Invalid IPv6 address part");
      }
      bytes.push(num >> 8 & 255);
      bytes.push(num & 255);
      return bytes;
    }, []);
  }
  static expandIPv6(ip2) {
    if (!ip2.includes("::")) {
      return ip2;
    }
    const parts = ip2.split("::");
    if (parts.length > 2) {
      throw new Error("Invalid IPv6 address");
    }
    const left = parts[0] ? parts[0].split(":") : [];
    const right = parts[1] ? parts[1].split(":") : [];
    const missing = 8 - (left.length + right.length);
    if (missing < 0) {
      throw new Error("Invalid IPv6 address");
    }
    return [...left, ...Array(missing).fill("0"), ...right].join(":");
  }
  static formatIPv6(bytes) {
    const parts = [];
    for (let i = 0;i < 16; i += 2) {
      parts.push((bytes[i] << 8 | bytes[i + 1]).toString(16));
    }
    return this.compressIPv6(parts.join(":"));
  }
  static compressIPv6(ip2) {
    const parts = ip2.split(":");
    let longestZeroStart = -1;
    let longestZeroLength = 0;
    let currentZeroStart = -1;
    let currentZeroLength = 0;
    for (let i = 0;i < parts.length; i++) {
      if (parts[i] === "0") {
        if (currentZeroStart === -1) {
          currentZeroStart = i;
        }
        currentZeroLength++;
      } else {
        if (currentZeroLength > longestZeroLength) {
          longestZeroStart = currentZeroStart;
          longestZeroLength = currentZeroLength;
        }
        currentZeroStart = -1;
        currentZeroLength = 0;
      }
    }
    if (currentZeroLength > longestZeroLength) {
      longestZeroStart = currentZeroStart;
      longestZeroLength = currentZeroLength;
    }
    if (longestZeroLength > 1) {
      const before = parts.slice(0, longestZeroStart).join(":");
      const after = parts.slice(longestZeroStart + longestZeroLength).join(":");
      return `${before}::${after}`;
    }
    return ip2;
  }
  static parseCIDR(text) {
    const [addr, prefixStr] = text.split("/");
    const prefix = parseInt(prefixStr, 10);
    if (this.isIPv4(addr)) {
      if (prefix < 0 || prefix > 32) {
        throw new Error("Invalid IPv4 prefix length");
      }
      return [this.parseIPv4(addr), prefix];
    } else {
      if (prefix < 0 || prefix > 128) {
        throw new Error("Invalid IPv6 prefix length");
      }
      return [this.parseIPv6(addr), prefix];
    }
  }
  static decodeIP(value) {
    if (value.length === 64 && parseInt(value, 16) === 0) {
      return "::/0";
    }
    if (value.length !== 16) {
      return value;
    }
    const mask = parseInt(value.slice(8), 16).toString(2).split("").reduce((a, k) => a + +k, 0);
    let ip2 = value.slice(0, 8).replace(/(.{2})/g, (match2) => `${parseInt(match2, 16)}.`);
    ip2 = ip2.slice(0, -1);
    return `${ip2}/${mask}`;
  }
  static toString(buf) {
    const uint8 = new Uint8Array(buf);
    if (uint8.length === 4) {
      return Array.from(uint8).join(".");
    }
    if (uint8.length === 16) {
      return this.formatIPv6(uint8);
    }
    if (uint8.length === 8 || uint8.length === 32) {
      const half = uint8.length / 2;
      const addrBytes = uint8.slice(0, half);
      const maskBytes = uint8.slice(half);
      const isAllZeros = uint8.every((byte) => byte === 0);
      if (isAllZeros) {
        return uint8.length === 8 ? "0.0.0.0/0" : "::/0";
      }
      const prefixLen = maskBytes.reduce((a, b) => a + (b.toString(2).match(/1/g) || []).length, 0);
      if (uint8.length === 8) {
        const addrStr = Array.from(addrBytes).join(".");
        return `${addrStr}/${prefixLen}`;
      } else {
        const addrStr = this.formatIPv6(addrBytes);
        return `${addrStr}/${prefixLen}`;
      }
    }
    return this.decodeIP(Convert.ToHex(buf));
  }
  static fromString(text) {
    if (text.includes("/")) {
      const [addr, prefix] = this.parseCIDR(text);
      const maskBytes = new Uint8Array(addr.length);
      let bitsLeft = prefix;
      for (let i = 0;i < maskBytes.length; i++) {
        if (bitsLeft >= 8) {
          maskBytes[i] = 255;
          bitsLeft -= 8;
        } else if (bitsLeft > 0) {
          maskBytes[i] = 255 << 8 - bitsLeft;
          bitsLeft = 0;
        }
      }
      const out = new Uint8Array(addr.length * 2);
      out.set(addr, 0);
      out.set(maskBytes, addr.length);
      return out.buffer;
    }
    const bytes = this.isIPv4(text) ? this.parseIPv4(text) : this.parseIPv6(text);
    return new Uint8Array(bytes).buffer;
  }
}

// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/name.js
var RelativeDistinguishedName_18;
var RDNSequence_18;
var Name_18;
var DirectoryString15 = class DirectoryString16 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.bmpString || this.printableString || this.teletexString || this.universalString || this.utf8String || "";
  }
};
__decorate([
  AsnProp8({ type: AsnPropTypes8.TeletexString })
], DirectoryString15.prototype, "teletexString", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.PrintableString })
], DirectoryString15.prototype, "printableString", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.UniversalString })
], DirectoryString15.prototype, "universalString", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.Utf8String })
], DirectoryString15.prototype, "utf8String", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.BmpString })
], DirectoryString15.prototype, "bmpString", undefined);
DirectoryString15 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Choice })
], DirectoryString15);
var AttributeValue15 = class AttributeValue16 extends DirectoryString15 {
  constructor(params = {}) {
    super(params);
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || (this.anyValue ? Convert.ToHex(this.anyValue) : super.toString());
  }
};
__decorate([
  AsnProp8({ type: AsnPropTypes8.IA5String })
], AttributeValue15.prototype, "ia5String", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.Any })
], AttributeValue15.prototype, "anyValue", undefined);
AttributeValue15 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Choice })
], AttributeValue15);
class AttributeTypeAndValue8 {
  constructor(params = {}) {
    this.type = "";
    this.value = new AttributeValue15;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: AsnPropTypes8.ObjectIdentifier })
], AttributeTypeAndValue8.prototype, "type", undefined);
__decorate([
  AsnProp8({ type: AttributeValue15 })
], AttributeTypeAndValue8.prototype, "value", undefined);
var RelativeDistinguishedName15 = RelativeDistinguishedName_18 = class RelativeDistinguishedName16 extends AsnArray8 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RelativeDistinguishedName_18.prototype);
  }
};
RelativeDistinguishedName15 = RelativeDistinguishedName_18 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Set, itemType: AttributeTypeAndValue8 })
], RelativeDistinguishedName15);
var RDNSequence15 = RDNSequence_18 = class RDNSequence16 extends AsnArray8 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RDNSequence_18.prototype);
  }
};
RDNSequence15 = RDNSequence_18 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Sequence, itemType: RelativeDistinguishedName15 })
], RDNSequence15);
var Name15 = Name_18 = class Name16 extends RDNSequence15 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Name_18.prototype);
  }
};
Name15 = Name_18 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Sequence })
], Name15);

// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/general_name.js
var AsnIpConverter8 = {
  fromASN: (value) => IpConverter8.toString(AsnOctetStringConverter8.fromASN(value)),
  toASN: (value) => AsnOctetStringConverter8.toASN(IpConverter8.fromString(value))
};

class OtherName8 {
  constructor(params = {}) {
    this.typeId = "";
    this.value = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: AsnPropTypes8.ObjectIdentifier })
], OtherName8.prototype, "typeId", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.Any, context: 0 })
], OtherName8.prototype, "value", undefined);

class EDIPartyName8 {
  constructor(params = {}) {
    this.partyName = new DirectoryString15;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: DirectoryString15, optional: true, context: 0, implicit: true })
], EDIPartyName8.prototype, "nameAssigner", undefined);
__decorate([
  AsnProp8({ type: DirectoryString15, context: 1, implicit: true })
], EDIPartyName8.prototype, "partyName", undefined);
var GeneralName15 = class GeneralName16 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp8({ type: OtherName8, context: 0, implicit: true })
], GeneralName15.prototype, "otherName", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.IA5String, context: 1, implicit: true })
], GeneralName15.prototype, "rfc822Name", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.IA5String, context: 2, implicit: true })
], GeneralName15.prototype, "dNSName", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.Any, context: 3, implicit: true })
], GeneralName15.prototype, "x400Address", undefined);
__decorate([
  AsnProp8({ type: Name15, context: 4, implicit: false })
], GeneralName15.prototype, "directoryName", undefined);
__decorate([
  AsnProp8({ type: EDIPartyName8, context: 5 })
], GeneralName15.prototype, "ediPartyName", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.IA5String, context: 6, implicit: true })
], GeneralName15.prototype, "uniformResourceIdentifier", undefined);
__decorate([
  AsnProp8({
    type: AsnPropTypes8.OctetString,
    context: 7,
    implicit: true,
    converter: AsnIpConverter8
  })
], GeneralName15.prototype, "iPAddress", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.ObjectIdentifier, context: 8, implicit: true })
], GeneralName15.prototype, "registeredID", undefined);
GeneralName15 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Choice })
], GeneralName15);

// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js
var id_pkix8 = "1.3.6.1.5.5.7";
var id_pe8 = `${id_pkix8}.1`;
var id_qt8 = `${id_pkix8}.2`;
var id_kp8 = `${id_pkix8}.3`;
var id_ad8 = `${id_pkix8}.48`;
var id_qt_csp8 = `${id_qt8}.1`;
var id_qt_unotice8 = `${id_qt8}.2`;
var id_ad_ocsp8 = `${id_ad8}.1`;
var id_ad_caIssuers8 = `${id_ad8}.2`;
var id_ad_timeStamping8 = `${id_ad8}.3`;
var id_ad_caRepository8 = `${id_ad8}.5`;
var id_ce8 = "2.5.29";

// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_information_access.js
var AuthorityInfoAccessSyntax_18;
var id_pe_authorityInfoAccess8 = `${id_pe8}.1`;

class AccessDescription8 {
  constructor(params = {}) {
    this.accessMethod = "";
    this.accessLocation = new GeneralName15;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: AsnPropTypes8.ObjectIdentifier })
], AccessDescription8.prototype, "accessMethod", undefined);
__decorate([
  AsnProp8({ type: GeneralName15 })
], AccessDescription8.prototype, "accessLocation", undefined);
var AuthorityInfoAccessSyntax15 = AuthorityInfoAccessSyntax_18 = class AuthorityInfoAccessSyntax16 extends AsnArray8 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, AuthorityInfoAccessSyntax_18.prototype);
  }
};
AuthorityInfoAccessSyntax15 = AuthorityInfoAccessSyntax_18 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Sequence, itemType: AccessDescription8 })
], AuthorityInfoAccessSyntax15);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_key_identifier.js
var id_ce_authorityKeyIdentifier8 = `${id_ce8}.35`;

class KeyIdentifier8 extends OctetString16 {
}

class AuthorityKeyIdentifier8 {
  constructor(params = {}) {
    if (params) {
      Object.assign(this, params);
    }
  }
}
__decorate([
  AsnProp8({ type: KeyIdentifier8, context: 0, optional: true, implicit: true })
], AuthorityKeyIdentifier8.prototype, "keyIdentifier", undefined);
__decorate([
  AsnProp8({ type: GeneralName15, context: 1, optional: true, implicit: true, repeated: "sequence" })
], AuthorityKeyIdentifier8.prototype, "authorityCertIssuer", undefined);
__decorate([
  AsnProp8({
    type: AsnPropTypes8.Integer,
    context: 2,
    optional: true,
    implicit: true,
    converter: AsnIntegerArrayBufferConverter8
  })
], AuthorityKeyIdentifier8.prototype, "authorityCertSerialNumber", undefined);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/basic_constraints.js
var id_ce_basicConstraints8 = `${id_ce8}.19`;

class BasicConstraints8 {
  constructor(params = {}) {
    this.cA = false;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: AsnPropTypes8.Boolean, defaultValue: false })
], BasicConstraints8.prototype, "cA", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.Integer, optional: true })
], BasicConstraints8.prototype, "pathLenConstraint", undefined);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/general_names.js
var GeneralNames_18;
var GeneralNames15 = GeneralNames_18 = class GeneralNames16 extends AsnArray8 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralNames_18.prototype);
  }
};
GeneralNames15 = GeneralNames_18 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Sequence, itemType: GeneralName15 })
], GeneralNames15);

// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_issuer.js
var CertificateIssuer_18;
var id_ce_certificateIssuer8 = `${id_ce8}.29`;
var CertificateIssuer15 = CertificateIssuer_18 = class CertificateIssuer16 extends GeneralNames15 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificateIssuer_18.prototype);
  }
};
CertificateIssuer15 = CertificateIssuer_18 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Sequence })
], CertificateIssuer15);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_policies.js
var CertificatePolicies_18;
var id_ce_certificatePolicies8 = `${id_ce8}.32`;
var id_ce_certificatePolicies_anyPolicy8 = `${id_ce_certificatePolicies8}.0`;
var DisplayText15 = class DisplayText16 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || this.visibleString || this.bmpString || this.utf8String || "";
  }
};
__decorate([
  AsnProp8({ type: AsnPropTypes8.IA5String })
], DisplayText15.prototype, "ia5String", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.VisibleString })
], DisplayText15.prototype, "visibleString", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.BmpString })
], DisplayText15.prototype, "bmpString", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.Utf8String })
], DisplayText15.prototype, "utf8String", undefined);
DisplayText15 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Choice })
], DisplayText15);
class NoticeReference8 {
  constructor(params = {}) {
    this.organization = new DisplayText15;
    this.noticeNumbers = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: DisplayText15 })
], NoticeReference8.prototype, "organization", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.Integer, repeated: "sequence" })
], NoticeReference8.prototype, "noticeNumbers", undefined);

class UserNotice8 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: NoticeReference8, optional: true })
], UserNotice8.prototype, "noticeRef", undefined);
__decorate([
  AsnProp8({ type: DisplayText15, optional: true })
], UserNotice8.prototype, "explicitText", undefined);
var Qualifier15 = class Qualifier16 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp8({ type: AsnPropTypes8.IA5String })
], Qualifier15.prototype, "cPSuri", undefined);
__decorate([
  AsnProp8({ type: UserNotice8 })
], Qualifier15.prototype, "userNotice", undefined);
Qualifier15 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Choice })
], Qualifier15);
class PolicyQualifierInfo8 {
  constructor(params = {}) {
    this.policyQualifierId = "";
    this.qualifier = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: AsnPropTypes8.ObjectIdentifier })
], PolicyQualifierInfo8.prototype, "policyQualifierId", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.Any })
], PolicyQualifierInfo8.prototype, "qualifier", undefined);

class PolicyInformation8 {
  constructor(params = {}) {
    this.policyIdentifier = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: AsnPropTypes8.ObjectIdentifier })
], PolicyInformation8.prototype, "policyIdentifier", undefined);
__decorate([
  AsnProp8({ type: PolicyQualifierInfo8, repeated: "sequence", optional: true })
], PolicyInformation8.prototype, "policyQualifiers", undefined);
var CertificatePolicies15 = CertificatePolicies_18 = class CertificatePolicies16 extends AsnArray8 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificatePolicies_18.prototype);
  }
};
CertificatePolicies15 = CertificatePolicies_18 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Sequence, itemType: PolicyInformation8 })
], CertificatePolicies15);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_number.js
var id_ce_cRLNumber8 = `${id_ce8}.20`;
var CRLNumber15 = class CRLNumber16 {
  constructor(value = 0) {
    this.value = value;
  }
};
__decorate([
  AsnProp8({ type: AsnPropTypes8.Integer })
], CRLNumber15.prototype, "value", undefined);
CRLNumber15 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Choice })
], CRLNumber15);

// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_delta_indicator.js
var id_ce_deltaCRLIndicator8 = `${id_ce8}.27`;
var BaseCRLNumber15 = class BaseCRLNumber16 extends CRLNumber15 {
};
BaseCRLNumber15 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Choice })
], BaseCRLNumber15);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_distribution_points.js
var CRLDistributionPoints_18;
var id_ce_cRLDistributionPoints8 = `${id_ce8}.31`;
var ReasonFlags8;
(function(ReasonFlags9) {
  ReasonFlags9[ReasonFlags9["unused"] = 1] = "unused";
  ReasonFlags9[ReasonFlags9["keyCompromise"] = 2] = "keyCompromise";
  ReasonFlags9[ReasonFlags9["cACompromise"] = 4] = "cACompromise";
  ReasonFlags9[ReasonFlags9["affiliationChanged"] = 8] = "affiliationChanged";
  ReasonFlags9[ReasonFlags9["superseded"] = 16] = "superseded";
  ReasonFlags9[ReasonFlags9["cessationOfOperation"] = 32] = "cessationOfOperation";
  ReasonFlags9[ReasonFlags9["certificateHold"] = 64] = "certificateHold";
  ReasonFlags9[ReasonFlags9["privilegeWithdrawn"] = 128] = "privilegeWithdrawn";
  ReasonFlags9[ReasonFlags9["aACompromise"] = 256] = "aACompromise";
})(ReasonFlags8 || (ReasonFlags8 = {}));

class Reason8 extends BitString16 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & ReasonFlags8.aACompromise) {
      res.push("aACompromise");
    }
    if (flags & ReasonFlags8.affiliationChanged) {
      res.push("affiliationChanged");
    }
    if (flags & ReasonFlags8.cACompromise) {
      res.push("cACompromise");
    }
    if (flags & ReasonFlags8.certificateHold) {
      res.push("certificateHold");
    }
    if (flags & ReasonFlags8.cessationOfOperation) {
      res.push("cessationOfOperation");
    }
    if (flags & ReasonFlags8.keyCompromise) {
      res.push("keyCompromise");
    }
    if (flags & ReasonFlags8.privilegeWithdrawn) {
      res.push("privilegeWithdrawn");
    }
    if (flags & ReasonFlags8.superseded) {
      res.push("superseded");
    }
    if (flags & ReasonFlags8.unused) {
      res.push("unused");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
}
var DistributionPointName15 = class DistributionPointName16 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp8({ type: GeneralName15, context: 0, repeated: "sequence", implicit: true })
], DistributionPointName15.prototype, "fullName", undefined);
__decorate([
  AsnProp8({ type: RelativeDistinguishedName15, context: 1, implicit: true })
], DistributionPointName15.prototype, "nameRelativeToCRLIssuer", undefined);
DistributionPointName15 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Choice })
], DistributionPointName15);
class DistributionPoint8 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: DistributionPointName15, context: 0, optional: true })
], DistributionPoint8.prototype, "distributionPoint", undefined);
__decorate([
  AsnProp8({ type: Reason8, context: 1, optional: true, implicit: true })
], DistributionPoint8.prototype, "reasons", undefined);
__decorate([
  AsnProp8({ type: GeneralName15, context: 2, optional: true, repeated: "sequence", implicit: true })
], DistributionPoint8.prototype, "cRLIssuer", undefined);
var CRLDistributionPoints15 = CRLDistributionPoints_18 = class CRLDistributionPoints16 extends AsnArray8 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CRLDistributionPoints_18.prototype);
  }
};
CRLDistributionPoints15 = CRLDistributionPoints_18 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Sequence, itemType: DistributionPoint8 })
], CRLDistributionPoints15);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_freshest.js
var FreshestCRL_18;
var id_ce_freshestCRL8 = `${id_ce8}.46`;
var FreshestCRL15 = FreshestCRL_18 = class FreshestCRL16 extends CRLDistributionPoints15 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, FreshestCRL_18.prototype);
  }
};
FreshestCRL15 = FreshestCRL_18 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Sequence, itemType: DistributionPoint8 })
], FreshestCRL15);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_issuing_distribution_point.js
var id_ce_issuingDistributionPoint8 = `${id_ce8}.28`;

class IssuingDistributionPoint8 {
  constructor(params = {}) {
    this.onlyContainsUserCerts = IssuingDistributionPoint8.ONLY;
    this.onlyContainsCACerts = IssuingDistributionPoint8.ONLY;
    this.indirectCRL = IssuingDistributionPoint8.ONLY;
    this.onlyContainsAttributeCerts = IssuingDistributionPoint8.ONLY;
    Object.assign(this, params);
  }
}
IssuingDistributionPoint8.ONLY = false;
__decorate([
  AsnProp8({ type: DistributionPointName15, context: 0, optional: true })
], IssuingDistributionPoint8.prototype, "distributionPoint", undefined);
__decorate([
  AsnProp8({
    type: AsnPropTypes8.Boolean,
    context: 1,
    defaultValue: IssuingDistributionPoint8.ONLY,
    implicit: true
  })
], IssuingDistributionPoint8.prototype, "onlyContainsUserCerts", undefined);
__decorate([
  AsnProp8({
    type: AsnPropTypes8.Boolean,
    context: 2,
    defaultValue: IssuingDistributionPoint8.ONLY,
    implicit: true
  })
], IssuingDistributionPoint8.prototype, "onlyContainsCACerts", undefined);
__decorate([
  AsnProp8({ type: Reason8, context: 3, optional: true, implicit: true })
], IssuingDistributionPoint8.prototype, "onlySomeReasons", undefined);
__decorate([
  AsnProp8({
    type: AsnPropTypes8.Boolean,
    context: 4,
    defaultValue: IssuingDistributionPoint8.ONLY,
    implicit: true
  })
], IssuingDistributionPoint8.prototype, "indirectCRL", undefined);
__decorate([
  AsnProp8({
    type: AsnPropTypes8.Boolean,
    context: 5,
    defaultValue: IssuingDistributionPoint8.ONLY,
    implicit: true
  })
], IssuingDistributionPoint8.prototype, "onlyContainsAttributeCerts", undefined);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_reason.js
var id_ce_cRLReasons8 = `${id_ce8}.21`;
var CRLReasons8;
(function(CRLReasons9) {
  CRLReasons9[CRLReasons9["unspecified"] = 0] = "unspecified";
  CRLReasons9[CRLReasons9["keyCompromise"] = 1] = "keyCompromise";
  CRLReasons9[CRLReasons9["cACompromise"] = 2] = "cACompromise";
  CRLReasons9[CRLReasons9["affiliationChanged"] = 3] = "affiliationChanged";
  CRLReasons9[CRLReasons9["superseded"] = 4] = "superseded";
  CRLReasons9[CRLReasons9["cessationOfOperation"] = 5] = "cessationOfOperation";
  CRLReasons9[CRLReasons9["certificateHold"] = 6] = "certificateHold";
  CRLReasons9[CRLReasons9["removeFromCRL"] = 8] = "removeFromCRL";
  CRLReasons9[CRLReasons9["privilegeWithdrawn"] = 9] = "privilegeWithdrawn";
  CRLReasons9[CRLReasons9["aACompromise"] = 10] = "aACompromise";
})(CRLReasons8 || (CRLReasons8 = {}));
var CRLReason15 = class CRLReason16 {
  constructor(reason = CRLReasons8.unspecified) {
    this.reason = CRLReasons8.unspecified;
    this.reason = reason;
  }
  toJSON() {
    return CRLReasons8[this.reason];
  }
  toString() {
    return this.toJSON();
  }
};
__decorate([
  AsnProp8({ type: AsnPropTypes8.Enumerated })
], CRLReason15.prototype, "reason", undefined);
CRLReason15 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Choice })
], CRLReason15);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/extended_key_usage.js
var ExtendedKeyUsage_18;
var id_ce_extKeyUsage8 = `${id_ce8}.37`;
var ExtendedKeyUsage15 = ExtendedKeyUsage_18 = class ExtendedKeyUsage16 extends AsnArray8 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, ExtendedKeyUsage_18.prototype);
  }
};
ExtendedKeyUsage15 = ExtendedKeyUsage_18 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Sequence, itemType: AsnPropTypes8.ObjectIdentifier })
], ExtendedKeyUsage15);
var anyExtendedKeyUsage8 = `${id_ce_extKeyUsage8}.0`;
var id_kp_serverAuth8 = `${id_kp8}.1`;
var id_kp_clientAuth8 = `${id_kp8}.2`;
var id_kp_codeSigning8 = `${id_kp8}.3`;
var id_kp_emailProtection8 = `${id_kp8}.4`;
var id_kp_timeStamping8 = `${id_kp8}.8`;
var id_kp_OCSPSigning8 = `${id_kp8}.9`;
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/inhibit_any_policy.js
var id_ce_inhibitAnyPolicy8 = `${id_ce8}.54`;
var InhibitAnyPolicy15 = class InhibitAnyPolicy16 {
  constructor(value = new ArrayBuffer(0)) {
    this.value = value;
  }
};
__decorate([
  AsnProp8({ type: AsnPropTypes8.Integer, converter: AsnIntegerArrayBufferConverter8 })
], InhibitAnyPolicy15.prototype, "value", undefined);
InhibitAnyPolicy15 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Choice })
], InhibitAnyPolicy15);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/invalidity_date.js
var id_ce_invalidityDate8 = `${id_ce8}.24`;
var InvalidityDate15 = class InvalidityDate16 {
  constructor(value) {
    this.value = new Date;
    if (value) {
      this.value = value;
    }
  }
};
__decorate([
  AsnProp8({ type: AsnPropTypes8.GeneralizedTime })
], InvalidityDate15.prototype, "value", undefined);
InvalidityDate15 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Choice })
], InvalidityDate15);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/issuer_alternative_name.js
var IssueAlternativeName_18;
var id_ce_issuerAltName8 = `${id_ce8}.18`;
var IssueAlternativeName15 = IssueAlternativeName_18 = class IssueAlternativeName16 extends GeneralNames15 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, IssueAlternativeName_18.prototype);
  }
};
IssueAlternativeName15 = IssueAlternativeName_18 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Sequence })
], IssueAlternativeName15);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/key_usage.js
var id_ce_keyUsage8 = `${id_ce8}.15`;
var KeyUsageFlags8;
(function(KeyUsageFlags9) {
  KeyUsageFlags9[KeyUsageFlags9["digitalSignature"] = 1] = "digitalSignature";
  KeyUsageFlags9[KeyUsageFlags9["nonRepudiation"] = 2] = "nonRepudiation";
  KeyUsageFlags9[KeyUsageFlags9["keyEncipherment"] = 4] = "keyEncipherment";
  KeyUsageFlags9[KeyUsageFlags9["dataEncipherment"] = 8] = "dataEncipherment";
  KeyUsageFlags9[KeyUsageFlags9["keyAgreement"] = 16] = "keyAgreement";
  KeyUsageFlags9[KeyUsageFlags9["keyCertSign"] = 32] = "keyCertSign";
  KeyUsageFlags9[KeyUsageFlags9["cRLSign"] = 64] = "cRLSign";
  KeyUsageFlags9[KeyUsageFlags9["encipherOnly"] = 128] = "encipherOnly";
  KeyUsageFlags9[KeyUsageFlags9["decipherOnly"] = 256] = "decipherOnly";
})(KeyUsageFlags8 || (KeyUsageFlags8 = {}));
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/name_constraints.js
var GeneralSubtrees_18;
var id_ce_nameConstraints8 = `${id_ce8}.30`;

class GeneralSubtree8 {
  constructor(params = {}) {
    this.base = new GeneralName15;
    this.minimum = 0;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: GeneralName15 })
], GeneralSubtree8.prototype, "base", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.Integer, context: 0, defaultValue: 0, implicit: true })
], GeneralSubtree8.prototype, "minimum", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.Integer, context: 1, optional: true, implicit: true })
], GeneralSubtree8.prototype, "maximum", undefined);
var GeneralSubtrees15 = GeneralSubtrees_18 = class GeneralSubtrees16 extends AsnArray8 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralSubtrees_18.prototype);
  }
};
GeneralSubtrees15 = GeneralSubtrees_18 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Sequence, itemType: GeneralSubtree8 })
], GeneralSubtrees15);
class NameConstraints8 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: GeneralSubtrees15, context: 0, optional: true, implicit: true })
], NameConstraints8.prototype, "permittedSubtrees", undefined);
__decorate([
  AsnProp8({ type: GeneralSubtrees15, context: 1, optional: true, implicit: true })
], NameConstraints8.prototype, "excludedSubtrees", undefined);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_constraints.js
var id_ce_policyConstraints8 = `${id_ce8}.36`;

class PolicyConstraints8 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({
    type: AsnPropTypes8.Integer,
    context: 0,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter8
  })
], PolicyConstraints8.prototype, "requireExplicitPolicy", undefined);
__decorate([
  AsnProp8({
    type: AsnPropTypes8.Integer,
    context: 1,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter8
  })
], PolicyConstraints8.prototype, "inhibitPolicyMapping", undefined);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_mappings.js
var PolicyMappings_18;
var id_ce_policyMappings8 = `${id_ce8}.33`;

class PolicyMapping8 {
  constructor(params = {}) {
    this.issuerDomainPolicy = "";
    this.subjectDomainPolicy = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: AsnPropTypes8.ObjectIdentifier })
], PolicyMapping8.prototype, "issuerDomainPolicy", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.ObjectIdentifier })
], PolicyMapping8.prototype, "subjectDomainPolicy", undefined);
var PolicyMappings15 = PolicyMappings_18 = class PolicyMappings16 extends AsnArray8 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, PolicyMappings_18.prototype);
  }
};
PolicyMappings15 = PolicyMappings_18 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Sequence, itemType: PolicyMapping8 })
], PolicyMappings15);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_alternative_name.js
var SubjectAlternativeName_18;
var id_ce_subjectAltName8 = `${id_ce8}.17`;
var SubjectAlternativeName15 = SubjectAlternativeName_18 = class SubjectAlternativeName16 extends GeneralNames15 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectAlternativeName_18.prototype);
  }
};
SubjectAlternativeName15 = SubjectAlternativeName_18 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Sequence })
], SubjectAlternativeName15);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/attribute.js
class Attribute9 {
  constructor(params = {}) {
    this.type = "";
    this.values = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: AsnPropTypes8.ObjectIdentifier })
], Attribute9.prototype, "type", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.Any, repeated: "set" })
], Attribute9.prototype, "values", undefined);

// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_directory_attributes.js
var SubjectDirectoryAttributes_18;
var id_ce_subjectDirectoryAttributes8 = `${id_ce8}.9`;
var SubjectDirectoryAttributes15 = SubjectDirectoryAttributes_18 = class SubjectDirectoryAttributes16 extends AsnArray8 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectDirectoryAttributes_18.prototype);
  }
};
SubjectDirectoryAttributes15 = SubjectDirectoryAttributes_18 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Sequence, itemType: Attribute9 })
], SubjectDirectoryAttributes15);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_key_identifier.js
var id_ce_subjectKeyIdentifier8 = `${id_ce8}.14`;
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/private_key_usage_period.js
var id_ce_privateKeyUsagePeriod8 = `${id_ce8}.16`;

class PrivateKeyUsagePeriod8 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: AsnPropTypes8.GeneralizedTime, context: 0, implicit: true, optional: true })
], PrivateKeyUsagePeriod8.prototype, "notBefore", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.GeneralizedTime, context: 1, implicit: true, optional: true })
], PrivateKeyUsagePeriod8.prototype, "notAfter", undefined);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/entrust_version_info.js
var EntrustInfoFlags8;
(function(EntrustInfoFlags9) {
  EntrustInfoFlags9[EntrustInfoFlags9["keyUpdateAllowed"] = 1] = "keyUpdateAllowed";
  EntrustInfoFlags9[EntrustInfoFlags9["newExtensions"] = 2] = "newExtensions";
  EntrustInfoFlags9[EntrustInfoFlags9["pKIXCertificate"] = 4] = "pKIXCertificate";
})(EntrustInfoFlags8 || (EntrustInfoFlags8 = {}));

class EntrustInfo8 extends BitString16 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & EntrustInfoFlags8.pKIXCertificate) {
      res.push("pKIXCertificate");
    }
    if (flags & EntrustInfoFlags8.newExtensions) {
      res.push("newExtensions");
    }
    if (flags & EntrustInfoFlags8.keyUpdateAllowed) {
      res.push("keyUpdateAllowed");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
}

class EntrustVersionInfo8 {
  constructor(params = {}) {
    this.entrustVers = "";
    this.entrustInfoFlags = new EntrustInfo8;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: AsnPropTypes8.GeneralString })
], EntrustVersionInfo8.prototype, "entrustVers", undefined);
__decorate([
  AsnProp8({ type: EntrustInfo8 })
], EntrustVersionInfo8.prototype, "entrustInfoFlags", undefined);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_info_access.js
var SubjectInfoAccessSyntax_18;
var id_pe_subjectInfoAccess8 = `${id_pe8}.11`;
var SubjectInfoAccessSyntax15 = SubjectInfoAccessSyntax_18 = class SubjectInfoAccessSyntax16 extends AsnArray8 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectInfoAccessSyntax_18.prototype);
  }
};
SubjectInfoAccessSyntax15 = SubjectInfoAccessSyntax_18 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Sequence, itemType: AccessDescription8 })
], SubjectInfoAccessSyntax15);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js
class AlgorithmIdentifier8 {
  constructor(params = {}) {
    this.algorithm = "";
    Object.assign(this, params);
  }
  isEqual(data) {
    return data instanceof AlgorithmIdentifier8 && data.algorithm == this.algorithm && (data.parameters && this.parameters && isEqual(data.parameters, this.parameters) || data.parameters === this.parameters);
  }
}
__decorate([
  AsnProp8({
    type: AsnPropTypes8.ObjectIdentifier
  })
], AlgorithmIdentifier8.prototype, "algorithm", undefined);
__decorate([
  AsnProp8({
    type: AsnPropTypes8.Any,
    optional: true
  })
], AlgorithmIdentifier8.prototype, "parameters", undefined);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/subject_public_key_info.js
class SubjectPublicKeyInfo8 {
  constructor(params = {}) {
    this.algorithm = new AlgorithmIdentifier8;
    this.subjectPublicKey = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: AlgorithmIdentifier8 })
], SubjectPublicKeyInfo8.prototype, "algorithm", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.BitString })
], SubjectPublicKeyInfo8.prototype, "subjectPublicKey", undefined);

// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/time.js
var Time15 = class Time16 {
  constructor(time9) {
    if (time9) {
      if (typeof time9 === "string" || typeof time9 === "number" || time9 instanceof Date) {
        const date = new Date(time9);
        if (date.getUTCFullYear() > 2049) {
          this.generalTime = date;
        } else {
          this.utcTime = date;
        }
      } else {
        Object.assign(this, time9);
      }
    }
  }
  getTime() {
    const time9 = this.utcTime || this.generalTime;
    if (!time9) {
      throw new Error("Cannot get time from CHOICE object");
    }
    return time9;
  }
};
__decorate([
  AsnProp8({
    type: AsnPropTypes8.UTCTime
  })
], Time15.prototype, "utcTime", undefined);
__decorate([
  AsnProp8({
    type: AsnPropTypes8.GeneralizedTime
  })
], Time15.prototype, "generalTime", undefined);
Time15 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Choice })
], Time15);

// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/validity.js
class Validity8 {
  constructor(params) {
    this.notBefore = new Time15(new Date);
    this.notAfter = new Time15(new Date);
    if (params) {
      this.notBefore = new Time15(params.notBefore);
      this.notAfter = new Time15(params.notAfter);
    }
  }
}
__decorate([
  AsnProp8({ type: Time15 })
], Validity8.prototype, "notBefore", undefined);
__decorate([
  AsnProp8({ type: Time15 })
], Validity8.prototype, "notAfter", undefined);

// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/extension.js
var Extensions_18;

class Extension8 {
  constructor(params = {}) {
    this.extnID = "";
    this.critical = Extension8.CRITICAL;
    this.extnValue = new OctetString16;
    Object.assign(this, params);
  }
}
Extension8.CRITICAL = false;
__decorate([
  AsnProp8({ type: AsnPropTypes8.ObjectIdentifier })
], Extension8.prototype, "extnID", undefined);
__decorate([
  AsnProp8({
    type: AsnPropTypes8.Boolean,
    defaultValue: Extension8.CRITICAL
  })
], Extension8.prototype, "critical", undefined);
__decorate([
  AsnProp8({ type: OctetString16 })
], Extension8.prototype, "extnValue", undefined);
var Extensions15 = Extensions_18 = class Extensions16 extends AsnArray8 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Extensions_18.prototype);
  }
};
Extensions15 = Extensions_18 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Sequence, itemType: Extension8 })
], Extensions15);

// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/types.js
var Version9;
(function(Version10) {
  Version10[Version10["v1"] = 0] = "v1";
  Version10[Version10["v2"] = 1] = "v2";
  Version10[Version10["v3"] = 2] = "v3";
})(Version9 || (Version9 = {}));

// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/tbs_certificate.js
class TBSCertificate8 {
  constructor(params = {}) {
    this.version = Version9.v1;
    this.serialNumber = new ArrayBuffer(0);
    this.signature = new AlgorithmIdentifier8;
    this.issuer = new Name15;
    this.validity = new Validity8;
    this.subject = new Name15;
    this.subjectPublicKeyInfo = new SubjectPublicKeyInfo8;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({
    type: AsnPropTypes8.Integer,
    context: 0,
    defaultValue: Version9.v1
  })
], TBSCertificate8.prototype, "version", undefined);
__decorate([
  AsnProp8({
    type: AsnPropTypes8.Integer,
    converter: AsnIntegerArrayBufferConverter8
  })
], TBSCertificate8.prototype, "serialNumber", undefined);
__decorate([
  AsnProp8({ type: AlgorithmIdentifier8 })
], TBSCertificate8.prototype, "signature", undefined);
__decorate([
  AsnProp8({ type: Name15 })
], TBSCertificate8.prototype, "issuer", undefined);
__decorate([
  AsnProp8({ type: Validity8 })
], TBSCertificate8.prototype, "validity", undefined);
__decorate([
  AsnProp8({ type: Name15 })
], TBSCertificate8.prototype, "subject", undefined);
__decorate([
  AsnProp8({ type: SubjectPublicKeyInfo8 })
], TBSCertificate8.prototype, "subjectPublicKeyInfo", undefined);
__decorate([
  AsnProp8({
    type: AsnPropTypes8.BitString,
    context: 1,
    implicit: true,
    optional: true
  })
], TBSCertificate8.prototype, "issuerUniqueID", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.BitString, context: 2, implicit: true, optional: true })
], TBSCertificate8.prototype, "subjectUniqueID", undefined);
__decorate([
  AsnProp8({ type: Extensions15, context: 3, optional: true })
], TBSCertificate8.prototype, "extensions", undefined);

// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/certificate.js
class Certificate8 {
  constructor(params = {}) {
    this.tbsCertificate = new TBSCertificate8;
    this.signatureAlgorithm = new AlgorithmIdentifier8;
    this.signatureValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: TBSCertificate8, raw: true })
], Certificate8.prototype, "tbsCertificate", undefined);
__decorate([
  AsnProp8({ type: AlgorithmIdentifier8 })
], Certificate8.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.BitString })
], Certificate8.prototype, "signatureValue", undefined);
// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/tbs_cert_list.js
class RevokedCertificate8 {
  constructor(params = {}) {
    this.userCertificate = new ArrayBuffer(0);
    this.revocationDate = new Time15;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: AsnPropTypes8.Integer, converter: AsnIntegerArrayBufferConverter8 })
], RevokedCertificate8.prototype, "userCertificate", undefined);
__decorate([
  AsnProp8({ type: Time15 })
], RevokedCertificate8.prototype, "revocationDate", undefined);
__decorate([
  AsnProp8({ type: Extension8, optional: true, repeated: "sequence" })
], RevokedCertificate8.prototype, "crlEntryExtensions", undefined);

class TBSCertList8 {
  constructor(params = {}) {
    this.signature = new AlgorithmIdentifier8;
    this.issuer = new Name15;
    this.thisUpdate = new Time15;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: AsnPropTypes8.Integer, optional: true })
], TBSCertList8.prototype, "version", undefined);
__decorate([
  AsnProp8({ type: AlgorithmIdentifier8 })
], TBSCertList8.prototype, "signature", undefined);
__decorate([
  AsnProp8({ type: Name15 })
], TBSCertList8.prototype, "issuer", undefined);
__decorate([
  AsnProp8({ type: Time15 })
], TBSCertList8.prototype, "thisUpdate", undefined);
__decorate([
  AsnProp8({ type: Time15, optional: true })
], TBSCertList8.prototype, "nextUpdate", undefined);
__decorate([
  AsnProp8({ type: RevokedCertificate8, repeated: "sequence", optional: true })
], TBSCertList8.prototype, "revokedCertificates", undefined);
__decorate([
  AsnProp8({ type: Extension8, optional: true, context: 0, repeated: "sequence" })
], TBSCertList8.prototype, "crlExtensions", undefined);

// node_modules/@peculiar/asn1-csr/node_modules/@peculiar/asn1-x509/build/es2015/certificate_list.js
class CertificateList8 {
  constructor(params = {}) {
    this.tbsCertList = new TBSCertList8;
    this.signatureAlgorithm = new AlgorithmIdentifier8;
    this.signature = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: TBSCertList8, raw: true })
], CertificateList8.prototype, "tbsCertList", undefined);
__decorate([
  AsnProp8({ type: AlgorithmIdentifier8 })
], CertificateList8.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.BitString })
], CertificateList8.prototype, "signature", undefined);
// node_modules/@peculiar/asn1-csr/build/es2015/attributes.js
var Attributes_12;
var Attributes3 = Attributes_12 = class Attributes4 extends AsnArray8 {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Attributes_12.prototype);
  }
};
Attributes3 = Attributes_12 = __decorate([
  AsnType8({ type: AsnTypeTypes8.Sequence, itemType: Attribute9 })
], Attributes3);
// node_modules/@peculiar/asn1-csr/build/es2015/certification_request_info.js
class CertificationRequestInfo {
  constructor(params = {}) {
    this.version = 0;
    this.subject = new Name15;
    this.subjectPKInfo = new SubjectPublicKeyInfo8;
    this.attributes = new Attributes3;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: AsnPropTypes8.Integer })
], CertificationRequestInfo.prototype, "version", undefined);
__decorate([
  AsnProp8({ type: Name15 })
], CertificationRequestInfo.prototype, "subject", undefined);
__decorate([
  AsnProp8({ type: SubjectPublicKeyInfo8 })
], CertificationRequestInfo.prototype, "subjectPKInfo", undefined);
__decorate([
  AsnProp8({ type: Attributes3, implicit: true, context: 0 })
], CertificationRequestInfo.prototype, "attributes", undefined);

// node_modules/@peculiar/asn1-csr/build/es2015/certification_request.js
class CertificationRequest {
  constructor(params = {}) {
    this.certificationRequestInfo = new CertificationRequestInfo;
    this.signatureAlgorithm = new AlgorithmIdentifier8;
    this.signature = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp8({ type: CertificationRequestInfo, raw: true })
], CertificationRequest.prototype, "certificationRequestInfo", undefined);
__decorate([
  AsnProp8({ type: AlgorithmIdentifier8 })
], CertificationRequest.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp8({ type: AsnPropTypes8.BitString })
], CertificationRequest.prototype, "signature", undefined);
// node_modules/@peculiar/x509/build/x509.es.js
/*!
 * MIT License
 * 
 * Copyright (c) Peculiar Ventures. All rights reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */
var diAlgorithm = "crypto.algorithm";

class AlgorithmProvider {
  getAlgorithms() {
    return instance.resolveAll(diAlgorithm);
  }
  toAsnAlgorithm(alg) {
    ({ ...alg });
    for (const algorithm2 of this.getAlgorithms()) {
      const res = algorithm2.toAsnAlgorithm(alg);
      if (res) {
        return res;
      }
    }
    if (/^[0-9.]+$/.test(alg.name)) {
      const res = new AlgorithmIdentifier2({
        algorithm: alg.name
      });
      if ("parameters" in alg) {
        const unknown = alg;
        res.parameters = unknown.parameters;
      }
      return res;
    }
    throw new Error("Cannot convert WebCrypto algorithm to ASN.1 algorithm");
  }
  toWebAlgorithm(alg) {
    for (const algorithm2 of this.getAlgorithms()) {
      const res = algorithm2.toWebAlgorithm(alg);
      if (res) {
        return res;
      }
    }
    const unknown = {
      name: alg.algorithm,
      parameters: alg.parameters
    };
    return unknown;
  }
}
var diAlgorithmProvider = "crypto.algorithmProvider";
instance.registerSingleton(diAlgorithmProvider, AlgorithmProvider);
var EcAlgorithm_1;
var idVersionOne = "1.3.36.3.3.2.8.1.1";
var idBrainpoolP160r1 = `${idVersionOne}.1`;
var idBrainpoolP160t1 = `${idVersionOne}.2`;
var idBrainpoolP192r1 = `${idVersionOne}.3`;
var idBrainpoolP192t1 = `${idVersionOne}.4`;
var idBrainpoolP224r1 = `${idVersionOne}.5`;
var idBrainpoolP224t1 = `${idVersionOne}.6`;
var idBrainpoolP256r1 = `${idVersionOne}.7`;
var idBrainpoolP256t1 = `${idVersionOne}.8`;
var idBrainpoolP320r1 = `${idVersionOne}.9`;
var idBrainpoolP320t1 = `${idVersionOne}.10`;
var idBrainpoolP384r1 = `${idVersionOne}.11`;
var idBrainpoolP384t1 = `${idVersionOne}.12`;
var idBrainpoolP512r1 = `${idVersionOne}.13`;
var idBrainpoolP512t1 = `${idVersionOne}.14`;
var brainpoolP160r1 = "brainpoolP160r1";
var brainpoolP160t1 = "brainpoolP160t1";
var brainpoolP192r1 = "brainpoolP192r1";
var brainpoolP192t1 = "brainpoolP192t1";
var brainpoolP224r1 = "brainpoolP224r1";
var brainpoolP224t1 = "brainpoolP224t1";
var brainpoolP256r1 = "brainpoolP256r1";
var brainpoolP256t1 = "brainpoolP256t1";
var brainpoolP320r1 = "brainpoolP320r1";
var brainpoolP320t1 = "brainpoolP320t1";
var brainpoolP384r1 = "brainpoolP384r1";
var brainpoolP384t1 = "brainpoolP384t1";
var brainpoolP512r1 = "brainpoolP512r1";
var brainpoolP512t1 = "brainpoolP512t1";
var ECDSA = "ECDSA";
var EcAlgorithm = EcAlgorithm_1 = class EcAlgorithm2 {
  toAsnAlgorithm(alg) {
    switch (alg.name.toLowerCase()) {
      case ECDSA.toLowerCase():
        if ("hash" in alg) {
          const hash = typeof alg.hash === "string" ? alg.hash : alg.hash.name;
          switch (hash.toLowerCase()) {
            case "sha-1":
              return ecdsaWithSHA1;
            case "sha-256":
              return ecdsaWithSHA256;
            case "sha-384":
              return ecdsaWithSHA384;
            case "sha-512":
              return ecdsaWithSHA512;
          }
        } else if ("namedCurve" in alg) {
          let parameters3 = "";
          switch (alg.namedCurve) {
            case "P-256":
              parameters3 = id_secp256r1;
              break;
            case "K-256":
              parameters3 = EcAlgorithm_1.SECP256K1;
              break;
            case "P-384":
              parameters3 = id_secp384r1;
              break;
            case "P-521":
              parameters3 = id_secp521r1;
              break;
            case brainpoolP160r1:
              parameters3 = idBrainpoolP160r1;
              break;
            case brainpoolP160t1:
              parameters3 = idBrainpoolP160t1;
              break;
            case brainpoolP192r1:
              parameters3 = idBrainpoolP192r1;
              break;
            case brainpoolP192t1:
              parameters3 = idBrainpoolP192t1;
              break;
            case brainpoolP224r1:
              parameters3 = idBrainpoolP224r1;
              break;
            case brainpoolP224t1:
              parameters3 = idBrainpoolP224t1;
              break;
            case brainpoolP256r1:
              parameters3 = idBrainpoolP256r1;
              break;
            case brainpoolP256t1:
              parameters3 = idBrainpoolP256t1;
              break;
            case brainpoolP320r1:
              parameters3 = idBrainpoolP320r1;
              break;
            case brainpoolP320t1:
              parameters3 = idBrainpoolP320t1;
              break;
            case brainpoolP384r1:
              parameters3 = idBrainpoolP384r1;
              break;
            case brainpoolP384t1:
              parameters3 = idBrainpoolP384t1;
              break;
            case brainpoolP512r1:
              parameters3 = idBrainpoolP512r1;
              break;
            case brainpoolP512t1:
              parameters3 = idBrainpoolP512t1;
              break;
          }
          if (parameters3) {
            return new AlgorithmIdentifier2({
              algorithm: id_ecPublicKey,
              parameters: AsnConvert2.serialize(new ECParameters({ namedCurve: parameters3 }))
            });
          }
        }
    }
    return null;
  }
  toWebAlgorithm(alg) {
    switch (alg.algorithm) {
      case id_ecdsaWithSHA1:
        return { name: ECDSA, hash: { name: "SHA-1" } };
      case id_ecdsaWithSHA256:
        return { name: ECDSA, hash: { name: "SHA-256" } };
      case id_ecdsaWithSHA384:
        return { name: ECDSA, hash: { name: "SHA-384" } };
      case id_ecdsaWithSHA512:
        return { name: ECDSA, hash: { name: "SHA-512" } };
      case id_ecPublicKey: {
        if (!alg.parameters) {
          throw new TypeError("Cannot get required parameters from EC algorithm");
        }
        const parameters3 = AsnConvert2.parse(alg.parameters, ECParameters);
        switch (parameters3.namedCurve) {
          case id_secp256r1:
            return { name: ECDSA, namedCurve: "P-256" };
          case EcAlgorithm_1.SECP256K1:
            return { name: ECDSA, namedCurve: "K-256" };
          case id_secp384r1:
            return { name: ECDSA, namedCurve: "P-384" };
          case id_secp521r1:
            return { name: ECDSA, namedCurve: "P-521" };
          case idBrainpoolP160r1:
            return { name: ECDSA, namedCurve: brainpoolP160r1 };
          case idBrainpoolP160t1:
            return { name: ECDSA, namedCurve: brainpoolP160t1 };
          case idBrainpoolP192r1:
            return { name: ECDSA, namedCurve: brainpoolP192r1 };
          case idBrainpoolP192t1:
            return { name: ECDSA, namedCurve: brainpoolP192t1 };
          case idBrainpoolP224r1:
            return { name: ECDSA, namedCurve: brainpoolP224r1 };
          case idBrainpoolP224t1:
            return { name: ECDSA, namedCurve: brainpoolP224t1 };
          case idBrainpoolP256r1:
            return { name: ECDSA, namedCurve: brainpoolP256r1 };
          case idBrainpoolP256t1:
            return { name: ECDSA, namedCurve: brainpoolP256t1 };
          case idBrainpoolP320r1:
            return { name: ECDSA, namedCurve: brainpoolP320r1 };
          case idBrainpoolP320t1:
            return { name: ECDSA, namedCurve: brainpoolP320t1 };
          case idBrainpoolP384r1:
            return { name: ECDSA, namedCurve: brainpoolP384r1 };
          case idBrainpoolP384t1:
            return { name: ECDSA, namedCurve: brainpoolP384t1 };
          case idBrainpoolP512r1:
            return { name: ECDSA, namedCurve: brainpoolP512r1 };
          case idBrainpoolP512t1:
            return { name: ECDSA, namedCurve: brainpoolP512t1 };
        }
      }
    }
    return null;
  }
};
EcAlgorithm.SECP256K1 = "1.3.132.0.10";
EcAlgorithm = EcAlgorithm_1 = __decorate([
  injectable_default()
], EcAlgorithm);
instance.registerSingleton(diAlgorithm, EcAlgorithm);
var NAME9 = Symbol("name");
var VALUE = Symbol("value");

class TextObject {
  constructor(name9, items = {}, value = "") {
    this[NAME9] = name9;
    this[VALUE] = value;
    for (const key in items) {
      this[key] = items[key];
    }
  }
}
TextObject.NAME = NAME9;
TextObject.VALUE = VALUE;

class DefaultAlgorithmSerializer {
  static toTextObject(alg) {
    const obj = new TextObject("Algorithm Identifier", {}, OidSerializer.toString(alg.algorithm));
    if (alg.parameters) {
      switch (alg.algorithm) {
        case id_ecPublicKey: {
          const ecAlg = new EcAlgorithm().toWebAlgorithm(alg);
          if (ecAlg && "namedCurve" in ecAlg) {
            obj["Named Curve"] = ecAlg.namedCurve;
          } else {
            obj["Parameters"] = alg.parameters;
          }
          break;
        }
        default:
          obj["Parameters"] = alg.parameters;
      }
    }
    return obj;
  }
}

class OidSerializer {
  static toString(oid) {
    const name9 = this.items[oid];
    if (name9) {
      return name9;
    }
    return oid;
  }
}
OidSerializer.items = {
  [id_sha1]: "sha1",
  [id_sha224]: "sha224",
  [id_sha256]: "sha256",
  [id_sha384]: "sha384",
  [id_sha512]: "sha512",
  [id_rsaEncryption]: "rsaEncryption",
  [id_sha1WithRSAEncryption]: "sha1WithRSAEncryption",
  [id_sha224WithRSAEncryption]: "sha224WithRSAEncryption",
  [id_sha256WithRSAEncryption]: "sha256WithRSAEncryption",
  [id_sha384WithRSAEncryption]: "sha384WithRSAEncryption",
  [id_sha512WithRSAEncryption]: "sha512WithRSAEncryption",
  [id_ecPublicKey]: "ecPublicKey",
  [id_ecdsaWithSHA1]: "ecdsaWithSHA1",
  [id_ecdsaWithSHA224]: "ecdsaWithSHA224",
  [id_ecdsaWithSHA256]: "ecdsaWithSHA256",
  [id_ecdsaWithSHA384]: "ecdsaWithSHA384",
  [id_ecdsaWithSHA512]: "ecdsaWithSHA512",
  [id_kp_serverAuth2]: "TLS WWW server authentication",
  [id_kp_clientAuth2]: "TLS WWW client authentication",
  [id_kp_codeSigning2]: "Code Signing",
  [id_kp_emailProtection2]: "E-mail Protection",
  [id_kp_timeStamping2]: "Time Stamping",
  [id_kp_OCSPSigning2]: "OCSP Signing",
  [id_signedData]: "Signed Data"
};

class TextConverter {
  static serialize(obj) {
    return this.serializeObj(obj).join(`
`);
  }
  static pad(deep = 0) {
    return "".padStart(2 * deep, " ");
  }
  static serializeObj(obj, deep = 0) {
    const res = [];
    let pad = this.pad(deep++);
    let value = "";
    const objValue = obj[TextObject.VALUE];
    if (objValue) {
      value = ` ${objValue}`;
    }
    res.push(`${pad}${obj[TextObject.NAME]}:${value}`);
    pad = this.pad(deep);
    for (const key in obj) {
      if (typeof key === "symbol") {
        continue;
      }
      const value2 = obj[key];
      const keyValue = key ? `${key}: ` : "";
      if (typeof value2 === "string" || typeof value2 === "number" || typeof value2 === "boolean") {
        res.push(`${pad}${keyValue}${value2}`);
      } else if (value2 instanceof Date) {
        res.push(`${pad}${keyValue}${value2.toUTCString()}`);
      } else if (Array.isArray(value2)) {
        for (const obj2 of value2) {
          obj2[TextObject.NAME] = key;
          res.push(...this.serializeObj(obj2, deep));
        }
      } else if (value2 instanceof TextObject) {
        value2[TextObject.NAME] = key;
        res.push(...this.serializeObj(value2, deep));
      } else if (BufferSourceConverter.isBufferSource(value2)) {
        if (key) {
          res.push(`${pad}${keyValue}`);
          res.push(...this.serializeBufferSource(value2, deep + 1));
        } else {
          res.push(...this.serializeBufferSource(value2, deep));
        }
      } else if ("toTextObject" in value2) {
        const obj2 = value2.toTextObject();
        obj2[TextObject.NAME] = key;
        res.push(...this.serializeObj(obj2, deep));
      } else {
        throw new TypeError("Cannot serialize data in text format. Unsupported type.");
      }
    }
    return res;
  }
  static serializeBufferSource(buffer, deep = 0) {
    const pad = this.pad(deep);
    const view = BufferSourceConverter.toUint8Array(buffer);
    const res = [];
    for (let i = 0;i < view.length; ) {
      const row = [];
      for (let j = 0;j < 16 && i < view.length; j++) {
        if (j === 8) {
          row.push("");
        }
        const hex = view[i++].toString(16).padStart(2, "0");
        row.push(hex);
      }
      res.push(`${pad}${row.join(" ")}`);
    }
    return res;
  }
  static serializeAlgorithm(alg) {
    return this.algorithmSerializer.toTextObject(alg);
  }
}
TextConverter.oidSerializer = OidSerializer;
TextConverter.algorithmSerializer = DefaultAlgorithmSerializer;
var _AsnData_rawData;

class AsnData {
  get rawData() {
    if (!__classPrivateFieldGet(this, _AsnData_rawData, "f")) {
      __classPrivateFieldSet(this, _AsnData_rawData, AsnConvert2.serialize(this.asn), "f");
    }
    return __classPrivateFieldGet(this, _AsnData_rawData, "f");
  }
  constructor(...args) {
    _AsnData_rawData.set(this, undefined);
    if (BufferSourceConverter.isBufferSource(args[0])) {
      this.asn = AsnConvert2.parse(args[0], args[1]);
      __classPrivateFieldSet(this, _AsnData_rawData, BufferSourceConverter.toArrayBuffer(args[0]), "f");
      this.onInit(this.asn);
    } else {
      this.asn = args[0];
      this.onInit(this.asn);
    }
  }
  equal(data) {
    if (data instanceof AsnData) {
      return isEqual(data.rawData, this.rawData);
    }
    return false;
  }
  toString(format = "text") {
    switch (format) {
      case "asn":
        return AsnConvert2.toString(this.rawData);
      case "text":
        return TextConverter.serialize(this.toTextObject());
      case "hex":
        return Convert.ToHex(this.rawData);
      case "base64":
        return Convert.ToBase64(this.rawData);
      case "base64url":
        return Convert.ToBase64Url(this.rawData);
      default:
        throw TypeError("Argument 'format' is unsupported value");
    }
  }
  getTextName() {
    const constructor = this.constructor;
    return constructor.NAME;
  }
  toTextObject() {
    const obj = this.toTextObjectEmpty();
    obj[""] = this.rawData;
    return obj;
  }
  toTextObjectEmpty(value) {
    return new TextObject(this.getTextName(), {}, value);
  }
}
_AsnData_rawData = new WeakMap;
AsnData.NAME = "ASN";

class Extension9 extends AsnData {
  constructor(...args) {
    let raw2;
    if (BufferSourceConverter.isBufferSource(args[0])) {
      raw2 = BufferSourceConverter.toArrayBuffer(args[0]);
    } else {
      raw2 = AsnConvert2.serialize(new Extension2({
        extnID: args[0],
        critical: args[1],
        extnValue: new OctetString4(BufferSourceConverter.toArrayBuffer(args[2]))
      }));
    }
    super(raw2, Extension2);
  }
  onInit(asn) {
    this.type = asn.extnID;
    this.critical = asn.critical;
    this.value = asn.extnValue.buffer;
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    obj[""] = this.value;
    return obj;
  }
  toTextObjectWithoutValue() {
    const obj = this.toTextObjectEmpty(this.critical ? "critical" : undefined);
    if (obj[TextObject.NAME] === Extension9.NAME) {
      obj[TextObject.NAME] = OidSerializer.toString(this.type);
    }
    return obj;
  }
}
var _a9;

class CryptoProvider {
  static isCryptoKeyPair(data) {
    return data && data.privateKey && data.publicKey;
  }
  static isCryptoKey(data) {
    return data && data.usages && data.type && data.algorithm && data.extractable !== undefined;
  }
  constructor() {
    this.items = new Map;
    this[_a9] = "CryptoProvider";
    if (typeof self !== "undefined" && typeof crypto !== "undefined") {
      this.set(CryptoProvider.DEFAULT, crypto);
    } else if (typeof global !== "undefined" && global.crypto && global.crypto.subtle) {
      this.set(CryptoProvider.DEFAULT, global.crypto);
    }
  }
  clear() {
    this.items.clear();
  }
  delete(key) {
    return this.items.delete(key);
  }
  forEach(callbackfn, thisArg) {
    return this.items.forEach(callbackfn, thisArg);
  }
  has(key) {
    return this.items.has(key);
  }
  get size() {
    return this.items.size;
  }
  entries() {
    return this.items.entries();
  }
  keys() {
    return this.items.keys();
  }
  values() {
    return this.items.values();
  }
  [Symbol.iterator]() {
    return this.items[Symbol.iterator]();
  }
  get(key = CryptoProvider.DEFAULT) {
    const crypto3 = this.items.get(key.toLowerCase());
    if (!crypto3) {
      throw new Error(`Cannot get Crypto by name '${key}'`);
    }
    return crypto3;
  }
  set(key, value) {
    if (typeof key === "string") {
      if (!value) {
        throw new TypeError("Argument 'value' is required");
      }
      this.items.set(key.toLowerCase(), value);
    } else {
      this.items.set(CryptoProvider.DEFAULT, key);
    }
    return this;
  }
}
_a9 = Symbol.toStringTag;
CryptoProvider.DEFAULT = "default";
var cryptoProvider = new CryptoProvider;
var OID_REGEX = /^[0-2](?:\.[1-9][0-9]*)+$/;
function isOID(id) {
  return new RegExp(OID_REGEX).test(id);
}

class NameIdentifier {
  constructor(names = {}) {
    this.items = {};
    for (const id in names) {
      this.register(id, names[id]);
    }
  }
  get(idOrName) {
    return this.items[idOrName] || null;
  }
  findId(idOrName) {
    if (!isOID(idOrName)) {
      return this.get(idOrName);
    }
    return idOrName;
  }
  register(id, name9) {
    this.items[id] = name9;
    this.items[name9] = id;
  }
}
var names = new NameIdentifier;
names.register("CN", "2.5.4.3");
names.register("L", "2.5.4.7");
names.register("ST", "2.5.4.8");
names.register("O", "2.5.4.10");
names.register("OU", "2.5.4.11");
names.register("C", "2.5.4.6");
names.register("DC", "0.9.2342.19200300.100.1.25");
names.register("E", "1.2.840.113549.1.9.1");
names.register("G", "2.5.4.42");
names.register("I", "2.5.4.43");
names.register("SN", "2.5.4.4");
names.register("T", "2.5.4.12");
function replaceUnknownCharacter(text, char) {
  return `\\${Convert.ToHex(Convert.FromUtf8String(char)).toUpperCase()}`;
}
function escape2(data) {
  return data.replace(/([,+"\\<>;])/g, "\\$1").replace(/^([ #])/, "\\$1").replace(/([ ]$)/, "\\$1").replace(/([\r\n\t])/, replaceUnknownCharacter);
}

class Name17 {
  static isASCII(text) {
    for (let i = 0;i < text.length; i++) {
      const code = text.charCodeAt(i);
      if (code > 255) {
        return false;
      }
    }
    return true;
  }
  static isPrintableString(text) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/g.test(text);
  }
  constructor(data, extraNames = {}) {
    this.extraNames = new NameIdentifier;
    this.asn = new Name3;
    for (const key in extraNames) {
      if (Object.prototype.hasOwnProperty.call(extraNames, key)) {
        const value = extraNames[key];
        this.extraNames.register(key, value);
      }
    }
    if (typeof data === "string") {
      this.asn = this.fromString(data);
    } else if (data instanceof Name3) {
      this.asn = data;
    } else if (BufferSourceConverter.isBufferSource(data)) {
      this.asn = AsnConvert2.parse(data, Name3);
    } else {
      this.asn = this.fromJSON(data);
    }
  }
  getField(idOrName) {
    const id = this.extraNames.findId(idOrName) || names.findId(idOrName);
    const res = [];
    for (const name9 of this.asn) {
      for (const rdn of name9) {
        if (rdn.type === id) {
          res.push(rdn.value.toString());
        }
      }
    }
    return res;
  }
  getName(idOrName) {
    return this.extraNames.get(idOrName) || names.get(idOrName);
  }
  toString() {
    return this.asn.map((rdn) => rdn.map((o) => {
      const type = this.getName(o.type) || o.type;
      const value = o.value.anyValue ? `#${Convert.ToHex(o.value.anyValue)}` : escape2(o.value.toString());
      return `${type}=${value}`;
    }).join("+")).join(", ");
  }
  toJSON() {
    var _a10;
    const json = [];
    for (const rdn of this.asn) {
      const jsonItem = {};
      for (const attr of rdn) {
        const type = this.getName(attr.type) || attr.type;
        (_a10 = jsonItem[type]) !== null && _a10 !== undefined || (jsonItem[type] = []);
        jsonItem[type].push(attr.value.anyValue ? `#${Convert.ToHex(attr.value.anyValue)}` : attr.value.toString());
      }
      json.push(jsonItem);
    }
    return json;
  }
  fromString(data) {
    const asn = new Name3;
    const regex = /(\d\.[\d.]*\d|[A-Za-z]+)=((?:"")|(?:".*?[^\\]")|(?:[^,+"\\](?=[,+]|$))|(?:[^,+].*?(?:[^\\][,+]))|(?:))([,+])?/g;
    let matches = null;
    let level = ",";
    while (matches = regex.exec(`${data},`)) {
      let [, type, value] = matches;
      const lastChar = value[value.length - 1];
      if (lastChar === "," || lastChar === "+") {
        value = value.slice(0, value.length - 1);
        matches[3] = lastChar;
      }
      const next = matches[3];
      type = this.getTypeOid(type);
      const attr = this.createAttribute(type, value);
      if (level === "+") {
        asn[asn.length - 1].push(attr);
      } else {
        asn.push(new RelativeDistinguishedName3([attr]));
      }
      level = next;
    }
    return asn;
  }
  fromJSON(data) {
    const asn = new Name3;
    for (const item of data) {
      const asnRdn = new RelativeDistinguishedName3;
      for (const type in item) {
        const typeId = this.getTypeOid(type);
        const values = item[type];
        for (const value of values) {
          const asnAttr = this.createAttribute(typeId, value);
          asnRdn.push(asnAttr);
        }
      }
      asn.push(asnRdn);
    }
    return asn;
  }
  getTypeOid(type) {
    if (!/[\d.]+/.test(type)) {
      type = this.getName(type) || "";
    }
    if (!type) {
      throw new Error(`Cannot get OID for name type '${type}'`);
    }
    return type;
  }
  createAttribute(type, value) {
    const attr = new AttributeTypeAndValue2({ type });
    if (typeof value === "object") {
      for (const key in value) {
        switch (key) {
          case "ia5String":
            attr.value.ia5String = value[key];
            break;
          case "utf8String":
            attr.value.utf8String = value[key];
            break;
          case "universalString":
            attr.value.universalString = value[key];
            break;
          case "bmpString":
            attr.value.bmpString = value[key];
            break;
          case "printableString":
            attr.value.printableString = value[key];
            break;
        }
      }
    } else if (value[0] === "#") {
      attr.value.anyValue = Convert.FromHex(value.slice(1));
    } else {
      const processedValue = this.processStringValue(value);
      if (type === this.getName("E") || type === this.getName("DC")) {
        attr.value.ia5String = processedValue;
      } else {
        if (Name17.isPrintableString(processedValue)) {
          attr.value.printableString = processedValue;
        } else {
          attr.value.utf8String = processedValue;
        }
      }
    }
    return attr;
  }
  processStringValue(value) {
    const quotedMatches = /"(.*?[^\\])?"/.exec(value);
    if (quotedMatches) {
      value = quotedMatches[1];
    }
    return value.replace(/\\0a/ig, `
`).replace(/\\0d/ig, "\r").replace(/\\0g/ig, "\t").replace(/\\(.)/g, "$1");
  }
  toArrayBuffer() {
    return AsnConvert2.serialize(this.asn);
  }
  async getThumbprint(...args) {
    var _a10;
    let crypto3;
    let algorithm2 = "SHA-1";
    if (args.length >= 1 && !((_a10 = args[0]) === null || _a10 === undefined ? undefined : _a10.subtle)) {
      algorithm2 = args[0] || algorithm2;
      crypto3 = args[1] || cryptoProvider.get();
    } else {
      crypto3 = args[0] || cryptoProvider.get();
    }
    return await crypto3.subtle.digest(algorithm2, this.toArrayBuffer());
  }
}
var ERR_GN_CONSTRUCTOR = "Cannot initialize GeneralName from ASN.1 data.";
var ERR_GN_STRING_FORMAT = `${ERR_GN_CONSTRUCTOR} Unsupported string format in use.`;
var ERR_GUID = `${ERR_GN_CONSTRUCTOR} Value doesn't match to GUID regular expression.`;
var GUID_REGEX = /^([0-9a-f]{8})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{12})$/i;
var id_GUID = "1.3.6.1.4.1.311.25.1";
var id_UPN = "1.3.6.1.4.1.311.20.2.3";
var DNS = "dns";
var DN = "dn";
var EMAIL = "email";
var IP = "ip";
var URL2 = "url";
var GUID = "guid";
var UPN = "upn";
var REGISTERED_ID = "id";

class GeneralName17 extends AsnData {
  constructor(...args) {
    let name9;
    if (args.length === 2) {
      switch (args[0]) {
        case DN: {
          const derName = new Name17(args[1]).toArrayBuffer();
          const asnName = AsnConvert2.parse(derName, Name3);
          name9 = new GeneralName3({ directoryName: asnName });
          break;
        }
        case DNS:
          name9 = new GeneralName3({ dNSName: args[1] });
          break;
        case EMAIL:
          name9 = new GeneralName3({ rfc822Name: args[1] });
          break;
        case GUID: {
          const matches = new RegExp(GUID_REGEX, "i").exec(args[1]);
          if (!matches) {
            throw new Error("Cannot parse GUID value. Value doesn't match to regular expression");
          }
          const hex = matches.slice(1).map((o, i) => {
            if (i < 3) {
              return Convert.ToHex(new Uint8Array(Convert.FromHex(o)).reverse());
            }
            return o;
          }).join("");
          name9 = new GeneralName3({
            otherName: new OtherName2({
              typeId: id_GUID,
              value: AsnConvert2.serialize(new OctetString4(Convert.FromHex(hex)))
            })
          });
          break;
        }
        case IP:
          name9 = new GeneralName3({ iPAddress: args[1] });
          break;
        case REGISTERED_ID:
          name9 = new GeneralName3({ registeredID: args[1] });
          break;
        case UPN: {
          name9 = new GeneralName3({
            otherName: new OtherName2({
              typeId: id_UPN,
              value: AsnConvert2.serialize(AsnUtf8StringConverter2.toASN(args[1]))
            })
          });
          break;
        }
        case URL2:
          name9 = new GeneralName3({ uniformResourceIdentifier: args[1] });
          break;
        default:
          throw new Error("Cannot create GeneralName. Unsupported type of the name");
      }
    } else if (BufferSourceConverter.isBufferSource(args[0])) {
      name9 = AsnConvert2.parse(args[0], GeneralName3);
    } else {
      name9 = args[0];
    }
    super(name9);
  }
  onInit(asn) {
    if (asn.dNSName != null) {
      this.type = DNS;
      this.value = asn.dNSName;
    } else if (asn.rfc822Name != null) {
      this.type = EMAIL;
      this.value = asn.rfc822Name;
    } else if (asn.iPAddress != null) {
      this.type = IP;
      this.value = asn.iPAddress;
    } else if (asn.uniformResourceIdentifier != null) {
      this.type = URL2;
      this.value = asn.uniformResourceIdentifier;
    } else if (asn.registeredID != null) {
      this.type = REGISTERED_ID;
      this.value = asn.registeredID;
    } else if (asn.directoryName != null) {
      this.type = DN;
      this.value = new Name17(asn.directoryName).toString();
    } else if (asn.otherName != null) {
      if (asn.otherName.typeId === id_GUID) {
        this.type = GUID;
        const guid = AsnConvert2.parse(asn.otherName.value, OctetString4);
        const matches = new RegExp(GUID_REGEX, "i").exec(Convert.ToHex(guid));
        if (!matches) {
          throw new Error(ERR_GUID);
        }
        this.value = matches.slice(1).map((o, i) => {
          if (i < 3) {
            return Convert.ToHex(new Uint8Array(Convert.FromHex(o)).reverse());
          }
          return o;
        }).join("-");
      } else if (asn.otherName.typeId === id_UPN) {
        this.type = UPN;
        this.value = AsnConvert2.parse(asn.otherName.value, DirectoryString3).toString();
      } else {
        throw new Error(ERR_GN_STRING_FORMAT);
      }
    } else {
      throw new Error(ERR_GN_STRING_FORMAT);
    }
  }
  toJSON() {
    return {
      type: this.type,
      value: this.value
    };
  }
  toTextObject() {
    let type;
    switch (this.type) {
      case DN:
      case DNS:
      case GUID:
      case IP:
      case REGISTERED_ID:
      case UPN:
      case URL2:
        type = this.type.toUpperCase();
        break;
      case EMAIL:
        type = "Email";
        break;
      default:
        throw new Error("Unsupported GeneralName type");
    }
    let value = this.value;
    if (this.type === REGISTERED_ID) {
      value = OidSerializer.toString(value);
    }
    return new TextObject(type, undefined, value);
  }
}

class GeneralNames17 extends AsnData {
  constructor(params) {
    let names2;
    if (params instanceof GeneralNames3) {
      names2 = params;
    } else if (Array.isArray(params)) {
      const items = [];
      for (const name9 of params) {
        if (name9 instanceof GeneralName3) {
          items.push(name9);
        } else {
          const asnName = AsnConvert2.parse(new GeneralName17(name9.type, name9.value).rawData, GeneralName3);
          items.push(asnName);
        }
      }
      names2 = new GeneralNames3(items);
    } else if (BufferSourceConverter.isBufferSource(params)) {
      names2 = AsnConvert2.parse(params, GeneralNames3);
    } else {
      throw new Error("Cannot initialize GeneralNames. Incorrect incoming arguments");
    }
    super(names2);
  }
  onInit(asn) {
    const items = [];
    for (const asnName of asn) {
      let name9 = null;
      try {
        name9 = new GeneralName17(asnName);
      } catch {
        continue;
      }
      items.push(name9);
    }
    this.items = items;
  }
  toJSON() {
    return this.items.map((o) => o.toJSON());
  }
  toTextObject() {
    const res = super.toTextObjectEmpty();
    for (const name9 of this.items) {
      const nameObj = name9.toTextObject();
      let field = res[nameObj[TextObject.NAME]];
      if (!Array.isArray(field)) {
        field = [];
        res[nameObj[TextObject.NAME]] = field;
      }
      field.push(nameObj);
    }
    return res;
  }
}
GeneralNames17.NAME = "GeneralNames";
var rPaddingTag = "-{5}";
var rEolChars = "\\n";
var rNameTag = `[^${rEolChars}]+`;
var rBeginTag = `${rPaddingTag}BEGIN (${rNameTag}(?=${rPaddingTag}))${rPaddingTag}`;
var rEndTag = `${rPaddingTag}END \\1${rPaddingTag}`;
var rEolGroup = "\\n";
var rHeaderKey = `[^:${rEolChars}]+`;
var rHeaderValue = `(?:[^${rEolChars}]+${rEolGroup}(?: +[^${rEolChars}]+${rEolGroup})*)`;
var rBase64Chars = "[a-zA-Z0-9=+/]+";
var rBase64 = `(?:${rBase64Chars}${rEolGroup})+`;
var rPem = `${rBeginTag}${rEolGroup}(?:((?:${rHeaderKey}: ${rHeaderValue})+))?${rEolGroup}?(${rBase64})${rEndTag}`;

class PemConverter {
  static isPem(data) {
    return typeof data === "string" && new RegExp(rPem, "g").test(data.replace(/\r/g, ""));
  }
  static decodeWithHeaders(pem) {
    pem = pem.replace(/\r/g, "");
    const pattern = new RegExp(rPem, "g");
    const res = [];
    let matches = null;
    while (matches = pattern.exec(pem)) {
      const base642 = matches[3].replace(new RegExp(`[${rEolChars}]+`, "g"), "");
      const pemStruct = {
        type: matches[1],
        headers: [],
        rawData: Convert.FromBase64(base642)
      };
      const headersString = matches[2];
      if (headersString) {
        const headers = headersString.split(new RegExp(rEolGroup, "g"));
        let lastHeader = null;
        for (const header of headers) {
          const [key, value] = header.split(/:(.*)/);
          if (value === undefined) {
            if (!lastHeader) {
              throw new Error("Cannot parse PEM string. Incorrect header value");
            }
            lastHeader.value += key.trim();
          } else {
            if (lastHeader) {
              pemStruct.headers.push(lastHeader);
            }
            lastHeader = { key, value: value.trim() };
          }
        }
        if (lastHeader) {
          pemStruct.headers.push(lastHeader);
        }
      }
      res.push(pemStruct);
    }
    return res;
  }
  static decode(pem) {
    const blocks = this.decodeWithHeaders(pem);
    return blocks.map((o) => o.rawData);
  }
  static decodeFirst(pem) {
    const items = this.decode(pem);
    if (!items.length) {
      throw new RangeError("PEM string doesn't contain any objects");
    }
    return items[0];
  }
  static encode(rawData, tag) {
    if (Array.isArray(rawData)) {
      const raws = new Array;
      if (tag) {
        rawData.forEach((element) => {
          if (!BufferSourceConverter.isBufferSource(element)) {
            throw new TypeError("Cannot encode array of BufferSource in PEM format. Not all items of the array are BufferSource");
          }
          raws.push(this.encodeStruct({
            type: tag,
            rawData: BufferSourceConverter.toArrayBuffer(element)
          }));
        });
      } else {
        rawData.forEach((element) => {
          if (!("type" in element)) {
            throw new TypeError("Cannot encode array of PemStruct in PEM format. Not all items of the array are PemStrut");
          }
          raws.push(this.encodeStruct(element));
        });
      }
      return raws.join(`
`);
    } else {
      if (!tag) {
        throw new Error("Required argument 'tag' is missed");
      }
      return this.encodeStruct({
        type: tag,
        rawData: BufferSourceConverter.toArrayBuffer(rawData)
      });
    }
  }
  static encodeStruct(pem) {
    var _a10;
    const upperCaseType = pem.type.toLocaleUpperCase();
    const res = [];
    res.push(`-----BEGIN ${upperCaseType}-----`);
    if ((_a10 = pem.headers) === null || _a10 === undefined ? undefined : _a10.length) {
      for (const header of pem.headers) {
        res.push(`${header.key}: ${header.value}`);
      }
      res.push("");
    }
    const base642 = Convert.ToBase64(pem.rawData);
    let sliced;
    let offset = 0;
    const rows = Array();
    while (offset < base642.length) {
      if (base642.length - offset < 64) {
        sliced = base642.substring(offset);
      } else {
        sliced = base642.substring(offset, offset + 64);
        offset += 64;
      }
      if (sliced.length !== 0) {
        rows.push(sliced);
        if (sliced.length < 64) {
          break;
        }
      } else {
        break;
      }
    }
    res.push(...rows);
    res.push(`-----END ${upperCaseType}-----`);
    return res.join(`
`);
  }
}
PemConverter.CertificateTag = "CERTIFICATE";
PemConverter.CrlTag = "CRL";
PemConverter.CertificateRequestTag = "CERTIFICATE REQUEST";
PemConverter.PublicKeyTag = "PUBLIC KEY";
PemConverter.PrivateKeyTag = "PRIVATE KEY";

class PemData extends AsnData {
  static isAsnEncoded(data) {
    return BufferSourceConverter.isBufferSource(data) || typeof data === "string";
  }
  static toArrayBuffer(raw2) {
    if (typeof raw2 === "string") {
      if (PemConverter.isPem(raw2)) {
        return PemConverter.decode(raw2)[0];
      } else if (Convert.isHex(raw2)) {
        return Convert.FromHex(raw2);
      } else if (Convert.isBase64(raw2)) {
        return Convert.FromBase64(raw2);
      } else if (Convert.isBase64Url(raw2)) {
        return Convert.FromBase64Url(raw2);
      } else {
        throw new TypeError("Unsupported format of 'raw' argument. Must be one of DER, PEM, HEX, Base64, or Base4Url");
      }
    } else {
      const buffer = BufferSourceConverter.toUint8Array(raw2);
      if (buffer.length > 0 && buffer[0] === 48) {
        return BufferSourceConverter.toArrayBuffer(raw2);
      }
      const stringRaw = Convert.ToBinary(raw2);
      if (PemConverter.isPem(stringRaw)) {
        return PemConverter.decode(stringRaw)[0];
      } else if (Convert.isHex(stringRaw)) {
        return Convert.FromHex(stringRaw);
      } else if (Convert.isBase64(stringRaw)) {
        return Convert.FromBase64(stringRaw);
      } else if (Convert.isBase64Url(stringRaw)) {
        return Convert.FromBase64Url(stringRaw);
      }
      throw new TypeError("Unsupported format of 'raw' argument. Must be one of DER, PEM, HEX, Base64, or Base4Url");
    }
  }
  constructor(...args) {
    if (PemData.isAsnEncoded(args[0])) {
      super(PemData.toArrayBuffer(args[0]), args[1]);
    } else {
      super(args[0]);
    }
  }
  toString(format = "pem") {
    switch (format) {
      case "pem":
        return PemConverter.encode(this.rawData, this.tag);
      default:
        return super.toString(format);
    }
  }
}

class PublicKey extends PemData {
  static async create(data, crypto3 = cryptoProvider.get()) {
    if (data instanceof PublicKey) {
      return data;
    } else if (CryptoProvider.isCryptoKey(data)) {
      if (data.type !== "public") {
        throw new TypeError("Public key is required");
      }
      const spki = await crypto3.subtle.exportKey("spki", data);
      return new PublicKey(spki);
    } else if (data.publicKey) {
      return data.publicKey;
    } else if (BufferSourceConverter.isBufferSource(data)) {
      return new PublicKey(data);
    } else {
      throw new TypeError("Unsupported PublicKeyType");
    }
  }
  constructor(param) {
    if (PemData.isAsnEncoded(param)) {
      super(param, SubjectPublicKeyInfo2);
    } else {
      super(param);
    }
    this.tag = PemConverter.PublicKeyTag;
  }
  async export(...args) {
    let crypto3;
    let keyUsages = ["verify"];
    let algorithm2 = { hash: "SHA-256", ...this.algorithm };
    if (args.length > 1) {
      algorithm2 = args[0] || algorithm2;
      keyUsages = args[1] || keyUsages;
      crypto3 = args[2] || cryptoProvider.get();
    } else {
      crypto3 = args[0] || cryptoProvider.get();
    }
    let raw2 = this.rawData;
    const asnSpki = AsnConvert2.parse(this.rawData, SubjectPublicKeyInfo2);
    if (asnSpki.algorithm.algorithm === id_RSASSA_PSS) {
      raw2 = convertSpkiToRsaPkcs1(asnSpki, raw2);
    }
    return crypto3.subtle.importKey("spki", raw2, algorithm2, true, keyUsages);
  }
  onInit(asn) {
    const algProv = instance.resolve(diAlgorithmProvider);
    const algorithm2 = this.algorithm = algProv.toWebAlgorithm(asn.algorithm);
    switch (asn.algorithm.algorithm) {
      case id_rsaEncryption: {
        const rsaPublicKey = AsnConvert2.parse(asn.subjectPublicKey, RSAPublicKey);
        const modulus = BufferSourceConverter.toUint8Array(rsaPublicKey.modulus);
        algorithm2.publicExponent = BufferSourceConverter.toUint8Array(rsaPublicKey.publicExponent);
        algorithm2.modulusLength = (!modulus[0] ? modulus.slice(1) : modulus).byteLength << 3;
        break;
      }
    }
  }
  async getThumbprint(...args) {
    var _a10;
    let crypto3;
    let algorithm2 = "SHA-1";
    if (args.length >= 1 && !((_a10 = args[0]) === null || _a10 === undefined ? undefined : _a10.subtle)) {
      algorithm2 = args[0] || algorithm2;
      crypto3 = args[1] || cryptoProvider.get();
    } else {
      crypto3 = args[0] || cryptoProvider.get();
    }
    return await crypto3.subtle.digest(algorithm2, this.rawData);
  }
  async getKeyIdentifier(...args) {
    let crypto3;
    let algorithm2 = "SHA-1";
    if (args.length === 1) {
      if (typeof args[0] === "string") {
        algorithm2 = args[0];
        crypto3 = cryptoProvider.get();
      } else {
        crypto3 = args[0];
      }
    } else if (args.length === 2) {
      algorithm2 = args[0];
      crypto3 = args[1];
    } else {
      crypto3 = cryptoProvider.get();
    }
    const asn = AsnConvert2.parse(this.rawData, SubjectPublicKeyInfo2);
    return await crypto3.subtle.digest(algorithm2, asn.subjectPublicKey);
  }
  toTextObject() {
    const obj = this.toTextObjectEmpty();
    const asn = AsnConvert2.parse(this.rawData, SubjectPublicKeyInfo2);
    obj["Algorithm"] = TextConverter.serializeAlgorithm(asn.algorithm);
    switch (asn.algorithm.algorithm) {
      case id_ecPublicKey:
        obj["EC Point"] = asn.subjectPublicKey;
        break;
      case id_rsaEncryption:
      default:
        obj["Raw Data"] = asn.subjectPublicKey;
    }
    return obj;
  }
}
function convertSpkiToRsaPkcs1(asnSpki, raw2) {
  asnSpki.algorithm = new AlgorithmIdentifier2({
    algorithm: id_rsaEncryption,
    parameters: null
  });
  raw2 = AsnConvert2.serialize(asnSpki);
  return raw2;
}

class AuthorityKeyIdentifierExtension extends Extension9 {
  static async create(param, critical = false, crypto3 = cryptoProvider.get()) {
    if ("name" in param && "serialNumber" in param) {
      return new AuthorityKeyIdentifierExtension(param, critical);
    }
    const key = await PublicKey.create(param, crypto3);
    const id = await key.getKeyIdentifier(crypto3);
    return new AuthorityKeyIdentifierExtension(Convert.ToHex(id), critical);
  }
  constructor(...args) {
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
    } else if (typeof args[0] === "string") {
      const value = new AuthorityKeyIdentifier2({ keyIdentifier: new KeyIdentifier2(Convert.FromHex(args[0])) });
      super(id_ce_authorityKeyIdentifier2, args[1], AsnConvert2.serialize(value));
    } else {
      const certId = args[0];
      const certIdName = certId.name instanceof GeneralNames17 ? AsnConvert2.parse(certId.name.rawData, GeneralNames3) : certId.name;
      const value = new AuthorityKeyIdentifier2({
        authorityCertIssuer: certIdName,
        authorityCertSerialNumber: Convert.FromHex(certId.serialNumber)
      });
      super(id_ce_authorityKeyIdentifier2, args[1], AsnConvert2.serialize(value));
    }
  }
  onInit(asn) {
    super.onInit(asn);
    const aki = AsnConvert2.parse(asn.extnValue, AuthorityKeyIdentifier2);
    if (aki.keyIdentifier) {
      this.keyId = Convert.ToHex(aki.keyIdentifier);
    }
    if (aki.authorityCertIssuer || aki.authorityCertSerialNumber) {
      this.certId = {
        name: aki.authorityCertIssuer || [],
        serialNumber: aki.authorityCertSerialNumber ? Convert.ToHex(aki.authorityCertSerialNumber) : ""
      };
    }
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    const asn = AsnConvert2.parse(this.value, AuthorityKeyIdentifier2);
    if (asn.authorityCertIssuer) {
      obj["Authority Issuer"] = new GeneralNames17(asn.authorityCertIssuer).toTextObject();
    }
    if (asn.authorityCertSerialNumber) {
      obj["Authority Serial Number"] = asn.authorityCertSerialNumber;
    }
    if (asn.keyIdentifier) {
      obj[""] = asn.keyIdentifier;
    }
    return obj;
  }
}
AuthorityKeyIdentifierExtension.NAME = "Authority Key Identifier";

class BasicConstraintsExtension extends Extension9 {
  constructor(...args) {
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
      const value = AsnConvert2.parse(this.value, BasicConstraints2);
      this.ca = value.cA;
      this.pathLength = value.pathLenConstraint;
    } else {
      const value = new BasicConstraints2({
        cA: args[0],
        pathLenConstraint: args[1]
      });
      super(id_ce_basicConstraints2, args[2], AsnConvert2.serialize(value));
      this.ca = args[0];
      this.pathLength = args[1];
    }
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    if (this.ca) {
      obj["CA"] = this.ca;
    }
    if (this.pathLength !== undefined) {
      obj["Path Length"] = this.pathLength;
    }
    return obj;
  }
}
BasicConstraintsExtension.NAME = "Basic Constraints";
var ExtendedKeyUsage17;
(function(ExtendedKeyUsage18) {
  ExtendedKeyUsage18["serverAuth"] = "1.3.6.1.5.5.7.3.1";
  ExtendedKeyUsage18["clientAuth"] = "1.3.6.1.5.5.7.3.2";
  ExtendedKeyUsage18["codeSigning"] = "1.3.6.1.5.5.7.3.3";
  ExtendedKeyUsage18["emailProtection"] = "1.3.6.1.5.5.7.3.4";
  ExtendedKeyUsage18["timeStamping"] = "1.3.6.1.5.5.7.3.8";
  ExtendedKeyUsage18["ocspSigning"] = "1.3.6.1.5.5.7.3.9";
})(ExtendedKeyUsage17 || (ExtendedKeyUsage17 = {}));

class ExtendedKeyUsageExtension extends Extension9 {
  constructor(...args) {
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
      const value = AsnConvert2.parse(this.value, ExtendedKeyUsage3);
      this.usages = value.map((o) => o);
    } else {
      const value = new ExtendedKeyUsage3(args[0]);
      super(id_ce_extKeyUsage2, args[1], AsnConvert2.serialize(value));
      this.usages = args[0];
    }
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    obj[""] = this.usages.map((o) => OidSerializer.toString(o)).join(", ");
    return obj;
  }
}
ExtendedKeyUsageExtension.NAME = "Extended Key Usages";
var KeyUsageFlags9;
(function(KeyUsageFlags10) {
  KeyUsageFlags10[KeyUsageFlags10["digitalSignature"] = 1] = "digitalSignature";
  KeyUsageFlags10[KeyUsageFlags10["nonRepudiation"] = 2] = "nonRepudiation";
  KeyUsageFlags10[KeyUsageFlags10["keyEncipherment"] = 4] = "keyEncipherment";
  KeyUsageFlags10[KeyUsageFlags10["dataEncipherment"] = 8] = "dataEncipherment";
  KeyUsageFlags10[KeyUsageFlags10["keyAgreement"] = 16] = "keyAgreement";
  KeyUsageFlags10[KeyUsageFlags10["keyCertSign"] = 32] = "keyCertSign";
  KeyUsageFlags10[KeyUsageFlags10["cRLSign"] = 64] = "cRLSign";
  KeyUsageFlags10[KeyUsageFlags10["encipherOnly"] = 128] = "encipherOnly";
  KeyUsageFlags10[KeyUsageFlags10["decipherOnly"] = 256] = "decipherOnly";
})(KeyUsageFlags9 || (KeyUsageFlags9 = {}));

class KeyUsagesExtension extends Extension9 {
  constructor(...args) {
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
      const value = AsnConvert2.parse(this.value, KeyUsage);
      this.usages = value.toNumber();
    } else {
      const value = new KeyUsage(args[0]);
      super(id_ce_keyUsage2, args[1], AsnConvert2.serialize(value));
      this.usages = args[0];
    }
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    const asn = AsnConvert2.parse(this.value, KeyUsage);
    obj[""] = asn.toJSON().join(", ");
    return obj;
  }
}
KeyUsagesExtension.NAME = "Key Usages";

class SubjectKeyIdentifierExtension extends Extension9 {
  static async create(publicKey, critical = false, crypto3 = cryptoProvider.get()) {
    const key = await PublicKey.create(publicKey, crypto3);
    const id = await key.getKeyIdentifier(crypto3);
    return new SubjectKeyIdentifierExtension(Convert.ToHex(id), critical);
  }
  constructor(...args) {
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
      const value = AsnConvert2.parse(this.value, SubjectKeyIdentifier);
      this.keyId = Convert.ToHex(value);
    } else {
      const identifier = typeof args[0] === "string" ? Convert.FromHex(args[0]) : args[0];
      const value = new SubjectKeyIdentifier(identifier);
      super(id_ce_subjectKeyIdentifier2, args[1], AsnConvert2.serialize(value));
      this.keyId = Convert.ToHex(identifier);
    }
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    const asn = AsnConvert2.parse(this.value, SubjectKeyIdentifier);
    obj[""] = asn;
    return obj;
  }
}
SubjectKeyIdentifierExtension.NAME = "Subject Key Identifier";

class SubjectAlternativeNameExtension extends Extension9 {
  constructor(...args) {
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
    } else {
      super(id_ce_subjectAltName2, args[1], new GeneralNames17(args[0] || []).rawData);
    }
  }
  onInit(asn) {
    super.onInit(asn);
    const value = AsnConvert2.parse(asn.extnValue, SubjectAlternativeName3);
    this.names = new GeneralNames17(value);
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    const namesObj = this.names.toTextObject();
    for (const key in namesObj) {
      obj[key] = namesObj[key];
    }
    return obj;
  }
}
SubjectAlternativeNameExtension.NAME = "Subject Alternative Name";

class ExtensionFactory {
  static register(id, type) {
    this.items.set(id, type);
  }
  static create(data) {
    const extension9 = new Extension9(data);
    const Type = this.items.get(extension9.type);
    if (Type) {
      return new Type(data);
    }
    return extension9;
  }
}
ExtensionFactory.items = new Map;

class CertificatePolicyExtension extends Extension9 {
  constructor(...args) {
    var _a10;
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
      const asnPolicies = AsnConvert2.parse(this.value, CertificatePolicies3);
      this.policies = asnPolicies.map((o) => o.policyIdentifier);
    } else {
      const policies = args[0];
      const critical = (_a10 = args[1]) !== null && _a10 !== undefined ? _a10 : false;
      const value = new CertificatePolicies3(policies.map((o) => new PolicyInformation2({
        policyIdentifier: o
      })));
      super(id_ce_certificatePolicies2, critical, AsnConvert2.serialize(value));
      this.policies = policies;
    }
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    obj["Policy"] = this.policies.map((o) => new TextObject("", {}, OidSerializer.toString(o)));
    return obj;
  }
}
CertificatePolicyExtension.NAME = "Certificate Policies";
ExtensionFactory.register(id_ce_certificatePolicies2, CertificatePolicyExtension);

class CRLDistributionPointsExtension extends Extension9 {
  constructor(...args) {
    var _a10;
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
    } else if (Array.isArray(args[0]) && typeof args[0][0] === "string") {
      const urls = args[0];
      const dps = urls.map((url) => {
        return new DistributionPoint2({
          distributionPoint: new DistributionPointName3({
            fullName: [new GeneralName3({ uniformResourceIdentifier: url })]
          })
        });
      });
      const value = new CRLDistributionPoints3(dps);
      super(id_ce_cRLDistributionPoints2, args[1], AsnConvert2.serialize(value));
    } else {
      const value = new CRLDistributionPoints3(args[0]);
      super(id_ce_cRLDistributionPoints2, args[1], AsnConvert2.serialize(value));
    }
    (_a10 = this.distributionPoints) !== null && _a10 !== undefined || (this.distributionPoints = []);
  }
  onInit(asn) {
    super.onInit(asn);
    const crlExt = AsnConvert2.parse(asn.extnValue, CRLDistributionPoints3);
    this.distributionPoints = crlExt;
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    obj["Distribution Point"] = this.distributionPoints.map((dp) => {
      var _a10;
      const dpObj = {};
      if (dp.distributionPoint) {
        dpObj[""] = (_a10 = dp.distributionPoint.fullName) === null || _a10 === undefined ? undefined : _a10.map((name9) => new GeneralName17(name9).toString()).join(", ");
      }
      if (dp.reasons) {
        dpObj["Reasons"] = dp.reasons.toString();
      }
      if (dp.cRLIssuer) {
        dpObj["CRL Issuer"] = dp.cRLIssuer.map((issuer) => issuer.toString()).join(", ");
      }
      return dpObj;
    });
    return obj;
  }
}
CRLDistributionPointsExtension.NAME = "CRL Distribution Points";

class AuthorityInfoAccessExtension extends Extension9 {
  constructor(...args) {
    var _a10, _b, _c, _d;
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
    } else if (args[0] instanceof AuthorityInfoAccessSyntax3) {
      const value = new AuthorityInfoAccessSyntax3(args[0]);
      super(id_pe_authorityInfoAccess2, args[1], AsnConvert2.serialize(value));
    } else {
      const params = args[0];
      const value = new AuthorityInfoAccessSyntax3;
      addAccessDescriptions(value, params, id_ad_ocsp2, "ocsp");
      addAccessDescriptions(value, params, id_ad_caIssuers2, "caIssuers");
      addAccessDescriptions(value, params, id_ad_timeStamping2, "timeStamping");
      addAccessDescriptions(value, params, id_ad_caRepository2, "caRepository");
      super(id_pe_authorityInfoAccess2, args[1], AsnConvert2.serialize(value));
    }
    (_a10 = this.ocsp) !== null && _a10 !== undefined || (this.ocsp = []);
    (_b = this.caIssuers) !== null && _b !== undefined || (this.caIssuers = []);
    (_c = this.timeStamping) !== null && _c !== undefined || (this.timeStamping = []);
    (_d = this.caRepository) !== null && _d !== undefined || (this.caRepository = []);
  }
  onInit(asn) {
    super.onInit(asn);
    this.ocsp = [];
    this.caIssuers = [];
    this.timeStamping = [];
    this.caRepository = [];
    const aia = AsnConvert2.parse(asn.extnValue, AuthorityInfoAccessSyntax3);
    aia.forEach((accessDescription) => {
      switch (accessDescription.accessMethod) {
        case id_ad_ocsp2:
          this.ocsp.push(new GeneralName17(accessDescription.accessLocation));
          break;
        case id_ad_caIssuers2:
          this.caIssuers.push(new GeneralName17(accessDescription.accessLocation));
          break;
        case id_ad_timeStamping2:
          this.timeStamping.push(new GeneralName17(accessDescription.accessLocation));
          break;
        case id_ad_caRepository2:
          this.caRepository.push(new GeneralName17(accessDescription.accessLocation));
          break;
      }
    });
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    if (this.ocsp.length) {
      addUrlsToObject(obj, "OCSP", this.ocsp);
    }
    if (this.caIssuers.length) {
      addUrlsToObject(obj, "CA Issuers", this.caIssuers);
    }
    if (this.timeStamping.length) {
      addUrlsToObject(obj, "Time Stamping", this.timeStamping);
    }
    if (this.caRepository.length) {
      addUrlsToObject(obj, "CA Repository", this.caRepository);
    }
    return obj;
  }
}
AuthorityInfoAccessExtension.NAME = "Authority Info Access";
function addUrlsToObject(obj, key, urls) {
  if (urls.length === 1) {
    obj[key] = urls[0].toTextObject();
  } else {
    const names2 = new TextObject("");
    urls.forEach((name9, index) => {
      const nameObj = name9.toTextObject();
      const indexedKey = `${nameObj[TextObject.NAME]} ${index + 1}`;
      let field = names2[indexedKey];
      if (!Array.isArray(field)) {
        field = [];
        names2[indexedKey] = field;
      }
      field.push(nameObj);
    });
    obj[key] = names2;
  }
}
function addAccessDescriptions(value, params, method, key) {
  const items = params[key];
  if (items) {
    const array = Array.isArray(items) ? items : [items];
    array.forEach((url) => {
      if (typeof url === "string") {
        url = new GeneralName17("url", url);
      }
      value.push(new AccessDescription2({
        accessMethod: method,
        accessLocation: AsnConvert2.parse(url.rawData, GeneralName3)
      }));
    });
  }
}

class IssuerAlternativeNameExtension extends Extension9 {
  constructor(...args) {
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
    } else {
      super(id_ce_issuerAltName2, args[1], new GeneralNames17(args[0] || []).rawData);
    }
  }
  onInit(asn) {
    super.onInit(asn);
    const value = AsnConvert2.parse(asn.extnValue, GeneralNames3);
    this.names = new GeneralNames17(value);
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    const namesObj = this.names.toTextObject();
    for (const key in namesObj) {
      obj[key] = namesObj[key];
    }
    return obj;
  }
}
IssuerAlternativeNameExtension.NAME = "Issuer Alternative Name";

class Attribute10 extends AsnData {
  constructor(...args) {
    let raw2;
    if (BufferSourceConverter.isBufferSource(args[0])) {
      raw2 = BufferSourceConverter.toArrayBuffer(args[0]);
    } else {
      const type = args[0];
      const values = Array.isArray(args[1]) ? args[1].map((o) => BufferSourceConverter.toArrayBuffer(o)) : [];
      raw2 = AsnConvert2.serialize(new Attribute2({ type, values }));
    }
    super(raw2, Attribute2);
  }
  onInit(asn) {
    this.type = asn.type;
    this.values = asn.values;
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    obj["Value"] = this.values.map((o) => new TextObject("", { "": o }));
    return obj;
  }
  toTextObjectWithoutValue() {
    const obj = this.toTextObjectEmpty();
    if (obj[TextObject.NAME] === Attribute10.NAME) {
      obj[TextObject.NAME] = OidSerializer.toString(this.type);
    }
    return obj;
  }
}
Attribute10.NAME = "Attribute";

class ChallengePasswordAttribute extends Attribute10 {
  constructor(...args) {
    var _a10;
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
    } else {
      const value = new ChallengePassword({
        printableString: args[0]
      });
      super(id_pkcs9_at_challengePassword, [AsnConvert2.serialize(value)]);
    }
    (_a10 = this.password) !== null && _a10 !== undefined || (this.password = "");
  }
  onInit(asn) {
    super.onInit(asn);
    if (this.values[0]) {
      const value = AsnConvert2.parse(this.values[0], ChallengePassword);
      this.password = value.toString();
    }
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    obj[TextObject.VALUE] = this.password;
    return obj;
  }
}
ChallengePasswordAttribute.NAME = "Challenge Password";

class ExtensionsAttribute extends Attribute10 {
  constructor(...args) {
    var _a10;
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
    } else {
      const extensions9 = args[0];
      const value = new Extensions3;
      for (const extension9 of extensions9) {
        value.push(AsnConvert2.parse(extension9.rawData, Extension2));
      }
      super(id_pkcs9_at_extensionRequest, [AsnConvert2.serialize(value)]);
    }
    (_a10 = this.items) !== null && _a10 !== undefined || (this.items = []);
  }
  onInit(asn) {
    super.onInit(asn);
    if (this.values[0]) {
      const value = AsnConvert2.parse(this.values[0], Extensions3);
      this.items = value.map((o) => ExtensionFactory.create(AsnConvert2.serialize(o)));
    }
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    const extensions9 = this.items.map((o) => o.toTextObject());
    for (const extension9 of extensions9) {
      obj[extension9[TextObject.NAME]] = extension9;
    }
    return obj;
  }
}
ExtensionsAttribute.NAME = "Extensions";

class AttributeFactory {
  static register(id, type) {
    this.items.set(id, type);
  }
  static create(data) {
    const attribute11 = new Attribute10(data);
    const Type = this.items.get(attribute11.type);
    if (Type) {
      return new Type(data);
    }
    return attribute11;
  }
}
AttributeFactory.items = new Map;
var diAsnSignatureFormatter = "crypto.signatureFormatter";

class AsnDefaultSignatureFormatter {
  toAsnSignature(algorithm2, signature) {
    return BufferSourceConverter.toArrayBuffer(signature);
  }
  toWebSignature(algorithm2, signature) {
    return BufferSourceConverter.toArrayBuffer(signature);
  }
}
var RsaAlgorithm_1;
var RsaAlgorithm = RsaAlgorithm_1 = class RsaAlgorithm2 {
  static createPssParams(hash, saltLength) {
    const hashAlgorithm = RsaAlgorithm_1.getHashAlgorithm(hash);
    if (!hashAlgorithm) {
      return null;
    }
    return new RsaSaPssParams({
      hashAlgorithm,
      maskGenAlgorithm: new AlgorithmIdentifier2({
        algorithm: id_mgf1,
        parameters: AsnConvert2.serialize(hashAlgorithm)
      }),
      saltLength
    });
  }
  static getHashAlgorithm(alg) {
    const algProv = instance.resolve(diAlgorithmProvider);
    if (typeof alg === "string") {
      return algProv.toAsnAlgorithm({ name: alg });
    }
    if (typeof alg === "object" && alg && "name" in alg) {
      return algProv.toAsnAlgorithm(alg);
    }
    return null;
  }
  toAsnAlgorithm(alg) {
    switch (alg.name.toLowerCase()) {
      case "rsassa-pkcs1-v1_5":
        if ("hash" in alg) {
          let hash;
          if (typeof alg.hash === "string") {
            hash = alg.hash;
          } else if (alg.hash && typeof alg.hash === "object" && "name" in alg.hash && typeof alg.hash.name === "string") {
            hash = alg.hash.name.toUpperCase();
          } else {
            throw new Error("Cannot get hash algorithm name");
          }
          switch (hash.toLowerCase()) {
            case "sha-1":
              return new AlgorithmIdentifier2({ algorithm: id_sha1WithRSAEncryption, parameters: null });
            case "sha-256":
              return new AlgorithmIdentifier2({ algorithm: id_sha256WithRSAEncryption, parameters: null });
            case "sha-384":
              return new AlgorithmIdentifier2({ algorithm: id_sha384WithRSAEncryption, parameters: null });
            case "sha-512":
              return new AlgorithmIdentifier2({ algorithm: id_sha512WithRSAEncryption, parameters: null });
          }
        } else {
          return new AlgorithmIdentifier2({ algorithm: id_rsaEncryption, parameters: null });
        }
        break;
      case "rsa-pss":
        if ("hash" in alg) {
          if (!(("saltLength" in alg) && typeof alg.saltLength === "number")) {
            throw new Error("Cannot get 'saltLength' from 'alg' argument");
          }
          const pssParams = RsaAlgorithm_1.createPssParams(alg.hash, alg.saltLength);
          if (!pssParams) {
            throw new Error("Cannot create PSS parameters");
          }
          return new AlgorithmIdentifier2({ algorithm: id_RSASSA_PSS, parameters: AsnConvert2.serialize(pssParams) });
        } else {
          return new AlgorithmIdentifier2({ algorithm: id_RSASSA_PSS, parameters: null });
        }
    }
    return null;
  }
  toWebAlgorithm(alg) {
    switch (alg.algorithm) {
      case id_rsaEncryption:
        return { name: "RSASSA-PKCS1-v1_5" };
      case id_sha1WithRSAEncryption:
        return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-1" } };
      case id_sha256WithRSAEncryption:
        return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } };
      case id_sha384WithRSAEncryption:
        return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-384" } };
      case id_sha512WithRSAEncryption:
        return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-512" } };
      case id_RSASSA_PSS:
        if (alg.parameters) {
          const pssParams = AsnConvert2.parse(alg.parameters, RsaSaPssParams);
          const algProv = instance.resolve(diAlgorithmProvider);
          const hashAlg = algProv.toWebAlgorithm(pssParams.hashAlgorithm);
          return {
            name: "RSA-PSS",
            hash: hashAlg,
            saltLength: pssParams.saltLength
          };
        } else {
          return { name: "RSA-PSS" };
        }
    }
    return null;
  }
};
RsaAlgorithm = RsaAlgorithm_1 = __decorate([
  injectable_default()
], RsaAlgorithm);
instance.registerSingleton(diAlgorithm, RsaAlgorithm);
var ShaAlgorithm = class ShaAlgorithm2 {
  toAsnAlgorithm(alg) {
    switch (alg.name.toLowerCase()) {
      case "sha-1":
        return new AlgorithmIdentifier2({ algorithm: id_sha1 });
      case "sha-256":
        return new AlgorithmIdentifier2({ algorithm: id_sha256 });
      case "sha-384":
        return new AlgorithmIdentifier2({ algorithm: id_sha384 });
      case "sha-512":
        return new AlgorithmIdentifier2({ algorithm: id_sha512 });
    }
    return null;
  }
  toWebAlgorithm(alg) {
    switch (alg.algorithm) {
      case id_sha1:
        return { name: "SHA-1" };
      case id_sha256:
        return { name: "SHA-256" };
      case id_sha384:
        return { name: "SHA-384" };
      case id_sha512:
        return { name: "SHA-512" };
    }
    return null;
  }
};
ShaAlgorithm = __decorate([
  injectable_default()
], ShaAlgorithm);
instance.registerSingleton(diAlgorithm, ShaAlgorithm);

class AsnEcSignatureFormatter {
  addPadding(pointSize, data) {
    const bytes = BufferSourceConverter.toUint8Array(data);
    const res = new Uint8Array(pointSize);
    res.set(bytes, pointSize - bytes.length);
    return res.buffer;
  }
  removePadding(data, positive = false) {
    let bytes = BufferSourceConverter.toUint8Array(data);
    for (let i = 0;i < bytes.length; i++) {
      if (!bytes[i]) {
        continue;
      }
      bytes = bytes.slice(i);
      break;
    }
    if (positive && bytes[0] > 127) {
      const result = new Uint8Array(bytes.length + 1);
      result.set(bytes, 1);
      return result.buffer;
    }
    return bytes.buffer;
  }
  toAsnSignature(algorithm2, signature) {
    if (algorithm2.name === "ECDSA") {
      const namedCurve = algorithm2.namedCurve;
      const pointSize = AsnEcSignatureFormatter.namedCurveSize.get(namedCurve) || AsnEcSignatureFormatter.defaultNamedCurveSize;
      const ecSignature = new ECDSASigValue;
      const uint8Signature = BufferSourceConverter.toUint8Array(signature);
      ecSignature.r = this.removePadding(uint8Signature.slice(0, pointSize), true);
      ecSignature.s = this.removePadding(uint8Signature.slice(pointSize, pointSize + pointSize), true);
      return AsnConvert2.serialize(ecSignature);
    }
    return null;
  }
  toWebSignature(algorithm2, signature) {
    if (algorithm2.name === "ECDSA") {
      const ecSigValue = AsnConvert2.parse(signature, ECDSASigValue);
      const namedCurve = algorithm2.namedCurve;
      const pointSize = AsnEcSignatureFormatter.namedCurveSize.get(namedCurve) || AsnEcSignatureFormatter.defaultNamedCurveSize;
      const r = this.addPadding(pointSize, this.removePadding(ecSigValue.r));
      const s = this.addPadding(pointSize, this.removePadding(ecSigValue.s));
      return combine(r, s);
    }
    return null;
  }
}
AsnEcSignatureFormatter.namedCurveSize = new Map;
AsnEcSignatureFormatter.defaultNamedCurveSize = 32;
var idX25519 = "1.3.101.110";
var idX448 = "1.3.101.111";
var idEd25519 = "1.3.101.112";
var idEd448 = "1.3.101.113";
var EdAlgorithm = class EdAlgorithm2 {
  toAsnAlgorithm(alg) {
    let algorithm2 = null;
    switch (alg.name.toLowerCase()) {
      case "ed25519":
        algorithm2 = idEd25519;
        break;
      case "x25519":
        algorithm2 = idX25519;
        break;
      case "eddsa":
        switch (alg.namedCurve.toLowerCase()) {
          case "ed25519":
            algorithm2 = idEd25519;
            break;
          case "ed448":
            algorithm2 = idEd448;
            break;
        }
        break;
      case "ecdh-es":
        switch (alg.namedCurve.toLowerCase()) {
          case "x25519":
            algorithm2 = idX25519;
            break;
          case "x448":
            algorithm2 = idX448;
            break;
        }
    }
    if (algorithm2) {
      return new AlgorithmIdentifier2({
        algorithm: algorithm2
      });
    }
    return null;
  }
  toWebAlgorithm(alg) {
    switch (alg.algorithm) {
      case idEd25519:
        return { name: "Ed25519" };
      case idEd448:
        return { name: "EdDSA", namedCurve: "Ed448" };
      case idX25519:
        return { name: "X25519" };
      case idX448:
        return { name: "ECDH-ES", namedCurve: "X448" };
    }
    return null;
  }
};
EdAlgorithm = __decorate([
  injectable_default()
], EdAlgorithm);
instance.registerSingleton(diAlgorithm, EdAlgorithm);
var _Pkcs10CertificateRequest_tbs;
var _Pkcs10CertificateRequest_subjectName;
var _Pkcs10CertificateRequest_subject;
var _Pkcs10CertificateRequest_signatureAlgorithm;
var _Pkcs10CertificateRequest_signature;
var _Pkcs10CertificateRequest_publicKey;
var _Pkcs10CertificateRequest_attributes;
var _Pkcs10CertificateRequest_extensions;

class Pkcs10CertificateRequest extends PemData {
  get subjectName() {
    if (!__classPrivateFieldGet(this, _Pkcs10CertificateRequest_subjectName, "f")) {
      __classPrivateFieldSet(this, _Pkcs10CertificateRequest_subjectName, new Name17(this.asn.certificationRequestInfo.subject), "f");
    }
    return __classPrivateFieldGet(this, _Pkcs10CertificateRequest_subjectName, "f");
  }
  get subject() {
    if (!__classPrivateFieldGet(this, _Pkcs10CertificateRequest_subject, "f")) {
      __classPrivateFieldSet(this, _Pkcs10CertificateRequest_subject, this.subjectName.toString(), "f");
    }
    return __classPrivateFieldGet(this, _Pkcs10CertificateRequest_subject, "f");
  }
  get signatureAlgorithm() {
    if (!__classPrivateFieldGet(this, _Pkcs10CertificateRequest_signatureAlgorithm, "f")) {
      const algProv = instance.resolve(diAlgorithmProvider);
      __classPrivateFieldSet(this, _Pkcs10CertificateRequest_signatureAlgorithm, algProv.toWebAlgorithm(this.asn.signatureAlgorithm), "f");
    }
    return __classPrivateFieldGet(this, _Pkcs10CertificateRequest_signatureAlgorithm, "f");
  }
  get signature() {
    if (!__classPrivateFieldGet(this, _Pkcs10CertificateRequest_signature, "f")) {
      __classPrivateFieldSet(this, _Pkcs10CertificateRequest_signature, this.asn.signature, "f");
    }
    return __classPrivateFieldGet(this, _Pkcs10CertificateRequest_signature, "f");
  }
  get publicKey() {
    if (!__classPrivateFieldGet(this, _Pkcs10CertificateRequest_publicKey, "f")) {
      __classPrivateFieldSet(this, _Pkcs10CertificateRequest_publicKey, new PublicKey(this.asn.certificationRequestInfo.subjectPKInfo), "f");
    }
    return __classPrivateFieldGet(this, _Pkcs10CertificateRequest_publicKey, "f");
  }
  get attributes() {
    if (!__classPrivateFieldGet(this, _Pkcs10CertificateRequest_attributes, "f")) {
      __classPrivateFieldSet(this, _Pkcs10CertificateRequest_attributes, this.asn.certificationRequestInfo.attributes.map((o) => AttributeFactory.create(AsnConvert2.serialize(o))), "f");
    }
    return __classPrivateFieldGet(this, _Pkcs10CertificateRequest_attributes, "f");
  }
  get extensions() {
    if (!__classPrivateFieldGet(this, _Pkcs10CertificateRequest_extensions, "f")) {
      __classPrivateFieldSet(this, _Pkcs10CertificateRequest_extensions, [], "f");
      const extensions9 = this.getAttribute(id_pkcs9_at_extensionRequest);
      if (extensions9 instanceof ExtensionsAttribute) {
        __classPrivateFieldSet(this, _Pkcs10CertificateRequest_extensions, extensions9.items, "f");
      }
    }
    return __classPrivateFieldGet(this, _Pkcs10CertificateRequest_extensions, "f");
  }
  get tbs() {
    if (!__classPrivateFieldGet(this, _Pkcs10CertificateRequest_tbs, "f")) {
      __classPrivateFieldSet(this, _Pkcs10CertificateRequest_tbs, this.asn.certificationRequestInfoRaw || AsnConvert2.serialize(this.asn.certificationRequestInfo), "f");
    }
    return __classPrivateFieldGet(this, _Pkcs10CertificateRequest_tbs, "f");
  }
  constructor(param) {
    const args = PemData.isAsnEncoded(param) ? [param, CertificationRequest] : [param];
    super(args[0], args[1]);
    _Pkcs10CertificateRequest_tbs.set(this, undefined);
    _Pkcs10CertificateRequest_subjectName.set(this, undefined);
    _Pkcs10CertificateRequest_subject.set(this, undefined);
    _Pkcs10CertificateRequest_signatureAlgorithm.set(this, undefined);
    _Pkcs10CertificateRequest_signature.set(this, undefined);
    _Pkcs10CertificateRequest_publicKey.set(this, undefined);
    _Pkcs10CertificateRequest_attributes.set(this, undefined);
    _Pkcs10CertificateRequest_extensions.set(this, undefined);
    this.tag = PemConverter.CertificateRequestTag;
  }
  onInit(_asn) {}
  getAttribute(type) {
    for (const attr of this.attributes) {
      if (attr.type === type) {
        return attr;
      }
    }
    return null;
  }
  getAttributes(type) {
    return this.attributes.filter((o) => o.type === type);
  }
  getExtension(type) {
    for (const ext of this.extensions) {
      if (ext.type === type) {
        return ext;
      }
    }
    return null;
  }
  getExtensions(type) {
    return this.extensions.filter((o) => o.type === type);
  }
  async verify(crypto3 = cryptoProvider.get()) {
    const algorithm2 = { ...this.publicKey.algorithm, ...this.signatureAlgorithm };
    const publicKey = await this.publicKey.export(algorithm2, ["verify"], crypto3);
    const signatureFormatters = instance.resolveAll(diAsnSignatureFormatter).reverse();
    let signature = null;
    for (const signatureFormatter of signatureFormatters) {
      signature = signatureFormatter.toWebSignature(algorithm2, this.signature);
      if (signature) {
        break;
      }
    }
    if (!signature) {
      throw Error("Cannot convert WebCrypto signature value to ASN.1 format");
    }
    const ok = await crypto3.subtle.verify(this.signatureAlgorithm, publicKey, signature, this.tbs);
    return ok;
  }
  toTextObject() {
    const obj = this.toTextObjectEmpty();
    const req = AsnConvert2.parse(this.rawData, CertificationRequest);
    const tbs = req.certificationRequestInfo;
    const data = new TextObject("", {
      Version: `${Version2[tbs.version]} (${tbs.version})`,
      Subject: this.subject,
      "Subject Public Key Info": this.publicKey
    });
    if (this.attributes.length) {
      const attrs = new TextObject("");
      for (const ext of this.attributes) {
        const attrObj = ext.toTextObject();
        attrs[attrObj[TextObject.NAME]] = attrObj;
      }
      data["Attributes"] = attrs;
    }
    obj["Data"] = data;
    obj["Signature"] = new TextObject("", {
      Algorithm: TextConverter.serializeAlgorithm(req.signatureAlgorithm),
      "": req.signature
    });
    return obj;
  }
}
_Pkcs10CertificateRequest_tbs = new WeakMap, _Pkcs10CertificateRequest_subjectName = new WeakMap, _Pkcs10CertificateRequest_subject = new WeakMap, _Pkcs10CertificateRequest_signatureAlgorithm = new WeakMap, _Pkcs10CertificateRequest_signature = new WeakMap, _Pkcs10CertificateRequest_publicKey = new WeakMap, _Pkcs10CertificateRequest_attributes = new WeakMap, _Pkcs10CertificateRequest_extensions = new WeakMap;
Pkcs10CertificateRequest.NAME = "PKCS#10 Certificate Request";
var _X509Certificate_tbs;
var _X509Certificate_serialNumber;
var _X509Certificate_subjectName;
var _X509Certificate_subject;
var _X509Certificate_issuerName;
var _X509Certificate_issuer;
var _X509Certificate_notBefore;
var _X509Certificate_notAfter;
var _X509Certificate_signatureAlgorithm;
var _X509Certificate_signature;
var _X509Certificate_extensions;
var _X509Certificate_publicKey;

class X509Certificate extends PemData {
  get publicKey() {
    if (!__classPrivateFieldGet(this, _X509Certificate_publicKey, "f")) {
      __classPrivateFieldSet(this, _X509Certificate_publicKey, new PublicKey(this.asn.tbsCertificate.subjectPublicKeyInfo), "f");
    }
    return __classPrivateFieldGet(this, _X509Certificate_publicKey, "f");
  }
  get serialNumber() {
    if (!__classPrivateFieldGet(this, _X509Certificate_serialNumber, "f")) {
      const tbs = this.asn.tbsCertificate;
      let serialNumberBytes = new Uint8Array(tbs.serialNumber);
      if (serialNumberBytes.length > 1 && serialNumberBytes[0] === 0 && serialNumberBytes[1] > 127) {
        serialNumberBytes = serialNumberBytes.slice(1);
      }
      __classPrivateFieldSet(this, _X509Certificate_serialNumber, Convert.ToHex(serialNumberBytes), "f");
    }
    return __classPrivateFieldGet(this, _X509Certificate_serialNumber, "f");
  }
  get subjectName() {
    if (!__classPrivateFieldGet(this, _X509Certificate_subjectName, "f")) {
      __classPrivateFieldSet(this, _X509Certificate_subjectName, new Name17(this.asn.tbsCertificate.subject), "f");
    }
    return __classPrivateFieldGet(this, _X509Certificate_subjectName, "f");
  }
  get subject() {
    if (!__classPrivateFieldGet(this, _X509Certificate_subject, "f")) {
      __classPrivateFieldSet(this, _X509Certificate_subject, this.subjectName.toString(), "f");
    }
    return __classPrivateFieldGet(this, _X509Certificate_subject, "f");
  }
  get issuerName() {
    if (!__classPrivateFieldGet(this, _X509Certificate_issuerName, "f")) {
      __classPrivateFieldSet(this, _X509Certificate_issuerName, new Name17(this.asn.tbsCertificate.issuer), "f");
    }
    return __classPrivateFieldGet(this, _X509Certificate_issuerName, "f");
  }
  get issuer() {
    if (!__classPrivateFieldGet(this, _X509Certificate_issuer, "f")) {
      __classPrivateFieldSet(this, _X509Certificate_issuer, this.issuerName.toString(), "f");
    }
    return __classPrivateFieldGet(this, _X509Certificate_issuer, "f");
  }
  get notBefore() {
    if (!__classPrivateFieldGet(this, _X509Certificate_notBefore, "f")) {
      const notBefore = this.asn.tbsCertificate.validity.notBefore.utcTime || this.asn.tbsCertificate.validity.notBefore.generalTime;
      if (!notBefore) {
        throw new Error("Cannot get 'notBefore' value");
      }
      __classPrivateFieldSet(this, _X509Certificate_notBefore, notBefore, "f");
    }
    return __classPrivateFieldGet(this, _X509Certificate_notBefore, "f");
  }
  get notAfter() {
    if (!__classPrivateFieldGet(this, _X509Certificate_notAfter, "f")) {
      const notAfter = this.asn.tbsCertificate.validity.notAfter.utcTime || this.asn.tbsCertificate.validity.notAfter.generalTime;
      if (!notAfter) {
        throw new Error("Cannot get 'notAfter' value");
      }
      __classPrivateFieldSet(this, _X509Certificate_notAfter, notAfter, "f");
    }
    return __classPrivateFieldGet(this, _X509Certificate_notAfter, "f");
  }
  get signatureAlgorithm() {
    if (!__classPrivateFieldGet(this, _X509Certificate_signatureAlgorithm, "f")) {
      const algProv = instance.resolve(diAlgorithmProvider);
      __classPrivateFieldSet(this, _X509Certificate_signatureAlgorithm, algProv.toWebAlgorithm(this.asn.signatureAlgorithm), "f");
    }
    return __classPrivateFieldGet(this, _X509Certificate_signatureAlgorithm, "f");
  }
  get signature() {
    if (!__classPrivateFieldGet(this, _X509Certificate_signature, "f")) {
      __classPrivateFieldSet(this, _X509Certificate_signature, this.asn.signatureValue, "f");
    }
    return __classPrivateFieldGet(this, _X509Certificate_signature, "f");
  }
  get extensions() {
    if (!__classPrivateFieldGet(this, _X509Certificate_extensions, "f")) {
      __classPrivateFieldSet(this, _X509Certificate_extensions, [], "f");
      if (this.asn.tbsCertificate.extensions) {
        __classPrivateFieldSet(this, _X509Certificate_extensions, this.asn.tbsCertificate.extensions.map((o) => ExtensionFactory.create(AsnConvert2.serialize(o))), "f");
      }
    }
    return __classPrivateFieldGet(this, _X509Certificate_extensions, "f");
  }
  get tbs() {
    if (!__classPrivateFieldGet(this, _X509Certificate_tbs, "f")) {
      __classPrivateFieldSet(this, _X509Certificate_tbs, this.asn.tbsCertificateRaw || AsnConvert2.serialize(this.asn.tbsCertificate), "f");
    }
    return __classPrivateFieldGet(this, _X509Certificate_tbs, "f");
  }
  constructor(param) {
    const args = PemData.isAsnEncoded(param) ? [param, Certificate2] : [param];
    super(args[0], args[1]);
    _X509Certificate_tbs.set(this, undefined);
    _X509Certificate_serialNumber.set(this, undefined);
    _X509Certificate_subjectName.set(this, undefined);
    _X509Certificate_subject.set(this, undefined);
    _X509Certificate_issuerName.set(this, undefined);
    _X509Certificate_issuer.set(this, undefined);
    _X509Certificate_notBefore.set(this, undefined);
    _X509Certificate_notAfter.set(this, undefined);
    _X509Certificate_signatureAlgorithm.set(this, undefined);
    _X509Certificate_signature.set(this, undefined);
    _X509Certificate_extensions.set(this, undefined);
    _X509Certificate_publicKey.set(this, undefined);
    this.tag = PemConverter.CertificateTag;
  }
  onInit(_asn) {}
  getExtension(type) {
    for (const ext of this.extensions) {
      if (typeof type === "string") {
        if (ext.type === type) {
          return ext;
        }
      } else {
        if (ext instanceof type) {
          return ext;
        }
      }
    }
    return null;
  }
  getExtensions(type) {
    return this.extensions.filter((o) => {
      if (typeof type === "string") {
        return o.type === type;
      } else {
        return o instanceof type;
      }
    });
  }
  async verify(params = {}, crypto3 = cryptoProvider.get()) {
    let keyAlgorithm;
    let publicKey;
    const paramsKey = params.publicKey;
    try {
      if (!paramsKey) {
        keyAlgorithm = { ...this.publicKey.algorithm, ...this.signatureAlgorithm };
        publicKey = await this.publicKey.export(keyAlgorithm, ["verify"], crypto3);
      } else if ("publicKey" in paramsKey) {
        keyAlgorithm = { ...paramsKey.publicKey.algorithm, ...this.signatureAlgorithm };
        publicKey = await paramsKey.publicKey.export(keyAlgorithm, ["verify"], crypto3);
      } else if (paramsKey instanceof PublicKey) {
        keyAlgorithm = { ...paramsKey.algorithm, ...this.signatureAlgorithm };
        publicKey = await paramsKey.export(keyAlgorithm, ["verify"], crypto3);
      } else if (BufferSourceConverter.isBufferSource(paramsKey)) {
        const key = new PublicKey(paramsKey);
        keyAlgorithm = { ...key.algorithm, ...this.signatureAlgorithm };
        publicKey = await key.export(keyAlgorithm, ["verify"], crypto3);
      } else {
        keyAlgorithm = { ...paramsKey.algorithm, ...this.signatureAlgorithm };
        publicKey = paramsKey;
      }
    } catch (_e) {
      return false;
    }
    const signatureFormatters = instance.resolveAll(diAsnSignatureFormatter).reverse();
    let signature = null;
    for (const signatureFormatter of signatureFormatters) {
      signature = signatureFormatter.toWebSignature(keyAlgorithm, this.signature);
      if (signature) {
        break;
      }
    }
    if (!signature) {
      throw Error("Cannot convert ASN.1 signature value to WebCrypto format");
    }
    const ok = await crypto3.subtle.verify(this.signatureAlgorithm, publicKey, signature, this.tbs);
    if (params.signatureOnly) {
      return ok;
    } else {
      const date = params.date || new Date;
      const time10 = date.getTime();
      return ok && this.notBefore.getTime() < time10 && time10 < this.notAfter.getTime();
    }
  }
  async getThumbprint(...args) {
    let crypto3;
    let algorithm2 = "SHA-1";
    if (args[0]) {
      if (!args[0].subtle) {
        algorithm2 = args[0] || algorithm2;
        crypto3 = args[1];
      } else {
        crypto3 = args[0];
      }
    }
    crypto3 !== null && crypto3 !== undefined || (crypto3 = cryptoProvider.get());
    return await crypto3.subtle.digest(algorithm2, this.rawData);
  }
  async isSelfSigned(crypto3 = cryptoProvider.get()) {
    return this.subject === this.issuer && await this.verify({ signatureOnly: true }, crypto3);
  }
  toTextObject() {
    const obj = this.toTextObjectEmpty();
    const cert = AsnConvert2.parse(this.rawData, Certificate2);
    const tbs = cert.tbsCertificate;
    const data = new TextObject("", {
      Version: `${Version2[tbs.version]} (${tbs.version})`,
      "Serial Number": tbs.serialNumber,
      "Signature Algorithm": TextConverter.serializeAlgorithm(tbs.signature),
      Issuer: this.issuer,
      Validity: new TextObject("", {
        "Not Before": tbs.validity.notBefore.getTime(),
        "Not After": tbs.validity.notAfter.getTime()
      }),
      Subject: this.subject,
      "Subject Public Key Info": this.publicKey
    });
    if (tbs.issuerUniqueID) {
      data["Issuer Unique ID"] = tbs.issuerUniqueID;
    }
    if (tbs.subjectUniqueID) {
      data["Subject Unique ID"] = tbs.subjectUniqueID;
    }
    if (this.extensions.length) {
      const extensions9 = new TextObject("");
      for (const ext of this.extensions) {
        const extObj = ext.toTextObject();
        extensions9[extObj[TextObject.NAME]] = extObj;
      }
      data["Extensions"] = extensions9;
    }
    obj["Data"] = data;
    obj["Signature"] = new TextObject("", {
      Algorithm: TextConverter.serializeAlgorithm(cert.signatureAlgorithm),
      "": cert.signatureValue
    });
    return obj;
  }
}
_X509Certificate_tbs = new WeakMap, _X509Certificate_serialNumber = new WeakMap, _X509Certificate_subjectName = new WeakMap, _X509Certificate_subject = new WeakMap, _X509Certificate_issuerName = new WeakMap, _X509Certificate_issuer = new WeakMap, _X509Certificate_notBefore = new WeakMap, _X509Certificate_notAfter = new WeakMap, _X509Certificate_signatureAlgorithm = new WeakMap, _X509Certificate_signature = new WeakMap, _X509Certificate_extensions = new WeakMap, _X509Certificate_publicKey = new WeakMap;
X509Certificate.NAME = "Certificate";
function generateCertificateSerialNumber(input, crypto3 = cryptoProvider.get()) {
  const inputView = BufferSourceConverter.toUint8Array(Convert.FromHex(input || ""));
  let serialNumber = inputView && inputView.length && inputView.some((o) => o > 0) ? new Uint8Array(inputView) : undefined;
  if (!serialNumber) {
    serialNumber = crypto3.getRandomValues(new Uint8Array(16));
  }
  let firstNonZero = 0;
  while (firstNonZero < serialNumber.length - 1 && serialNumber[firstNonZero] === 0) {
    firstNonZero++;
  }
  serialNumber = serialNumber.slice(firstNonZero);
  if (serialNumber[0] > 127) {
    const newSerialNumber = new Uint8Array(serialNumber.length + 1);
    newSerialNumber[0] = 0;
    newSerialNumber.set(serialNumber, 1);
    serialNumber = newSerialNumber;
  }
  return serialNumber.buffer;
}
var _X509CrlEntry_serialNumber;
var _X509CrlEntry_revocationDate;
var _X509CrlEntry_reason;
var _X509CrlEntry_invalidity;
var _X509CrlEntry_extensions;
var X509CrlReason;
(function(X509CrlReason2) {
  X509CrlReason2[X509CrlReason2["unspecified"] = 0] = "unspecified";
  X509CrlReason2[X509CrlReason2["keyCompromise"] = 1] = "keyCompromise";
  X509CrlReason2[X509CrlReason2["cACompromise"] = 2] = "cACompromise";
  X509CrlReason2[X509CrlReason2["affiliationChanged"] = 3] = "affiliationChanged";
  X509CrlReason2[X509CrlReason2["superseded"] = 4] = "superseded";
  X509CrlReason2[X509CrlReason2["cessationOfOperation"] = 5] = "cessationOfOperation";
  X509CrlReason2[X509CrlReason2["certificateHold"] = 6] = "certificateHold";
  X509CrlReason2[X509CrlReason2["removeFromCRL"] = 8] = "removeFromCRL";
  X509CrlReason2[X509CrlReason2["privilegeWithdrawn"] = 9] = "privilegeWithdrawn";
  X509CrlReason2[X509CrlReason2["aACompromise"] = 10] = "aACompromise";
})(X509CrlReason || (X509CrlReason = {}));

class X509CrlEntry extends AsnData {
  get serialNumber() {
    if (!__classPrivateFieldGet(this, _X509CrlEntry_serialNumber, "f")) {
      __classPrivateFieldSet(this, _X509CrlEntry_serialNumber, Convert.ToHex(this.asn.userCertificate), "f");
    }
    return __classPrivateFieldGet(this, _X509CrlEntry_serialNumber, "f");
  }
  get revocationDate() {
    if (!__classPrivateFieldGet(this, _X509CrlEntry_revocationDate, "f")) {
      __classPrivateFieldSet(this, _X509CrlEntry_revocationDate, this.asn.revocationDate.getTime(), "f");
    }
    return __classPrivateFieldGet(this, _X509CrlEntry_revocationDate, "f");
  }
  get reason() {
    if (__classPrivateFieldGet(this, _X509CrlEntry_reason, "f") === undefined) {
      this.extensions;
    }
    return __classPrivateFieldGet(this, _X509CrlEntry_reason, "f");
  }
  get invalidity() {
    if (__classPrivateFieldGet(this, _X509CrlEntry_invalidity, "f") === undefined) {
      this.extensions;
    }
    return __classPrivateFieldGet(this, _X509CrlEntry_invalidity, "f");
  }
  get extensions() {
    if (!__classPrivateFieldGet(this, _X509CrlEntry_extensions, "f")) {
      __classPrivateFieldSet(this, _X509CrlEntry_extensions, [], "f");
      if (this.asn.crlEntryExtensions) {
        __classPrivateFieldSet(this, _X509CrlEntry_extensions, this.asn.crlEntryExtensions.map((o) => {
          const extension9 = ExtensionFactory.create(AsnConvert2.serialize(o));
          switch (extension9.type) {
            case id_ce_cRLReasons2:
              if (__classPrivateFieldGet(this, _X509CrlEntry_reason, "f") === undefined) {
                __classPrivateFieldSet(this, _X509CrlEntry_reason, AsnConvert2.parse(extension9.value, CRLReason3).reason, "f");
              }
              break;
            case id_ce_invalidityDate2:
              if (__classPrivateFieldGet(this, _X509CrlEntry_invalidity, "f") === undefined) {
                __classPrivateFieldSet(this, _X509CrlEntry_invalidity, AsnConvert2.parse(extension9.value, InvalidityDate3).value, "f");
              }
              break;
          }
          return extension9;
        }), "f");
      }
    }
    return __classPrivateFieldGet(this, _X509CrlEntry_extensions, "f");
  }
  constructor(...args) {
    let raw2;
    if (BufferSourceConverter.isBufferSource(args[0])) {
      raw2 = BufferSourceConverter.toArrayBuffer(args[0]);
    } else if (typeof args[0] === "string") {
      raw2 = AsnConvert2.serialize(new RevokedCertificate2({
        userCertificate: generateCertificateSerialNumber(args[0]),
        revocationDate: new Time3(args[1]),
        crlEntryExtensions: args[2]
      }));
    } else if (args[0] instanceof RevokedCertificate2) {
      raw2 = args[0];
    }
    if (!raw2) {
      throw new TypeError("Cannot create X509CrlEntry instance. Wrong constructor arguments.");
    }
    super(raw2, RevokedCertificate2);
    _X509CrlEntry_serialNumber.set(this, undefined);
    _X509CrlEntry_revocationDate.set(this, undefined);
    _X509CrlEntry_reason.set(this, undefined);
    _X509CrlEntry_invalidity.set(this, undefined);
    _X509CrlEntry_extensions.set(this, undefined);
  }
  onInit(_asn) {}
}
_X509CrlEntry_serialNumber = new WeakMap, _X509CrlEntry_revocationDate = new WeakMap, _X509CrlEntry_reason = new WeakMap, _X509CrlEntry_invalidity = new WeakMap, _X509CrlEntry_extensions = new WeakMap;
var _X509Crl_tbs;
var _X509Crl_signatureAlgorithm;
var _X509Crl_issuerName;
var _X509Crl_thisUpdate;
var _X509Crl_nextUpdate;
var _X509Crl_entries;
var _X509Crl_extensions;

class X509Crl extends PemData {
  get version() {
    return this.asn.tbsCertList.version;
  }
  get signatureAlgorithm() {
    if (!__classPrivateFieldGet(this, _X509Crl_signatureAlgorithm, "f")) {
      const algProv = instance.resolve(diAlgorithmProvider);
      __classPrivateFieldSet(this, _X509Crl_signatureAlgorithm, algProv.toWebAlgorithm(this.asn.signatureAlgorithm), "f");
    }
    return __classPrivateFieldGet(this, _X509Crl_signatureAlgorithm, "f");
  }
  get signature() {
    return this.asn.signature;
  }
  get issuer() {
    return this.issuerName.toString();
  }
  get issuerName() {
    if (!__classPrivateFieldGet(this, _X509Crl_issuerName, "f")) {
      __classPrivateFieldSet(this, _X509Crl_issuerName, new Name17(this.asn.tbsCertList.issuer), "f");
    }
    return __classPrivateFieldGet(this, _X509Crl_issuerName, "f");
  }
  get thisUpdate() {
    if (!__classPrivateFieldGet(this, _X509Crl_thisUpdate, "f")) {
      const thisUpdate = this.asn.tbsCertList.thisUpdate.getTime();
      if (!thisUpdate) {
        throw new Error("Cannot get 'thisUpdate' value");
      }
      __classPrivateFieldSet(this, _X509Crl_thisUpdate, thisUpdate, "f");
    }
    return __classPrivateFieldGet(this, _X509Crl_thisUpdate, "f");
  }
  get nextUpdate() {
    var _a10;
    if (__classPrivateFieldGet(this, _X509Crl_nextUpdate, "f") === undefined) {
      __classPrivateFieldSet(this, _X509Crl_nextUpdate, ((_a10 = this.asn.tbsCertList.nextUpdate) === null || _a10 === undefined ? undefined : _a10.getTime()) || undefined, "f");
    }
    return __classPrivateFieldGet(this, _X509Crl_nextUpdate, "f");
  }
  get entries() {
    var _a10;
    if (!__classPrivateFieldGet(this, _X509Crl_entries, "f")) {
      __classPrivateFieldSet(this, _X509Crl_entries, ((_a10 = this.asn.tbsCertList.revokedCertificates) === null || _a10 === undefined ? undefined : _a10.map((o) => new X509CrlEntry(o))) || [], "f");
    }
    return __classPrivateFieldGet(this, _X509Crl_entries, "f");
  }
  get extensions() {
    if (!__classPrivateFieldGet(this, _X509Crl_extensions, "f")) {
      __classPrivateFieldSet(this, _X509Crl_extensions, [], "f");
      if (this.asn.tbsCertList.crlExtensions) {
        __classPrivateFieldSet(this, _X509Crl_extensions, this.asn.tbsCertList.crlExtensions.map((o) => ExtensionFactory.create(AsnConvert2.serialize(o))), "f");
      }
    }
    return __classPrivateFieldGet(this, _X509Crl_extensions, "f");
  }
  get tbs() {
    if (!__classPrivateFieldGet(this, _X509Crl_tbs, "f")) {
      __classPrivateFieldSet(this, _X509Crl_tbs, this.asn.tbsCertListRaw || AsnConvert2.serialize(this.asn.tbsCertList), "f");
    }
    return __classPrivateFieldGet(this, _X509Crl_tbs, "f");
  }
  get tbsCertListSignatureAlgorithm() {
    return this.asn.tbsCertList.signature;
  }
  get certListSignatureAlgorithm() {
    return this.asn.signatureAlgorithm;
  }
  constructor(param) {
    super(param, PemData.isAsnEncoded(param) ? CertificateList2 : undefined);
    this.tag = PemConverter.CrlTag;
    _X509Crl_tbs.set(this, undefined);
    _X509Crl_signatureAlgorithm.set(this, undefined);
    _X509Crl_issuerName.set(this, undefined);
    _X509Crl_thisUpdate.set(this, undefined);
    _X509Crl_nextUpdate.set(this, undefined);
    _X509Crl_entries.set(this, undefined);
    _X509Crl_extensions.set(this, undefined);
  }
  onInit(_asn) {}
  getExtension(type) {
    for (const ext of this.extensions) {
      if (typeof type === "string") {
        if (ext.type === type) {
          return ext;
        }
      } else {
        if (ext instanceof type) {
          return ext;
        }
      }
    }
    return null;
  }
  getExtensions(type) {
    return this.extensions.filter((o) => {
      if (typeof type === "string") {
        return o.type === type;
      } else {
        return o instanceof type;
      }
    });
  }
  async verify(params, crypto3 = cryptoProvider.get()) {
    if (!this.certListSignatureAlgorithm.isEqual(this.tbsCertListSignatureAlgorithm)) {
      throw new Error("algorithm identifier in the sequence tbsCertList and CertificateList mismatch");
    }
    let keyAlgorithm;
    let publicKey;
    const paramsKey = params.publicKey;
    try {
      if (paramsKey instanceof X509Certificate) {
        keyAlgorithm = {
          ...paramsKey.publicKey.algorithm,
          ...paramsKey.signatureAlgorithm
        };
        publicKey = await paramsKey.publicKey.export(keyAlgorithm, ["verify"]);
      } else if (paramsKey instanceof PublicKey) {
        keyAlgorithm = { ...paramsKey.algorithm, ...this.signatureAlgorithm };
        publicKey = await paramsKey.export(keyAlgorithm, ["verify"]);
      } else {
        keyAlgorithm = { ...paramsKey.algorithm, ...this.signatureAlgorithm };
        publicKey = paramsKey;
      }
    } catch (_e) {
      return false;
    }
    const signatureFormatters = instance.resolveAll(diAsnSignatureFormatter).reverse();
    let signature = null;
    for (const signatureFormatter of signatureFormatters) {
      signature = signatureFormatter.toWebSignature(keyAlgorithm, this.signature);
      if (signature) {
        break;
      }
    }
    if (!signature) {
      throw Error("Cannot convert ASN.1 signature value to WebCrypto format");
    }
    return await crypto3.subtle.verify(this.signatureAlgorithm, publicKey, signature, this.tbs);
  }
  async getThumbprint(...args) {
    let crypto3;
    let algorithm2 = "SHA-1";
    if (args[0]) {
      if (!args[0].subtle) {
        algorithm2 = args[0] || algorithm2;
        crypto3 = args[1];
      } else {
        crypto3 = args[0];
      }
    }
    crypto3 !== null && crypto3 !== undefined || (crypto3 = cryptoProvider.get());
    return await crypto3.subtle.digest(algorithm2, this.rawData);
  }
  findRevoked(certOrSerialNumber) {
    const serialNumber = typeof certOrSerialNumber === "string" ? certOrSerialNumber : certOrSerialNumber.serialNumber;
    const serialBuffer = generateCertificateSerialNumber(serialNumber);
    for (const revoked of this.asn.tbsCertList.revokedCertificates || []) {
      if (BufferSourceConverter.isEqual(revoked.userCertificate, serialBuffer)) {
        return new X509CrlEntry(AsnConvert2.serialize(revoked));
      }
    }
    return null;
  }
}
_X509Crl_tbs = new WeakMap, _X509Crl_signatureAlgorithm = new WeakMap, _X509Crl_issuerName = new WeakMap, _X509Crl_thisUpdate = new WeakMap, _X509Crl_nextUpdate = new WeakMap, _X509Crl_entries = new WeakMap, _X509Crl_extensions = new WeakMap;
ExtensionFactory.register(id_ce_basicConstraints2, BasicConstraintsExtension);
ExtensionFactory.register(id_ce_extKeyUsage2, ExtendedKeyUsageExtension);
ExtensionFactory.register(id_ce_keyUsage2, KeyUsagesExtension);
ExtensionFactory.register(id_ce_subjectKeyIdentifier2, SubjectKeyIdentifierExtension);
ExtensionFactory.register(id_ce_authorityKeyIdentifier2, AuthorityKeyIdentifierExtension);
ExtensionFactory.register(id_ce_subjectAltName2, SubjectAlternativeNameExtension);
ExtensionFactory.register(id_ce_cRLDistributionPoints2, CRLDistributionPointsExtension);
ExtensionFactory.register(id_pe_authorityInfoAccess2, AuthorityInfoAccessExtension);
ExtensionFactory.register(id_ce_issuerAltName2, IssuerAlternativeNameExtension);
AttributeFactory.register(id_pkcs9_at_challengePassword, ChallengePasswordAttribute);
AttributeFactory.register(id_pkcs9_at_extensionRequest, ExtensionsAttribute);
instance.registerSingleton(diAsnSignatureFormatter, AsnDefaultSignatureFormatter);
instance.registerSingleton(diAsnSignatureFormatter, AsnEcSignatureFormatter);
AsnEcSignatureFormatter.namedCurveSize.set("P-256", 32);
AsnEcSignatureFormatter.namedCurveSize.set("K-256", 32);
AsnEcSignatureFormatter.namedCurveSize.set("P-384", 48);
AsnEcSignatureFormatter.namedCurveSize.set("P-521", 66);

// node_modules/@simplewebauthn/server/esm/helpers/fetch.js
function fetch(url) {
  return _fetchInternals.stubThis(url);
}
var _fetchInternals = {
  stubThis: (url) => globalThis.fetch(url)
};

// node_modules/@simplewebauthn/server/esm/helpers/isCertRevoked.js
var cacheRevokedCerts = {};
async function isCertRevoked(cert) {
  const { extensions: extensions9 } = cert;
  if (!extensions9) {
    return false;
  }
  let extAuthorityKeyID;
  let extSubjectKeyID;
  let extCRLDistributionPoints;
  extensions9.forEach((ext) => {
    if (ext instanceof AuthorityKeyIdentifierExtension) {
      extAuthorityKeyID = ext;
    } else if (ext instanceof SubjectKeyIdentifierExtension) {
      extSubjectKeyID = ext;
    } else if (ext instanceof CRLDistributionPointsExtension) {
      extCRLDistributionPoints = ext;
    }
  });
  let keyIdentifier = undefined;
  if (extAuthorityKeyID && extAuthorityKeyID.keyId) {
    keyIdentifier = extAuthorityKeyID.keyId;
  } else if (extSubjectKeyID) {
    keyIdentifier = extSubjectKeyID.keyId;
  }
  if (keyIdentifier) {
    const cached = cacheRevokedCerts[keyIdentifier];
    if (cached) {
      const now = new Date;
      if (!cached.nextUpdate || cached.nextUpdate > now) {
        return cached.revokedCerts.indexOf(cert.serialNumber) >= 0;
      }
    }
  }
  const crlURL = extCRLDistributionPoints?.distributionPoints?.[0].distributionPoint?.fullName?.[0].uniformResourceIdentifier;
  if (!crlURL) {
    return false;
  }
  let certListBytes;
  try {
    const respCRL = await fetch(crlURL);
    certListBytes = await respCRL.arrayBuffer();
  } catch (_err) {
    return false;
  }
  let data;
  try {
    data = new X509Crl(certListBytes);
  } catch (_err) {
    return false;
  }
  const newCached = {
    revokedCerts: [],
    nextUpdate: undefined
  };
  if (data.nextUpdate) {
    newCached.nextUpdate = data.nextUpdate;
  }
  const revokedCerts = data.entries;
  if (revokedCerts) {
    for (const cert2 of revokedCerts) {
      const revokedHex = cert2.serialNumber;
      newCached.revokedCerts.push(revokedHex);
    }
    if (keyIdentifier) {
      cacheRevokedCerts[keyIdentifier] = newCached;
    }
    return newCached.revokedCerts.indexOf(cert.serialNumber) >= 0;
  }
  return false;
}
// node_modules/@simplewebauthn/server/esm/helpers/decodeAuthenticatorExtensions.js
function decodeAuthenticatorExtensions(extensionData) {
  let toCBOR;
  try {
    toCBOR = exports_isoCBOR.decodeFirst(extensionData);
  } catch (err) {
    const _err = err;
    throw new Error(`Error decoding authenticator extensions: ${_err.message}`);
  }
  return convertMapToObjectDeep(toCBOR);
}
function convertMapToObjectDeep(input) {
  const mapped = {};
  for (const [key, value] of input) {
    if (value instanceof Map) {
      mapped[key] = convertMapToObjectDeep(value);
    } else {
      mapped[key] = value;
    }
  }
  return mapped;
}

// node_modules/@simplewebauthn/server/esm/helpers/parseAuthenticatorData.js
function parseAuthenticatorData(authData) {
  if (authData.byteLength < 37) {
    throw new Error(`Authenticator data was ${authData.byteLength} bytes, expected at least 37 bytes`);
  }
  let pointer = 0;
  const dataView = exports_isoUint8Array.toDataView(authData);
  const rpIdHash = authData.slice(pointer, pointer += 32);
  const flagsBuf = authData.slice(pointer, pointer += 1);
  const flagsInt = flagsBuf[0];
  const flags = {
    up: !!(flagsInt & 1 << 0),
    uv: !!(flagsInt & 1 << 2),
    be: !!(flagsInt & 1 << 3),
    bs: !!(flagsInt & 1 << 4),
    at: !!(flagsInt & 1 << 6),
    ed: !!(flagsInt & 1 << 7),
    flagsInt
  };
  const counterBuf = authData.slice(pointer, pointer + 4);
  const counter = dataView.getUint32(pointer, false);
  pointer += 4;
  let aaguid = undefined;
  let credentialID = undefined;
  let credentialPublicKey = undefined;
  if (flags.at) {
    aaguid = authData.slice(pointer, pointer += 16);
    const credIDLen = dataView.getUint16(pointer);
    pointer += 2;
    credentialID = authData.slice(pointer, pointer += credIDLen);
    const badEdDSACBOR = exports_isoUint8Array.fromHex("a301634f4b500327206745643235353139");
    const bytesAtCurrentPosition = authData.slice(pointer, pointer + badEdDSACBOR.byteLength);
    let foundBadCBOR = false;
    if (exports_isoUint8Array.areEqual(badEdDSACBOR, bytesAtCurrentPosition)) {
      foundBadCBOR = true;
      authData[pointer] = 164;
    }
    const firstDecoded = exports_isoCBOR.decodeFirst(authData.slice(pointer));
    const firstEncoded = Uint8Array.from(exports_isoCBOR.encode(firstDecoded));
    if (foundBadCBOR) {
      authData[pointer] = 163;
    }
    credentialPublicKey = firstEncoded;
    pointer += firstEncoded.byteLength;
  }
  let extensionsData = undefined;
  let extensionsDataBuffer = undefined;
  if (flags.ed) {
    const firstDecoded = exports_isoCBOR.decodeFirst(authData.slice(pointer));
    extensionsDataBuffer = Uint8Array.from(exports_isoCBOR.encode(firstDecoded));
    extensionsData = decodeAuthenticatorExtensions(extensionsDataBuffer);
    pointer += extensionsDataBuffer.byteLength;
  }
  if (authData.byteLength > pointer) {
    throw new Error("Leftover bytes detected while parsing authenticator data");
  }
  return _parseAuthenticatorDataInternals.stubThis({
    rpIdHash,
    flagsBuf,
    flags,
    counter,
    counterBuf,
    aaguid,
    credentialID,
    credentialPublicKey,
    extensionsData,
    extensionsDataBuffer
  });
}
var _parseAuthenticatorDataInternals = {
  stubThis: (value) => value
};
// node_modules/@simplewebauthn/server/esm/helpers/toHash.js
function toHash(data, algorithm2 = -7) {
  if (typeof data === "string") {
    data = exports_isoUint8Array.fromUTF8String(data);
  }
  const digest2 = exports_isoCrypto.digest(data, algorithm2);
  return digest2;
}
// node_modules/@simplewebauthn/server/esm/helpers/validateCertificatePath.js
async function validateCertificatePath(x5cCertsPEM, trustAnchorsPEM = []) {
  if (trustAnchorsPEM.length === 0) {
    return true;
  }
  const WebCrypto = await getWebCrypto();
  const x5cCertsParsed = x5cCertsPEM.map((certPEM) => new X509Certificate(certPEM));
  for (let i = 0;i < x5cCertsParsed.length; i++) {
    const cert = x5cCertsParsed[i];
    const certPEM = x5cCertsPEM[i];
    try {
      await assertCertNotRevoked(cert);
    } catch (_err) {
      throw new Error(`Found revoked certificate in x5c:
${certPEM}`);
    }
    try {
      assertCertIsWithinValidTimeWindow(cert.notBefore, cert.notAfter);
    } catch (_err) {
      throw new Error(`Found certificate out of validity period in x5c:
${certPEM}`);
    }
  }
  const trustAnchorsParsed = trustAnchorsPEM.map((certPEM) => {
    try {
      return new X509Certificate(certPEM);
    } catch (err) {
      const _err = err;
      throw new Error(`Could not parse trust anchor certificate:
${certPEM}`, { cause: _err });
    }
  });
  const validTrustAnchors = [];
  for (let i = 0;i < trustAnchorsParsed.length; i++) {
    const cert = trustAnchorsParsed[i];
    try {
      await assertCertNotRevoked(cert);
    } catch (_err) {
      continue;
    }
    try {
      assertCertIsWithinValidTimeWindow(cert.notBefore, cert.notAfter);
    } catch (_err) {
      continue;
    }
    validTrustAnchors.push(cert);
  }
  if (validTrustAnchors.length === 0) {
    throw new Error("No specified trust anchor was valid for verifying x5c");
  }
  let invalidSubjectAndIssuerError = false;
  for (const anchor of trustAnchorsParsed) {
    try {
      const x5cWithTrustAnchor = x5cCertsParsed.concat([anchor]);
      if (new Set(x5cWithTrustAnchor).size !== x5cWithTrustAnchor.length) {
        throw new Error("Invalid certificate path: found duplicate certificates");
      }
      for (let i = 0;i < x5cWithTrustAnchor.length - 1; i++) {
        const subject = x5cWithTrustAnchor[i];
        const issuer = x5cWithTrustAnchor[i + 1];
        const issuerSignedSubject = await subject.verify({ publicKey: issuer.publicKey, signatureOnly: true }, WebCrypto);
        if (!issuerSignedSubject) {
          throw new InvalidSubjectAndIssuer;
        }
        if (issuer.subject === issuer.issuer) {
          const issuerSignedIssuer = await issuer.verify({ publicKey: issuer.publicKey, signatureOnly: true }, WebCrypto);
          if (!issuerSignedIssuer) {
            throw new InvalidSubjectAndIssuer;
          }
          break;
        }
      }
      invalidSubjectAndIssuerError = false;
      break;
    } catch (err) {
      if (err instanceof InvalidSubjectAndIssuer) {
        invalidSubjectAndIssuerError = true;
      } else {
        throw new Error("Unexpected error while validating certificate path", { cause: err });
      }
    }
  }
  if (invalidSubjectAndIssuerError) {
    throw new InvalidSubjectAndIssuer;
  }
  return true;
}
async function assertCertNotRevoked(certificate9) {
  const subjectCertRevoked = await isCertRevoked(certificate9);
  if (subjectCertRevoked) {
    throw new Error("Found revoked certificate in certificate path");
  }
}
function assertCertIsWithinValidTimeWindow(certNotBefore, certNotAfter) {
  const now = new Date(Date.now());
  if (certNotBefore > now || certNotAfter < now) {
    throw new Error("Certificate is not yet valid or expired");
  }
}

class InvalidSubjectAndIssuer extends Error {
  constructor() {
    const message = "Subject issuer did not match issuer subject";
    super(message);
    this.name = "InvalidSubjectAndIssuer";
  }
}
// node_modules/@peculiar/asn1-ecc/build/es2015/object_identifiers.js
var id_ecPublicKey2 = "1.2.840.10045.2.1";
var id_ecdsaWithSHA12 = "1.2.840.10045.4.1";
var id_ecdsaWithSHA2242 = "1.2.840.10045.4.3.1";
var id_ecdsaWithSHA2562 = "1.2.840.10045.4.3.2";
var id_ecdsaWithSHA3842 = "1.2.840.10045.4.3.3";
var id_ecdsaWithSHA5122 = "1.2.840.10045.4.3.4";
var id_secp256r12 = "1.2.840.10045.3.1.7";
var id_secp384r12 = "1.3.132.0.34";

// node_modules/@peculiar/asn1-ecc/build/es2015/algorithms.js
function create4(algorithm2) {
  return new AlgorithmIdentifier({ algorithm: algorithm2 });
}
var ecdsaWithSHA12 = create4(id_ecdsaWithSHA12);
var ecdsaWithSHA2242 = create4(id_ecdsaWithSHA2242);
var ecdsaWithSHA2562 = create4(id_ecdsaWithSHA2562);
var ecdsaWithSHA3842 = create4(id_ecdsaWithSHA3842);
var ecdsaWithSHA5122 = create4(id_ecdsaWithSHA5122);
// node_modules/@peculiar/asn1-ecc/build/es2015/rfc3279.js
var FieldID3 = class FieldID4 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], FieldID3.prototype, "fieldType", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Any })
], FieldID3.prototype, "parameters", undefined);
FieldID3 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence })
], FieldID3);
class ECPoint2 extends OctetString2 {
}
var Curve3 = class Curve4 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.OctetString })
], Curve3.prototype, "a", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.OctetString })
], Curve3.prototype, "b", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.BitString, optional: true })
], Curve3.prototype, "seed", undefined);
Curve3 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence })
], Curve3);
var ECPVer2;
(function(ECPVer3) {
  ECPVer3[ECPVer3["ecpVer1"] = 1] = "ecpVer1";
})(ECPVer2 || (ECPVer2 = {}));
var SpecifiedECDomain3 = class SpecifiedECDomain4 {
  constructor(params = {}) {
    this.version = ECPVer2.ecpVer1;
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], SpecifiedECDomain3.prototype, "version", undefined);
__decorate([
  AsnProp({ type: FieldID3 })
], SpecifiedECDomain3.prototype, "fieldID", undefined);
__decorate([
  AsnProp({ type: Curve3 })
], SpecifiedECDomain3.prototype, "curve", undefined);
__decorate([
  AsnProp({ type: ECPoint2 })
], SpecifiedECDomain3.prototype, "base", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], SpecifiedECDomain3.prototype, "order", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, optional: true })
], SpecifiedECDomain3.prototype, "cofactor", undefined);
SpecifiedECDomain3 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence })
], SpecifiedECDomain3);

// node_modules/@peculiar/asn1-ecc/build/es2015/ec_parameters.js
var ECParameters3 = class ECParameters4 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], ECParameters3.prototype, "namedCurve", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Null })
], ECParameters3.prototype, "implicitCurve", undefined);
__decorate([
  AsnProp({ type: SpecifiedECDomain3 })
], ECParameters3.prototype, "specifiedCurve", undefined);
ECParameters3 = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], ECParameters3);
// node_modules/@peculiar/asn1-ecc/build/es2015/ec_private_key.js
class ECPrivateKey2 {
  constructor(params = {}) {
    this.version = 1;
    this.privateKey = new OctetString2;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], ECPrivateKey2.prototype, "version", undefined);
__decorate([
  AsnProp({ type: OctetString2 })
], ECPrivateKey2.prototype, "privateKey", undefined);
__decorate([
  AsnProp({ type: ECParameters3, context: 0, optional: true })
], ECPrivateKey2.prototype, "parameters", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.BitString, context: 1, optional: true })
], ECPrivateKey2.prototype, "publicKey", undefined);
// node_modules/@peculiar/asn1-ecc/build/es2015/ec_signature_value.js
class ECDSASigValue2 {
  constructor(params = {}) {
    this.r = new ArrayBuffer(0);
    this.s = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], ECDSASigValue2.prototype, "r", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], ECDSASigValue2.prototype, "s", undefined);
// node_modules/@peculiar/asn1-rsa/build/es2015/object_identifiers.js
var id_pkcs_15 = "1.2.840.113549.1.1";
var id_rsaEncryption3 = `${id_pkcs_15}.1`;
var id_RSAES_OAEP3 = `${id_pkcs_15}.7`;
var id_pSpecified3 = `${id_pkcs_15}.9`;
var id_RSASSA_PSS3 = `${id_pkcs_15}.10`;
var id_md2WithRSAEncryption3 = `${id_pkcs_15}.2`;
var id_md5WithRSAEncryption3 = `${id_pkcs_15}.4`;
var id_sha1WithRSAEncryption3 = `${id_pkcs_15}.5`;
var id_sha224WithRSAEncryption3 = `${id_pkcs_15}.14`;
var id_sha256WithRSAEncryption3 = `${id_pkcs_15}.11`;
var id_sha384WithRSAEncryption3 = `${id_pkcs_15}.12`;
var id_sha512WithRSAEncryption3 = `${id_pkcs_15}.13`;
var id_sha512_224WithRSAEncryption3 = `${id_pkcs_15}.15`;
var id_sha512_256WithRSAEncryption3 = `${id_pkcs_15}.16`;
var id_sha13 = "1.3.14.3.2.26";
var id_sha2243 = "2.16.840.1.101.3.4.2.4";
var id_sha2563 = "2.16.840.1.101.3.4.2.1";
var id_sha3843 = "2.16.840.1.101.3.4.2.2";
var id_sha5123 = "2.16.840.1.101.3.4.2.3";
var id_sha512_2243 = "2.16.840.1.101.3.4.2.5";
var id_sha512_2563 = "2.16.840.1.101.3.4.2.6";
var id_md23 = "1.2.840.113549.2.2";
var id_md53 = "1.2.840.113549.2.5";
var id_mgf13 = `${id_pkcs_15}.8`;

// node_modules/@peculiar/asn1-rsa/build/es2015/algorithms.js
function create5(algorithm2) {
  return new AlgorithmIdentifier({ algorithm: algorithm2, parameters: null });
}
var md23 = create5(id_md23);
var md43 = create5(id_md53);
var sha13 = create5(id_sha13);
var sha2243 = create5(id_sha2243);
var sha2563 = create5(id_sha2563);
var sha3843 = create5(id_sha3843);
var sha5123 = create5(id_sha5123);
var sha512_2243 = create5(id_sha512_2243);
var sha512_2563 = create5(id_sha512_2563);
var mgf1SHA13 = new AlgorithmIdentifier({
  algorithm: id_mgf13,
  parameters: AsnConvert.serialize(sha13)
});
var pSpecifiedEmpty3 = new AlgorithmIdentifier({
  algorithm: id_pSpecified3,
  parameters: AsnConvert.serialize(AsnOctetStringConverter.toASN(new Uint8Array([218, 57, 163, 238, 94, 107, 75, 13, 50, 85, 191, 239, 149, 96, 24, 144, 175, 216, 7, 9]).buffer))
});
var rsaEncryption3 = create5(id_rsaEncryption3);
var md2WithRSAEncryption3 = create5(id_md2WithRSAEncryption3);
var md5WithRSAEncryption3 = create5(id_md5WithRSAEncryption3);
var sha1WithRSAEncryption3 = create5(id_sha1WithRSAEncryption3);
var sha224WithRSAEncryption3 = create5(id_sha512_224WithRSAEncryption3);
var sha256WithRSAEncryption3 = create5(id_sha512_256WithRSAEncryption3);
var sha384WithRSAEncryption3 = create5(id_sha384WithRSAEncryption3);
var sha512WithRSAEncryption3 = create5(id_sha512WithRSAEncryption3);
var sha512_224WithRSAEncryption3 = create5(id_sha512_224WithRSAEncryption3);
var sha512_256WithRSAEncryption3 = create5(id_sha512_256WithRSAEncryption3);

// node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsaes_oaep.js
class RsaEsOaepParams3 {
  constructor(params = {}) {
    this.hashAlgorithm = new AlgorithmIdentifier(sha13);
    this.maskGenAlgorithm = new AlgorithmIdentifier({
      algorithm: id_mgf13,
      parameters: AsnConvert.serialize(sha13)
    });
    this.pSourceAlgorithm = new AlgorithmIdentifier(pSpecifiedEmpty3);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AlgorithmIdentifier, context: 0, defaultValue: sha13 })
], RsaEsOaepParams3.prototype, "hashAlgorithm", undefined);
__decorate([
  AsnProp({ type: AlgorithmIdentifier, context: 1, defaultValue: mgf1SHA13 })
], RsaEsOaepParams3.prototype, "maskGenAlgorithm", undefined);
__decorate([
  AsnProp({ type: AlgorithmIdentifier, context: 2, defaultValue: pSpecifiedEmpty3 })
], RsaEsOaepParams3.prototype, "pSourceAlgorithm", undefined);
var RSAES_OAEP3 = new AlgorithmIdentifier({
  algorithm: id_RSAES_OAEP3,
  parameters: AsnConvert.serialize(new RsaEsOaepParams3)
});
// node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pss.js
class RsaSaPssParams3 {
  constructor(params = {}) {
    this.hashAlgorithm = new AlgorithmIdentifier(sha13);
    this.maskGenAlgorithm = new AlgorithmIdentifier({
      algorithm: id_mgf13,
      parameters: AsnConvert.serialize(sha13)
    });
    this.saltLength = 20;
    this.trailerField = 1;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AlgorithmIdentifier, context: 0, defaultValue: sha13 })
], RsaSaPssParams3.prototype, "hashAlgorithm", undefined);
__decorate([
  AsnProp({ type: AlgorithmIdentifier, context: 1, defaultValue: mgf1SHA13 })
], RsaSaPssParams3.prototype, "maskGenAlgorithm", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, context: 2, defaultValue: 20 })
], RsaSaPssParams3.prototype, "saltLength", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, context: 3, defaultValue: 1 })
], RsaSaPssParams3.prototype, "trailerField", undefined);
var RSASSA_PSS3 = new AlgorithmIdentifier({
  algorithm: id_RSASSA_PSS3,
  parameters: AsnConvert.serialize(new RsaSaPssParams3)
});
// node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pkcs1_v1_5.js
class DigestInfo3 {
  constructor(params = {}) {
    this.digestAlgorithm = new AlgorithmIdentifier;
    this.digest = new OctetString2;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AlgorithmIdentifier })
], DigestInfo3.prototype, "digestAlgorithm", undefined);
__decorate([
  AsnProp({ type: OctetString2 })
], DigestInfo3.prototype, "digest", undefined);
// node_modules/@peculiar/asn1-rsa/build/es2015/other_prime_info.js
var OtherPrimeInfos_13;

class OtherPrimeInfo3 {
  constructor(params = {}) {
    this.prime = new ArrayBuffer(0);
    this.exponent = new ArrayBuffer(0);
    this.coefficient = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], OtherPrimeInfo3.prototype, "prime", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], OtherPrimeInfo3.prototype, "exponent", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], OtherPrimeInfo3.prototype, "coefficient", undefined);
var OtherPrimeInfos5 = OtherPrimeInfos_13 = class OtherPrimeInfos6 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, OtherPrimeInfos_13.prototype);
  }
};
OtherPrimeInfos5 = OtherPrimeInfos_13 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: OtherPrimeInfo3 })
], OtherPrimeInfos5);
// node_modules/@peculiar/asn1-rsa/build/es2015/rsa_private_key.js
class RSAPrivateKey3 {
  constructor(params = {}) {
    this.version = 0;
    this.modulus = new ArrayBuffer(0);
    this.publicExponent = new ArrayBuffer(0);
    this.privateExponent = new ArrayBuffer(0);
    this.prime1 = new ArrayBuffer(0);
    this.prime2 = new ArrayBuffer(0);
    this.exponent1 = new ArrayBuffer(0);
    this.exponent2 = new ArrayBuffer(0);
    this.coefficient = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], RSAPrivateKey3.prototype, "version", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey3.prototype, "modulus", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey3.prototype, "publicExponent", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey3.prototype, "privateExponent", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey3.prototype, "prime1", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey3.prototype, "prime2", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey3.prototype, "exponent1", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey3.prototype, "exponent2", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey3.prototype, "coefficient", undefined);
__decorate([
  AsnProp({ type: OtherPrimeInfos5, optional: true })
], RSAPrivateKey3.prototype, "otherPrimeInfos", undefined);
// node_modules/@peculiar/asn1-rsa/build/es2015/rsa_public_key.js
class RSAPublicKey3 {
  constructor(params = {}) {
    this.modulus = new ArrayBuffer(0);
    this.publicExponent = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPublicKey3.prototype, "modulus", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPublicKey3.prototype, "publicExponent", undefined);
// node_modules/@simplewebauthn/server/esm/helpers/mapX509SignatureAlgToCOSEAlg.js
function mapX509SignatureAlgToCOSEAlg(signatureAlgorithm) {
  let alg;
  if (signatureAlgorithm === "1.2.840.10045.4.3.2") {
    alg = COSEALG.ES256;
  } else if (signatureAlgorithm === "1.2.840.10045.4.3.3") {
    alg = COSEALG.ES384;
  } else if (signatureAlgorithm === "1.2.840.10045.4.3.4") {
    alg = COSEALG.ES512;
  } else if (signatureAlgorithm === "1.2.840.113549.1.1.11") {
    alg = COSEALG.RS256;
  } else if (signatureAlgorithm === "1.2.840.113549.1.1.12") {
    alg = COSEALG.RS384;
  } else if (signatureAlgorithm === "1.2.840.113549.1.1.13") {
    alg = COSEALG.RS512;
  } else if (signatureAlgorithm === "1.2.840.113549.1.1.5") {
    alg = COSEALG.RS1;
  } else {
    throw new Error(`Unable to map X.509 signature algorithm ${signatureAlgorithm} to a COSE algorithm`);
  }
  return alg;
}

// node_modules/@simplewebauthn/server/esm/helpers/convertX509PublicKeyToCOSE.js
function convertX509PublicKeyToCOSE(x509Certificate) {
  let cosePublicKey = new Map;
  const x509 = AsnParser.parse(x509Certificate, Certificate);
  const { tbsCertificate } = x509;
  const { subjectPublicKeyInfo, signature: _tbsSignature } = tbsCertificate;
  const signatureAlgorithm = _tbsSignature.algorithm;
  const publicKeyAlgorithmID = subjectPublicKeyInfo.algorithm.algorithm;
  if (publicKeyAlgorithmID === id_ecPublicKey2) {
    if (!subjectPublicKeyInfo.algorithm.parameters) {
      throw new Error("Certificate public key was missing parameters (EC2)");
    }
    const ecParameters = AsnParser.parse(new Uint8Array(subjectPublicKeyInfo.algorithm.parameters), ECParameters3);
    let crv = -999;
    const { namedCurve } = ecParameters;
    if (namedCurve === id_secp256r12) {
      crv = COSECRV.P256;
    } else if (namedCurve === id_secp384r12) {
      crv = COSECRV.P384;
    } else {
      throw new Error(`Certificate public key contained unexpected namedCurve ${namedCurve} (EC2)`);
    }
    const subjectPublicKey = new Uint8Array(subjectPublicKeyInfo.subjectPublicKey);
    let x;
    let y;
    if (subjectPublicKey[0] === 4) {
      let pointer = 1;
      const halfLength = (subjectPublicKey.length - 1) / 2;
      x = subjectPublicKey.slice(pointer, pointer += halfLength);
      y = subjectPublicKey.slice(pointer);
    } else {
      throw new Error('TODO: Figure out how to handle public keys in "compressed form"');
    }
    const coseEC2PubKey = new Map;
    coseEC2PubKey.set(COSEKEYS.kty, COSEKTY.EC2);
    coseEC2PubKey.set(COSEKEYS.alg, mapX509SignatureAlgToCOSEAlg(signatureAlgorithm));
    coseEC2PubKey.set(COSEKEYS.crv, crv);
    coseEC2PubKey.set(COSEKEYS.x, x);
    coseEC2PubKey.set(COSEKEYS.y, y);
    cosePublicKey = coseEC2PubKey;
  } else if (publicKeyAlgorithmID === id_rsaEncryption3) {
    const rsaPublicKey = AsnParser.parse(subjectPublicKeyInfo.subjectPublicKey, RSAPublicKey3);
    const coseRSAPubKey = new Map;
    coseRSAPubKey.set(COSEKEYS.kty, COSEKTY.RSA);
    coseRSAPubKey.set(COSEKEYS.alg, mapX509SignatureAlgToCOSEAlg(signatureAlgorithm));
    coseRSAPubKey.set(COSEKEYS.n, new Uint8Array(rsaPublicKey.modulus));
    coseRSAPubKey.set(COSEKEYS.e, new Uint8Array(rsaPublicKey.publicExponent));
    cosePublicKey = coseRSAPubKey;
  } else {
    throw new Error(`Certificate public key contained unexpected algorithm ID ${publicKeyAlgorithmID}`);
  }
  return cosePublicKey;
}

// node_modules/@simplewebauthn/server/esm/helpers/verifySignature.js
function verifySignature2(opts) {
  const { signature, data, credentialPublicKey, x509Certificate, hashAlgorithm } = opts;
  if (!x509Certificate && !credentialPublicKey) {
    throw new Error('Must declare either "leafCert" or "credentialPublicKey"');
  }
  if (x509Certificate && credentialPublicKey) {
    throw new Error('Must not declare both "leafCert" and "credentialPublicKey"');
  }
  let cosePublicKey = new Map;
  if (credentialPublicKey) {
    cosePublicKey = decodeCredentialPublicKey(credentialPublicKey);
  } else if (x509Certificate) {
    cosePublicKey = convertX509PublicKeyToCOSE(x509Certificate);
  }
  return _verifySignatureInternals.stubThis(exports_isoCrypto.verify({
    cosePublicKey,
    signature,
    data,
    shaHashOverride: hashAlgorithm
  }));
}
var _verifySignatureInternals = {
  stubThis: (value) => value
};
// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/verifyOKP.js
async function verifyOKP(opts) {
  const { cosePublicKey, signature, data } = opts;
  const WebCrypto = await getWebCrypto();
  const alg = cosePublicKey.get(COSEKEYS.alg);
  const crv = cosePublicKey.get(COSEKEYS.crv);
  const x = cosePublicKey.get(COSEKEYS.x);
  if (!alg) {
    throw new Error("Public key was missing alg (OKP)");
  }
  if (!isCOSEAlg(alg)) {
    throw new Error(`Public key had invalid alg ${alg} (OKP)`);
  }
  if (!crv) {
    throw new Error("Public key was missing crv (OKP)");
  }
  if (!x) {
    throw new Error("Public key was missing x (OKP)");
  }
  let _crv;
  if (crv === COSECRV.ED25519) {
    _crv = "Ed25519";
  } else {
    throw new Error(`Unexpected COSE crv value of ${crv} (OKP)`);
  }
  const keyData = {
    kty: "OKP",
    crv: _crv,
    alg: "EdDSA",
    x: exports_isoBase64URL.fromBuffer(x),
    ext: false
  };
  const keyAlgorithm = {
    name: _crv,
    namedCurve: _crv
  };
  const key = await importKey({
    keyData,
    algorithm: keyAlgorithm
  });
  const verifyAlgorithm = {
    name: _crv
  };
  return WebCrypto.subtle.verify(verifyAlgorithm, key, signature, data);
}

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/unwrapEC2Signature.js
function unwrapEC2Signature(signature, crv) {
  const parsedSignature = AsnParser.parse(signature, ECDSASigValue2);
  const rBytes = new Uint8Array(parsedSignature.r);
  const sBytes = new Uint8Array(parsedSignature.s);
  const componentLength = getSignatureComponentLength(crv);
  const rNormalizedBytes = toNormalizedBytes(rBytes, componentLength);
  const sNormalizedBytes = toNormalizedBytes(sBytes, componentLength);
  const finalSignature = exports_isoUint8Array.concat([
    rNormalizedBytes,
    sNormalizedBytes
  ]);
  return finalSignature;
}
function getSignatureComponentLength(crv) {
  switch (crv) {
    case COSECRV.P256:
      return 32;
    case COSECRV.P384:
      return 48;
    case COSECRV.P521:
      return 66;
    default:
      throw new Error(`Unexpected COSE crv value of ${crv} (EC2)`);
  }
}
function toNormalizedBytes(bytes, componentLength) {
  let normalizedBytes;
  if (bytes.length < componentLength) {
    normalizedBytes = new Uint8Array(componentLength);
    normalizedBytes.set(bytes, componentLength - bytes.length);
  } else if (bytes.length === componentLength) {
    normalizedBytes = bytes;
  } else if (bytes.length === componentLength + 1 && bytes[0] === 0 && (bytes[1] & 128) === 128) {
    normalizedBytes = bytes.subarray(1);
  } else {
    throw new Error(`Invalid signature component length ${bytes.length}, expected ${componentLength}`);
  }
  return normalizedBytes;
}

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/verify.js
function verify(opts) {
  const { cosePublicKey, signature, data, shaHashOverride } = opts;
  if (isCOSEPublicKeyEC2(cosePublicKey)) {
    const crv = cosePublicKey.get(COSEKEYS.crv);
    if (!isCOSECrv(crv)) {
      throw new Error(`unknown COSE curve ${crv}`);
    }
    const unwrappedSignature = unwrapEC2Signature(signature, crv);
    return verifyEC2({
      cosePublicKey,
      signature: unwrappedSignature,
      data,
      shaHashOverride
    });
  } else if (isCOSEPublicKeyRSA(cosePublicKey)) {
    return verifyRSA({ cosePublicKey, signature, data, shaHashOverride });
  } else if (isCOSEPublicKeyOKP(cosePublicKey)) {
    return verifyOKP({ cosePublicKey, signature, data });
  }
  const kty = cosePublicKey.get(COSEKEYS.kty);
  throw new Error(`Signature verification with public key of kty ${kty} is not supported by this method`);
}
// node_modules/@simplewebauthn/server/esm/helpers/iso/isoUint8Array.js
var exports_isoUint8Array = {};
__export(exports_isoUint8Array, {
  toUTF8String: () => toUTF8String2,
  toHex: () => toHex,
  toDataView: () => toDataView,
  fromUTF8String: () => fromUTF8String2,
  fromHex: () => fromHex,
  fromASCIIString: () => fromASCIIString,
  concat: () => concat9,
  areEqual: () => areEqual
});
function areEqual(array1, array2) {
  if (array1.length != array2.length) {
    return false;
  }
  return array1.every((val, i) => val === array2[i]);
}
function toHex(array) {
  const hexParts = Array.from(array, (i) => i.toString(16).padStart(2, "0"));
  return hexParts.join("");
}
function fromHex(hex) {
  if (!hex) {
    return Uint8Array.from([]);
  }
  const isValid2 = hex.length !== 0 && hex.length % 2 === 0 && !/[^a-fA-F0-9]/u.test(hex);
  if (!isValid2) {
    throw new Error("Invalid hex string");
  }
  const byteStrings = hex.match(/.{1,2}/g) ?? [];
  return Uint8Array.from(byteStrings.map((byte) => parseInt(byte, 16)));
}
function concat9(arrays) {
  let pointer = 0;
  const totalLength = arrays.reduce((prev, curr) => prev + curr.length, 0);
  const toReturn = new Uint8Array(totalLength);
  arrays.forEach((arr) => {
    toReturn.set(arr, pointer);
    pointer += arr.length;
  });
  return toReturn;
}
function toUTF8String2(array) {
  const decoder = new globalThis.TextDecoder("utf-8");
  return decoder.decode(array);
}
function fromUTF8String2(utf8String) {
  const encoder = new globalThis.TextEncoder;
  return encoder.encode(utf8String);
}
function fromASCIIString(value) {
  return Uint8Array.from(value.split("").map((x) => x.charCodeAt(0)));
}
function toDataView(array) {
  return new DataView(array.buffer, array.byteOffset, array.length);
}
// node_modules/@simplewebauthn/server/esm/helpers/generateChallenge.js
async function generateChallenge2() {
  const challenge = new Uint8Array(32);
  await exports_isoCrypto.getRandomValues(challenge);
  return _generateChallengeInternals.stubThis(challenge);
}
var _generateChallengeInternals = {
  stubThis: (value) => value
};

// node_modules/@simplewebauthn/server/esm/registration/generateRegistrationOptions.js
var supportedCOSEAlgorithmIdentifiers = [
  -8,
  -7,
  -36,
  -37,
  -38,
  -39,
  -257,
  -258,
  -259,
  -65535
];
var defaultAuthenticatorSelection = {
  residentKey: "preferred",
  userVerification: "preferred"
};
var defaultSupportedAlgorithmIDs = [-8, -7, -257];
async function generateRegistrationOptions(options) {
  const { rpName, rpID, userName, userID, challenge = await generateChallenge2(), userDisplayName = "", timeout = 60000, attestationType = "none", excludeCredentials = [], authenticatorSelection = defaultAuthenticatorSelection, extensions: extensions9, supportedAlgorithmIDs = defaultSupportedAlgorithmIDs, preferredAuthenticatorType } = options;
  const pubKeyCredParams = supportedAlgorithmIDs.map((id) => ({
    alg: id,
    type: "public-key"
  }));
  if (authenticatorSelection.residentKey === undefined) {
    if (authenticatorSelection.requireResidentKey) {
      authenticatorSelection.residentKey = "required";
    } else {}
  } else {
    authenticatorSelection.requireResidentKey = authenticatorSelection.residentKey === "required";
  }
  let _challenge = challenge;
  if (typeof _challenge === "string") {
    _challenge = exports_isoUint8Array.fromUTF8String(_challenge);
  }
  if (typeof userID === "string") {
    throw new Error(`String values for \`userID\` are no longer supported. See https://simplewebauthn.dev/docs/advanced/server/custom-user-ids`);
  }
  let _userID = userID;
  if (!_userID) {
    _userID = await generateUserID();
  }
  const hints = [];
  if (preferredAuthenticatorType) {
    if (preferredAuthenticatorType === "securityKey") {
      hints.push("security-key");
      authenticatorSelection.authenticatorAttachment = "cross-platform";
    } else if (preferredAuthenticatorType === "localDevice") {
      hints.push("client-device");
      authenticatorSelection.authenticatorAttachment = "platform";
    } else if (preferredAuthenticatorType === "remoteDevice") {
      hints.push("hybrid");
      authenticatorSelection.authenticatorAttachment = "cross-platform";
    }
  }
  return {
    challenge: exports_isoBase64URL.fromBuffer(_challenge),
    rp: {
      name: rpName,
      id: rpID
    },
    user: {
      id: exports_isoBase64URL.fromBuffer(_userID),
      name: userName,
      displayName: userDisplayName
    },
    pubKeyCredParams,
    timeout,
    attestation: attestationType,
    excludeCredentials: excludeCredentials.map((cred) => {
      if (!exports_isoBase64URL.isBase64URL(cred.id)) {
        throw new Error(`excludeCredential id "${cred.id}" is not a valid base64url string`);
      }
      return {
        ...cred,
        id: exports_isoBase64URL.trimPadding(cred.id),
        type: "public-key"
      };
    }),
    authenticatorSelection,
    extensions: {
      ...extensions9,
      credProps: true
    },
    hints
  };
}
// node_modules/@simplewebauthn/server/esm/helpers/parseBackupFlags.js
function parseBackupFlags({ be, bs }) {
  const credentialBackedUp = bs;
  let credentialDeviceType = "singleDevice";
  if (be) {
    credentialDeviceType = "multiDevice";
  }
  if (credentialDeviceType === "singleDevice" && credentialBackedUp) {
    throw new InvalidBackupFlags("Single-device credential indicated that it was backed up, which should be impossible.");
  }
  return { credentialDeviceType, credentialBackedUp };
}

class InvalidBackupFlags extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidBackupFlags";
  }
}

// node_modules/@simplewebauthn/server/esm/helpers/matchExpectedRPID.js
async function matchExpectedRPID(rpIDHash, expectedRPIDs) {
  try {
    const matchedRPID = await Promise.any(expectedRPIDs.map((expected) => {
      return new Promise((resolve, reject) => {
        toHash(exports_isoUint8Array.fromASCIIString(expected)).then((expectedRPIDHash) => {
          if (exports_isoUint8Array.areEqual(rpIDHash, expectedRPIDHash)) {
            resolve(expected);
          } else {
            reject();
          }
        });
      });
    }));
    return matchedRPID;
  } catch (err) {
    const _err = err;
    if (_err.name === "AggregateError") {
      throw new UnexpectedRPIDHash;
    }
    throw err;
  }
}

class UnexpectedRPIDHash extends Error {
  constructor() {
    const message = "Unexpected RP ID hash";
    super(message);
    this.name = "UnexpectedRPIDHash";
  }
}

// node_modules/@simplewebauthn/server/esm/services/defaultRootCerts/android-safetynet.js
var GlobalSign_Root_CA = `-----BEGIN CERTIFICATE-----
MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG
A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv
b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw
MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i
YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT
aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ
jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp
xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp
1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG
snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ
U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8
9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E
BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B
AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz
yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE
38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP
AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad
DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME
HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==
-----END CERTIFICATE-----
`;

// node_modules/@simplewebauthn/server/esm/services/defaultRootCerts/android-key.js
var Google_Hardware_Attestation_Root_1 = `-----BEGIN CERTIFICATE-----
MIIFYDCCA0igAwIBAgIJAOj6GWMU0voYMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV
BAUTEGY5MjAwOWU4NTNiNmIwNDUwHhcNMTYwNTI2MTYyODUyWhcNMjYwNTI0MTYy
ODUyWjAbMRkwFwYDVQQFExBmOTIwMDllODUzYjZiMDQ1MIICIjANBgkqhkiG9w0B
AQEFAAOCAg8AMIICCgKCAgEAr7bHgiuxpwHsK7Qui8xUFmOr75gvMsd/dTEDDJdS
Sxtf6An7xyqpRR90PL2abxM1dEqlXnf2tqw1Ne4Xwl5jlRfdnJLmN0pTy/4lj4/7
tv0Sk3iiKkypnEUtR6WfMgH0QZfKHM1+di+y9TFRtv6y//0rb+T+W8a9nsNL/ggj
nar86461qO0rOs2cXjp3kOG1FEJ5MVmFmBGtnrKpa73XpXyTqRxB/M0n1n/W9nGq
C4FSYa04T6N5RIZGBN2z2MT5IKGbFlbC8UrW0DxW7AYImQQcHtGl/m00QLVWutHQ
oVJYnFPlXTcHYvASLu+RhhsbDmxMgJJ0mcDpvsC4PjvB+TxywElgS70vE0XmLD+O
JtvsBslHZvPBKCOdT0MS+tgSOIfga+z1Z1g7+DVagf7quvmag8jfPioyKvxnK/Eg
sTUVi2ghzq8wm27ud/mIM7AY2qEORR8Go3TVB4HzWQgpZrt3i5MIlCaY504LzSRi
igHCzAPlHws+W0rB5N+er5/2pJKnfBSDiCiFAVtCLOZ7gLiMm0jhO2B6tUXHI/+M
RPjy02i59lINMRRev56GKtcd9qO/0kUJWdZTdA2XoS82ixPvZtXQpUpuL12ab+9E
aDK8Z4RHJYYfCT3Q5vNAXaiWQ+8PTWm2QgBR/bkwSWc+NpUFgNPN9PvQi8WEg5Um
AGMCAwEAAaOBpjCBozAdBgNVHQ4EFgQUNmHhAHyIBQlRi0RsR/8aTMnqTxIwHwYD
VR0jBBgwFoAUNmHhAHyIBQlRi0RsR/8aTMnqTxIwDwYDVR0TAQH/BAUwAwEB/zAO
BgNVHQ8BAf8EBAMCAYYwQAYDVR0fBDkwNzA1oDOgMYYvaHR0cHM6Ly9hbmRyb2lk
Lmdvb2dsZWFwaXMuY29tL2F0dGVzdGF0aW9uL2NybC8wDQYJKoZIhvcNAQELBQAD
ggIBACDIw41L3KlXG0aMiS//cqrG+EShHUGo8HNsw30W1kJtjn6UBwRM6jnmiwfB
Pb8VA91chb2vssAtX2zbTvqBJ9+LBPGCdw/E53Rbf86qhxKaiAHOjpvAy5Y3m00m
qC0w/Zwvju1twb4vhLaJ5NkUJYsUS7rmJKHHBnETLi8GFqiEsqTWpG/6ibYCv7rY
DBJDcR9W62BW9jfIoBQcxUCUJouMPH25lLNcDc1ssqvC2v7iUgI9LeoM1sNovqPm
QUiG9rHli1vXxzCyaMTjwftkJLkf6724DFhuKug2jITV0QkXvaJWF4nUaHOTNA4u
JU9WDvZLI1j83A+/xnAJUucIv/zGJ1AMH2boHqF8CY16LpsYgBt6tKxxWH00XcyD
CdW2KlBCeqbQPcsFmWyWugxdcekhYsAWyoSf818NUsZdBWBaR/OukXrNLfkQ79Iy
ZohZbvabO/X+MVT3rriAoKc8oE2Uws6DF+60PV7/WIPjNvXySdqspImSN78mflxD
qwLqRBYkA3I75qppLGG9rp7UCdRjxMl8ZDBld+7yvHVgt1cVzJx9xnyGCC23Uaic
MDSXYrB4I4WHXPGjxhZuCuPBLTdOLU8YRvMYdEvYebWHMpvwGCF6bAx3JBpIeOQ1
wDB5y0USicV3YgYGmi+NZfhA4URSh77Yd6uuJOJENRaNVTzk
-----END CERTIFICATE-----
`;
var Google_Hardware_Attestation_Root_2 = `-----BEGIN CERTIFICATE-----
MIIFHDCCAwSgAwIBAgIJANUP8luj8tazMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV
BAUTEGY5MjAwOWU4NTNiNmIwNDUwHhcNMTkxMTIyMjAzNzU4WhcNMzQxMTE4MjAz
NzU4WjAbMRkwFwYDVQQFExBmOTIwMDllODUzYjZiMDQ1MIICIjANBgkqhkiG9w0B
AQEFAAOCAg8AMIICCgKCAgEAr7bHgiuxpwHsK7Qui8xUFmOr75gvMsd/dTEDDJdS
Sxtf6An7xyqpRR90PL2abxM1dEqlXnf2tqw1Ne4Xwl5jlRfdnJLmN0pTy/4lj4/7
tv0Sk3iiKkypnEUtR6WfMgH0QZfKHM1+di+y9TFRtv6y//0rb+T+W8a9nsNL/ggj
nar86461qO0rOs2cXjp3kOG1FEJ5MVmFmBGtnrKpa73XpXyTqRxB/M0n1n/W9nGq
C4FSYa04T6N5RIZGBN2z2MT5IKGbFlbC8UrW0DxW7AYImQQcHtGl/m00QLVWutHQ
oVJYnFPlXTcHYvASLu+RhhsbDmxMgJJ0mcDpvsC4PjvB+TxywElgS70vE0XmLD+O
JtvsBslHZvPBKCOdT0MS+tgSOIfga+z1Z1g7+DVagf7quvmag8jfPioyKvxnK/Eg
sTUVi2ghzq8wm27ud/mIM7AY2qEORR8Go3TVB4HzWQgpZrt3i5MIlCaY504LzSRi
igHCzAPlHws+W0rB5N+er5/2pJKnfBSDiCiFAVtCLOZ7gLiMm0jhO2B6tUXHI/+M
RPjy02i59lINMRRev56GKtcd9qO/0kUJWdZTdA2XoS82ixPvZtXQpUpuL12ab+9E
aDK8Z4RHJYYfCT3Q5vNAXaiWQ+8PTWm2QgBR/bkwSWc+NpUFgNPN9PvQi8WEg5Um
AGMCAwEAAaNjMGEwHQYDVR0OBBYEFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMB8GA1Ud
IwQYMBaAFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMA8GA1UdEwEB/wQFMAMBAf8wDgYD
VR0PAQH/BAQDAgIEMA0GCSqGSIb3DQEBCwUAA4ICAQBOMaBc8oumXb2voc7XCWnu
XKhBBK3e2KMGz39t7lA3XXRe2ZLLAkLM5y3J7tURkf5a1SutfdOyXAmeE6SRo83U
h6WszodmMkxK5GM4JGrnt4pBisu5igXEydaW7qq2CdC6DOGjG+mEkN8/TA6p3cno
L/sPyz6evdjLlSeJ8rFBH6xWyIZCbrcpYEJzXaUOEaxxXxgYz5/cTiVKN2M1G2ok
QBUIYSY6bjEL4aUN5cfo7ogP3UvliEo3Eo0YgwuzR2v0KR6C1cZqZJSTnghIC/vA
D32KdNQ+c3N+vl2OTsUVMC1GiWkngNx1OO1+kXW+YTnnTUOtOIswUP/Vqd5SYgAI
mMAfY8U9/iIgkQj6T2W6FsScy94IN9fFhE1UtzmLoBIuUFsVXJMTz+Jucth+IqoW
Fua9v1R93/k98p41pjtFX+H8DslVgfP097vju4KDlqN64xV1grw3ZLl4CiOe/A91
oeLm2UHOq6wn3esB4r2EIQKb6jTVGu5sYCcdWpXr0AUVqcABPdgL+H7qJguBw09o
jm6xNIrw2OocrDKsudk/okr/AwqEyPKw9WnMlQgLIKw1rODG2NvU9oR3GVGdMkUB
ZutL8VuFkERQGt6vQ2OCw0sV47VMkuYbacK/xyZFiRcrPJPb41zgbQj9XAEyLKCH
ex0SdDrx+tWUDqG8At2JHA==
-----END CERTIFICATE-----
`;
var Google_Hardware_Attestation_Root_3 = `
-----BEGIN CERTIFICATE-----
MIIFHDCCAwSgAwIBAgIJAMNrfES5rhgxMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV
BAUTEGY5MjAwOWU4NTNiNmIwNDUwHhcNMjExMTE3MjMxMDQyWhcNMzYxMTEzMjMx
MDQyWjAbMRkwFwYDVQQFExBmOTIwMDllODUzYjZiMDQ1MIICIjANBgkqhkiG9w0B
AQEFAAOCAg8AMIICCgKCAgEAr7bHgiuxpwHsK7Qui8xUFmOr75gvMsd/dTEDDJdS
Sxtf6An7xyqpRR90PL2abxM1dEqlXnf2tqw1Ne4Xwl5jlRfdnJLmN0pTy/4lj4/7
tv0Sk3iiKkypnEUtR6WfMgH0QZfKHM1+di+y9TFRtv6y//0rb+T+W8a9nsNL/ggj
nar86461qO0rOs2cXjp3kOG1FEJ5MVmFmBGtnrKpa73XpXyTqRxB/M0n1n/W9nGq
C4FSYa04T6N5RIZGBN2z2MT5IKGbFlbC8UrW0DxW7AYImQQcHtGl/m00QLVWutHQ
oVJYnFPlXTcHYvASLu+RhhsbDmxMgJJ0mcDpvsC4PjvB+TxywElgS70vE0XmLD+O
JtvsBslHZvPBKCOdT0MS+tgSOIfga+z1Z1g7+DVagf7quvmag8jfPioyKvxnK/Eg
sTUVi2ghzq8wm27ud/mIM7AY2qEORR8Go3TVB4HzWQgpZrt3i5MIlCaY504LzSRi
igHCzAPlHws+W0rB5N+er5/2pJKnfBSDiCiFAVtCLOZ7gLiMm0jhO2B6tUXHI/+M
RPjy02i59lINMRRev56GKtcd9qO/0kUJWdZTdA2XoS82ixPvZtXQpUpuL12ab+9E
aDK8Z4RHJYYfCT3Q5vNAXaiWQ+8PTWm2QgBR/bkwSWc+NpUFgNPN9PvQi8WEg5Um
AGMCAwEAAaNjMGEwHQYDVR0OBBYEFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMB8GA1Ud
IwQYMBaAFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMA8GA1UdEwEB/wQFMAMBAf8wDgYD
VR0PAQH/BAQDAgIEMA0GCSqGSIb3DQEBCwUAA4ICAQBTNNZe5cuf8oiq+jV0itTG
zWVhSTjOBEk2FQvh11J3o3lna0o7rd8RFHnN00q4hi6TapFhh4qaw/iG6Xg+xOan
63niLWIC5GOPFgPeYXM9+nBb3zZzC8ABypYuCusWCmt6Tn3+Pjbz3MTVhRGXuT/T
QH4KGFY4PhvzAyXwdjTOCXID+aHud4RLcSySr0Fq/L+R8TWalvM1wJJPhyRjqRCJ
erGtfBagiALzvhnmY7U1qFcS0NCnKjoO7oFedKdWlZz0YAfu3aGCJd4KHT0MsGiL
Zez9WP81xYSrKMNEsDK+zK5fVzw6jA7cxmpXcARTnmAuGUeI7VVDhDzKeVOctf3a
0qQLwC+d0+xrETZ4r2fRGNw2YEs2W8Qj6oDcfPvq9JySe7pJ6wcHnl5EZ0lwc4xH
7Y4Dx9RA1JlfooLMw3tOdJZH0enxPXaydfAD3YifeZpFaUzicHeLzVJLt9dvGB0b
HQLE4+EqKFgOZv2EoP686DQqbVS1u+9k0p2xbMA105TBIk7npraa8VM0fnrRKi7w
lZKwdH+aNAyhbXRW9xsnODJ+g8eF452zvbiKKngEKirK5LGieoXBX7tZ9D1GNBH2
Ob3bKOwwIWdEFle/YF/h6zWgdeoaNGDqVBrLr2+0DtWoiB1aDEjLWl9FmyIUyUm7
mD/vFDkzF+wm7cyWpQpCVQ==
-----END CERTIFICATE-----
`;
var Google_Hardware_Attestation_Root_4 = `
-----BEGIN CERTIFICATE-----
MIIFHDCCAwSgAwIBAgIJAPHBcqaZ6vUdMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV
BAUTEGY5MjAwOWU4NTNiNmIwNDUwHhcNMjIwMzIwMTgwNzQ4WhcNNDIwMzE1MTgw
NzQ4WjAbMRkwFwYDVQQFExBmOTIwMDllODUzYjZiMDQ1MIICIjANBgkqhkiG9w0B
AQEFAAOCAg8AMIICCgKCAgEAr7bHgiuxpwHsK7Qui8xUFmOr75gvMsd/dTEDDJdS
Sxtf6An7xyqpRR90PL2abxM1dEqlXnf2tqw1Ne4Xwl5jlRfdnJLmN0pTy/4lj4/7
tv0Sk3iiKkypnEUtR6WfMgH0QZfKHM1+di+y9TFRtv6y//0rb+T+W8a9nsNL/ggj
nar86461qO0rOs2cXjp3kOG1FEJ5MVmFmBGtnrKpa73XpXyTqRxB/M0n1n/W9nGq
C4FSYa04T6N5RIZGBN2z2MT5IKGbFlbC8UrW0DxW7AYImQQcHtGl/m00QLVWutHQ
oVJYnFPlXTcHYvASLu+RhhsbDmxMgJJ0mcDpvsC4PjvB+TxywElgS70vE0XmLD+O
JtvsBslHZvPBKCOdT0MS+tgSOIfga+z1Z1g7+DVagf7quvmag8jfPioyKvxnK/Eg
sTUVi2ghzq8wm27ud/mIM7AY2qEORR8Go3TVB4HzWQgpZrt3i5MIlCaY504LzSRi
igHCzAPlHws+W0rB5N+er5/2pJKnfBSDiCiFAVtCLOZ7gLiMm0jhO2B6tUXHI/+M
RPjy02i59lINMRRev56GKtcd9qO/0kUJWdZTdA2XoS82ixPvZtXQpUpuL12ab+9E
aDK8Z4RHJYYfCT3Q5vNAXaiWQ+8PTWm2QgBR/bkwSWc+NpUFgNPN9PvQi8WEg5Um
AGMCAwEAAaNjMGEwHQYDVR0OBBYEFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMB8GA1Ud
IwQYMBaAFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMA8GA1UdEwEB/wQFMAMBAf8wDgYD
VR0PAQH/BAQDAgIEMA0GCSqGSIb3DQEBCwUAA4ICAQB8cMqTllHc8U+qCrOlg3H7
174lmaCsbo/bJ0C17JEgMLb4kvrqsXZs01U3mB/qABg/1t5Pd5AORHARs1hhqGIC
W/nKMav574f9rZN4PC2ZlufGXb7sIdJpGiO9ctRhiLuYuly10JccUZGEHpHSYM2G
tkgYbZba6lsCPYAAP83cyDV+1aOkTf1RCp/lM0PKvmxYN10RYsK631jrleGdcdkx
oSK//mSQbgcWnmAEZrzHoF1/0gso1HZgIn0YLzVhLSA/iXCX4QT2h3J5z3znluKG
1nv8NQdxei2DIIhASWfu804CA96cQKTTlaae2fweqXjdN1/v2nqOhngNyz1361mF
mr4XmaKH/ItTwOe72NI9ZcwS1lVaCvsIkTDCEXdm9rCNPAY10iTunIHFXRh+7KPz
lHGewCq/8TOohBRn0/NNfh7uRslOSZ/xKbN9tMBtw37Z8d2vvnXq/YWdsm1+JLVw
n6yYD/yacNJBlwpddla8eaVMjsF6nBnIgQOf9zKSe06nSTqvgwUHosgOECZJZ1Eu
zbH4yswbt02tKtKEFhx+v+OTge/06V+jGsqTWLsfrOCNLuA8H++z+pUENmpqnnHo
vaI47gC+TNpkgYGkkBT6B/m/U01BuOBBTzhIlMEZq9qkDWuM2cA5kW5V3FJUcfHn
w1IdYIg2Wxg7yHcQZemFQg==
-----END CERTIFICATE-----
`;

// node_modules/@simplewebauthn/server/esm/services/defaultRootCerts/apple.js
var Apple_WebAuthn_Root_CA = `-----BEGIN CERTIFICATE-----
MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w
HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ
bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx
NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG
A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49
AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k
xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/
pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk
2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA
MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3
jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B
1bWeT0vT
-----END CERTIFICATE-----
`;

// node_modules/@simplewebauthn/server/esm/services/defaultRootCerts/mds.js
var GlobalSign_Root_CA_R3 = `-----BEGIN CERTIFICATE-----
MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G
A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp
Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4
MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG
A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8
RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT
gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm
KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd
QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ
XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw
DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o
LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU
RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp
jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK
6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX
mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs
Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH
WD9f
-----END CERTIFICATE-----
 `;

// node_modules/@simplewebauthn/server/esm/services/settingsService.js
class BaseSettingsService {
  constructor() {
    Object.defineProperty(this, "pemCertificates", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.pemCertificates = new Map;
  }
  setRootCertificates(opts) {
    const { identifier, certificates } = opts;
    const newCertificates = [];
    for (const cert of certificates) {
      if (cert instanceof Uint8Array) {
        newCertificates.push(convertCertBufferToPEM(cert));
      } else {
        newCertificates.push(cert);
      }
    }
    this.pemCertificates.set(identifier, newCertificates);
  }
  getRootCertificates(opts) {
    const { identifier } = opts;
    return this.pemCertificates.get(identifier) ?? [];
  }
}
var SettingsService = new BaseSettingsService;
SettingsService.setRootCertificates({
  identifier: "android-key",
  certificates: [
    Google_Hardware_Attestation_Root_1,
    Google_Hardware_Attestation_Root_2,
    Google_Hardware_Attestation_Root_3,
    Google_Hardware_Attestation_Root_4
  ]
});
SettingsService.setRootCertificates({
  identifier: "android-safetynet",
  certificates: [GlobalSign_Root_CA]
});
SettingsService.setRootCertificates({
  identifier: "apple",
  certificates: [Apple_WebAuthn_Root_CA]
});
SettingsService.setRootCertificates({
  identifier: "mds",
  certificates: [GlobalSign_Root_CA_R3]
});

// node_modules/@simplewebauthn/server/esm/registration/verifications/verifyAttestationFIDOU2F.js
async function verifyAttestationFIDOU2F(options) {
  const { attStmt, clientDataHash, rpIdHash, credentialID, credentialPublicKey, aaguid, rootCertificates } = options;
  const reservedByte = Uint8Array.from([0]);
  const publicKey = convertCOSEtoPKCS(credentialPublicKey);
  const signatureBase = exports_isoUint8Array.concat([
    reservedByte,
    rpIdHash,
    clientDataHash,
    credentialID,
    publicKey
  ]);
  const sig = attStmt.get("sig");
  const x5c = attStmt.get("x5c");
  if (!x5c) {
    throw new Error("No attestation certificate provided in attestation statement (FIDOU2F)");
  }
  if (!sig) {
    throw new Error("No attestation signature provided in attestation statement (FIDOU2F)");
  }
  const aaguidToHex = Number.parseInt(exports_isoUint8Array.toHex(aaguid), 16);
  if (aaguidToHex !== 0) {
    throw new Error(`AAGUID "${aaguidToHex}" was not expected value`);
  }
  try {
    await validateCertificatePath(x5c.map(convertCertBufferToPEM), rootCertificates);
  } catch (err) {
    const _err = err;
    throw new Error(`${_err.message} (FIDOU2F)`);
  }
  return verifySignature2({
    signature: sig,
    data: signatureBase,
    x509Certificate: x5c[0],
    hashAlgorithm: COSEALG.ES256
  });
}

// node_modules/@simplewebauthn/server/esm/helpers/validateExtFIDOGenCEAAGUID.js
var id_fido_gen_ce_aaguid = "1.3.6.1.4.1.45724.1.1.4";
function validateExtFIDOGenCEAAGUID(certExtensions, aaguid) {
  if (!certExtensions) {
    return true;
  }
  const extFIDOGenCEAAGUID = certExtensions.find((ext) => ext.extnID === id_fido_gen_ce_aaguid);
  if (!extFIDOGenCEAAGUID) {
    return true;
  }
  const parsedExtFIDOGenCEAAGUID = AsnParser.parse(extFIDOGenCEAAGUID.extnValue, OctetString2);
  const extValue = new Uint8Array(parsedExtFIDOGenCEAAGUID.buffer);
  const aaguidAndExtAreEqual = exports_isoUint8Array.areEqual(aaguid, extValue);
  if (!aaguidAndExtAreEqual) {
    const _debugExtHex = exports_isoUint8Array.toHex(extValue);
    const _debugAAGUIDHex = exports_isoUint8Array.toHex(aaguid);
    throw new Error(`Certificate extension id-fido-gen-ce-aaguid (${id_fido_gen_ce_aaguid}) value of "${_debugExtHex}" was present but not equal to attestation statement AAGUID value of "${_debugAAGUIDHex}"`);
  }
  return true;
}

// node_modules/@simplewebauthn/server/esm/helpers/logging.js
function getLogger(_name) {
  return (_message, ..._rest) => {};
}

// node_modules/@simplewebauthn/server/esm/helpers/convertPEMToBytes.js
function convertPEMToBytes(pem) {
  const certBase64 = pem.replace("-----BEGIN CERTIFICATE-----", "").replace("-----END CERTIFICATE-----", "").replace(/[\n ]/g, "");
  return exports_isoBase64URL.toBuffer(certBase64, "base64");
}

// node_modules/@simplewebauthn/server/esm/metadata/parseJWT.js
function parseJWT(jwt) {
  const parts = jwt.split(".");
  return [
    JSON.parse(exports_isoBase64URL.toUTF8String(parts[0])),
    JSON.parse(exports_isoBase64URL.toUTF8String(parts[1])),
    parts[2]
  ];
}

// node_modules/@simplewebauthn/server/esm/metadata/verifyJWT.js
function verifyJWT(jwt, leafCert) {
  const [header, payload, signature] = jwt.split(".");
  const certCOSE = convertX509PublicKeyToCOSE(leafCert);
  const data = exports_isoUint8Array.fromUTF8String(`${header}.${payload}`);
  const signatureBytes = exports_isoBase64URL.toBuffer(signature);
  if (isCOSEPublicKeyEC2(certCOSE)) {
    return verifyEC2({
      data,
      signature: signatureBytes,
      cosePublicKey: certCOSE,
      shaHashOverride: COSEALG.ES256
    });
  } else if (isCOSEPublicKeyRSA(certCOSE)) {
    return verifyRSA({
      data,
      signature: signatureBytes,
      cosePublicKey: certCOSE
    });
  }
  const kty = certCOSE.get(COSEKEYS.kty);
  throw new Error(`JWT verification with public key of kty ${kty} is not supported by this method`);
}

// node_modules/@simplewebauthn/server/esm/services/metadataService.js
var defaultURLMDS = "https://mds.fidoalliance.org/";
var SERVICE_STATE;
(function(SERVICE_STATE2) {
  SERVICE_STATE2[SERVICE_STATE2["DISABLED"] = 0] = "DISABLED";
  SERVICE_STATE2[SERVICE_STATE2["REFRESHING"] = 1] = "REFRESHING";
  SERVICE_STATE2[SERVICE_STATE2["READY"] = 2] = "READY";
})(SERVICE_STATE || (SERVICE_STATE = {}));
var log3 = getLogger("MetadataService");

class BaseMetadataService {
  constructor() {
    Object.defineProperty(this, "mdsCache", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "statementCache", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "state", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: SERVICE_STATE.DISABLED
    });
    Object.defineProperty(this, "verificationMode", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "strict"
    });
  }
  async initialize(opts = {}) {
    const { mdsServers = [defaultURLMDS], statements, verificationMode } = opts;
    this.setState(SERVICE_STATE.REFRESHING);
    if (statements?.length) {
      let statementsAdded = 0;
      statements.forEach((statement) => {
        if (statement.aaguid) {
          this.statementCache[statement.aaguid] = {
            entry: {
              metadataStatement: statement,
              statusReports: [],
              timeOfLastStatusChange: "1970-01-01"
            },
            url: ""
          };
          statementsAdded += 1;
        }
      });
      log3(`Cached ${statementsAdded} local statements`);
    }
    if (mdsServers?.length) {
      const currentCacheCount = Object.keys(this.statementCache).length;
      let numServers = mdsServers.length;
      for (const url of mdsServers) {
        try {
          await this.downloadBlob({
            url,
            no: 0,
            nextUpdate: new Date(0)
          });
        } catch (err) {
          log3(`Could not download BLOB from ${url}:`, err);
          numServers -= 1;
        }
      }
      const newCacheCount = Object.keys(this.statementCache).length;
      const cacheDiff = newCacheCount - currentCacheCount;
      log3(`Cached ${cacheDiff} statements from ${numServers} metadata server(s)`);
    }
    if (verificationMode) {
      this.verificationMode = verificationMode;
    }
    this.setState(SERVICE_STATE.READY);
  }
  async getStatement(aaguid) {
    if (this.state === SERVICE_STATE.DISABLED) {
      return;
    }
    if (!aaguid) {
      return;
    }
    if (aaguid instanceof Uint8Array) {
      aaguid = convertAAGUIDToString(aaguid);
    }
    await this.pauseUntilReady();
    const cachedStatement = this.statementCache[aaguid];
    if (!cachedStatement) {
      if (this.verificationMode === "strict") {
        throw new Error(`No metadata statement found for aaguid "${aaguid}"`);
      }
      return;
    }
    if (cachedStatement.url) {
      const mds = this.mdsCache[cachedStatement.url];
      const now = new Date;
      if (now > mds.nextUpdate) {
        try {
          this.setState(SERVICE_STATE.REFRESHING);
          await this.downloadBlob(mds);
        } finally {
          this.setState(SERVICE_STATE.READY);
        }
      }
    }
    const { entry } = cachedStatement;
    for (const report of entry.statusReports) {
      const { status } = report;
      if (status === "USER_VERIFICATION_BYPASS" || status === "ATTESTATION_KEY_COMPROMISE" || status === "USER_KEY_REMOTE_COMPROMISE" || status === "USER_KEY_PHYSICAL_COMPROMISE") {
        throw new Error(`Detected compromised aaguid "${aaguid}"`);
      }
    }
    return entry.metadataStatement;
  }
  async downloadBlob(mds) {
    const { url, no } = mds;
    const resp = await fetch(url);
    const data = await resp.text();
    const parsedJWT = parseJWT(data);
    const header = parsedJWT[0];
    const payload = parsedJWT[1];
    if (payload.no <= no) {
      throw new Error(`Latest BLOB no. "${payload.no}" is not greater than previous ${no}`);
    }
    const headerCertsPEM = header.x5c.map(convertCertBufferToPEM);
    try {
      const rootCerts = SettingsService.getRootCertificates({
        identifier: "mds"
      });
      await validateCertificatePath(headerCertsPEM, rootCerts);
    } catch (error) {
      const _error = error;
      throw new Error("BLOB certificate path could not be validated", { cause: _error });
    }
    const leafCert = headerCertsPEM[0];
    const verified = await verifyJWT(data, convertPEMToBytes(leafCert));
    if (!verified) {
      throw new Error("BLOB signature could not be verified");
    }
    for (const entry of payload.entries) {
      if (entry.aaguid) {
        this.statementCache[entry.aaguid] = { entry, url };
      }
    }
    const [year, month, day] = payload.nextUpdate.split("-");
    this.mdsCache[url] = {
      ...mds,
      no: payload.no,
      nextUpdate: new Date(parseInt(year, 10), parseInt(month, 10) - 1, parseInt(day, 10))
    };
  }
  pauseUntilReady() {
    if (this.state === SERVICE_STATE.READY) {
      return new Promise((resolve) => {
        resolve();
      });
    }
    const readyPromise = new Promise((resolve, reject) => {
      const totalTimeoutMS = 70000;
      const intervalMS = 100;
      let iterations = totalTimeoutMS / intervalMS;
      const intervalID = globalThis.setInterval(() => {
        if (iterations < 1) {
          clearInterval(intervalID);
          reject(`State did not become ready in ${totalTimeoutMS / 1000} seconds`);
        } else if (this.state === SERVICE_STATE.READY) {
          clearInterval(intervalID);
          resolve();
        }
        iterations -= 1;
      }, intervalMS);
    });
    return readyPromise;
  }
  setState(newState) {
    this.state = newState;
    if (newState === SERVICE_STATE.DISABLED) {
      log3("MetadataService is DISABLED");
    } else if (newState === SERVICE_STATE.REFRESHING) {
      log3("MetadataService is REFRESHING");
    } else if (newState === SERVICE_STATE.READY) {
      log3("MetadataService is READY");
    }
  }
}
var MetadataService = new BaseMetadataService;

// node_modules/@simplewebauthn/server/esm/metadata/verifyAttestationWithMetadata.js
async function verifyAttestationWithMetadata({ statement, credentialPublicKey, x5c, attestationStatementAlg }) {
  const { authenticationAlgorithms, authenticatorGetInfo, attestationRootCertificates } = statement;
  const keypairCOSEAlgs = new Set;
  authenticationAlgorithms.forEach((algSign) => {
    const algSignCOSEINFO = algSignToCOSEInfoMap[algSign];
    if (algSignCOSEINFO) {
      keypairCOSEAlgs.add(algSignCOSEINFO);
    }
  });
  const decodedPublicKey = decodeCredentialPublicKey(credentialPublicKey);
  const kty = decodedPublicKey.get(COSEKEYS.kty);
  const alg = decodedPublicKey.get(COSEKEYS.alg);
  if (!kty) {
    throw new Error("Credential public key was missing kty");
  }
  if (!alg) {
    throw new Error("Credential public key was missing alg");
  }
  if (!kty) {
    throw new Error("Credential public key was missing kty");
  }
  const publicKeyCOSEInfo = { kty, alg };
  if (isCOSEPublicKeyEC2(decodedPublicKey)) {
    const crv = decodedPublicKey.get(COSEKEYS.crv);
    publicKeyCOSEInfo.crv = crv;
  }
  let foundMatch = false;
  for (const keypairAlg of keypairCOSEAlgs) {
    if (keypairAlg.alg === publicKeyCOSEInfo.alg && keypairAlg.kty === publicKeyCOSEInfo.kty) {
      if ((keypairAlg.kty === COSEKTY.EC2 || keypairAlg.kty === COSEKTY.OKP) && keypairAlg.crv === publicKeyCOSEInfo.crv) {
        foundMatch = true;
      } else {
        foundMatch = true;
      }
    }
    if (foundMatch) {
      break;
    }
  }
  if (!foundMatch) {
    const debugMDSAlgs = authenticationAlgorithms.map((algSign) => `'${algSign}' (COSE info: ${stringifyCOSEInfo(algSignToCOSEInfoMap[algSign])})`);
    const strMDSAlgs = JSON.stringify(debugMDSAlgs, null, 2).replace(/"/g, "");
    const strPubKeyAlg = stringifyCOSEInfo(publicKeyCOSEInfo);
    throw new Error(`Public key parameters ${strPubKeyAlg} did not match any of the following metadata algorithms:
${strMDSAlgs}`);
  }
  if (attestationStatementAlg !== undefined && authenticatorGetInfo?.algorithms !== undefined) {
    const getInfoAlgs = authenticatorGetInfo.algorithms.map((_alg) => _alg.alg);
    if (getInfoAlgs.indexOf(attestationStatementAlg) < 0) {
      throw new Error(`Attestation statement alg ${attestationStatementAlg} did not match one of ${getInfoAlgs}`);
    }
  }
  const authenticatorCerts = x5c.map(convertCertBufferToPEM);
  const statementRootCerts = attestationRootCertificates.map(convertCertBufferToPEM);
  let authenticatorIsSelfReferencing = false;
  if (authenticatorCerts.length === 1 && statementRootCerts.indexOf(authenticatorCerts[0]) >= 0) {
    authenticatorIsSelfReferencing = true;
  }
  if (!authenticatorIsSelfReferencing) {
    try {
      await validateCertificatePath(authenticatorCerts, statementRootCerts);
    } catch (err) {
      const _err = err;
      throw new Error(`Could not validate certificate path with any metadata root certificates: ${_err.message}`);
    }
  }
  return true;
}
var algSignToCOSEInfoMap = {
  secp256r1_ecdsa_sha256_raw: { kty: 2, alg: -7, crv: 1 },
  secp256r1_ecdsa_sha256_der: { kty: 2, alg: -7, crv: 1 },
  rsassa_pss_sha256_raw: { kty: 3, alg: -37 },
  rsassa_pss_sha256_der: { kty: 3, alg: -37 },
  secp256k1_ecdsa_sha256_raw: { kty: 2, alg: -47, crv: 8 },
  secp256k1_ecdsa_sha256_der: { kty: 2, alg: -47, crv: 8 },
  rsassa_pss_sha384_raw: { kty: 3, alg: -38 },
  rsassa_pkcsv15_sha256_raw: { kty: 3, alg: -257 },
  rsassa_pkcsv15_sha384_raw: { kty: 3, alg: -258 },
  rsassa_pkcsv15_sha512_raw: { kty: 3, alg: -259 },
  rsassa_pkcsv15_sha1_raw: { kty: 3, alg: -65535 },
  secp384r1_ecdsa_sha384_raw: { kty: 2, alg: -35, crv: 2 },
  secp512r1_ecdsa_sha256_raw: { kty: 2, alg: -36, crv: 3 },
  ed25519_eddsa_sha512_raw: { kty: 1, alg: -8, crv: 6 }
};
function stringifyCOSEInfo(info) {
  const { kty, alg, crv } = info;
  let toReturn = "";
  if (kty !== COSEKTY.RSA) {
    toReturn = `{ kty: ${kty}, alg: ${alg}, crv: ${crv} }`;
  } else {
    toReturn = `{ kty: ${kty}, alg: ${alg} }`;
  }
  return toReturn;
}

// node_modules/@simplewebauthn/server/esm/registration/verifications/verifyAttestationPacked.js
async function verifyAttestationPacked(options) {
  const { attStmt, clientDataHash, authData, credentialPublicKey, aaguid, rootCertificates } = options;
  const sig = attStmt.get("sig");
  const x5c = attStmt.get("x5c");
  const alg = attStmt.get("alg");
  if (!sig) {
    throw new Error("No attestation signature provided in attestation statement (Packed)");
  }
  if (!alg) {
    throw new Error("Attestation statement did not contain alg (Packed)");
  }
  if (!isCOSEAlg(alg)) {
    throw new Error(`Attestation statement contained invalid alg ${alg} (Packed)`);
  }
  const signatureBase = exports_isoUint8Array.concat([authData, clientDataHash]);
  let verified = false;
  if (x5c) {
    const { subject, basicConstraintsCA, version, notBefore, notAfter, parsedCertificate } = getCertificateInfo(x5c[0]);
    const { OU, CN, O, C } = subject;
    if (OU !== "Authenticator Attestation") {
      throw new Error('Certificate OU was not "Authenticator Attestation" (Packed|Full)');
    }
    if (!CN) {
      throw new Error("Certificate CN was empty (Packed|Full)");
    }
    if (!O) {
      throw new Error("Certificate O was empty (Packed|Full)");
    }
    if (!C || C.length !== 2) {
      throw new Error("Certificate C was not two-character ISO 3166 code (Packed|Full)");
    }
    if (basicConstraintsCA) {
      throw new Error("Certificate basic constraints CA was not `false` (Packed|Full)");
    }
    if (version !== 2) {
      throw new Error("Certificate version was not `3` (ASN.1 value of 2) (Packed|Full)");
    }
    let now = new Date;
    if (notBefore > now) {
      throw new Error(`Certificate not good before "${notBefore.toString()}" (Packed|Full)`);
    }
    now = new Date;
    if (notAfter < now) {
      throw new Error(`Certificate not good after "${notAfter.toString()}" (Packed|Full)`);
    }
    try {
      await validateExtFIDOGenCEAAGUID(parsedCertificate.tbsCertificate.extensions, aaguid);
    } catch (err) {
      const _err = err;
      throw new Error(`${_err.message} (Packed|Full)`);
    }
    const statement = await MetadataService.getStatement(aaguid);
    if (statement) {
      if (statement.attestationTypes.indexOf("basic_full") < 0) {
        throw new Error("Metadata does not indicate support for full attestations (Packed|Full)");
      }
      try {
        await verifyAttestationWithMetadata({
          statement,
          credentialPublicKey,
          x5c,
          attestationStatementAlg: alg
        });
      } catch (err) {
        const _err = err;
        throw new Error(`${_err.message} (Packed|Full)`);
      }
    } else {
      try {
        await validateCertificatePath(x5c.map(convertCertBufferToPEM), rootCertificates);
      } catch (err) {
        const _err = err;
        throw new Error(`${_err.message} (Packed|Full)`);
      }
    }
    verified = await verifySignature2({
      signature: sig,
      data: signatureBase,
      x509Certificate: x5c[0]
    });
  } else {
    verified = await verifySignature2({
      signature: sig,
      data: signatureBase,
      credentialPublicKey,
      hashAlgorithm: alg
    });
  }
  return verified;
}

// node_modules/@simplewebauthn/server/esm/registration/verifications/verifyAttestationAndroidSafetyNet.js
async function verifyAttestationAndroidSafetyNet(options) {
  const { attStmt, clientDataHash, authData, aaguid, rootCertificates, verifyTimestampMS = true, credentialPublicKey, attestationSafetyNetEnforceCTSCheck } = options;
  const alg = attStmt.get("alg");
  const response = attStmt.get("response");
  const ver = attStmt.get("ver");
  if (!ver) {
    throw new Error("No ver value in attestation (SafetyNet)");
  }
  if (!response) {
    throw new Error("No response was included in attStmt by authenticator (SafetyNet)");
  }
  const jwt = exports_isoUint8Array.toUTF8String(response);
  const jwtParts = jwt.split(".");
  const HEADER = JSON.parse(exports_isoBase64URL.toUTF8String(jwtParts[0]));
  const PAYLOAD = JSON.parse(exports_isoBase64URL.toUTF8String(jwtParts[1]));
  const SIGNATURE = jwtParts[2];
  const { nonce, ctsProfileMatch, timestampMs } = PAYLOAD;
  if (verifyTimestampMS) {
    let now = Date.now();
    if (timestampMs > Date.now()) {
      throw new Error(`Payload timestamp "${timestampMs}" was later than "${now}" (SafetyNet)`);
    }
    const timestampPlusDelay = timestampMs + 60 * 1000;
    now = Date.now();
    if (timestampPlusDelay < now) {
      throw new Error(`Payload timestamp "${timestampPlusDelay}" has expired (SafetyNet)`);
    }
  }
  const nonceBase = exports_isoUint8Array.concat([authData, clientDataHash]);
  const nonceBuffer = await toHash(nonceBase);
  const expectedNonce = exports_isoBase64URL.fromBuffer(nonceBuffer, "base64");
  if (nonce !== expectedNonce) {
    throw new Error("Could not verify payload nonce (SafetyNet)");
  }
  if (attestationSafetyNetEnforceCTSCheck && !ctsProfileMatch) {
    throw new Error("Could not verify device integrity (SafetyNet)");
  }
  const leafCertBuffer = exports_isoBase64URL.toBuffer(HEADER.x5c[0], "base64");
  const leafCertInfo = getCertificateInfo(leafCertBuffer);
  const { subject } = leafCertInfo;
  if (subject.CN !== "attest.android.com") {
    throw new Error('Certificate common name was not "attest.android.com" (SafetyNet)');
  }
  const statement = await MetadataService.getStatement(aaguid);
  if (statement) {
    try {
      await verifyAttestationWithMetadata({
        statement,
        credentialPublicKey,
        x5c: HEADER.x5c,
        attestationStatementAlg: alg
      });
    } catch (err) {
      const _err = err;
      throw new Error(`${_err.message} (SafetyNet)`);
    }
  } else {
    try {
      await validateCertificatePath(HEADER.x5c.map(convertCertBufferToPEM), rootCertificates);
    } catch (err) {
      const _err = err;
      throw new Error(`${_err.message} (SafetyNet)`);
    }
  }
  const signatureBaseBuffer = exports_isoUint8Array.fromUTF8String(`${jwtParts[0]}.${jwtParts[1]}`);
  const signatureBuffer = exports_isoBase64URL.toBuffer(SIGNATURE);
  const verified = await verifySignature2({
    signature: signatureBuffer,
    data: signatureBaseBuffer,
    x509Certificate: leafCertBuffer
  });
  return verified;
}

// node_modules/@simplewebauthn/server/esm/registration/verifications/tpm/constants.js
var TPM_ST = {
  196: "TPM_ST_RSP_COMMAND",
  32768: "TPM_ST_NULL",
  32769: "TPM_ST_NO_SESSIONS",
  32770: "TPM_ST_SESSIONS",
  32788: "TPM_ST_ATTEST_NV",
  32789: "TPM_ST_ATTEST_COMMAND_AUDIT",
  32790: "TPM_ST_ATTEST_SESSION_AUDIT",
  32791: "TPM_ST_ATTEST_CERTIFY",
  32792: "TPM_ST_ATTEST_QUOTE",
  32793: "TPM_ST_ATTEST_TIME",
  32794: "TPM_ST_ATTEST_CREATION",
  32801: "TPM_ST_CREATION",
  32802: "TPM_ST_VERIFIED",
  32803: "TPM_ST_AUTH_SECRET",
  32804: "TPM_ST_HASHCHECK",
  32805: "TPM_ST_AUTH_SIGNED",
  32809: "TPM_ST_FU_MANIFEST"
};
var TPM_ALG = {
  0: "TPM_ALG_ERROR",
  1: "TPM_ALG_RSA",
  4: "TPM_ALG_SHA",
  4: "TPM_ALG_SHA1",
  5: "TPM_ALG_HMAC",
  6: "TPM_ALG_AES",
  7: "TPM_ALG_MGF1",
  8: "TPM_ALG_KEYEDHASH",
  10: "TPM_ALG_XOR",
  11: "TPM_ALG_SHA256",
  12: "TPM_ALG_SHA384",
  13: "TPM_ALG_SHA512",
  16: "TPM_ALG_NULL",
  18: "TPM_ALG_SM3_256",
  19: "TPM_ALG_SM4",
  20: "TPM_ALG_RSASSA",
  21: "TPM_ALG_RSAES",
  22: "TPM_ALG_RSAPSS",
  23: "TPM_ALG_OAEP",
  24: "TPM_ALG_ECDSA",
  25: "TPM_ALG_ECDH",
  26: "TPM_ALG_ECDAA",
  27: "TPM_ALG_SM2",
  28: "TPM_ALG_ECSCHNORR",
  29: "TPM_ALG_ECMQV",
  32: "TPM_ALG_KDF1_SP800_56A",
  33: "TPM_ALG_KDF2",
  34: "TPM_ALG_KDF1_SP800_108",
  35: "TPM_ALG_ECC",
  37: "TPM_ALG_SYMCIPHER",
  38: "TPM_ALG_CAMELLIA",
  64: "TPM_ALG_CTR",
  65: "TPM_ALG_OFB",
  66: "TPM_ALG_CBC",
  67: "TPM_ALG_CFB",
  68: "TPM_ALG_ECB"
};
var TPM_ECC_CURVE = {
  0: "TPM_ECC_NONE",
  1: "TPM_ECC_NIST_P192",
  2: "TPM_ECC_NIST_P224",
  3: "TPM_ECC_NIST_P256",
  4: "TPM_ECC_NIST_P384",
  5: "TPM_ECC_NIST_P521",
  16: "TPM_ECC_BN_P256",
  17: "TPM_ECC_BN_P638",
  32: "TPM_ECC_SM2_P256"
};
var TPM_MANUFACTURERS = {
  "id:414D4400": { name: "AMD", id: "AMD" },
  "id:414E5400": { name: "Ant Group", id: "ANT" },
  "id:41544D4C": { name: "Atmel", id: "ATML" },
  "id:4252434D": { name: "Broadcom", id: "BRCM" },
  "id:4353434F": { name: "Cisco", id: "CSCO" },
  "id:464C5953": { name: "Flyslice Technologies", id: "FLYS" },
  "id:524F4343": { name: "Fuzhou Rockchip", id: "ROCC" },
  "id:474F4F47": { name: "Google", id: "GOOG" },
  "id:48504900": { name: "HPI", id: "HPI" },
  "id:48504500": { name: "HPE", id: "HPE" },
  "id:48495349": { name: "Huawei", id: "HISI" },
  "id:49424d00": { name: "IBM", id: "IBM" },
  "id:49424D00": { name: "IBM", id: "IBM" },
  "id:49465800": { name: "Infineon", id: "IFX" },
  "id:494E5443": { name: "Intel", id: "INTC" },
  "id:4C454E00": { name: "Lenovo", id: "LEN" },
  "id:4D534654": { name: "Microsoft", id: "MSFT" },
  "id:4E534D20": { name: "National Semiconductor", id: "NSM" },
  "id:4E545A00": { name: "Nationz", id: "NTZ" },
  "id:4E534700": { name: "NSING", id: "NSG" },
  "id:4E544300": { name: "Nuvoton Technology", id: "NTC" },
  "id:51434F4D": { name: "Qualcomm", id: "QCOM" },
  "id:534D534E": { name: "Samsung", id: "SMSN" },
  "id:53454345": { name: "SecEdge", id: "SECE" },
  "id:534E5300": { name: "Sinosun", id: "SNS" },
  "id:534D5343": { name: "SMSC", id: "SMSC" },
  "id:53544D20": { name: "STMicroelectronics", id: "STM" },
  "id:54584E00": { name: "Texas Instruments", id: "TXN" },
  "id:57454300": { name: "Winbond", id: "WEC" },
  "id:5345414C": { name: "Wisekey", id: "SEAL" },
  "id:FFFFF1D0": { name: "FIDO Alliance", id: "FIDO" }
};
var TPM_ECC_CURVE_COSE_CRV_MAP = {
  TPM_ECC_NIST_P256: 1,
  TPM_ECC_NIST_P384: 2,
  TPM_ECC_NIST_P521: 3,
  TPM_ECC_BN_P256: 1,
  TPM_ECC_SM2_P256: 1
};

// node_modules/@simplewebauthn/server/esm/registration/verifications/tpm/parseCertInfo.js
function parseCertInfo(certInfo) {
  let pointer = 0;
  const dataView = exports_isoUint8Array.toDataView(certInfo);
  const magic = dataView.getUint32(pointer);
  pointer += 4;
  const typeBuffer = dataView.getUint16(pointer);
  pointer += 2;
  const type = TPM_ST[typeBuffer];
  const qualifiedSignerLength = dataView.getUint16(pointer);
  pointer += 2;
  const qualifiedSigner = certInfo.slice(pointer, pointer += qualifiedSignerLength);
  const extraDataLength = dataView.getUint16(pointer);
  pointer += 2;
  const extraData = certInfo.slice(pointer, pointer += extraDataLength);
  const clock = certInfo.slice(pointer, pointer += 8);
  const resetCount = dataView.getUint32(pointer);
  pointer += 4;
  const restartCount = dataView.getUint32(pointer);
  pointer += 4;
  const safe = !!certInfo.slice(pointer, pointer += 1);
  const clockInfo = { clock, resetCount, restartCount, safe };
  const firmwareVersion = certInfo.slice(pointer, pointer += 8);
  const attestedNameLength = dataView.getUint16(pointer);
  pointer += 2;
  const attestedName = certInfo.slice(pointer, pointer += attestedNameLength);
  const attestedNameDataView = exports_isoUint8Array.toDataView(attestedName);
  const qualifiedNameLength = dataView.getUint16(pointer);
  pointer += 2;
  const qualifiedName = certInfo.slice(pointer, pointer += qualifiedNameLength);
  const attested = {
    nameAlg: TPM_ALG[attestedNameDataView.getUint16(0)],
    nameAlgBuffer: attestedName.slice(0, 2),
    name: attestedName,
    qualifiedName
  };
  return {
    magic,
    type,
    qualifiedSigner,
    extraData,
    clockInfo,
    firmwareVersion,
    attested
  };
}

// node_modules/@simplewebauthn/server/esm/registration/verifications/tpm/parsePubArea.js
function parsePubArea(pubArea) {
  let pointer = 0;
  const dataView = exports_isoUint8Array.toDataView(pubArea);
  const type = TPM_ALG[dataView.getUint16(pointer)];
  pointer += 2;
  const nameAlg = TPM_ALG[dataView.getUint16(pointer)];
  pointer += 2;
  const objectAttributesInt = dataView.getUint32(pointer);
  pointer += 4;
  const objectAttributes = {
    fixedTPM: !!(objectAttributesInt & 1),
    stClear: !!(objectAttributesInt & 2),
    fixedParent: !!(objectAttributesInt & 8),
    sensitiveDataOrigin: !!(objectAttributesInt & 16),
    userWithAuth: !!(objectAttributesInt & 32),
    adminWithPolicy: !!(objectAttributesInt & 64),
    noDA: !!(objectAttributesInt & 512),
    encryptedDuplication: !!(objectAttributesInt & 1024),
    restricted: !!(objectAttributesInt & 32768),
    decrypt: !!(objectAttributesInt & 65536),
    signOrEncrypt: !!(objectAttributesInt & 131072)
  };
  const authPolicyLength = dataView.getUint16(pointer);
  pointer += 2;
  const authPolicy = pubArea.slice(pointer, pointer += authPolicyLength);
  const parameters4 = {};
  let unique = Uint8Array.from([]);
  if (type === "TPM_ALG_RSA") {
    const symmetric = TPM_ALG[dataView.getUint16(pointer)];
    pointer += 2;
    const scheme = TPM_ALG[dataView.getUint16(pointer)];
    pointer += 2;
    const keyBits = dataView.getUint16(pointer);
    pointer += 2;
    const exponent = dataView.getUint32(pointer);
    pointer += 4;
    parameters4.rsa = { symmetric, scheme, keyBits, exponent };
    const uniqueLength = dataView.getUint16(pointer);
    pointer += 2;
    unique = pubArea.slice(pointer, pointer += uniqueLength);
  } else if (type === "TPM_ALG_ECC") {
    const symmetric = TPM_ALG[dataView.getUint16(pointer)];
    pointer += 2;
    const scheme = TPM_ALG[dataView.getUint16(pointer)];
    pointer += 2;
    const curveID = TPM_ECC_CURVE[dataView.getUint16(pointer)];
    pointer += 2;
    const kdf = TPM_ALG[dataView.getUint16(pointer)];
    pointer += 2;
    parameters4.ecc = { symmetric, scheme, curveID, kdf };
    const uniqueXLength = dataView.getUint16(pointer);
    pointer += 2;
    const uniqueX = pubArea.slice(pointer, pointer += uniqueXLength);
    const uniqueYLength = dataView.getUint16(pointer);
    pointer += 2;
    const uniqueY = pubArea.slice(pointer, pointer += uniqueYLength);
    unique = exports_isoUint8Array.concat([uniqueX, uniqueY]);
  } else {
    throw new Error(`Unexpected type "${type}" (TPM)`);
  }
  return {
    type,
    nameAlg,
    objectAttributes,
    authPolicy,
    parameters: parameters4,
    unique
  };
}

// node_modules/@simplewebauthn/server/esm/registration/verifications/tpm/verifyAttestationTPM.js
async function verifyAttestationTPM(options) {
  const { aaguid, attStmt, authData, credentialPublicKey, clientDataHash, rootCertificates } = options;
  const ver = attStmt.get("ver");
  const sig = attStmt.get("sig");
  const alg = attStmt.get("alg");
  const x5c = attStmt.get("x5c");
  const pubArea = attStmt.get("pubArea");
  const certInfo = attStmt.get("certInfo");
  if (ver !== "2.0") {
    throw new Error(`Unexpected ver "${ver}", expected "2.0" (TPM)`);
  }
  if (!sig) {
    throw new Error("No attestation signature provided in attestation statement (TPM)");
  }
  if (!alg) {
    throw new Error(`Attestation statement did not contain alg (TPM)`);
  }
  if (!isCOSEAlg(alg)) {
    throw new Error(`Attestation statement contained invalid alg ${alg} (TPM)`);
  }
  if (!x5c) {
    throw new Error("No attestation certificate provided in attestation statement (TPM)");
  }
  if (!pubArea) {
    throw new Error("Attestation statement did not contain pubArea (TPM)");
  }
  if (!certInfo) {
    throw new Error("Attestation statement did not contain certInfo (TPM)");
  }
  const parsedPubArea = parsePubArea(pubArea);
  const { unique, type: pubType, parameters: parameters4 } = parsedPubArea;
  const cosePublicKey = decodeCredentialPublicKey(credentialPublicKey);
  if (pubType === "TPM_ALG_RSA") {
    if (!isCOSEPublicKeyRSA(cosePublicKey)) {
      throw new Error(`Credential public key with kty ${cosePublicKey.get(COSEKEYS.kty)} did not match ${pubType}`);
    }
    const n = cosePublicKey.get(COSEKEYS.n);
    const e = cosePublicKey.get(COSEKEYS.e);
    if (!n) {
      throw new Error("COSE public key missing n (TPM|RSA)");
    }
    if (!e) {
      throw new Error("COSE public key missing e (TPM|RSA)");
    }
    if (!exports_isoUint8Array.areEqual(unique, n)) {
      throw new Error("PubArea unique is not same as credentialPublicKey (TPM|RSA)");
    }
    if (!parameters4.rsa) {
      throw new Error(`Parsed pubArea type is RSA, but missing parameters.rsa (TPM|RSA)`);
    }
    const eBuffer = e;
    const pubAreaExponent = parameters4.rsa.exponent || 65537;
    const eSum = eBuffer[0] + (eBuffer[1] << 8) + (eBuffer[2] << 16);
    if (pubAreaExponent !== eSum) {
      throw new Error(`Unexpected public key exp ${eSum}, expected ${pubAreaExponent} (TPM|RSA)`);
    }
  } else if (pubType === "TPM_ALG_ECC") {
    if (!isCOSEPublicKeyEC2(cosePublicKey)) {
      throw new Error(`Credential public key with kty ${cosePublicKey.get(COSEKEYS.kty)} did not match ${pubType}`);
    }
    const crv = cosePublicKey.get(COSEKEYS.crv);
    const x = cosePublicKey.get(COSEKEYS.x);
    const y = cosePublicKey.get(COSEKEYS.y);
    if (!crv) {
      throw new Error("COSE public key missing crv (TPM|ECC)");
    }
    if (!x) {
      throw new Error("COSE public key missing x (TPM|ECC)");
    }
    if (!y) {
      throw new Error("COSE public key missing y (TPM|ECC)");
    }
    if (!exports_isoUint8Array.areEqual(unique, exports_isoUint8Array.concat([x, y]))) {
      throw new Error("PubArea unique is not same as public key x and y (TPM|ECC)");
    }
    if (!parameters4.ecc) {
      throw new Error(`Parsed pubArea type is ECC, but missing parameters.ecc (TPM|ECC)`);
    }
    const pubAreaCurveID = parameters4.ecc.curveID;
    const pubAreaCurveIDMapToCOSECRV = TPM_ECC_CURVE_COSE_CRV_MAP[pubAreaCurveID];
    if (pubAreaCurveIDMapToCOSECRV !== crv) {
      throw new Error(`Public area key curve ID "${pubAreaCurveID}" mapped to "${pubAreaCurveIDMapToCOSECRV}" which did not match public key crv of "${crv}" (TPM|ECC)`);
    }
  } else {
    throw new Error(`Unsupported pubArea.type "${pubType}"`);
  }
  const parsedCertInfo = parseCertInfo(certInfo);
  const { magic, type: certType, attested, extraData } = parsedCertInfo;
  if (magic !== 4283712327) {
    throw new Error(`Unexpected magic value "${magic}", expected "0xff544347" (TPM)`);
  }
  if (certType !== "TPM_ST_ATTEST_CERTIFY") {
    throw new Error(`Unexpected type "${certType}", expected "TPM_ST_ATTEST_CERTIFY" (TPM)`);
  }
  const pubAreaHash = await toHash(pubArea, attestedNameAlgToCOSEAlg(attested.nameAlg));
  const attestedName = exports_isoUint8Array.concat([
    attested.nameAlgBuffer,
    pubAreaHash
  ]);
  if (!exports_isoUint8Array.areEqual(attested.name, attestedName)) {
    throw new Error(`Attested name comparison failed (TPM)`);
  }
  const attToBeSigned = exports_isoUint8Array.concat([authData, clientDataHash]);
  const attToBeSignedHash = await toHash(attToBeSigned, alg);
  if (!exports_isoUint8Array.areEqual(extraData, attToBeSignedHash)) {
    throw new Error("CertInfo extra data did not equal hashed attestation (TPM)");
  }
  if (x5c.length < 1) {
    throw new Error("No certificates present in x5c array (TPM)");
  }
  const leafCertInfo = getCertificateInfo(x5c[0]);
  const { basicConstraintsCA, version, subject, notAfter, notBefore } = leafCertInfo;
  if (basicConstraintsCA) {
    throw new Error("Certificate basic constraints CA was not `false` (TPM)");
  }
  if (version !== 2) {
    throw new Error("Certificate version was not `3` (ASN.1 value of 2) (TPM)");
  }
  if (subject.combined.length > 0) {
    throw new Error("Certificate subject was not empty (TPM)");
  }
  let now = new Date;
  if (notBefore > now) {
    throw new Error(`Certificate not good before "${notBefore.toString()}" (TPM)`);
  }
  now = new Date;
  if (notAfter < now) {
    throw new Error(`Certificate not good after "${notAfter.toString()}" (TPM)`);
  }
  const parsedCert = AsnParser.parse(x5c[0], Certificate);
  if (!parsedCert.tbsCertificate.extensions) {
    throw new Error("Certificate was missing extensions (TPM)");
  }
  let subjectAltNamePresent;
  let extKeyUsage;
  parsedCert.tbsCertificate.extensions.forEach((ext) => {
    if (ext.extnID === id_ce_subjectAltName) {
      subjectAltNamePresent = AsnParser.parse(ext.extnValue, SubjectAlternativeName);
    } else if (ext.extnID === id_ce_extKeyUsage) {
      extKeyUsage = AsnParser.parse(ext.extnValue, ExtendedKeyUsage);
    }
  });
  if (!subjectAltNamePresent) {
    throw new Error("Certificate did not contain subjectAltName extension (TPM)");
  }
  if (!subjectAltNamePresent[0].directoryName?.[0].length) {
    throw new Error("Certificate subjectAltName extension directoryName was empty (TPM)");
  }
  const { tcgAtTpmManufacturer, tcgAtTpmModel, tcgAtTpmVersion } = getTcgAtTpmValues(subjectAltNamePresent[0].directoryName);
  if (!tcgAtTpmManufacturer || !tcgAtTpmModel || !tcgAtTpmVersion) {
    throw new Error("Certificate contained incomplete subjectAltName data (TPM)");
  }
  if (!extKeyUsage) {
    throw new Error("Certificate did not contain ExtendedKeyUsage extension (TPM)");
  }
  if (!TPM_MANUFACTURERS[tcgAtTpmManufacturer]) {
    throw new Error(`Could not match TPM manufacturer "${tcgAtTpmManufacturer}" (TPM)`);
  }
  if (extKeyUsage[0] !== "2.23.133.8.3") {
    throw new Error(`Unexpected extKeyUsage "${extKeyUsage[0]}", expected "2.23.133.8.3" (TPM)`);
  }
  try {
    await validateExtFIDOGenCEAAGUID(parsedCert.tbsCertificate.extensions, aaguid);
  } catch (err) {
    const _err = err;
    throw new Error(`${_err.message} (TPM)`);
  }
  const statement = await MetadataService.getStatement(aaguid);
  if (statement) {
    try {
      await verifyAttestationWithMetadata({
        statement,
        credentialPublicKey,
        x5c,
        attestationStatementAlg: alg
      });
    } catch (err) {
      const _err = err;
      throw new Error(`${_err.message} (TPM)`);
    }
  } else {
    try {
      await validateCertificatePath(x5c.map(convertCertBufferToPEM), rootCertificates);
    } catch (err) {
      const _err = err;
      throw new Error(`${_err.message} (TPM)`);
    }
  }
  return verifySignature2({
    signature: sig,
    data: certInfo,
    x509Certificate: x5c[0],
    hashAlgorithm: alg
  });
}
function getTcgAtTpmValues(root) {
  const oidManufacturer = "2.23.133.2.1";
  const oidModel = "2.23.133.2.2";
  const oidVersion = "2.23.133.2.3";
  let tcgAtTpmManufacturer;
  let tcgAtTpmModel;
  let tcgAtTpmVersion;
  root.forEach((relName) => {
    relName.forEach((attr) => {
      if (attr.type === oidManufacturer) {
        tcgAtTpmManufacturer = attr.value.toString();
      } else if (attr.type === oidModel) {
        tcgAtTpmModel = attr.value.toString();
      } else if (attr.type === oidVersion) {
        tcgAtTpmVersion = attr.value.toString();
      }
    });
  });
  return {
    tcgAtTpmManufacturer,
    tcgAtTpmModel,
    tcgAtTpmVersion
  };
}
function attestedNameAlgToCOSEAlg(alg) {
  if (alg === "TPM_ALG_SHA256") {
    return COSEALG.ES256;
  } else if (alg === "TPM_ALG_SHA384") {
    return COSEALG.ES384;
  } else if (alg === "TPM_ALG_SHA512") {
    return COSEALG.ES512;
  }
  throw new Error(`Unexpected TPM attested name alg ${alg}`);
}

// node_modules/@peculiar/asn1-android/build/es2015/key_description.js
var IntegerSet_1;
var id_ce_keyDescription = "1.3.6.1.4.1.11129.2.1.17";
var VerifiedBootState;
(function(VerifiedBootState2) {
  VerifiedBootState2[VerifiedBootState2["verified"] = 0] = "verified";
  VerifiedBootState2[VerifiedBootState2["selfSigned"] = 1] = "selfSigned";
  VerifiedBootState2[VerifiedBootState2["unverified"] = 2] = "unverified";
  VerifiedBootState2[VerifiedBootState2["failed"] = 3] = "failed";
})(VerifiedBootState || (VerifiedBootState = {}));

class RootOfTrust {
  constructor(params = {}) {
    this.verifiedBootKey = new OctetString2;
    this.deviceLocked = false;
    this.verifiedBootState = VerifiedBootState.verified;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: OctetString2 })
], RootOfTrust.prototype, "verifiedBootKey", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Boolean })
], RootOfTrust.prototype, "deviceLocked", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Enumerated })
], RootOfTrust.prototype, "verifiedBootState", undefined);
__decorate([
  AsnProp({ type: OctetString2, optional: true })
], RootOfTrust.prototype, "verifiedBootHash", undefined);
var IntegerSet = IntegerSet_1 = class IntegerSet2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, IntegerSet_1.prototype);
  }
};
IntegerSet = IntegerSet_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Set, itemType: AsnPropTypes.Integer })
], IntegerSet);
class AuthorizationList {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ context: 1, type: IntegerSet, optional: true })
], AuthorizationList.prototype, "purpose", undefined);
__decorate([
  AsnProp({ context: 2, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "algorithm", undefined);
__decorate([
  AsnProp({ context: 3, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "keySize", undefined);
__decorate([
  AsnProp({ context: 5, type: IntegerSet, optional: true })
], AuthorizationList.prototype, "digest", undefined);
__decorate([
  AsnProp({ context: 6, type: IntegerSet, optional: true })
], AuthorizationList.prototype, "padding", undefined);
__decorate([
  AsnProp({ context: 10, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "ecCurve", undefined);
__decorate([
  AsnProp({ context: 200, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "rsaPublicExponent", undefined);
__decorate([
  AsnProp({ context: 203, type: IntegerSet, optional: true })
], AuthorizationList.prototype, "mgfDigest", undefined);
__decorate([
  AsnProp({ context: 303, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "rollbackResistance", undefined);
__decorate([
  AsnProp({ context: 305, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "earlyBootOnly", undefined);
__decorate([
  AsnProp({ context: 400, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "activeDateTime", undefined);
__decorate([
  AsnProp({ context: 401, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "originationExpireDateTime", undefined);
__decorate([
  AsnProp({ context: 402, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "usageExpireDateTime", undefined);
__decorate([
  AsnProp({ context: 405, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "usageCountLimit", undefined);
__decorate([
  AsnProp({ context: 503, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "noAuthRequired", undefined);
__decorate([
  AsnProp({ context: 504, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "userAuthType", undefined);
__decorate([
  AsnProp({ context: 505, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "authTimeout", undefined);
__decorate([
  AsnProp({ context: 506, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "allowWhileOnBody", undefined);
__decorate([
  AsnProp({ context: 507, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "trustedUserPresenceRequired", undefined);
__decorate([
  AsnProp({ context: 508, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "trustedConfirmationRequired", undefined);
__decorate([
  AsnProp({ context: 509, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "unlockedDeviceRequired", undefined);
__decorate([
  AsnProp({ context: 600, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "allApplications", undefined);
__decorate([
  AsnProp({ context: 601, type: OctetString2, optional: true })
], AuthorizationList.prototype, "applicationId", undefined);
__decorate([
  AsnProp({ context: 701, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "creationDateTime", undefined);
__decorate([
  AsnProp({ context: 702, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "origin", undefined);
__decorate([
  AsnProp({ context: 703, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "rollbackResistant", undefined);
__decorate([
  AsnProp({ context: 704, type: RootOfTrust, optional: true })
], AuthorizationList.prototype, "rootOfTrust", undefined);
__decorate([
  AsnProp({ context: 705, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "osVersion", undefined);
__decorate([
  AsnProp({ context: 706, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "osPatchLevel", undefined);
__decorate([
  AsnProp({ context: 709, type: OctetString2, optional: true })
], AuthorizationList.prototype, "attestationApplicationId", undefined);
__decorate([
  AsnProp({ context: 710, type: OctetString2, optional: true })
], AuthorizationList.prototype, "attestationIdBrand", undefined);
__decorate([
  AsnProp({ context: 711, type: OctetString2, optional: true })
], AuthorizationList.prototype, "attestationIdDevice", undefined);
__decorate([
  AsnProp({ context: 712, type: OctetString2, optional: true })
], AuthorizationList.prototype, "attestationIdProduct", undefined);
__decorate([
  AsnProp({ context: 713, type: OctetString2, optional: true })
], AuthorizationList.prototype, "attestationIdSerial", undefined);
__decorate([
  AsnProp({ context: 714, type: OctetString2, optional: true })
], AuthorizationList.prototype, "attestationIdImei", undefined);
__decorate([
  AsnProp({ context: 715, type: OctetString2, optional: true })
], AuthorizationList.prototype, "attestationIdMeid", undefined);
__decorate([
  AsnProp({ context: 716, type: OctetString2, optional: true })
], AuthorizationList.prototype, "attestationIdManufacturer", undefined);
__decorate([
  AsnProp({ context: 717, type: OctetString2, optional: true })
], AuthorizationList.prototype, "attestationIdModel", undefined);
__decorate([
  AsnProp({ context: 718, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "vendorPatchLevel", undefined);
__decorate([
  AsnProp({ context: 719, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "bootPatchLevel", undefined);
__decorate([
  AsnProp({ context: 720, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "deviceUniqueAttestation", undefined);
var SecurityLevel;
(function(SecurityLevel2) {
  SecurityLevel2[SecurityLevel2["software"] = 0] = "software";
  SecurityLevel2[SecurityLevel2["trustedEnvironment"] = 1] = "trustedEnvironment";
  SecurityLevel2[SecurityLevel2["strongBox"] = 2] = "strongBox";
})(SecurityLevel || (SecurityLevel = {}));
var Version10;
(function(Version11) {
  Version11[Version11["KM2"] = 1] = "KM2";
  Version11[Version11["KM3"] = 2] = "KM3";
  Version11[Version11["KM4"] = 3] = "KM4";
  Version11[Version11["KM4_1"] = 4] = "KM4_1";
  Version11[Version11["keyMint1"] = 100] = "keyMint1";
  Version11[Version11["keyMint2"] = 200] = "keyMint2";
})(Version10 || (Version10 = {}));

class KeyDescription {
  constructor(params = {}) {
    this.attestationVersion = Version10.KM4;
    this.attestationSecurityLevel = SecurityLevel.software;
    this.keymasterVersion = 0;
    this.keymasterSecurityLevel = SecurityLevel.software;
    this.attestationChallenge = new OctetString2;
    this.uniqueId = new OctetString2;
    this.softwareEnforced = new AuthorizationList;
    this.teeEnforced = new AuthorizationList;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], KeyDescription.prototype, "attestationVersion", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Enumerated })
], KeyDescription.prototype, "attestationSecurityLevel", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], KeyDescription.prototype, "keymasterVersion", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Enumerated })
], KeyDescription.prototype, "keymasterSecurityLevel", undefined);
__decorate([
  AsnProp({ type: OctetString2 })
], KeyDescription.prototype, "attestationChallenge", undefined);
__decorate([
  AsnProp({ type: OctetString2 })
], KeyDescription.prototype, "uniqueId", undefined);
__decorate([
  AsnProp({ type: AuthorizationList })
], KeyDescription.prototype, "softwareEnforced", undefined);
__decorate([
  AsnProp({ type: AuthorizationList })
], KeyDescription.prototype, "teeEnforced", undefined);
// node_modules/@peculiar/asn1-android/build/es2015/nonstandard.js
var NonStandardAuthorizationList_1;
var NonStandardAuthorization = class NonStandardAuthorization2 extends AuthorizationList {
};
NonStandardAuthorization = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], NonStandardAuthorization);
var NonStandardAuthorizationList = NonStandardAuthorizationList_1 = class NonStandardAuthorizationList2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, NonStandardAuthorizationList_1.prototype);
  }
  findProperty(key) {
    const prop = this.find((o) => (key in o));
    if (prop) {
      return prop[key];
    }
    return;
  }
};
NonStandardAuthorizationList = NonStandardAuthorizationList_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: NonStandardAuthorization })
], NonStandardAuthorizationList);
class NonStandardKeyDescription {
  constructor(params = {}) {
    this.attestationVersion = Version10.KM4;
    this.attestationSecurityLevel = SecurityLevel.software;
    this.keymasterVersion = 0;
    this.keymasterSecurityLevel = SecurityLevel.software;
    this.attestationChallenge = new OctetString2;
    this.uniqueId = new OctetString2;
    this.softwareEnforced = new NonStandardAuthorizationList;
    this.teeEnforced = new NonStandardAuthorizationList;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], NonStandardKeyDescription.prototype, "attestationVersion", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Enumerated })
], NonStandardKeyDescription.prototype, "attestationSecurityLevel", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], NonStandardKeyDescription.prototype, "keymasterVersion", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Enumerated })
], NonStandardKeyDescription.prototype, "keymasterSecurityLevel", undefined);
__decorate([
  AsnProp({ type: OctetString2 })
], NonStandardKeyDescription.prototype, "attestationChallenge", undefined);
__decorate([
  AsnProp({ type: OctetString2 })
], NonStandardKeyDescription.prototype, "uniqueId", undefined);
__decorate([
  AsnProp({ type: NonStandardAuthorizationList })
], NonStandardKeyDescription.prototype, "softwareEnforced", undefined);
__decorate([
  AsnProp({ type: NonStandardAuthorizationList })
], NonStandardKeyDescription.prototype, "teeEnforced", undefined);
// node_modules/@peculiar/asn1-android/build/es2015/attestation.js
class AttestationPackageInfo {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.OctetString })
], AttestationPackageInfo.prototype, "packageName", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], AttestationPackageInfo.prototype, "version", undefined);

class AttestationApplicationId {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AttestationPackageInfo, repeated: "set" })
], AttestationApplicationId.prototype, "packageInfos", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.OctetString, repeated: "set" })
], AttestationApplicationId.prototype, "signatureDigests", undefined);
// node_modules/@simplewebauthn/server/esm/registration/verifications/verifyAttestationAndroidKey.js
async function verifyAttestationAndroidKey(options) {
  const { authData, clientDataHash, attStmt, credentialPublicKey, aaguid, rootCertificates } = options;
  const x5c = attStmt.get("x5c");
  const sig = attStmt.get("sig");
  const alg = attStmt.get("alg");
  if (!x5c) {
    throw new Error("No attestation certificate provided in attestation statement (Android Key)");
  }
  if (!sig) {
    throw new Error("No attestation signature provided in attestation statement (Android Key)");
  }
  if (!alg) {
    throw new Error(`Attestation statement did not contain alg (Android Key)`);
  }
  if (!isCOSEAlg(alg)) {
    throw new Error(`Attestation statement contained invalid alg ${alg} (Android Key)`);
  }
  const parsedCert = AsnParser.parse(x5c[0], Certificate);
  const parsedCertPubKey = new Uint8Array(parsedCert.tbsCertificate.subjectPublicKeyInfo.subjectPublicKey);
  const credPubKeyPKCS = convertCOSEtoPKCS(credentialPublicKey);
  if (!exports_isoUint8Array.areEqual(credPubKeyPKCS, parsedCertPubKey)) {
    throw new Error("Credential public key does not equal leaf cert public key (Android Key)");
  }
  const extKeyStore = parsedCert.tbsCertificate.extensions?.find((ext) => ext.extnID === id_ce_keyDescription);
  if (!extKeyStore) {
    throw new Error("Certificate did not contain extKeyStore (Android Key)");
  }
  const parsedExtKeyStore = AsnParser.parse(extKeyStore.extnValue, KeyDescription);
  const { attestationChallenge, teeEnforced, softwareEnforced } = parsedExtKeyStore;
  if (!exports_isoUint8Array.areEqual(new Uint8Array(attestationChallenge.buffer), clientDataHash)) {
    throw new Error("Attestation challenge was not equal to client data hash (Android Key)");
  }
  if (teeEnforced.allApplications !== undefined) {
    throw new Error('teeEnforced contained "allApplications [600]" tag (Android Key)');
  }
  if (softwareEnforced.allApplications !== undefined) {
    throw new Error('teeEnforced contained "allApplications [600]" tag (Android Key)');
  }
  const statement = await MetadataService.getStatement(aaguid);
  if (statement) {
    try {
      await verifyAttestationWithMetadata({
        statement,
        credentialPublicKey,
        x5c,
        attestationStatementAlg: alg
      });
    } catch (err) {
      const _err = err;
      throw new Error(`${_err.message} (Android Key)`, { cause: _err });
    }
  } else {
    const x5cNoRootPEM = x5c.slice(0, -1).map(convertCertBufferToPEM);
    const x5cRootPEM = x5c.slice(-1).map(convertCertBufferToPEM);
    try {
      await validateCertificatePath(x5cNoRootPEM, x5cRootPEM);
    } catch (err) {
      const _err = err;
      throw new Error(`${_err.message} (Android Key)`, { cause: _err });
    }
    if (rootCertificates.length > 0 && rootCertificates.indexOf(x5cRootPEM[0]) < 0) {
      throw new Error("x5c root certificate was not a known root certificate (Android Key)");
    }
  }
  const signatureBase = exports_isoUint8Array.concat([authData, clientDataHash]);
  return verifySignature2({
    signature: sig,
    data: signatureBase,
    x509Certificate: x5c[0],
    hashAlgorithm: alg
  });
}

// node_modules/@simplewebauthn/server/esm/registration/verifications/verifyAttestationApple.js
async function verifyAttestationApple(options) {
  const { attStmt, authData, clientDataHash, credentialPublicKey, rootCertificates } = options;
  const x5c = attStmt.get("x5c");
  if (!x5c) {
    throw new Error("No attestation certificate provided in attestation statement (Apple)");
  }
  try {
    await validateCertificatePath(x5c.map(convertCertBufferToPEM), rootCertificates);
  } catch (err) {
    const _err = err;
    throw new Error(`${_err.message} (Apple)`);
  }
  const parsedCredCert = AsnParser.parse(x5c[0], Certificate);
  const { extensions: extensions9, subjectPublicKeyInfo } = parsedCredCert.tbsCertificate;
  if (!extensions9) {
    throw new Error("credCert missing extensions (Apple)");
  }
  const extCertNonce = extensions9.find((ext) => ext.extnID === "1.2.840.113635.100.8.2");
  if (!extCertNonce) {
    throw new Error('credCert missing "1.2.840.113635.100.8.2" extension (Apple)');
  }
  const nonceToHash = exports_isoUint8Array.concat([authData, clientDataHash]);
  const nonce = await toHash(nonceToHash);
  const extNonce = new Uint8Array(extCertNonce.extnValue.buffer).slice(6);
  if (!exports_isoUint8Array.areEqual(nonce, extNonce)) {
    throw new Error(`credCert nonce was not expected value (Apple)`);
  }
  const credPubKeyPKCS = convertCOSEtoPKCS(credentialPublicKey);
  const credCertSubjectPublicKey = new Uint8Array(subjectPublicKeyInfo.subjectPublicKey);
  if (!exports_isoUint8Array.areEqual(credPubKeyPKCS, credCertSubjectPublicKey)) {
    throw new Error("Credential public key does not equal credCert public key (Apple)");
  }
  return true;
}

// node_modules/@simplewebauthn/server/esm/registration/verifyRegistrationResponse.js
async function verifyRegistrationResponse(options) {
  const { response, expectedChallenge, expectedOrigin, expectedRPID, expectedType, requireUserPresence = true, requireUserVerification = true, supportedAlgorithmIDs = supportedCOSEAlgorithmIdentifiers, attestationSafetyNetEnforceCTSCheck = true } = options;
  const { id, rawId, type: credentialType, response: attestationResponse } = response;
  if (!id) {
    throw new Error("Missing credential ID");
  }
  if (id !== rawId) {
    throw new Error("Credential ID was not base64url-encoded");
  }
  if (credentialType !== "public-key") {
    throw new Error(`Unexpected credential type ${credentialType}, expected "public-key"`);
  }
  const clientDataJSON = decodeClientDataJSON(attestationResponse.clientDataJSON);
  const { type, origin, challenge, tokenBinding } = clientDataJSON;
  if (Array.isArray(expectedType)) {
    if (!expectedType.includes(type)) {
      const joinedExpectedType = expectedType.join(", ");
      throw new Error(`Unexpected registration response type "${type}", expected one of: ${joinedExpectedType}`);
    }
  } else if (expectedType) {
    if (type !== expectedType) {
      throw new Error(`Unexpected registration response type "${type}", expected "${expectedType}"`);
    }
  } else if (type !== "webauthn.create") {
    throw new Error(`Unexpected registration response type: ${type}`);
  }
  if (typeof expectedChallenge === "function") {
    if (!await expectedChallenge(challenge)) {
      throw new Error(`Custom challenge verifier returned false for registration response challenge "${challenge}"`);
    }
  } else if (challenge !== expectedChallenge) {
    throw new Error(`Unexpected registration response challenge "${challenge}", expected "${expectedChallenge}"`);
  }
  if (Array.isArray(expectedOrigin)) {
    if (!expectedOrigin.includes(origin)) {
      throw new Error(`Unexpected registration response origin "${origin}", expected one of: ${expectedOrigin.join(", ")}`);
    }
  } else {
    if (origin !== expectedOrigin) {
      throw new Error(`Unexpected registration response origin "${origin}", expected "${expectedOrigin}"`);
    }
  }
  if (tokenBinding) {
    if (typeof tokenBinding !== "object") {
      throw new Error(`Unexpected value for TokenBinding "${tokenBinding}"`);
    }
    if (["present", "supported", "not-supported"].indexOf(tokenBinding.status) < 0) {
      throw new Error(`Unexpected tokenBinding.status value of "${tokenBinding.status}"`);
    }
  }
  const attestationObject = exports_isoBase64URL.toBuffer(attestationResponse.attestationObject);
  const decodedAttestationObject = decodeAttestationObject(attestationObject);
  const fmt = decodedAttestationObject.get("fmt");
  const authData = decodedAttestationObject.get("authData");
  const attStmt = decodedAttestationObject.get("attStmt");
  const parsedAuthData = parseAuthenticatorData(authData);
  const { aaguid, rpIdHash, flags, credentialID, counter, credentialPublicKey, extensionsData } = parsedAuthData;
  let matchedRPID;
  if (expectedRPID) {
    let expectedRPIDs = [];
    if (typeof expectedRPID === "string") {
      expectedRPIDs = [expectedRPID];
    } else {
      expectedRPIDs = expectedRPID;
    }
    matchedRPID = await matchExpectedRPID(rpIdHash, expectedRPIDs);
  }
  if (requireUserPresence && !flags.up) {
    throw new Error("User presence was required, but user was not present");
  }
  if (requireUserVerification && !flags.uv) {
    throw new Error("User verification was required, but user could not be verified");
  }
  if (!credentialID) {
    throw new Error("No credential ID was provided by authenticator");
  }
  if (!credentialPublicKey) {
    throw new Error("No public key was provided by authenticator");
  }
  if (!aaguid) {
    throw new Error("No AAGUID was present during registration");
  }
  const decodedPublicKey = decodeCredentialPublicKey(credentialPublicKey);
  const alg = decodedPublicKey.get(COSEKEYS.alg);
  if (typeof alg !== "number") {
    throw new Error("Credential public key was missing numeric alg");
  }
  if (!supportedAlgorithmIDs.includes(alg)) {
    const supported = supportedAlgorithmIDs.join(", ");
    throw new Error(`Unexpected public key alg "${alg}", expected one of "${supported}"`);
  }
  const clientDataHash = await toHash(exports_isoBase64URL.toBuffer(attestationResponse.clientDataJSON));
  const rootCertificates = SettingsService.getRootCertificates({
    identifier: fmt
  });
  const verifierOpts = {
    aaguid,
    attStmt,
    authData,
    clientDataHash,
    credentialID,
    credentialPublicKey,
    rootCertificates,
    rpIdHash,
    attestationSafetyNetEnforceCTSCheck
  };
  let verified = false;
  if (fmt === "fido-u2f") {
    verified = await verifyAttestationFIDOU2F(verifierOpts);
  } else if (fmt === "packed") {
    verified = await verifyAttestationPacked(verifierOpts);
  } else if (fmt === "android-safetynet") {
    verified = await verifyAttestationAndroidSafetyNet(verifierOpts);
  } else if (fmt === "android-key") {
    verified = await verifyAttestationAndroidKey(verifierOpts);
  } else if (fmt === "tpm") {
    verified = await verifyAttestationTPM(verifierOpts);
  } else if (fmt === "apple") {
    verified = await verifyAttestationApple(verifierOpts);
  } else if (fmt === "none") {
    if (attStmt.size > 0) {
      throw new Error("None attestation had unexpected attestation statement");
    }
    verified = true;
  } else {
    throw new Error(`Unsupported Attestation Format: ${fmt}`);
  }
  if (!verified) {
    return { verified: false };
  }
  const { credentialDeviceType, credentialBackedUp } = parseBackupFlags(flags);
  return {
    verified: true,
    registrationInfo: {
      fmt,
      aaguid: convertAAGUIDToString(aaguid),
      credentialType,
      credential: {
        id: exports_isoBase64URL.fromBuffer(credentialID),
        publicKey: credentialPublicKey,
        counter,
        transports: response.response.transports
      },
      attestationObject,
      userVerified: flags.uv,
      credentialDeviceType,
      credentialBackedUp,
      origin: clientDataJSON.origin,
      rpID: matchedRPID,
      authenticatorExtensionResults: extensionsData
    }
  };
}
// node_modules/@simplewebauthn/server/esm/authentication/generateAuthenticationOptions.js
async function generateAuthenticationOptions(options) {
  const { allowCredentials, challenge = await generateChallenge2(), timeout = 60000, userVerification = "preferred", extensions: extensions9, rpID } = options;
  let _challenge = challenge;
  if (typeof _challenge === "string") {
    _challenge = exports_isoUint8Array.fromUTF8String(_challenge);
  }
  return {
    rpId: rpID,
    challenge: exports_isoBase64URL.fromBuffer(_challenge),
    allowCredentials: allowCredentials?.map((cred) => {
      if (!exports_isoBase64URL.isBase64URL(cred.id)) {
        throw new Error(`allowCredential id "${cred.id}" is not a valid base64url string`);
      }
      return {
        ...cred,
        id: exports_isoBase64URL.trimPadding(cred.id),
        type: "public-key"
      };
    }),
    timeout,
    userVerification,
    extensions: extensions9
  };
}
// node_modules/@simplewebauthn/server/esm/authentication/verifyAuthenticationResponse.js
async function verifyAuthenticationResponse(options) {
  const { response, expectedChallenge, expectedOrigin, expectedRPID, expectedType, credential, requireUserVerification = true, advancedFIDOConfig } = options;
  const { id, rawId, type: credentialType, response: assertionResponse } = response;
  if (!id) {
    throw new Error("Missing credential ID");
  }
  if (id !== rawId) {
    throw new Error("Credential ID was not base64url-encoded");
  }
  if (credentialType !== "public-key") {
    throw new Error(`Unexpected credential type ${credentialType}, expected "public-key"`);
  }
  if (!response) {
    throw new Error("Credential missing response");
  }
  if (typeof assertionResponse?.clientDataJSON !== "string") {
    throw new Error("Credential response clientDataJSON was not a string");
  }
  const clientDataJSON = decodeClientDataJSON(assertionResponse.clientDataJSON);
  const { type, origin, challenge, tokenBinding } = clientDataJSON;
  if (Array.isArray(expectedType)) {
    if (!expectedType.includes(type)) {
      const joinedExpectedType = expectedType.join(", ");
      throw new Error(`Unexpected authentication response type "${type}", expected one of: ${joinedExpectedType}`);
    }
  } else if (expectedType) {
    if (type !== expectedType) {
      throw new Error(`Unexpected authentication response type "${type}", expected "${expectedType}"`);
    }
  } else if (type !== "webauthn.get") {
    throw new Error(`Unexpected authentication response type: ${type}`);
  }
  if (typeof expectedChallenge === "function") {
    if (!await expectedChallenge(challenge)) {
      throw new Error(`Custom challenge verifier returned false for registration response challenge "${challenge}"`);
    }
  } else if (challenge !== expectedChallenge) {
    throw new Error(`Unexpected authentication response challenge "${challenge}", expected "${expectedChallenge}"`);
  }
  if (Array.isArray(expectedOrigin)) {
    if (!expectedOrigin.includes(origin)) {
      const joinedExpectedOrigin = expectedOrigin.join(", ");
      throw new Error(`Unexpected authentication response origin "${origin}", expected one of: ${joinedExpectedOrigin}`);
    }
  } else {
    if (origin !== expectedOrigin) {
      throw new Error(`Unexpected authentication response origin "${origin}", expected "${expectedOrigin}"`);
    }
  }
  if (!exports_isoBase64URL.isBase64URL(assertionResponse.authenticatorData)) {
    throw new Error("Credential response authenticatorData was not a base64url string");
  }
  if (!exports_isoBase64URL.isBase64URL(assertionResponse.signature)) {
    throw new Error("Credential response signature was not a base64url string");
  }
  if (assertionResponse.userHandle && typeof assertionResponse.userHandle !== "string") {
    throw new Error("Credential response userHandle was not a string");
  }
  if (tokenBinding) {
    if (typeof tokenBinding !== "object") {
      throw new Error("ClientDataJSON tokenBinding was not an object");
    }
    if (["present", "supported", "notSupported"].indexOf(tokenBinding.status) < 0) {
      throw new Error(`Unexpected tokenBinding status ${tokenBinding.status}`);
    }
  }
  const authDataBuffer = exports_isoBase64URL.toBuffer(assertionResponse.authenticatorData);
  const parsedAuthData = parseAuthenticatorData(authDataBuffer);
  const { rpIdHash, flags, counter, extensionsData } = parsedAuthData;
  let expectedRPIDs = [];
  if (typeof expectedRPID === "string") {
    expectedRPIDs = [expectedRPID];
  } else {
    expectedRPIDs = expectedRPID;
  }
  const matchedRPID = await matchExpectedRPID(rpIdHash, expectedRPIDs);
  if (advancedFIDOConfig !== undefined) {
    const { userVerification: fidoUserVerification } = advancedFIDOConfig;
    if (fidoUserVerification === "required") {
      if (!flags.uv) {
        throw new Error("User verification required, but user could not be verified");
      }
    } else if (fidoUserVerification === "preferred" || fidoUserVerification === "discouraged") {}
  } else {
    if (!flags.up) {
      throw new Error("User not present during authentication");
    }
    if (requireUserVerification && !flags.uv) {
      throw new Error("User verification required, but user could not be verified");
    }
  }
  const clientDataHash = await toHash(exports_isoBase64URL.toBuffer(assertionResponse.clientDataJSON));
  const signatureBase = exports_isoUint8Array.concat([authDataBuffer, clientDataHash]);
  const signature = exports_isoBase64URL.toBuffer(assertionResponse.signature);
  if ((counter > 0 || credential.counter > 0) && counter <= credential.counter) {
    throw new Error(`Response counter value ${counter} was lower than expected ${credential.counter}`);
  }
  const { credentialDeviceType, credentialBackedUp } = parseBackupFlags(flags);
  const toReturn = {
    verified: await verifySignature2({
      signature,
      data: signatureBase,
      credentialPublicKey: credential.publicKey
    }),
    authenticationInfo: {
      newCounter: counter,
      credentialID: credential.id,
      userVerified: flags.uv,
      credentialDeviceType,
      credentialBackedUp,
      authenticatorExtensionResults: extensionsData,
      origin: clientDataJSON.origin,
      rpID: matchedRPID
    }
  };
  return toReturn;
}
// server/db/module/regUser.ts
var createAdminOrUsers = async (user_name, user_email) => {
  const result = await sql.begin(async (tx) => {
    const [isAdminExist] = await tx`
      SELECT reg_user_id FROM multi_schema."RegisteredUser" LIMIT 1`;
    const userId = Bun.randomUUIDv7();
    const [serverId] = await sql`
      SELECT * FROM multi_schema."ServerSystem" LIMIT 1`;
    const insertUser = {
      reg_user_id: userId,
      user_name,
      user_email,
      role_type: !isAdminExist ? "admin" : "user",
      status: !isAdminExist,
      ServerSystem: serverId.system_id
    };
    await tx`
      INSERT INTO multi_schema."RegisteredUser" ${sql(insertUser)}`;
    return userId;
  });
  return result;
};
var createPasskey = async (cred_id, cred_public_key, RegisteredUser, counter, registered_device, backup_eligible, transports) => {
  try {
    const [result] = await sql`
      INSERT INTO multi_schema."Passkeys" ( cred_id,  cred_public_key,  "RegisteredUser",  counter,  registered_device,  backup_eligible,  transports) 
    VALUES (${cred_id}, ${cred_public_key}, ${RegisteredUser}, ${counter}, ${registered_device}, ${backup_eligible}, ${JSON.stringify(transports)}::jsonb ) RETURNING *`;
    return result;
  } catch (error) {
    console.log(error);
    return null;
  }
};
var findRegUser = async (user_email) => {
  const [user] = await sql`
    SELECT reg_user_id, user_email, status, role_type FROM multi_schema."RegisteredUser" 
    WHERE user_email = ${user_email} LIMIT 1`;
  return user;
};
var userPassKeyByEmail = async (user_email) => {
  const [rows] = await sql`
    SELECT reg.reg_user_id, reg.user_email, reg.user_name, reg.role_type, reg.status, pks.cred_id, pks.cred_public_key, pks.counter, pks.transports 
    FROM multi_schema."RegisteredUser" reg 
    JOIN multi_schema."Passkeys" pks ON reg.reg_user_id = pks."RegisteredUser"
    WHERE reg.user_email = ${user_email}`;
  return rows;
};
var countSuspendedUsers = async () => {
  const [result] = await sql`
    SELECT COUNT(reg_user_id) AS count_users 
    FROM multi_schema."RegisteredUser" 
    WHERE status = false`;
  return result.count_users;
};
var updateAccountStatus = async (userEmail) => {
  const [result] = await sql`
    UPDATE multi_schema."RegisteredUser" SET status = NOT status 
    WHERE user_email = ${userEmail} RETURNING reg_user_id`;
  return result;
};

// node_modules/hono/dist/utils/buffer.js
var bufferToFormData = (arrayBuffer, contentType) => {
  const response = new Response(arrayBuffer, {
    headers: {
      "Content-Type": contentType
    }
  });
  return response.formData();
};

// node_modules/hono/dist/validator/validator.js
var jsonRegex = /^application\/([a-z-\.]+\+)?json(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var multipartRegex = /^multipart\/form-data(;\s?boundary=[a-zA-Z0-9'"()+_,\-./:=?]+)?$/;
var urlencodedRegex = /^application\/x-www-form-urlencoded(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var validator = (target2, validationFunc) => {
  return async (c, next) => {
    let value = {};
    const contentType = c.req.header("Content-Type");
    switch (target2) {
      case "json":
        if (!contentType || !jsonRegex.test(contentType)) {
          break;
        }
        try {
          value = await c.req.json();
        } catch {
          const message = "Malformed JSON in request body";
          throw new HTTPException(400, { message });
        }
        break;
      case "form": {
        if (!contentType || !(multipartRegex.test(contentType) || urlencodedRegex.test(contentType))) {
          break;
        }
        let formData;
        if (c.req.bodyCache.formData) {
          formData = await c.req.bodyCache.formData;
        } else {
          try {
            const arrayBuffer = await c.req.arrayBuffer();
            formData = await bufferToFormData(arrayBuffer, contentType);
            c.req.bodyCache.formData = formData;
          } catch (e) {
            let message = "Malformed FormData request.";
            message += e instanceof Error ? ` ${e.message}` : ` ${String(e)}`;
            throw new HTTPException(400, { message });
          }
        }
        const form = {};
        formData.forEach((value2, key) => {
          if (key.endsWith("[]")) {
            (form[key] ??= []).push(value2);
          } else if (Array.isArray(form[key])) {
            form[key].push(value2);
          } else if (key in form) {
            form[key] = [form[key], value2];
          } else {
            form[key] = value2;
          }
        });
        value = form;
        break;
      }
      case "query":
        value = Object.fromEntries(Object.entries(c.req.queries()).map(([k, v]) => {
          return v.length === 1 ? [k, v[0]] : [k, v];
        }));
        break;
      case "param":
        value = c.req.param();
        break;
      case "header":
        value = c.req.header();
        break;
      case "cookie":
        value = getCookie(c);
        break;
    }
    const res = await validationFunc(value, c);
    if (res instanceof Response) {
      return res;
    }
    c.req.addValidatedData(target2, res);
    return await next();
  };
};

// node_modules/@hono/zod-validator/dist/index.js
var zValidator = (target2, schema, hook) => validator(target2, async (value, c) => {
  let validatorValue = value;
  if (target2 === "header" && schema instanceof ZodObject) {
    const schemaKeys = Object.keys(schema.shape);
    const caseInsensitiveKeymap = Object.fromEntries(schemaKeys.map((key) => [key.toLowerCase(), key]));
    validatorValue = Object.fromEntries(Object.entries(value).map(([key, value2]) => [caseInsensitiveKeymap[key] || key, value2]));
  }
  const result = await schema.safeParseAsync(validatorValue);
  if (hook) {
    const hookResult = await hook({ data: validatorValue, ...result, target: target2 }, c);
    if (hookResult) {
      if (hookResult instanceof Response) {
        return hookResult;
      }
      if ("response" in hookResult) {
        return hookResult.response;
      }
    }
  }
  if (!result.success) {
    return c.json(result, 400);
  }
  return result.data;
});

// server/modules/validateSchema.ts
var validateSchema = (type, schema) => zValidator(type, schema, (result, c) => {
  if (!result.success)
    return c.json({ error: result.error.errors[0].message }, 400);
});

// server/routes/auth.ts
var auth = new Hono2;
var WEBSITE_TITLE = "Photos Gallery X";
var LIMIT_NUMBER_REGISTER = 2;
auth.get("/init-register", logUserInDB(false), validateSchema("query", userAuthSchema), async (c) => {
  try {
    const result = await countSuspendedUsers();
    if (result.waiting >= LIMIT_NUMBER_REGISTER)
      return c.json({ error: "User creation have reached limited." }, 400);
    const { username, email } = c.req.valid("query");
    if (!email)
      return c.json({ error: "Email is required" }, 400);
    if (await findRegUser(email))
      return c.json({ error: "User already exists" }, 400);
    const options = await generateRegistrationOptions({
      rpName: WEBSITE_TITLE,
      rpID: Bun.env.DOMAIN_NAME,
      userName: email,
      userDisplayName: username,
      authenticatorSelection: {
        residentKey: "required",
        userVerification: "preferred"
      }
    });
    const registerInfor = { username, email, challenge: options.challenge };
    await setSecureCookie(c, "regInfo", registerInfor);
    return c.json(options, 200);
  } catch (error) {
    console.error(error);
    await insertErrorLog("auth.ts", "init-register", error);
    return c.json({ error: "Failed to fetch Account" }, 500);
  }
});
auth.post("/verify-register", async (c) => {
  try {
    const regInfo = await getSecureCookie(c, "regInfo");
    if (!regInfo)
      return c.json({ error: "Registration info not found" }, 403);
    const reqJson = await c.req.json();
    const verification = await verifyRegistrationResponse({
      response: reqJson,
      expectedChallenge: regInfo.challenge,
      expectedOrigin: Bun.env.ORIGIN_URL,
      expectedRPID: Bun.env.DOMAIN_NAME,
      requireUserVerification: true
    });
    if (!(verification.verified && verification.registrationInfo)) {
      return c.json({ verified: false, error: "Verification failed" }, 400);
    }
    const lastInsertId = await createAdminOrUsers(regInfo.username, regInfo.email);
    if (!lastInsertId)
      return c.json({ error: "User creation failed" }, 400);
    const createPK = await createPasskey(verification.registrationInfo.credential.id, verification.registrationInfo.credential.publicKey, lastInsertId, verification.registrationInfo.credential.counter, verification.registrationInfo.credentialDeviceType, verification.registrationInfo.credentialBackedUp, verification.registrationInfo.credential.transports);
    if (!createPK)
      return c.json({ error: "Passkey creation failed" }, 400);
    clearCookie(c, "regInfo");
    return c.json({ verified: verification.verified }, 200);
  } catch (error) {
    await insertErrorLog("auth.ts", "verify-register", error);
    return c.json({ error: "Error with verification" }, 500);
  }
});
auth.get("/init-auth", logUserInDB(true), validateSchema("query", userAuthSchema), async (c) => {
  try {
    const { email } = c.req.valid("query");
    if (!email)
      return c.json({ error: "Email is required" }, 400);
    const userAccount = await findRegUser(email);
    if (!userAccount)
      return c.json({ error: "No user for this email" }, 400);
    if (!userAccount.status)
      return c.json({ error: `You don't have permission to log in at the moment. Please wait for admin approval` }, 400);
    const userPasskeys = await userPassKeyByEmail(email);
    if (!userPasskeys)
      return c.json({ error: "No passkey created for this email" }, 400);
    const options = await generateAuthenticationOptions({
      rpID: Bun.env.DOMAIN_NAME,
      allowCredentials: [
        {
          id: userPasskeys.cred_id,
          transports: JSON.parse(userPasskeys.transports)
        }
      ],
      userVerification: "required"
    });
    await setSecureCookie(c, "authInfo", { email, challenge: options.challenge });
    return c.json(options, 200);
  } catch (error) {
    await insertErrorLog("auth.ts", "init-auth", error);
    return c.json({ error: "Failed to auth " }, 500);
  }
});
auth.post("/verify-auth", async (c) => {
  try {
    const authInfo = await getSecureCookie(c, "authInfo");
    if (!authInfo)
      return c.json({ error: "Authentication info not found" }, 400);
    const userPasskeys = await userPassKeyByEmail(authInfo.email);
    if (!userPasskeys)
      return c.json({ error: "Invalid user credentials" }, 401);
    const reqJsonBody = await c.req.json();
    let verification;
    try {
      verification = await verifyAuthenticationResponse({
        response: reqJsonBody,
        expectedChallenge: authInfo.challenge,
        expectedOrigin: Bun.env.ORIGIN_URL,
        expectedRPID: Bun.env.DOMAIN_NAME,
        credential: {
          id: userPasskeys.cred_id,
          publicKey: userPasskeys.cred_public_key,
          counter: userPasskeys.counter,
          transports: JSON.parse(userPasskeys.transports)
        },
        requireUserVerification: true
      });
    } catch (error) {
      console.error(error);
      return c.json({ error: "Unauthorized access" }, 401);
    }
    const userLoggedIn = {
      userId: userPasskeys.reg_user_id,
      userEmail: userPasskeys.user_email,
      userName: userPasskeys.user_name,
      roleType: userPasskeys.role_type,
      status: userPasskeys.status
    };
    if (!verification.verified)
      return c.json({ verified: false, error: "Verification failed" }, 400);
    clearCookie(c, "authInfo");
    await createAuthSession(c, userLoggedIn);
    return c.json({ verified: verification.verified });
  } catch (error) {
    await insertErrorLog("auth.ts", "verify-auth", error);
    return c.json({ error: "Failed to auth" }, 500);
  }
});
var auth_default = auth;

// server/db/module/media.ts
import path2 from "path";
var {$: $3 } = globalThis.Bun;
var importedMediasThumbHash = async () => {
  return await sql`
    SELECT media_id, source_file, thumb_path, file_type, selected_frame, duration 
    FROM multi_schema."Media" 
    WHERE thumb_created = FALSE OR hash_code IS NULL
    ORDER BY media_id`;
};
var rescanThumbnail = async () => {
  return await sql`
    SELECT media_id, source_file, thumb_path, file_type, selected_frame, duration 
    FROM multi_schema."Media"
    ORDER BY media_id`;
};
var importedMediasCaption = async () => {
  return await sql`
    SELECT media_id, thumb_path FROM multi_schema."Media"
    WHERE caption IS NULL OR caption = '' ORDER BY media_id`;
};
var importedMediasLocation = async () => {
  return await sql`
    SELECT media_id, gps_latitude, gps_longitude 
    FROM multi_schema."Media" md
    LEFT JOIN multi_schema."LocationMedia" lm ON md.media_id = lm.media
    WHERE lm.media IS NULL AND md.gps_latitude IS NOT NULL
    ORDER BY media_id`;
};
var updateHashThumb = async (media_id, hashCode) => {
  return await sql.begin(async (tx) => {
    const [dupMedia] = await tx`
      SELECT media_id, hash_code 
      FROM multi_schema."Media" 
      WHERE hash_code = ${hashCode} AND media_id <> ${media_id} LIMIT 1`;
    if (dupMedia) {
      const insertDups = [
        { media: dupMedia.media_id, hash_code: dupMedia.hash_code },
        { media: media_id, hash_code: hashCode }
      ];
      await tx`
          INSERT INTO "multi_schema"."Duplicate" ${sql(insertDups)} 
          ON CONFLICT DO NOTHING`;
    }
    return await tx`
      UPDATE multi_schema."Media" SET hash_code = ${hashCode}, thumb_created = TRUE 
      WHERE media_id = ${media_id}`;
  });
};
var fetchCameraType = async () => {
  return await sql`
    SELECT camera_id, model FROM multi_schema."CameraType" 
    ORDER BY model ASC`;
};
var updateMedias = async (mediaIds, updateKey, updateValue) => {
  const result = await sql`
    UPDATE multi_schema."Media" SET ${sql(updateKey)} = ${updateValue} 
    WHERE media_id IN ${sql(mediaIds)}`;
  return result.count === mediaIds.length;
};
var updateMediaCaption = async (media) => {
  return await sql`
    UPDATE multi_schema."Media" SET caption = ${media.caption} 
    WHERE media_id = ${media.media_id}`;
};
var updateSelectFrameLivePhoto = async (mediaId, framePos) => {
  return await sql`
    UPDATE multi_schema."Media" SET selected_frame = ${framePos} 
    WHERE media_id = ${mediaId}`;
};
var updateCreateDate = async (mediaId, iso2) => {
  return await sql`
    UPDATE multi_schema."Media" SET create_date = ${iso2}::timestamptz
    WHERE media_id = ${mediaId} RETURNING media_id, create_date`;
};
var groupOfYear = async (inputMonth) => {
  const isMonth = inputMonth ? sql`AND md.create_month = ${inputMonth} ` : sql``;
  return await sql`
    SELECT create_year FROM multi_schema."Media" as md
    WHERE hidden = FALSE AND deleted = FALSE ${isMonth}
    GROUP BY create_year
    ORDER BY create_year DESC;
  `;
};
var groupMonthsByYear = async () => {
  return await sql`
    WITH ranked_media AS (
      SELECT media_id, thumb_path, file_type, create_year, create_month, create_date,
            ROW_NUMBER() OVER (
              PARTITION BY create_year, create_month
              ORDER BY create_date ) AS rn
        FROM multi_schema."Media" as md
        WHERE hidden = FALSE AND deleted = FALSE
    )
    SELECT * FROM ranked_media
    WHERE rn = 1
    ORDER BY create_year DESC, create_month DESC`;
};
var deleteMedias = async (mediaIds) => {
  try {
    const mediaDeleted = await sql.begin(async (tx) => {
      const deletePaths = await tx`
        SELECT media_id, source_file, thumb_path FROM "multi_schema"."Media" 
        WHERE media_id IN ${sql(mediaIds)}`;
      const result = await tx`
        DELETE FROM "multi_schema"."Media" 
        WHERE media_id IN ${sql(mediaIds)} 
        RETURNING media_id`;
      const countDelted = await deleteHelper(deletePaths);
      return result.length === countDelted ? countDelted : 0;
    });
    return mediaDeleted === mediaIds.length;
  } catch (error) {
    await insertErrorLog("db/module/media.ts", "deleteMedias", error);
    console.error("deleteMedias", error);
  }
};
var deleteAllInRecently = async () => {
  try {
    const mediaDeleted = await sql.begin(async (tx) => {
      const deletePaths = await tx`
        SELECT media_id, source_file, thumb_path FROM "multi_schema"."Media" 
        WHERE deleted = TRUE`;
      const result = await tx`
        DELETE FROM "multi_schema"."Media" 
        WHERE deleted = TRUE RETURNING media_id`;
      const countDelted = await deleteHelper(deletePaths);
      return result.length === countDelted;
    });
    return mediaDeleted;
  } catch (error) {
    await insertErrorLog("db/module/media.ts", "deleteMedias", error);
    console.error("deleteMedias", error);
  }
};
var deleteHelper = async (deletePaths) => {
  let count = 0;
  for (const each of deletePaths) {
    const thumbPath = path2.join(Bun.env.MAIN_PATH, each.thumb_path);
    const sourcePath = path2.join(Bun.env.MAIN_PATH, each.source_file);
    const { stderr, exitCode } = await $3`rm ${thumbPath} ${sourcePath}`;
    exitCode === 0 ? ++count : console.warn(stderr);
  }
  return count;
};
var createAlbum = async (regUserId, albumTitle) => {
  const [albumId] = await sql`
    INSERT INTO "multi_schema"."Album" ("RegisteredUser", title) 
    VALUES (${regUserId}, ${albumTitle}) RETURNING album_id`;
  return albumId.album_id;
};
var fetchAlbums = async () => {
  return await sql`
    SELECT al.album_id, al.title as title, COUNT(am.media) AS media_count, MIN(md.thumb_path) as thumb_path
    FROM multi_schema."Album" al
    LEFT JOIN multi_schema."AlbumMedia" am ON am.album = al.album_id
    LEFT JOIN multi_schema."Media" md ON am.media = md.media_id
    WHERE md.deleted = FALSE AND md.hidden = FALSE
    GROUP BY al.album_id
    ORDER BY al.title ASC`;
};
var fetchLocations = async () => {
  return await sql`
    SELECT loc.location_id, loc.city, loc.country, COUNT(lm.media) AS media_count, MIN(md.thumb_path) as thumb_path, MIN(md.create_date) as create_date
    FROM multi_schema."Location" loc
    LEFT JOIN multi_schema."LocationMedia" lm ON loc.location_id = lm.location
    LEFT JOIN multi_schema."Media" md ON lm.media = md.media_id
    WHERE md.deleted = FALSE AND md.hidden = FALSE
    GROUP BY loc.location_id
    ORDER BY loc.location_id ASC`;
};
var fetchAddToAlbum = async (mediaIds, albumId) => {
  const insertIds = mediaIds.map((id) => ({
    album: albumId,
    media: id
  }));
  return await sql`
    INSERT INTO "multi_schema"."AlbumMedia" ${sql(insertIds)} 
    ON CONFLICT DO NOTHING`;
};
var fetchRemoveFromAlbum = async (mediaIds, albumId) => {
  return await sql`
    DELETE FROM "multi_schema"."AlbumMedia" 
    WHERE album = ${albumId} AND media IN ${sql(mediaIds)}`;
};
var fetchMediaCount = async () => {
  const mediaCount = await sql`
    SELECT 
      SUM(CASE WHEN "favorite" = TRUE AND "hidden" = FALSE AND "deleted" = FALSE THEN 1 ELSE 0 END) AS "favorite",
      SUM(CASE WHEN "hidden" = TRUE AND "deleted" = FALSE THEN 1 ELSE 0 END) AS "hidden",
      ( SELECT COUNT("media") FROM "multi_schema"."Duplicate") AS "duplicate",
      SUM(CASE WHEN "deleted" = TRUE THEN 1 ELSE 0 END) AS "deleted"
    FROM "multi_schema"."Media"`;
  return mediaCount;
};
var sumSizeMediaType = async () => {
  const [mediaCount] = await sql`
    SELECT
        COALESCE(SUM(file_size) FILTER (WHERE file_type = 'Photo'), 0)::BIGINT AS "photo",
        COALESCE(SUM(file_size) FILTER (WHERE file_type = 'Live'), 0)::BIGINT AS "live",
        COALESCE(SUM(file_size) FILTER (WHERE file_type = 'Video'), 0)::BIGINT AS "video",
        SUM(file_size)::BIGINT AS "all"
    FROM "multi_schema"."Media"`;
  return mediaCount;
};
var getSourceFiles = async (mediaIds) => {
  return await sql`
    SELECT source_file FROM "multi_schema"."Media" 
    WHERE media_id IN ${sql(mediaIds)}`;
};
var mergeMedias = async () => {
  return await sql`
    SELECT media FROM (
      SELECT dp.media, dp.hash_code, md.file_size, 
      ROW_NUMBER() OVER (PARTITION BY dp.hash_code ORDER BY md.file_size DESC, dp.media ASC) rn
      FROM multi_schema."Duplicate" dp
      LEFT JOIN multi_schema."Media" md ON md.media_id = dp.media
    ) ranked
    WHERE rn > 1`.values();
};

// server/routes/user.ts
var user = new Hono2;
user.get("/verified", async (c) => {
  const userInfo = getUserBySession(c);
  if (userInfo)
    return c.json(userInfo, 200);
  await insertErrorLog("routes/user.ts", "get/verified", "User infor not found");
  return c.json({ error: "Failed to verified account" }, 500);
});
user.get("/logout", async (c) => {
  try {
    const sessionId = c.get(SET_USER_SESSION);
    sessionStore.delete(sessionId);
    clearCookie(c, SESSION_KEY);
    return c.json("Successfully logout!", 200);
  } catch (error) {
    console.error(error);
    await insertErrorLog("routes/user.ts", "get/logout", error);
    return c.json({ error: "Failed to logout account" }, 500);
  }
});
user.get("/serverCapacity", async (c) => {
  try {
    const diskCap = diskCapacity(Bun.env.MAIN_PATH);
    const sizeFileType = sumSizeMediaType();
    const [diskInfo, typesInfo] = await Promise.all([diskCap, sizeFileType]);
    if (diskInfo && typesInfo)
      return c.json({ ...diskInfo, ...typesInfo });
  } catch (err) {
    console.error(err);
    await insertErrorLog("routes/user.ts", "get/logout", err);
  }
  return c.json({ error: "Failed to fetch Account" }, 500);
});
var user_default = user;

// server/routes/album.ts
var album = new Hono2;
var albumSchema = exports_external.object({
  mediaIds: exports_external.array(exports_external.coerce.number()),
  albumId: exports_external.coerce.number().optional(),
  albumTitle: exports_external.string().optional()
});
album.get("/collection", async (c) => {
  try {
    const [albums, locations] = await Promise.all([fetchAlbums(), fetchLocations()]);
    return c.json({ albums, locations });
  } catch (error) {
    console.log("fetchAlbums/collection", error);
    await insertErrorLog("routes/album.ts", "get/collection", error);
    return c.json({ error: "Error fetch albums" }, 500);
  }
});
album.get("/statistic", async (c) => {
  try {
    return c.json(await fetchMediaCount(), 200);
  } catch (error) {
    console.error("Error fetching statistic:", error);
    await insertErrorLog("album.ts", "statistic", error);
    return c.json({ error: "Failed to fetch media" }, 500);
  }
});
album.put("/add", validateSchema("json", albumSchema), async (c) => {
  try {
    const { mediaIds, albumId, albumTitle } = c.req.valid("json");
    if (!albumId && !albumTitle)
      return c.json({ error: "Missing Album ID or Album Title" }, 400);
    const user2 = getUserBySession(c);
    if (!user2 || !user2.userId)
      return c.json({ error: "User not found" }, 500);
    const targetAlbumId = !albumId && albumTitle ? await createAlbum(user2.userId, albumTitle) : albumId;
    if (!targetAlbumId)
      return c.json({ error: "Album creation failed" }, 500);
    const addStatus = await fetchAddToAlbum(mediaIds, targetAlbumId);
    if (addStatus)
      return c.json(204);
    return c.json(201);
  } catch (error) {
    console.error("add Albums", error);
    await insertErrorLog("album.ts", "add to album", error);
    return c.json({ error: "Failed to add media to album" }, 500);
  }
});
album.put("/remove", validateSchema("json", albumSchema), async (c) => {
  try {
    const { mediaIds, albumId } = c.req.valid("json");
    if (!albumId)
      return c.json({ error: "Missing Album ID" }, 400);
    const removeStatus = await fetchRemoveFromAlbum(mediaIds, albumId);
    if (removeStatus)
      return c.json(204);
  } catch (error) {
    console.error("fetchRemoveFromAlbum ", error);
    await insertErrorLog("album.ts", "remove from album", error);
    return c.json({ error: "Failed to remove media from album" }, 500);
  }
});
var album_default = album;

// server/routes/admin.ts
import * as fs4 from "fs/promises";
import path9 from "path";

// node_modules/hono/dist/utils/stream.js
var StreamingApi = class {
  writer;
  encoder;
  writable;
  abortSubscribers = [];
  responseReadable;
  aborted = false;
  closed = false;
  constructor(writable, _readable) {
    this.writable = writable;
    this.writer = writable.getWriter();
    this.encoder = new TextEncoder;
    const reader = _readable.getReader();
    this.abortSubscribers.push(async () => {
      await reader.cancel();
    });
    this.responseReadable = new ReadableStream({
      async pull(controller) {
        const { done, value } = await reader.read();
        done ? controller.close() : controller.enqueue(value);
      },
      cancel: () => {
        this.abort();
      }
    });
  }
  async write(input) {
    try {
      if (typeof input === "string") {
        input = this.encoder.encode(input);
      }
      await this.writer.write(input);
    } catch {}
    return this;
  }
  async writeln(input) {
    await this.write(input + `
`);
    return this;
  }
  sleep(ms) {
    return new Promise((res) => setTimeout(res, ms));
  }
  async close() {
    try {
      await this.writer.close();
    } catch {}
    this.closed = true;
  }
  async pipe(body) {
    this.writer.releaseLock();
    await body.pipeTo(this.writable, { preventClose: true });
    this.writer = this.writable.getWriter();
  }
  onAbort(listener) {
    this.abortSubscribers.push(listener);
  }
  abort() {
    if (!this.aborted) {
      this.aborted = true;
      this.abortSubscribers.forEach((subscriber) => subscriber());
    }
  }
};

// node_modules/hono/dist/helper/streaming/utils.js
var isOldBunVersion = () => {
  const version = typeof Bun !== "undefined" ? Bun.version : undefined;
  if (version === undefined) {
    return false;
  }
  const result = version.startsWith("1.1") || version.startsWith("1.0") || version.startsWith("0.");
  isOldBunVersion = () => result;
  return result;
};

// node_modules/hono/dist/helper/streaming/stream.js
var contextStash = /* @__PURE__ */ new WeakMap;
var stream = (c, cb, onError) => {
  const { readable, writable } = new TransformStream;
  const stream2 = new StreamingApi(writable, readable);
  if (isOldBunVersion()) {
    c.req.raw.signal.addEventListener("abort", () => {
      if (!stream2.closed) {
        stream2.abort();
      }
    });
  }
  contextStash.set(stream2.responseReadable, c);
  (async () => {
    try {
      await cb(stream2);
    } catch (e) {
      if (e === undefined) {} else if (e instanceof Error && onError) {
        await onError(e, stream2);
      } else {
        console.error(e);
      }
    } finally {
      stream2.close();
    }
  })();
  return c.newResponse(stream2.responseReadable);
};

// node_modules/hono/dist/helper/streaming/text.js
var streamText = (c, cb, onError) => {
  c.header("Content-Type", TEXT_PLAIN);
  c.header("X-Content-Type-Options", "nosniff");
  c.header("Transfer-Encoding", "chunked");
  return stream(c, cb, onError);
};

// server/middleware/isRuningTask.ts
var activeTasks = { captioning: false, editing: false, importing: false };
var isTaskRunning = (key) => activeTasks[key];
var taskStatusMiddleware = (taskName) => createMiddleware(async (c, next) => {
  const taskRunningId = isTaskRunning(taskName);
  const user2 = getUserBySession(c);
  if (!user2 || !user2.userId)
    return c.json({ error: "\u274C User not found. Please login and try again" }, 503);
  if (!taskRunningId || user2.userId === taskRunningId)
    return await next();
  return c.json({ error: "\u274C Background processing. Try again shortly." }, 503);
});
var isCaptioningRunning = () => createMiddleware(async (c, next) => {
  const taskRunningId = isTaskRunning("captioning");
  if (!taskRunningId)
    return await next();
  return c.json({ error: "\u274C Captioning images is processing. Try again shortly." }, 503);
});
var markTaskStart = (key, userId) => {
  activeTasks[key] = userId || true;
};
var markTaskEnd = (key) => {
  activeTasks[key] = false;
};

// server/routes/importHelper/_imports.ts
import path7 from "path";

// server/service/index.ts
import path6 from "path";

// server/service/workers/index.ts
import os from "os";
var MAX_CONCURRENT_WORKERS = Math.max(1, os.cpus().length - 2);
var workerQueue = async (tasks, workerLimit = MAX_CONCURRENT_WORKERS) => {
  const executing = [];
  for (const task of tasks) {
    const promise = task().finally(() => {
      executing.splice(executing.indexOf(promise), 1);
    });
    executing.push(promise);
    if (executing.length >= workerLimit) {
      await Promise.race(executing);
    }
  }
  await Promise.allSettled(executing);
};

// server/service/generators/hashcode.ts
import fs2 from "fs";
var createHash = async (input) => {
  try {
    if (!await isExist(input))
      return "";
    const hasher = new Bun.CryptoHasher("sha256");
    const stream2 = fs2.createReadStream(input);
    await stream2.forEach(async (chunk) => {
      hasher.update(new Uint16Array(chunk));
    });
    return hasher.digest("hex");
  } catch (error) {
    console.error(`createHash ${input}: ${error}`);
    await insertErrorLog("generators/hashcode.ts", "createHash", `${error}`);
    return "";
  }
};

// server/service/generators/thumbnails.ts
var {$: $4 } = globalThis.Bun;
var THUMB_GEOMETRY = "512x512\\>";
var JPEG_QUALITY = 80;
var createThumbnail = async (input, output, media) => {
  try {
    if (!await isExist(input))
      return false;
    const command = media.file_type === "Photo" ? buildPhotoCmd(input, output) : buildVideoCmd(input, output, media);
    await command.quiet();
    return await isExist(output);
  } catch (error) {
    console.error(`createThumbnail threw for ${input}:`, error);
    await insertErrorLog("service/generators/thumbnails.ts", "createThumbnail", error);
    return false;
  }
};
var resolveSeekSeconds = (media) => {
  const duration = media.duration ?? 0;
  if (media.file_type === "Video" && duration > 0)
    return Math.min(1.5, duration);
  if (media.selected_frame !== undefined && media.selected_frame !== null)
    return media.selected_frame;
  if (duration > 0)
    return Math.min(0.5, duration);
  return 0.5;
};
var buildPhotoCmd = (input, output) => $4`magick ${`${input}[0]`} -auto-orient -thumbnail ${THUMB_GEOMETRY} -quality ${JPEG_QUALITY} ${output}`;
var buildVideoCmd = (input, output, media) => {
  const seekSec = resolveSeekSeconds(media);
  return $4`bash -lc ${`ffmpeg -hide_banner -loglevel error -ss 00:00:0${seekSec} -i ${JSON.stringify(input)} -frames:v 1 -f image2pipe -vcodec png - | ` + `magick - -auto-orient -thumbnail ${THUMB_GEOMETRY} -quality ${JPEG_QUALITY} ${JSON.stringify(output)}`}`;
};

// server/service/generators/caption.ts
import path3 from "path";

// server/service/generators/_sendTaskHelper.ts
var BATCH_SIZE_UPDATE_CAPTION = 100;
var sendTask = async (mediaObj, childProc, reader) => {
  const encoder = new TextEncoder;
  const decoder = new TextDecoder;
  childProc.stdin.write(encoder.encode(JSON.stringify(mediaObj) + `
`));
  while (true) {
    const { value, done } = await reader.read();
    if (done)
      break;
    const text = decoder.decode(value, { stream: true }).trim();
    for (const line of text.split(`
`)) {
      try {
        return JSON.parse(line);
      } catch {}
    }
  }
  throw new Error("Child process closed before sending a JSON response");
};

// server/service/generators/caption.ts
var PYTHON_EXE_PATH = "models/ai_model/image_captioning.py";
var createCaption = async (medias) => {
  const totalFile = medias.length;
  if (!totalFile)
    return;
  let count = 0;
  let { proc: childProc, reader } = startWorker();
  const captions = [];
  try {
    console.log(childProc.pid);
    for (const media of medias) {
      let resData;
      for (let attempt = 0;attempt < 2; attempt++) {
        try {
          resData = await sendTask({ id: media.media_id, path: path3.join(Bun.env.MAIN_PATH, media.thumb_path) }, childProc, reader);
          break;
        } catch (err) {
          await insertErrorLog("service/generate/captions.ts", "createCaption/restart", err);
          try {
            childProc.kill();
          } catch (err2) {
            console.log("error throwing!...........................");
          }
          const restarted = startWorker();
          childProc = restarted.proc;
          reader = restarted.reader;
          if (attempt === 1)
            throw err;
        }
      }
      if (!resData)
        continue;
      console.log(`Generating Caption: ${++count}/${totalFile}`);
      captions.push(resData);
      if (captions.length >= BATCH_SIZE_UPDATE_CAPTION) {
        await workerUpdateCaption(captions);
        captions.length = 0;
      }
    }
    if (captions.length > 0)
      await workerUpdateCaption(captions);
  } catch (error) {
    await insertErrorLog("service/generate/captions.ts", "createCaption", error);
    console.log(error);
  } finally {
    try {
      childProc.stdin?.end();
    } catch {
      console.log("Failed to close child stdin");
    }
    try {
      childProc.kill();
    } catch {
      console.log("Failed to kill child process");
    }
  }
};
var startWorker = () => {
  const proc = Bun.spawn(["python3", PYTHON_EXE_PATH], {
    stdout: "pipe",
    stdin: "pipe",
    stderr: "pipe"
  });
  return { proc, reader: proc.stdout.getReader() };
};
var workerUpdateCaption = async (captions) => {
  const tasks = captions.map((media) => () => updateMediaCaption(media));
  await workerQueue(tasks);
};

// server/service/generators/metadata.ts
var {$: $5 } = globalThis.Bun;
import path5 from "path";
import * as fs3 from "fs/promises";

// server/middleware/validateFiles.ts
import path4 from "path";
var GB = 1024 * 1024 * 1024;
var ALLOWED_FILE_SIZE = 1 * GB;
var ALLOWED_MIME_TYPES = [".3gp", ".webp", ".m4v", ".jpg", ".gif", ".mov", ".mp4", ".heif", ".heic", ".jpeg", ".png"];
var MAX_BODY_SIZE = 2 * GB;
var VALIDATED_RESULT = "validated_result";
var validateFiles = createMiddleware(async (c, next) => {
  const formData = await c.req.formData();
  const files = formData.getAll("uploadFiles");
  if (!files.length)
    return c.json({ error: "\u274C Bad request. No files uploaded." }, 400);
  let validFiles = 0;
  const writeToDir = path4.join(Bun.env.UPLOAD_PATH, nameFolderByTime());
  await createFolder(writeToDir);
  for (const file of files) {
    const extValid = validateFileExt(file);
    const sizeValid = file.size <= ALLOWED_FILE_SIZE;
    if (!extValid || !sizeValid)
      continue;
    const filePath = path4.join(writeToDir, file.name);
    await Bun.write(filePath, file);
    validFiles++;
  }
  if (!validFiles) {
    return c.json({ error: "\u274C Bad request. No valid files uploaded." }, 400);
  }
  const validResult = {
    totalFile: files.length,
    validatedFiles: validFiles,
    safeFileDir: writeToDir
  };
  c.set(VALIDATED_RESULT, validResult);
  return await next();
});
var fileExt = (file) => {
  return path4.extname(file.name).toLowerCase();
};
var validateFileExt = (file) => {
  return ALLOWED_MIME_TYPES.includes(fileExt(file));
};

// server/db/module/imported.ts
var DURATION_OF_SHORT = 5;
var insertImportedToMedia = async (newMedia, RegisteredUser) => {
  try {
    const sourceFilePath = reducePath(newMedia.SourceFile);
    const mediaType = fileType(newMedia.MIMEType, newMedia.Duration);
    const cameraId = await insertCameraToDb(newMedia.Make, newMedia.Model);
    await sql.begin(async (tx) => {
      const smallestDate = getSmallestDate(newMedia);
      const durationDisplay = convertDuration(newMedia.Duration);
      const mediaToInsert = {
        file_name: newMedia.FileName,
        file_type: mediaType,
        file_ext: newMedia.FileType,
        software: newMedia.Software,
        file_size: newMedia.FileSize,
        camera_type: cameraId,
        create_date: smallestDate,
        source_file: sourceFilePath,
        mime_type: newMedia.MIMEType,
        thumb_path: createThumbPath(smallestDate),
        orientation: newMedia.Orientation,
        image_width: newMedia.ImageWidth,
        image_height: newMedia.ImageHeight,
        megapixels: newMedia.Megapixels,
        lens_model: newMedia.LensModel,
        duration: newMedia.Duration,
        video_duration: durationDisplay,
        title: newMedia.Title,
        frame_rate: rountInt(newMedia.VideoFrameRate),
        gps_latitude: newMedia.GPSLatitude,
        gps_longitude: newMedia.GPSLongitude
      };
      const [mediaId] = await tx`
        INSERT INTO multi_schema."Media" ${sql(mediaToInsert)} 
        ON CONFLICT (source_file) DO NOTHING 
        RETURNING media_id`;
      if (!mediaId)
        return console.log("File had imported in the system");
      const lastMediaId = mediaId.media_id;
      await tx`
        INSERT INTO multi_schema."UploadBy" ("RegisteredUser", media) VALUES (${RegisteredUser}, ${lastMediaId})`;
      return lastMediaId;
    });
  } catch (error) {
    console.log("insertImportedToMedia", error);
    await insertErrorLog("db/module/imported.ts", "insertImportedToMedia", error);
  }
};
var insertCameraToDb = async (make, model) => {
  if (!model)
    return null;
  const camId = await sql.begin(async (tx) => {
    const [getCamera] = await tx`
          SELECT camera_id FROM multi_schema."CameraType" 
          WHERE model = ${model}`;
    if (getCamera)
      return getCamera.camera_id;
    const insertCamera = { make: make ?? null, model };
    const [idInserted] = await tx`
          INSERT INTO "multi_schema"."CameraType" ${sql(insertCamera)} 
          ON CONFLICT DO NOTHING
          RETURNING camera_id`;
    if (idInserted)
      return idInserted.camera_id;
  });
  if (camId)
    return camId;
  const [getCameraId] = await sql`
          SELECT camera_id FROM multi_schema."CameraType"
          WHERE model = ${model}`;
  if (getCameraId)
    return getCameraId.camera_id;
  console.log("Race condition failed to add camera type", model, make);
  return null;
};
var getSmallestDate = (newMedia) => {
  const validDates = [
    newMedia.CreateDate,
    newMedia.DateCreated,
    newMedia.CreationDate,
    newMedia.DateTimeOriginal,
    newMedia.FileModifyDate,
    newMedia.MediaCreateDate,
    newMedia.MediaModifyDate
  ].map((date) => new Date(date).getTime()).filter((date) => date > 0);
  const smallestDate = validDates.length ? new Date(Math.min(...validDates)) : new Date;
  return smallestDate;
};
var fileType = (MIMEType, duration) => {
  const prefix = MIMEType.split("/")[0];
  if (prefix === "image")
    return "Photo";
  if (prefix === "video")
    return duration && duration > DURATION_OF_SHORT ? "Video" : "Live";
  return "Unknown";
};
var createThumbPath = (inputDate) => {
  const randomId = createRandomId(9);
  return `/Thumbnails/${inputDate.getFullYear()}/${inputDate.toLocaleString("default", { month: "long" })}/${randomId}.webp`;
};
var convertDuration = (inputSecond) => {
  if (!inputSecond)
    return null;
  const hours = Math.floor(inputSecond / 3600);
  const minutes = Math.floor(inputSecond % 3600 / 60);
  const seconds = Math.round(inputSecond % 60);
  const formattedHours = hours === 0 ? "" : `${hours}:`;
  const formattedMinutes = minutes === 0 ? "0" : `${minutes}`;
  const formattedSeconds = seconds < 10 ? `0${seconds}` : `${seconds}`;
  return `${formattedHours}${formattedMinutes}:${formattedSeconds}`;
};
var rountInt = (input) => {
  if (!input)
    return 0;
  return Math.round(parseInt(input));
};

// server/service/generators/metadata.ts
var recursiveDir = async (dePath, tracking, RegisteredUser, stream2) => {
  try {
    const files = await fs3.readdir(dePath);
    for (const file of files) {
      const sourcePath = path5.join(dePath, file);
      if (startWithDot(sourcePath))
        continue;
      const stat3 = await fs3.stat(sourcePath);
      if (stat3.isDirectory()) {
        await recursiveDir(sourcePath, tracking, RegisteredUser, stream2);
      } else {
        await updateTrackingAndFileValidate(sourcePath, tracking);
        if (tracking.sourcePaths.length >= BATCH_SIZE_INSERT) {
          await insertMetadataToDB(tracking, RegisteredUser);
          await stream2.writeln(`\uD808\uDC4B Extracted Metadata of ${tracking.count} files...`);
        }
      }
    }
  } catch (error) {
    console.log("service/generator/metadata.ts", "recursiveDir", error);
    await insertErrorLog("service/generator/metadata.ts", "recursiveDir", error);
  }
};
var insertMetadataToDB = async (tracking, RegisteredUser) => {
  try {
    const metadatas = await extractMetadata(tracking.sourcePaths);
    const tasks = metadatas.map((media) => () => insertImportedToMedia(media, RegisteredUser));
    await workerQueue(tasks);
    tracking.sourcePaths.length = 0;
  } catch (error) {
    console.log("service/generator/metadata.ts", "recursiveDir", error);
    await insertErrorLog("service/generator/metadata.ts", "recursiveDir", error);
  }
};
var extractMetadata = async (sourcePaths) => {
  const { stdout, stderr, exitCode } = await $5`exiftool -json -d "%Y-%m-%dT%H:%M:%S%z" \
      -SourceFile -FileName -FileType -MIMEType \
      -Software -Title -FileSize# -Make -Model -LensModel -Orientation -CreateDate -DateCreated \
      -CreationDate -DateTimeOriginal -FileModifyDate -MediaCreateDate -MediaModifyDate -Duration# \
      -GPSLatitude# -GPSLongitude# -ImageWidth -ImageHeight -Megapixels -VideoFrameRate ${sourcePaths}`.quiet();
  if (exitCode !== 0) {
    console.log("service/generator/metadata.ts", "extractMetadata", stderr);
    await insertErrorLog("service/generator/metadata.ts", "extractMetadata", stderr);
  }
  return JSON.parse(stdout.toString().trim());
};
var updateTrackingAndFileValidate = async (sourcePath, tracking) => {
  const process2 = await validateFileExt2(sourcePath);
  if (!process2) {
    await moveUnsupportFile(sourcePath);
    return;
  }
  const sourceFile = await renameIfInvalid(sourcePath);
  ++tracking.count;
  tracking.sourcePaths.push(sourceFile);
};
var validateFileExt2 = async (file) => {
  const fileExt2 = path5.extname(file).toLowerCase();
  return ALLOWED_MIME_TYPES.includes(fileExt2);
};
var copyFileToExternalDir = async (copyToPath, dest) => {
  const files = await fs3.readdir(copyToPath);
  for (const file of files) {
    const sourcePath = path5.join(copyToPath, file);
    if (startWithDot(sourcePath))
      continue;
    const stat3 = await fs3.stat(sourcePath);
    if (stat3.isDirectory()) {
      await copyFileToExternalDir(sourcePath, dest);
    } else {
      const isValidExt = await validateFileExt2(sourcePath);
      if (isValidExt) {
        const copyStatus = await copyFile(sourcePath, dest);
        if (!copyStatus)
          console.log("\u274C Failed to copy files to system.");
      }
    }
  }
};

// server/service/generators/location.ts
var findLocation = async (medias) => {
  const pythonFilePath = "models/ai_model/get_location.py";
  const totalFile = medias.length;
  if (!totalFile)
    return;
  let count = 0;
  const childProc = Bun.spawn(["python3", pythonFilePath], {
    stdout: "pipe",
    stdin: "pipe"
  });
  const responseLocs = [];
  try {
    console.log(childProc.pid);
    const reader = childProc.stdout.getReader();
    for (const media of medias) {
      const resData = await sendTask({ id: media.media_id, latitude: media.gps_latitude, longitude: media.gps_longitude }, childProc, reader);
      console.log(`Getting Location: ${++count}/${totalFile}`);
      if (responseLocs.length >= BATCH_SIZE_UPDATE_CAPTION) {
        await workerUpdateLocation(responseLocs);
        responseLocs.length = 0;
      }
      responseLocs.push(resData);
    }
    if (responseLocs.length >= 0)
      await workerUpdateLocation(responseLocs);
  } catch (error) {
    await insertErrorLog("service/generate/location.ts", "findLocation", error);
    console.log(error);
  } finally {
    childProc.kill();
  }
};
var insertLocation = async (location) => {
  let locId = await sql.begin(async (tx) => {
    const [getExistLoc] = await tx`
          SELECT location_id FROM multi_schema."Location" 
          WHERE city = ${location.name} AND state = ${location.admin1} AND country = ${location.cc}`;
    if (getExistLoc)
      return getExistLoc.location_id;
    const insertLocation2 = { city: location.name, state: location.admin1, county: location.admin2, country: location.cc };
    const [idInserted] = await tx`
          INSERT INTO "multi_schema"."Location" ${sql(insertLocation2)} 
          ON CONFLICT (city, state) DO NOTHING RETURNING location_id`;
    if (idInserted)
      return idInserted.location_id;
  });
  if (!locId) {
    const [getExistLoc] = await sql`
          SELECT location_id FROM multi_schema."Location" 
          WHERE city = ${location.name} AND state = ${location.admin1} AND country = ${location.cc}`;
    if (getExistLoc)
      locId = getExistLoc.location_id;
  }
  const insertData = { location: locId, media: location.media_id };
  await sql`INSERT INTO "multi_schema"."LocationMedia" ${sql(insertData)} ON CONFLICT DO NOTHING`;
};
var workerUpdateLocation = async (responseLocs) => {
  const tasks = responseLocs.map((resLoc) => () => insertLocation(resLoc));
  await workerQueue(tasks);
};

// server/service/index.ts
var BATCH_SIZE_INSERT = 500;
var processMetadataExif = async (sourcePath, RegisteredUser, stream2) => {
  try {
    const tracking = { count: 0, sourcePaths: [] };
    await recursiveDir(sourcePath, tracking, RegisteredUser, stream2);
    if (tracking.sourcePaths.length > 0)
      await insertMetadataToDB(tracking, RegisteredUser);
    await stream2.writeln(`\uD808\uDC4B Extracted Metadata of ${tracking.count} files...`);
    console.log("------- PROCESS EXTRACTED METADATA COMPLETED -------");
    return tracking.count;
  } catch (error) {
    await insertErrorLog("service/index.ts", "processMetadataExif", error);
    console.log(`processMetadataExif: ${error}`);
    return 0;
  }
};
var thumbAndHashGenerate = async (media, overwrite = false) => {
  try {
    const input = path6.join(Bun.env.MAIN_PATH, media.source_file);
    const output = path6.join(Bun.env.MAIN_PATH, media.thumb_path);
    if (!await isExist(output) || overwrite) {
      await createFolder(output);
      const existCode = await createThumbnail(input, output, media);
      if (!existCode)
        return;
    }
    const hash = await createHash(output);
    if (!hash)
      return;
    await updateHashThumb(media.media_id, hash);
  } catch (error) {
    console.error(`thumbAndHashGenerate - Source: ${media.source_file}: ${error}`);
    await insertErrorLog("service/index.ts", "thumbAndHashGenerate", `error - ${media.source_file}`);
  }
};
var processThumbAndHash = async (loadedmedias, stream2) => {
  if (!loadedmedias.length)
    return false;
  let completedCount = 0;
  try {
    const tasks = loadedmedias.map((media) => async () => {
      await thumbAndHashGenerate(media);
      await stream2.writeln(`Scanning: ${++completedCount}/${loadedmedias.length}`);
    });
    await workerQueue(tasks);
    console.log("======= PROCESS THUMBNAIL AND HASH COMPLETED =======");
    return true;
  } catch (error) {
    console.error("preprocessMedia worker", error);
    await insertErrorLog("service/index.ts", "preprocessMedia", error);
    return false;
  }
};
var preprocessMedia = async (stream2) => {
  const loadedmedias = await importedMediasThumbHash();
  return await processThumbAndHash(loadedmedias, stream2);
};
var rescanningThumbs = async (stream2) => {
  const loadedmedias = await rescanThumbnail();
  return await processThumbAndHash(loadedmedias, stream2);
};
var processLocations = async () => {
  try {
    const medias = await importedMediasLocation();
    if (!medias.length)
      return;
    await findLocation(medias);
    console.log("++++++++ IMPORT LOCATION HAS BEEN COMPLETED ++++++++");
    return true;
  } catch (error) {
    console.error("processLocations", error);
    await insertErrorLog("service/index.ts", "processLocations", error);
    return false;
  }
};
var processCaptioning = async () => {
  try {
    markTaskStart("captioning");
    const medias = await importedMediasCaption();
    if (!medias.length)
      return;
    await createCaption(medias);
    console.log("******* PROCESS CAPTION HAS BEEN COMPLETED *******");
  } catch (error) {
    console.error("processCaptioning", error);
    await insertErrorLog("service/index.ts", "processCaptioning", error);
  } finally {
    markTaskEnd("captioning");
  }
};

// server/routes/importHelper/_imports.ts
var streamingImportMedia = async (dirPath, userId, stream2) => {
  stream2.onAbort(() => console.warn("Client aborted the stream!"));
  await stream2.writeln("\uD83D\uDCE5 Sanitizing files ...");
  if (!await isExist(dirPath)) {
    await stream2.writeln("\u274C Directory not found. Please ensure the directory exists");
    return false;
  }
  await stream2.writeln("\u23F3 Importing/Uploading files to system...");
  const totalFile = await processMetadataExif(dirPath, userId, stream2);
  if (!totalFile) {
    await stream2.writeln("\u274C Failed to importing medias to database.");
    return false;
  }
  if (!await preprocessMedia(stream2)) {
    await stream2.writeln("\u274C Failed to compressing medias and create hashcode");
    return false;
  }
  await processLocations();
  return true;
};
var importExternalPath = async (sourcePath, stream2) => {
  const writeToDir = path7.join(Bun.env.UPLOAD_PATH, nameFolderByTime());
  await createFolder(writeToDir);
  try {
    if (await isExist(writeToDir) && await isExist(sourcePath)) {
      await copyFileToExternalDir(sourcePath, writeToDir);
      return writeToDir;
    }
  } catch (error) {
    console.log("routes/importHelper/_imports.ts", "importExternalPath", error);
    await insertErrorLog("routes/importHelper/_imports.ts", "importExternalPath", error);
    await stream2.writeln(`\u274C An Error occors while transfering data to system!`);
    return "";
  }
};

// server/service/generators/reduceFps.ts
import path8 from "path";
var reduceFPS = async (sourcePath, stream2) => {
  const newSourcePath = sourcePath.split(".")[0] + ".mp4";
  const basename2 = path8.basename(sourcePath);
  const process2 = Bun.spawn(["ffmpeg", "-i", sourcePath, "-r", "30", "-c:v", "libx264", "-preset", "medium", "-crf", "28", "-c:a", "copy", "-map_metadata", "0", newSourcePath], {
    stderr: "pipe",
    stdout: "pipe"
  });
  try {
    const reader = process2.stderr.getReader();
    const decoder = new TextDecoder;
    while (true) {
      const { value, done } = await reader.read();
      if (done)
        break;
      const eachLine = decoder.decode(value, { stream: true }).trim();
      if (!eachLine.startsWith("frame="))
        continue;
      const timeIndex = eachLine.indexOf("time=");
      const timeStr = eachLine.substring(timeIndex + 5, timeIndex + 13);
      await stream2.writeln(`Process @ ${timeStr} - ${basename2}`);
    }
  } catch (error) {
    console.warn("Unexpected error reducing fps:", error);
    await insertErrorLog("service/generator/fps", "reduceFPS", error);
  } finally {
    process2.kill();
  }
  return await process2.exited === 0 ? newSourcePath : "";
};
var mediaUpdate = (absPath) => {
  const file = Bun.file(absPath);
  const file_size = file.size;
  const file_name = path8.basename(absPath);
  const file_ext = "MP4";
  const source_file = reducePath(absPath);
  const mime_type = "video/mp4";
  return { frame_rate: 30, source_file, file_size, mime_type, file_name, file_ext };
};

// server/routes/admin.ts
var admin = new Hono2;
var userAuthSchema2 = exports_external.object({
  userEmail: exports_external.string().email()
});
var sourcePathSchema = exports_external.string().max(256, "Path too long").regex(/^\/(Volumes|home|Users)(\/[a-zA-Z0-9_-]+)*\/?$/, "Path must be under /Volumes or /home and contain valid characters").refine((p) => !p.includes(".."), {
  message: "Path must not contain parent directory traversal"
}).optional();
var internalSchema = exports_external.object({
  aimode: exports_external.coerce.number().min(0).max(1).default(0).optional()
});
var externalSchema = exports_external.object({
  aimode: exports_external.coerce.number().min(0).max(1).default(0).optional(),
  sourcePath: sourcePathSchema
});
admin.get("/dashboard", async (c) => {
  try {
    const sysStatus = sql`
      SELECT process_medias, last_restore_time FROM multi_schema."ServerSystem" LIMIT 1`;
    const allUsers = sql`
      SELECT user_name, user_email, status, reg_user_id, created_at FROM multi_schema."RegisteredUser" reg WHERE role_type = 'user'`;
    const countMissed = sql`
      SELECT 
        COUNT(media_id) FILTER (WHERE thumb_created = FALSE) AS thumbnail,
        COUNT(media_id) FILTER (WHERE hash_code IS NULL) AS hashcode,
        COUNT(media_id) FILTER (WHERE caption IS NULL OR caption = '') AS caption
      FROM multi_schema."Media"`;
    const [[sys], users, [count]] = await Promise.all([sysStatus, allUsers, countMissed]);
    let lastbackupTime = "N/A";
    const stat4 = await isExist(Bun.env.DB_BACKUP) ? await fs4.stat(Bun.env.DB_BACKUP) : "";
    if (stat4 && stat4.mtime)
      lastbackupTime = stat4.mtime.toLocaleString();
    return c.json({ users, sysStatus: sys.process_medias, lastBackup: lastbackupTime, lastRestore: sys.last_restore_time, missedData: count }, 200);
  } catch (error) {
    console.log("admin.ts", "dashboard", error);
    await insertErrorLog("admin.ts", "dashboard", error);
    return c.json({ error: "Failed to fetch dashboard admin" }, 500);
  }
});
admin.post("/internal", taskStatusMiddleware("importing"), isCaptioningRunning(), validateSchema("json", internalSchema), async (c) => {
  return streamText(c, async (stream2) => {
    try {
      const userId = getUserBySession(c).userId;
      const { aimode } = c.req.valid("json");
      markTaskStart("importing", userId);
      const importing = await streamingImportMedia(Bun.env.PHOTO_PATH, userId, stream2);
      if (!importing)
        return;
      await updateProcessMediaStatus();
      await stream2.writeln(`\u2705 Finished Importing Multimedia! ${aimode ? "Images Analysis is running in background..." : ""}`);
      await stream2.close();
      if (!aimode)
        return;
      return await processCaptioning();
    } catch (error) {
      console.log(error);
      await stream2.writeln(`\u274C 500 Internal Server Error`);
      await insertErrorLog("admin.ts", "admin.post/import", error);
    } finally {
      if (!stream2.closed)
        await stream2.close();
      markTaskEnd("importing");
    }
  });
});
admin.post("/external", taskStatusMiddleware("importing"), isCaptioningRunning(), validateSchema("json", externalSchema), async (c) => {
  return streamText(c, async (stream2) => {
    const onAbort = () => {
      console.log("client disconnected; stopping stream writes");
    };
    try {
      const userId = getUserBySession(c).userId;
      const { sourcePath, aimode } = c.req.valid("json");
      c.req.raw.signal.addEventListener("abort", onAbort, { once: true });
      const processPath = await importExternalPath(sourcePath, stream2);
      if (!processPath)
        return;
      markTaskStart("importing", userId);
      const importing = await streamingImportMedia(processPath, userId, stream2);
      if (!importing)
        return;
      await updateProcessMediaStatus();
      if (!c.req.raw.signal.aborted) {
        await stream2.writeln(`\u2705 Finished Importing Multimedia! ${aimode ? "Images Analysis is running in background..." : ""}`);
        await stream2.close();
      }
      if (aimode) {
        processCaptioning().catch(async (err) => {
          console.log(err);
          await insertErrorLog("admin.ts", "processCaptioning/external", err);
        });
      }
    } catch (error) {
      console.log("admin.ts", "admin.post/import", error);
      if (!c.req.raw.signal.aborted)
        await stream2.writeln(`\u274C 500 Internal Server Error`);
      await insertErrorLog("admin.ts", "admin.post/import", error);
    } finally {
      c.req.raw.signal.removeEventListener("abort", onAbort);
      if (!stream2.closed)
        await stream2.close();
      markTaskEnd("importing");
    }
  });
});
admin.get("/reindex", taskStatusMiddleware("importing"), isCaptioningRunning(), async (c) => {
  return streamText(c, async (stream2) => {
    try {
      const userId = getUserBySession(c).userId;
      markTaskStart("importing", userId);
      await preprocessMedia(stream2);
      if (!c.req.raw.signal.aborted) {
        await stream2.writeln(`\u2705 Finished Importing Multimedia!`);
        await stream2.close();
      }
      processCaptioning().catch(async (err) => {
        console.log(err);
        await insertErrorLog("admin.ts", "processCaptioning/reindex", err);
      });
    } catch (error) {
      console.log("admin.ts", "admin.post/reindex", error);
      if (!c.req.raw.signal.aborted)
        await stream2.writeln(`\u274C 500 Internal Server Error`);
      await insertErrorLog("admin.ts", "admin.post/reindex", error);
    } finally {
      if (!stream2.closed)
        await stream2.close();
      markTaskEnd("importing");
    }
  });
});
admin.get("/backup", async (c) => {
  return streamText(c, async (stream2) => {
    try {
      await cleanUpCameraType();
      await removeEmptyDirs(Bun.env.UPLOAD_PATH);
      const backupStatus = await backupToDB();
      const verifyBackup = await isExist(Bun.env.DB_BACKUP);
      if (!backupStatus || !verifyBackup) {
        await stream2.writeln(`\u274C Failed to backup data`);
        return;
      }
      if (!await backupFiles(stream2))
        return;
      await stream2.writeln(`\u2705 Backup processing had been completed successfully`);
      await stream2.close();
      return;
    } catch (error) {
      console.log("admin.ts", "admin.post/reindex", error);
      await stream2.writeln(`\u274C 500 Internal Server Error`);
      await insertErrorLog("admin.ts", "admin.post/reindex", error);
    } finally {
      if (!stream2.closed)
        await stream2.close();
    }
  });
});
admin.get("/restore", async (c) => {
  try {
    if (!await isExist(Bun.env.DB_BACKUP))
      return c.json({ error: "Backup before restore file" }, 200);
    const restoreStatus = await restoreToDB();
    if (!restoreStatus)
      return c.json({ error: "Failed to restore data" }, 500);
    await sql`
      UPDATE multi_schema."ServerSystem" SET last_restore_time = NOW() 
      WHERE system_id = (
        SELECT system_id FROM multi_schema."ServerSystem" LIMIT 1)`;
    return c.json({ message: "Restore data successfully!" }, 200);
  } catch (err) {
    await insertErrorLog("admin.ts", "get/restore", err);
    console.error(err);
    return c.json({ error: "Failed to restore data" }, 500);
  }
});
admin.put("/changeStatus", validateSchema("json", userAuthSchema2), async (c) => {
  try {
    const { userEmail } = c.req.valid("json");
    const updatedUser = await updateAccountStatus(userEmail);
    if (!updatedUser)
      return c.json({ error: "Failed to update user status" }, 500);
    deleteOldUserSession(userEmail);
    return c.json("Success!", 200);
  } catch (err) {
    await insertErrorLog("admin.ts", "put/changeStatus", err);
    console.error(err);
    return c.json({ error: "Failed to fetch Account" }, 500);
  }
});
admin.get("/all-logs", async (c) => {
  try {
    const result = await sql`
        SELECT 'ERROR' AS title, file_error AS filename_ip, func_occur AS function_ip, stack_trace AS stackTrace_userAgent,  mark_at AS timestmp, func_occur as email FROM multi_schema."ErrorLog"
        UNION ALL
        SELECT 'INFO', ip_address, ip_address, user_agent, last_logged_in, email FROM multi_schema."UserLog" as ul 
        ORDER BY timestmp DESC;`;
    if (!result)
      return c.json({ error: "Failed to get logs System or User" }, 500);
    return c.json(result, 200);
  } catch (err) {
    await insertErrorLog("admin.ts", "get/all-logs", err);
    console.error(err);
    return c.json({ error: "Failed to get logs System and User" }, 500);
  }
});
admin.delete("/all-logs", async (c) => {
  try {
    await sql`TRUNCATE TABLE multi_schema."ErrorLog", multi_schema."UserLog";`;
    return c.json(204);
  } catch (err) {
    await insertErrorLog("admin.ts", "delete/all-logs", err);
    console.error(err);
    return c.json({ error: "Failed to delete logs System/Account" }, 500);
  }
});
admin.get("/storageOptimize", taskStatusMiddleware("importing"), async (c) => {
  return streamText(c, async (stream2) => {
    try {
      const userId = getUserBySession(c).userId;
      markTaskStart("importing", userId);
      const largeVideos = await sql`SELECT media_id, source_file, duration FROM multi_schema."Media" WHERE frame_rate > 60`;
      if (!largeVideos.length) {
        await stream2.writeln(`\u2705 Finished Importing Multimedia!`);
        return;
      }
      for (const each of largeVideos) {
        const originalSource = path9.join(Bun.env.MAIN_PATH, each.source_file);
        const convertedPath = await reduceFPS(originalSource, stream2);
        if (!convertedPath) {
          await stream2.writeln(`\u274C ${each.media_id}`);
          continue;
        }
        const mediaObj = mediaUpdate(convertedPath);
        await sql`UPDATE multi_schema."Media" SET ${sql(mediaObj)} WHERE media_id = ${each.media_id}`;
        await deleteFile(originalSource);
      }
      await stream2.writeln(`\u2705 Finished Optimizing Multimedia's Storage!`);
      return;
    } catch (error) {
      console.log("admin.ts", "admin.get/storageOptimize", error);
      await stream2.writeln(`\u274C 500 Internal Server Error`);
      await insertErrorLog("admin.ts", "admin.get/storageOptimize", error);
    } finally {
      if (!stream2.closed)
        await stream2.close();
      markTaskEnd("importing");
    }
  });
});
admin.get("/rescan-thumb", async (c) => {
  return streamText(c, async (stream2) => {
    try {
      const userId = getUserBySession(c).userId;
      markTaskStart("importing", userId);
      await rescanningThumbs(stream2);
      await stream2.writeln(`\u2705 Finished Recreating Thumbnails!`);
      await stream2.close();
      return;
    } catch (error) {
      console.log("admin.ts", "admin.get/rescan-thumb", error);
      await stream2.writeln(`\u274C 500 Internal Server Error`);
      await insertErrorLog("admin.ts", "admin.get/rescan-thumb", error);
    } finally {
      if (!stream2.closed)
        await stream2.close();
      markTaskEnd("importing");
    }
  });
});
var admin_default = admin;
var cleanUpCameraType = async () => {
  return await sql`
    DELETE FROM multi_schema."CameraType" AS cm 
    WHERE cm.camera_id = (
        SELECT cm.camera_id FROM multi_schema."CameraType" AS cm 
        LEFT JOIN multi_schema."Media" AS md ON md.camera_type = cm.camera_id
        WHERE media_id IS NULL
    )`;
};

// node_modules/hono/dist/middleware/body-limit/index.js
var ERROR_MESSAGE = "Payload Too Large";
var BodyLimitError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "BodyLimitError";
  }
};
var bodyLimit = (options) => {
  const onError = options.onError || (() => {
    const res = new Response(ERROR_MESSAGE, {
      status: 413
    });
    throw new HTTPException(413, { res });
  });
  const maxSize = options.maxSize;
  return async function bodyLimit2(c, next) {
    if (!c.req.raw.body) {
      return next();
    }
    const hasTransferEncoding = c.req.raw.headers.has("transfer-encoding");
    const hasContentLength = c.req.raw.headers.has("content-length");
    if (hasTransferEncoding && hasContentLength) {}
    if (hasContentLength && !hasTransferEncoding) {
      const contentLength = parseInt(c.req.raw.headers.get("content-length") || "0", 10);
      return contentLength > maxSize ? onError(c) : next();
    }
    let size = 0;
    const rawReader = c.req.raw.body.getReader();
    const reader = new ReadableStream({
      async start(controller) {
        try {
          for (;; ) {
            const { done, value } = await rawReader.read();
            if (done) {
              break;
            }
            size += value.length;
            if (size > maxSize) {
              controller.error(new BodyLimitError(ERROR_MESSAGE));
              break;
            }
            controller.enqueue(value);
          }
        } finally {
          controller.close();
        }
      }
    });
    const requestInit = { body: reader, duplex: "half" };
    c.req.raw = new Request(c.req.raw, requestInit);
    await next();
    if (c.error instanceof BodyLimitError) {
      c.res = await onError(c);
    }
  };
};

// server/routes/upload.ts
var upload = new Hono2;
var isAiModeSchema = exports_external.object({
  aimode: exports_external.coerce.number().min(0).max(1).default(0)
});
upload.post("/", taskStatusMiddleware("importing"), isCaptioningRunning(), validateSchema("query", isAiModeSchema), bodyLimit({
  maxSize: MAX_BODY_SIZE,
  onError: (c) => {
    return c.json({ error: "\u274C File(s) too large. Try a smaller file." }, 413);
  }
}), validateFiles, async (c) => {
  const user2 = getUserBySession(c);
  if (!user2 || !user2.userId)
    return c.json({ error: "\u274C User not found. Please login" }, 413);
  return streamText(c, async (stream2) => {
    try {
      const { totalFile, validatedFiles, safeFileDir } = c.get(VALIDATED_RESULT);
      const { aimode } = c.req.valid("query");
      markTaskStart("importing", user2.userId);
      const importing = await streamingImportMedia(safeFileDir, user2.userId, stream2);
      if (!importing)
        return;
      await stream2.writeln(`\u2705 Finished Uploading: ${validatedFiles}/${totalFile} files! ${aimode ? "Images Analysis is running in background..." : ""}`);
      await stream2.close();
      if (!aimode)
        return;
      return await processCaptioning();
    } catch (error) {
      await stream2.writeln(`\u274C 500 Internal Server Error`);
      console.log("upload.post:", error);
      await insertErrorLog("routes/upload.ts", "upload.post", error);
    } finally {
      if (!stream2.closed)
        await stream2.close();
      markTaskEnd("importing");
    }
  });
});
var upload_default = upload;

// server/db/module/search.ts
var refreshView = async () => {
  return await sql`
    REFRESH MATERIALIZED VIEW multi_schema.suggest_words`;
};

// server/routes/search.ts
var search = new Hono2;
var querySchema = exports_external.object({
  keywords: exports_external.string().trim().max(50).regex(/^[a-zA-Z0-9 -]*$/, "Only letters, numbers, spaces, and hyphens are allowed").optional()
});
search.get("/refreshView", async (c) => {
  await refreshView();
  return c.json({ status: "success" }, 200);
});
search.get("/", validateSchema("query", querySchema), async (c) => {
  const { keywords } = c.req.valid("query");
  if (!keywords) {
    const searchResults2 = sql`
      SELECT media_id, caption, favorite, thumb_path, COUNT(*) OVER() AS total_count
      FROM multi_schema."Media"
      WHERE hidden = FALSE AND deleted = FALSE
      LIMIT 9`;
    const result2 = { suggestCount: [], data: await searchResults2 };
    return c.json(result2, 200);
  }
  const lastWord = keywords.split(" ").at(-1);
  const suggestCount = sql`
    SELECT sw.word, sw.ndoc FROM multi_schema.suggest_words AS sw
      WHERE similarity(sw.word, ${lastWord}::text) > 0.3
      ORDER BY similarity(sw.word, ${lastWord}::text) DESC
      LIMIT 5`;
  const searchResults = sql`
    SELECT media_id, caption, favorite, thumb_path, COUNT(*) OVER() AS total_count
      FROM multi_schema."Media"
      WHERE caption_eng_tsv @@ (websearch_to_tsquery ('english', ${keywords}::text) 
        || websearch_to_tsquery ('simple', ${keywords}::text))
        AND hidden = FALSE AND deleted = FALSE
      LIMIT 9`;
  const [wordCount, searchResult] = await Promise.all([suggestCount, searchResults]);
  const result = {
    suggestCount: wordCount,
    data: searchResult
  };
  return c.json(result, 200);
});
var search_default = search;

// server/routes/media.ts
var media = new Hono2;
var infoSchema = exports_external.object({
  id: exports_external.coerce.number().min(1)
});
media.get("/", validateSchema("query", infoSchema), async (c) => {
  try {
    const { id } = c.req.valid("query");
    const [media2] = await sql`
    SELECT md.file_type, md.file_name, md.create_date, md.file_size, md.upload_at, md.file_ext, 
          md.software, md.mime_type, md.caption, md.image_width, md.image_height, md.megapixels, 
          md.lens_model, md.frame_rate, md.title, md.video_duration, md.media_id,
          ru.user_name, 
          cm.make, cm.model,
          lc.city, lc.state FROM "multi_schema"."Media" as md 
    LEFT JOIN multi_schema."UploadBy" as upl ON upl.media = md.media_id
    LEFT JOIN multi_schema."RegisteredUser" as ru ON ru.reg_user_id = upl."RegisteredUser"
    LEFT JOIN multi_schema."CameraType" as cm ON cm.camera_id = md.camera_type
    LEFT JOIN multi_schema."LocationMedia" as lm ON lm.media = md.media_id
    LEFT JOIN multi_schema."Location" as lc ON lc.location_id = lm.location
    WHERE md.media_id = ${id}`;
    return c.json(media2);
  } catch (error) {
    await insertErrorLog("routes/media.ts", "get/", error);
    console.log("routes/media.ts", "get/", error);
    return c.json({ error: "Server error" }, 500);
  }
});
var specialChars = /[^a-zA-Z0-9.,!?;:"'$()%\- ]/;
var captionSchema = exports_external.object({
  mediaId: exports_external.coerce.number().min(1),
  caption: exports_external.coerce.string().trim().refine((input) => !specialChars.test(input), {
    message: "Caption must not contain invalid characters <>{}[]"
  })
});
media.put("/caption", validateSchema("json", captionSchema), async (c) => {
  try {
    const { mediaId, caption } = c.req.valid("json");
    await updateMediaCaption({ media_id: mediaId, caption });
    return c.json("Success", 202);
  } catch (error) {
    await insertErrorLog("routes/media.ts", "put/caption", error);
    return c.json({ error: "Server error" }, 500);
  }
});
var frameSchema = exports_external.object({
  mediaId: exports_external.coerce.number().min(1),
  framePos: exports_external.coerce.number().min(0).max(5)
});
media.put("/live-frame", validateSchema("json", frameSchema), async (c) => {
  try {
    const { mediaId, framePos } = c.req.valid("json");
    await updateSelectFrameLivePhoto(mediaId, framePos);
    return c.json("Success", 202);
  } catch (error) {
    await insertErrorLog("routes/media.ts", "put/live-frame", error);
    return c.json({ error: "Server error" }, 500);
  }
});
var dateSchema = exports_external.object({
  mediaId: exports_external.coerce.number().min(1),
  date_iso: exports_external.string().datetime()
});
media.put("/update-date", validateSchema("json", dateSchema), async (c) => {
  try {
    const { mediaId, date_iso } = c.req.valid("json");
    await updateCreateDate(mediaId, date_iso);
    return c.json("Success", 202);
  } catch (error) {
    await insertErrorLog("routes/media.ts", "put/update-date", error);
    return c.json({ error: "Server error" }, 500);
  }
});
var media_default = media;

// server/routes/medias.ts
import path10 from "path";
import { promises as fs5 } from "fs";
import os2 from "os";
var {$: $6 } = globalThis.Bun;
var medias = new Hono2;
var updateSchema = exports_external.object({
  mediaIds: exports_external.array(exports_external.coerce.number()),
  updateKey: exports_external.enum(["favorite", "deleted", "hidden"]),
  updateValue: exports_external.coerce.number().min(0).max(1)
});
var mediaIdsSchema = exports_external.object({
  mediaIds: exports_external.array(exports_external.coerce.number())
});
var monthSchema = exports_external.object({
  monthInput: exports_external.preprocess((val) => {
    const num = Number(val);
    if (val === undefined || Number.isNaN(num))
      return;
    return num;
  }, exports_external.number().min(1).max(12).optional())
});
medias.get("/", async (c) => {
  try {
    return c.json(await groupMonthsByYear(), 200);
  } catch (error) {
    console.error("medias.get: await groupMonthsByYear()", error);
    await insertErrorLog("routes/medias.ts", "get/", error);
    return c.json({ error: "Failed to fetch media of each month" }, 500);
  }
});
medias.get("/filter-year", validateSchema("query", monthSchema), async (c) => {
  try {
    const { monthInput } = c.req.valid("query");
    return c.json(await groupOfYear(monthInput), 200);
  } catch (error) {
    console.error("medias.filter-year: await groupOfYear()", error);
    await insertErrorLog("routes/medias.ts", "get/", error);
    return c.json({ error: "Failed to fetch media of each month" }, 500);
  }
});
medias.get("/devices", async (c) => {
  try {
    return c.json(await fetchCameraType(), 200);
  } catch (error) {
    console.error("Error fetching devices:", error);
    await insertErrorLog("routes/medias.ts", "devices", error);
    return c.json({ error: "Failed to fetch media" }, 500);
  }
});
medias.put("/", validateSchema("json", updateSchema), async (c) => {
  try {
    const { mediaIds, updateKey, updateValue } = c.req.valid("json");
    const result = await updateMedias(mediaIds, updateKey, updateValue ? true : false);
    if (result)
      return c.json("Success", 202);
    return c.json({ error: "Failed to update media" }, 403);
  } catch (error) {
    await insertErrorLog("routes/medias.ts", "put/", error);
    return c.json({ error: "Server error" }, 500);
  }
});
medias.delete("/", validateSchema("json", mediaIdsSchema), async (c) => {
  const { mediaIds } = c.req.valid("json");
  try {
    const result = await deleteMedias(mediaIds);
    if (result)
      return c.json("Success", 202);
  } catch (error) {
    await insertErrorLog("routes/medias.ts", "delete/", error);
    return c.json({ error: "Failed to delete medias" }, 500);
  }
});
medias.get("/recently", async (c) => {
  try {
    const result = await deleteAllInRecently();
    if (result)
      return c.json("Success", 202);
  } catch (error) {
    await insertErrorLog("routes/medias.ts", "delete/recently", error);
    return c.json({ error: "Failed to delete all medias in Recently Delete" }, 500);
  }
});
medias.get("/merge-all", async (c) => {
  try {
    const dupIdsToDel = (await mergeMedias()).flat(1);
    const result = await deleteMedias(dupIdsToDel);
    if (result)
      return c.json("Success", 202);
  } catch (error) {
    await insertErrorLog("routes/medias.ts", "get/merge-all", error);
    return c.json({ error: "Failed to merge all medias" }, 500);
  }
});
medias.post("/download", validateSchema("json", mediaIdsSchema), async (c) => {
  try {
    const { mediaIds } = c.req.valid("json");
    if (!mediaIds || !mediaIds.length) {
      return new Response(JSON.stringify({ error: "No mediaIds provided" }), { status: 400 });
    }
    const sourceFiles = await getSourceFiles(mediaIds);
    if (!sourceFiles || !sourceFiles.length) {
      return new Response(JSON.stringify({ error: "No source files found for provided photos/video" }), { status: 404 });
    }
    const absPaths = sourceFiles.map((each) => path10.join(Bun.env.MAIN_PATH, each.source_file));
    const zipProc = Bun.spawn({
      cmd: [
        "zip",
        "-j",
        "-q",
        "-0",
        "-",
        ...absPaths
      ],
      stdout: "pipe",
      stderr: "inherit"
    });
    const exitCode = await zipProc.exited;
    if (exitCode !== 0) {
      await insertErrorLog("routes/medias.ts", "post/download", "Failed to create zip archive");
      return new Response(JSON.stringify({ error: "Failed to create zip archive" }), {
        status: 500
      });
    }
    return new Response(zipProc.stdout, {
      headers: {
        "Content-Type": "application/zip",
        "Content-Disposition": 'attachment; filename="archive.zip"'
      }
    });
  } catch (err) {
    await insertErrorLog("routes/medias.ts", "post/download", err);
    return new Response(JSON.stringify({ error: "Internal server error", details: err.message }), {
      status: 500
    });
  }
});
async function runCmd(args) {
  const proc = Bun.spawn(args, { stdout: "pipe", stderr: "pipe" });
  const [stdout, stderr, exitCode] = await Promise.all([new Response(proc.stdout).text(), new Response(proc.stderr).text(), proc.exited]);
  return { stdout, stderr, exitCode };
}
async function ffprobe(filePath) {
  const args = [
    "ffprobe",
    "-v",
    "error",
    "-print_format",
    "json",
    "-show_entries",
    "stream=codec_type,codec_name,width,height,pix_fmt,avg_frame_rate,r_frame_rate,sample_rate,channels",
    "-show_streams",
    filePath
  ];
  const { stdout, stderr, exitCode } = await runCmd(args);
  if (exitCode !== 0)
    throw new Error(`ffprobe failed: ${stderr}`);
  return JSON.parse(stdout);
}
function gcd(a, b) {
  a = Math.abs(a);
  b = Math.abs(b);
  while (b !== 0) {
    const t = a % b;
    a = b;
    b = t;
  }
  return a || 1;
}
function normalizeFrameRate(rate) {
  if (!rate || rate === "0/0")
    return;
  const [ns, ds] = rate.split("/");
  const n = Number(ns);
  const d = Number(ds);
  if (!Number.isFinite(n) || !Number.isFinite(d) || d === 0)
    return;
  const g = gcd(n, d);
  return `${n / g}/${d / g}`;
}
function pickSignature(ext, probe) {
  const streams = probe.streams ?? [];
  const v = streams.find((s) => s.codec_type === "video");
  if (!v?.codec_name || !v.width || !v.height || !v.pix_fmt) {
    throw new Error("Missing required video stream fields (codec/width/height/pix_fmt).");
  }
  const a = streams.find((s) => s.codec_type === "audio");
  const frameRateKey = normalizeFrameRate(v.r_frame_rate);
  return {
    ext,
    video: {
      codec: v.codec_name,
      width: v.width,
      height: v.height,
      pixFmt: v.pix_fmt,
      frameRateKey
    },
    audio: a?.codec_name ? { codec: a.codec_name, sampleRate: a.sample_rate, channels: a.channels } : undefined
  };
}
function compareSignatures(base, cur) {
  let issues = "";
  if (cur.video.codec !== base.video.codec)
    issues += `Video codec mismatch: ${cur.video.codec} != ${base.video.codec}
`;
  if (cur.video.width !== base.video.width || cur.video.height !== base.video.height) {
    issues += `Resolution mismatch: ${cur.video.width}x${cur.video.height} != ${base.video.width}x${base.video.height}
`;
  }
  if (cur.video.pixFmt !== base.video.pixFmt)
    issues += `Pixel format mismatch: ${cur.video.pixFmt} != ${base.video.pixFmt}
`;
  if ((cur.video.frameRateKey ?? "") !== (base.video.frameRateKey ?? "")) {
    issues += `Frame rate mismatch: ${cur.video.frameRateKey ?? "unknown"} != ${base.video.frameRateKey ?? "unknown"}
`;
  }
  const baseA = base.audio;
  const curA = cur.audio;
  if (!!baseA !== !!curA)
    issues += `Audio stream presence mismatch.
`;
  if (baseA && curA) {
    if (curA.codec !== baseA.codec)
      issues += `Audio codec mismatch: ${curA.codec} != ${baseA.codec}
`;
    if ((curA.sampleRate ?? "") !== (baseA.sampleRate ?? ""))
      issues += `Audio sample_rate mismatch: ${curA.sampleRate} != ${baseA.sampleRate}
`;
    if ((curA.channels ?? 0) !== (baseA.channels ?? 0))
      issues += `Audio channels mismatch: ${curA.channels} != ${baseA.channels}
`;
  }
  return issues;
}
function escapeForConcatList(p) {
  return p.replace(/\\/g, "\\\\").replace(/'/g, "\\'");
}
async function writeConcatListFile(listPath, filePaths) {
  const lines = filePaths.map((p) => `file '${escapeForConcatList(p)}'`).join(`
`) + `
`;
  await Bun.write(listPath, lines);
}
async function mapLimit(items, limit, fn) {
  const results = new Array(items.length);
  let cursor = 0;
  const workers = Array.from({ length: Math.min(limit, items.length) }, async () => {
    while (true) {
      const idx = cursor++;
      if (idx >= items.length)
        break;
      results[idx] = await fn(items[idx], idx);
    }
  });
  await Promise.all(workers);
  return results;
}
async function ffmpegConcatCopy(listPath, outPath) {
  const args = ["ffmpeg", "-y", "-hide_banner", "-loglevel", "error", "-f", "concat", "-safe", "0", "-i", listPath, "-c", "copy", "-movflags", "+faststart", outPath];
  const { stderr, exitCode } = await runCmd(args);
  return { stderr, exitCode };
}
medias.post("/merge-videos", validateSchema("json", mediaIdsSchema), async (c) => {
  const { mediaIds } = c.req.valid("json");
  if (!Array.isArray(mediaIds) || mediaIds.length < 2) {
    return c.json({ error: "Need at least 2 mediaIds to merge." }, 400);
  }
  const uniq = new Set(mediaIds);
  if (uniq.size !== mediaIds.length)
    return c.json({ error: "Duplicate mediaIds are not allowed." }, 400);
  let tempFolder = null;
  try {
    const rowsOfMedia = await sql`
      SELECT media_id, source_file, file_ext, file_type, file_name
      FROM "multi_schema"."Media"
      WHERE media_id IN ${sql(mediaIds)}
      ORDER BY create_date ASC
    `;
    if (!rowsOfMedia.length)
      return c.json({ error: "No media found for provided mediaIds." }, 404);
    if (rowsOfMedia.length !== mediaIds.length) {
      return c.json({ error: "Some mediaIds were not found." }, 400);
    }
    const photos = rowsOfMedia.some((r) => r.file_type === "Photo");
    if (photos)
      return c.json({ error: "Only videos or live photos can be merged. " }, 400);
    const inputs = rowsOfMedia.map((r) => ({
      mediaId: r.media_id,
      ext: r.file_ext,
      fileName: r.file_name,
      filePath: path10.join(Bun.env.MAIN_PATH, r.source_file)
    }));
    const probeConcurrency = Math.min(8, os2.cpus()?.length ?? 4);
    const diskChecks = await mapLimit(inputs, probeConcurrency, async (x) => ({
      ...x,
      ok: await isExist(x.filePath)
    }));
    const missing = diskChecks.filter((x) => !x.ok).map((x) => ({ mediaId: x.mediaId, fileName: x.fileName }));
    if (missing.length) {
      return c.json({ error: "Some source files are missing on disk.", validationIssues: missing }, 400);
    }
    const probed = await mapLimit(inputs, probeConcurrency, async (x) => {
      const probeJson = await ffprobe(x.filePath);
      const sig = pickSignature(x.ext, probeJson);
      return { ...x, sig };
    });
    const baseMedia = probed[0];
    const baseSig = baseMedia.sig;
    if (!baseSig)
      return c.json({ error: "Unable to determine base signature." }, 500);
    const validationIssues = [];
    for (const p of probed) {
      const issues = compareSignatures(baseSig, p.sig);
      if (issues.length)
        validationIssues.push({ mediaId: p.mediaId, fileName: p.fileName, issues });
    }
    if (validationIssues.length)
      return c.json({
        error: `Inputs are not merge-compatible for stream copy.
Must match codec, dimension, pix_fmt, frame rate, and audio.`,
        validationIssues
      }, 400);
    const baseExt = baseSig.ext;
    tempFolder = path10.join(Bun.env.UNSUPPORT_PATH, `merge_${nameFolderByTime(false)}`);
    await createFolder(tempFolder);
    const listPath = path10.join(tempFolder, `concat_list_${nameFolderByTime(false)}.txt`);
    await writeConcatListFile(listPath, inputs.map((x) => x.filePath));
    const tempOutputPath = path10.join(tempFolder, `output_${nameFolderByTime(false)}.${baseExt}`);
    const { stderr, exitCode } = await ffmpegConcatCopy(listPath, tempOutputPath);
    if (exitCode !== 0) {
      await insertErrorLog("routes/medias.ts", "post/merge-videos", `System merge video failed - ${stderr.trim()}`);
      return c.json({ error: `System merge video failed - ${stderr.trim()}` }, 500);
    }
    const cpyCreateDate = await $6`exiftool -overwrite_original -TagsFromFile ${baseMedia.filePath} "-CreateDate<CreateDate" "-ModifyDate=now" ${tempOutputPath}`;
    if (cpyCreateDate.exitCode !== 0) {
      await insertErrorLog("routes/medias.ts", "post/merge-videos", "Faile to write metadate to new merged video.");
      return c.json({ error: "Faile to write metadate to new merged video." }, 400);
    }
    const outputMetadata = await extractMetadata([tempOutputPath]);
    if (!outputMetadata || !outputMetadata.length) {
      await insertErrorLog("routes/medias.ts", "post/merge-videos", "Failed to extract metadata from merged video.");
      return c.json({ error: "Failed to extract metadata from merged video." }, 500);
    }
    const newVideoDB = {
      media_id: baseMedia.mediaId,
      file_size: outputMetadata[0].FileSize || 0,
      duration: outputMetadata[0].Duration || 0,
      file_type: outputMetadata[0].Duration && outputMetadata[0].Duration < DURATION_OF_SHORT ? "Live" : "Video",
      video_duration: outputMetadata[0].Duration ? convertDuration(outputMetadata[0].Duration) : "0:00"
    };
    const updateFirstMedia = await sql`
      UPDATE "multi_schema"."Media" SET ${sql(newVideoDB)} 
      WHERE media_id = ${newVideoDB.media_id} RETURNING media_id;
    `;
    if (updateFirstMedia.count < 1) {
      await insertErrorLog("routes/medias.ts", "post/merge-videos", "Failed to update metadata to database for new video.");
      return c.json({ error: "Failed to update metadata to database for new video." }, 500);
    }
    const finalOutputPath = baseMedia.filePath;
    await fs5.rename(tempOutputPath, finalOutputPath);
    const mediaIdsToDel = rowsOfMedia.reduce((acc, person) => {
      if (person.media_id !== baseMedia.mediaId) {
        acc.push(Number(person.media_id));
      }
      return acc;
    }, []);
    const isDeleteSuccess = await deleteMedias(mediaIdsToDel);
    if (!isDeleteSuccess) {
      await insertErrorLog("routes/medias.ts", "post/merge-videos", "Failed to delete old video after merged.");
      return c.json({ error: "Failed to delete old video after merged." }, 500);
    }
    return c.json({ status: "Success", mergedMedia: newVideoDB, removeIds: mediaIdsToDel }, 200);
  } catch (error) {
    await insertErrorLog("routes/medias.ts", "post/merge-videos", error);
    const msg = error instanceof Error ? error.message : String(error);
    return c.json({ error: "Failed to merge all medias", details: msg }, 500);
  } finally {
    if (tempFolder)
      await $6`rm -rf ${tempFolder}`;
  }
});
var medias_default = medias;

// server/routes/stream.ts
var PAGE_SIZE = 250;
var streamApi = new Hono2;
var querySchema2 = exports_external.object({
  year: exports_external.coerce.number().min(1800).max(9999).optional(),
  month: exports_external.coerce.number().min(1).max(12).optional(),
  pageNumber: exports_external.coerce.number().min(0).max(1000).default(0).optional(),
  filterDevice: exports_external.coerce.number().min(1).max(1000).optional(),
  filterType: exports_external.enum(["Video", "Photo", "Live"]).optional(),
  sortKey: exports_external.enum(["file_size", "create_date", "upload_at"]).optional(),
  sortOrder: exports_external.coerce.number().min(0).max(1).default(0).optional(),
  searchKey: exports_external.string().trim().max(50).regex(/^[a-zA-Z0-9 -]*$/, "Only letters, numbers, spaces, and hyphens are allowed").optional(),
  favorite: exports_external.coerce.number().min(0).max(1).optional(),
  hidden: exports_external.coerce.number().min(0).max(1).optional(),
  deleted: exports_external.coerce.number().min(0).max(1).optional(),
  duplicate: exports_external.coerce.number().min(0).max(1).optional(),
  albumId: exports_external.coerce.number().min(1).max(999999).optional(),
  locationId: exports_external.coerce.number().min(1).max(999999).optional()
});
streamApi.get("/", validateSchema("query", querySchema2), async (c) => {
  try {
    const { year, month, pageNumber, filterDevice, filterType, sortKey, sortOrder, searchKey, favorite, hidden, deleted, duplicate, albumId, locationId } = c.req.valid("query");
    const isYear = year ? sql`AND create_year = ${year} ` : sql``;
    const isMonth = month ? sql`AND create_month = ${month} ` : sql``;
    const isDevice = filterDevice ? sql`AND camera_type = ${filterDevice} ` : sql``;
    const isType = filterType ? sql`AND file_type = ${filterType} ` : sql``;
    const isFavorite = favorite ? sql`AND favorite = TRUE ` : sql``;
    const isHidden = hidden ? sql`AND hidden = TRUE ` : sql`AND hidden = FALSE `;
    const isDeleted = deleted ? sql`AND deleted = TRUE ` : sql`AND deleted = FALSE `;
    const sortOrders = sortOrder ? sql` ASC ` : sql` DESC `;
    const orderBy = sortKey ? sql`ORDER BY ${sql(sortKey)} ${sortOrders}, media_id ASC ` : sql`ORDER BY create_date ${sortOrders}, media_id ASC`;
    const limitOffset = sql`LIMIT ${PAGE_SIZE} OFFSET ${pageNumber * PAGE_SIZE}`;
    const getMedias = sql`
      SELECT media_id, thumb_path, source_file, create_month, create_year, video_duration, 
              duration, mime_type, file_type, favorite, file_size, upload_at, 
              create_date, selected_frame, frame_rate, file_ext, image_width, 
              image_height, file_name, megapixels
      FROM multi_schema."Media"
      WHERE 1=1 ${isYear} ${isMonth} ${isDevice} ${isType}
      ${isFavorite} ${isHidden} ${isDeleted}`;
    let result;
    if (albumId) {
      result = await sql`
        SELECT md.* FROM (
            SELECT am.media FROM "multi_schema"."AlbumMedia" AS am WHERE am.album = ${albumId}
        ) as media_in_album
        JOIN (${getMedias}) as md ON md."media_id" = media_in_album.media
        ${orderBy}
        ${limitOffset}`;
    } else if (locationId) {
      result = await sql`
        SELECT md.* FROM (
            SELECT lm.media FROM "multi_schema"."LocationMedia" AS lm WHERE lm.location = ${locationId}
        ) as media_in_album
        JOIN (${getMedias}) as md ON md."media_id" = media_in_album.media
        ${orderBy}
        ${limitOffset}`;
    } else if (duplicate) {
      result = await sql`
        SELECT md.* FROM "multi_schema"."Duplicate" AS dup
        JOIN (${getMedias}) as md ON md."media_id" = dup.media
        ORDER BY hash_code, media_id ASC
        ${limitOffset}`;
    } else if (searchKey) {
      result = await sql`
        SELECT md.* FROM (
            SELECT media_id FROM multi_schema."Media"
            WHERE caption_eng_tsv @@ (websearch_to_tsquery ('english', ${searchKey}::text) 
        || websearch_to_tsquery ('simple', ${searchKey}::text))
        ) as search_medias
        JOIN (${getMedias}) as md ON md."media_id" = search_medias.media_id
        ORDER BY media_id ASC
        ${limitOffset}`;
    } else {
      result = await sql`${getMedias}
      ${orderBy}
      ${limitOffset}`;
    }
    return c.json(result);
  } catch (error) {
    console.error("Unexpected loading medias:", error);
    await insertErrorLog("routes/stream.ts", "streamApis", error);
    return c.json({ error: "Internal Server Error" }, 500);
  }
});
var stream_default = streamApi;

// server/routes/serveStatic/thumbnails.ts
import path11 from "path";
var thumbnails = async (c) => {
  const reqUrl = new URL(c.req.url);
  const filePath = path11.join(Bun.env.MAIN_PATH, reqUrl.pathname);
  const file = Bun.file(filePath);
  if (!await file.exists()) {
    return c.text("Not Found", 404);
  }
  const etag = path11.basename(reqUrl.pathname);
  const lastModified = new Date(file.lastModified).toUTCString();
  let resHeaders = {
    "Access-Control-Allow-Origin": isDevMode ? "*" : "",
    ETag: etag,
    "Last-Modified": lastModified,
    "Cache-Control": "public, max-age=3600"
  };
  if (c.req.header("if-none-match") === etag || c.req.header("if-modified-since") === lastModified) {
    return c.body(null, 304, resHeaders);
  }
  return c.body(file.stream(), 200, {
    ...resHeaders,
    "Content-Type": file.type,
    "Content-Length": file.size.toString()
  });
};
var thumbnails_default = thumbnails;

// server/middleware/streamLargeVid.ts
import path12 from "path";
import * as fs6 from "fs";
var VIDEO_EXT = [".mov", ".mp4"];
var MB = 1024 * 1024;
var RESPONSE_IN_MB = 50 * MB;
var streamLargeVid = createMiddleware(async (c, next) => {
  const reqUrl = new URL(c.req.url);
  const isVideo = VIDEO_EXT.some((ext) => c.req.url.toLowerCase().endsWith(ext));
  if (!isVideo)
    return await next();
  const filePath = path12.join(Bun.env.MAIN_PATH, reqUrl.pathname);
  const videoFile = Bun.file(filePath);
  if (!await videoFile.exists())
    return c.json({ error: "File not found" }, 404);
  const fileSize = videoFile.size;
  if (!isDevMode && videoFile.size <= RESPONSE_IN_MB)
    return await next();
  const range = c.req.header("range") || "";
  const match2 = range.match(/bytes=(\d+)-(\d*)/);
  if (!match2)
    return c.text("Invalid Range Header", 416);
  const [_, startStr, endStr] = match2;
  const start = parseInt(startStr, 10);
  const getEnd = endStr ? parseInt(endStr, 10) : fileSize - 1;
  const end = Math.min(getEnd, start + RESPONSE_IN_MB - 1);
  if (start >= fileSize || end >= fileSize || start > end) {
    return c.text("Requested Range Not Satisfiable", 416);
  }
  const chunkSize = end - start + 1;
  const fileStream = fs6.createReadStream(filePath, { start, end });
  return new Response(fileStream, {
    status: 206,
    headers: {
      "Content-Range": `bytes ${start}-${end}/${fileSize}`,
      "Content-Length": chunkSize.toString(),
      "Content-Type": videoFile.type,
      "Accept-Ranges": "bytes",
      "Cache-Control": "public, max-age=3600, immutable"
    }
  });
});

// server/app.ts
var app = new Hono2;
app.use("*", logger());
if (isDevMode) {
  app.use("/*", cors({
    origin: Bun.env.ORIGIN_URL,
    allowHeaders: ["X-Custom-Header", "Upgrade-Insecure-Requests"],
    allowMethods: ["POST", "GET", "PUT", "DELETE"],
    exposeHeaders: ["Content-Length", "X-Kuma-Revision"],
    maxAge: 600,
    credentials: true
  }));
}
app.use(csrf({
  origin: Bun.env.ORIGIN_URL
}));
app.use(secureHeaders());
app.basePath("api/v1").route("/auth", auth_default).use(isAuthenticate).route("/search", search_default).route("/upload", upload_default).route("/stream", stream_default).route("/user", user_default).route("/medias", medias_default).route("/media", media_default).route("/album", album_default).use(isAdmin).route("/admin", admin_default);
app.get(`/${getDirName(Bun.env.THUMB_PATH)}/*`, isAuthenticate, thumbnails_default);
app.on("GET", [`/${getDirName(Bun.env.PHOTO_PATH)}/*`, `/${getDirName(Bun.env.UPLOAD_PATH)}/*`], isAuthenticate, streamLargeVid, serveStatic2({ root: Bun.env.MAIN_PATH }));
app.get("/assets/*", serveStatic2({ root: "./dist" }));
app.get("/sw.js", serveStatic2({ root: "./dist", path: "sw.js" }));
app.get("/manifest.webmanifest", serveStatic2({ root: "./dist", path: "manifest.webmanifest" }));
app.get("/*", serveStatic2({ root: "./dist", path: "index.html" }));
var app_default = app;

// server/index.ts
var server = Bun.serve({
  development: isDevMode,
  port: Bun.env.PORT,
  fetch: app_default.fetch,
  maxRequestBodySize: MAX_BODY_SIZE,
  idleTimeout: 30
});
console.log(`Listening on http://localhost:${server.port} ...`);
